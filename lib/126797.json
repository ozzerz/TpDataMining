{
  "comments": [
    "Since native painting is used for the LightweightSystem, it is impossible to use one\u0027s own subclasses of UpdateManager. This is because native painting needs a specialized UpdateManager.paint() method, like in DeferredUpdateManager. I cannot override paint in my own subclass of UpdateManager since its paint method has package visibility. So please make UpdateManager.paint protected.\n\nGEF 3.2 M4",
    "We do not want to make this API, so you are going to have to make some kind of arguement for what you are trying to do. This is a new method in 3.2. What were you doing prior to 3.2?\n\nThis package-visible method calls repairDamage(), which is protected so you can override.",
    "The basic problem (i think) is that in a subclass of UpdateManager i cannot get hold of a Graphics object to paint my Figures on when a NativeGraphicsSource is used. \n\nThat is because UpdateManager.paint() calls repairDamage(), through a call to performUpdate(). In UpdateManager.paint()\u0027s call to performUpdate() the Graphics object is lost. In performUpdate() (which I can override indeed) i receive a Rectangle, and in repairDamage() I cannot get hold of a Graphics object to paint on anymore, because NativeGraphicsSource.getGraphics() returns null.\n\nBefore rev. 1.25 of LightweightSystem all its paint requests were translated in a call to performUpdate() of the UpdateManager, where, through a call to getGraphics() we could get a Graphics object to paint figures on.\n\nBefore 3.2.0 i used a slightly modified version of DeferredUpdateManager (as it was at that time) with better performance. Also now, with native painting, it still performs better than DeferredUpdateManager, but then i need a Graphics object someway. I attached the source of my updatemanagers, in the state as i have them now, with a protected UpdateManager.paint() method. Also a screenshot of a situation in which my updatemanager outperforms DeferredUpdateManager. The figures are expensive to draw, because of irregular shapes with holes and transparency. Especialy when changes selection from one corner of the screen to the other corner difference is notable.",
    "Created an attachment (id\u003d34321)\nClusteringUpdateManager.java\n\nClusteringUpdateManager.java",
    "Created an attachment (id\u003d34322)\nMinimizingUpdateManager.java\n\nMinimizingUpdateManager.java",
    "Created an attachment (id\u003d34323)\nscreenshot\n\nscreenshot",
    "As a temporary workaround, can you try constructing the FigureCanvas without the DOUBLE_BUFFERED style bit set? This should allow your old code to function normally.",
    "I tried creating the FigureCanvas without double buffering and then my old code worked indeed without modifications. I must say that i did it (no double buffering) the dirty way, change it in the code of ScrollingGraphicalViewer itself. I did not try to do it the (a) official way yet, this may turn out to be quite difficult.\n\nI noticed some thing when experimenting with double buffering or not:\n\n- on my machine the effect of double buffering is neglectable (no speed difference with not using double buffering)\n- without double buffering, but leaving UpdateManager.paint(GC gc) protected and override it in the way DeferredUpdateManager does, gives the user a much sooner feedback. The screen starts to update immediately. Previously, the screen was updated in a buffer, and then displayed at once. With these settings (no double buffering, protected paint) the screen starts to update immediately. When the entire screen has to be updated, and screen updates take about 1-2 seconds then, this is much better for user experience. User sees immediately something is happening, that makes the wait seem less long.\n\nIn my case, it would be best if I could tell the ScrollingGraphicalViewer wheteher to use double buffering or not, and have a protected paint method in UpdateManager (or something else which gives the same effect).\n\nKoen\n",
    "What about the following code:\n\nScroklingGraphicalViewer viewer \u003d new ScrollingGraphicalViewer();\nviewer.setControl(new FigureCanvas(\n      composite,\n      SWT.NONE,\n      viewer.getLightweightSystem()));",
    "I don\u0027t see how this can be done. GraphicalViewerImpl.getLightweightSystem is a protected method, so it has to be done from inside a subclass of GraphicalViewerImpl. Doing this in the constructor of a subclass of GraphicalViewerImpl is also impossible because at that time we don\u0027t have a parent composite yet. Doing this in a overridden createControl method is impossible because ScrollingGraphicalViewer.createControl() is final ...\n\nDoing it like this\n\n\t\tLightweightSystem lws \u003d new LightweightSystem();\n\t\tlws.setUpdateManager(new MinimizingUpdateManager());\n\t\tFigureCanvas fc \u003d new FigureCanvas(parent, SWT.NONE, lws);\n\t\tgraphicalViewer.setControl(fc);\n\nin the createPartControl of the editor gives me this exception:\n\njava.lang.RuntimeException: Can not set control again once it has been set\n\tat org.eclipse.draw2d.SWTEventDispatcher.setControl(SWTEventDispatcher.java:399)\n\tat org.eclipse.draw2d.LightweightSystem.setControl(LightweightSystem.java:227)\n\tat org.eclipse.gef.ui.parts.GraphicalViewerImpl.hookControl(GraphicalViewerImpl.java:256)\n\tat org.eclipse.gef.ui.parts.AbstractEditPartViewer.setControl(AbstractEditPartViewer.java:598)\n\n\n....",
    "\u003e GraphicalViewerImpl. Doing this in the constructor of a subclass of\n\u003e GraphicalViewerImpl is also impossible because at that time we don\u0027t have a\n\u003e parent composite yet. Doing this in a overridden createControl method is\n\u003e impossible because ScrollingGraphicalViewer.createControl() is final\n\nYou should not have to subclass the viewer.  What about when viewer.createControl() is normally called (from the editorpart\u0027s createControl).  Override in your editorpart, and avoid calling createControl() on the viewer.",
    "Well, I was able to switch off the SWT.DOUBLE_BUFFERING in the way you described. This code snippet is from the EditorPart\n\n--------------------------------------------------\n\n@Override\npublic void createPartControl(final Composite parent) {\n\t\t\n\tclass MyViewer extends ScrollingGraphicalViewer {\n\t\tMyViewer() {\n\t\t\tsuper();\n                        // do NOT use double buffering\n\t\t\tFigureCanvas canvas \u003d new FigureCanvas(parent, SWT.NONE, getLightweightSystem());\n\t\t\tsuper.setControl(canvas);\n//\t\t\tinstallRootFigure();\n\t\t\tif (getFigureCanvas() \u003d\u003d null)\n\t\t\t\treturn;\n\t\t\tif (getRootFigure() instanceof Viewport)\n                       getFigureCanvas().setViewport((Viewport)getRootFigure());\n\t\t\telse\n\t\t\t    getFigureCanvas().setContents(getRootFigure());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// create graphical viewer\n\t\tif (false) {\n\t\t\tgraphicalViewer \u003d new SpatialViewer(this);\n\t\t\tgraphicalViewer.createControl(parent);\n\t\t} else {\n\t\t\t// Test for Bugzilla 126797, comment #10\n\t\t\tgraphicalViewer \u003d new MyViewer();\n\t\t\t// Do not call graphicalViewer.createControl, perform the trick in its constructor\n//\t\t\tgraphicalViewer.createControl(parent);\n\t\t}\n\n--------------------------------------------------\n\nBasically, what I did was copy the code of ScrollingGraphicalViewer.createControl to MyViewer\u0027s constructor, where I do have a parent Composite, and NOT call createControl from the EditorPart\u0027s createPartControl(). I had to \u0027inline\u0027 installRootFigure() because it is private, and call a deprecated getRootFigure() because rootFigure is package visibility.\n\nWhen I managed to switch off the double buffering this way, I was able to inject my own update manager in the LWS fairly easily (not shown in the snippet above, this is what started this all).\n\nAlthough now I am able to use a different updatemanager by switching off double-buffering without tweeking the GEF sources this is definitely not a solution, it is a temporary workaround as it is very un-intuitive and it depends on a deprecated method.\n",
    "Take care of misleading indentation. This is what it should look like\n\n--------------------------------------------------\n\n@Override\npublic void createPartControl(final Composite parent) {\n\n        class MyViewer extends ScrollingGraphicalViewer {\n                MyViewer() {\n                        super();\n                        // do NOT use double buffering\n                        FigureCanvas canvas \u003d new FigureCanvas(parent,\nSWT.NONE, getLightweightSystem());\n                        super.setControl(canvas);\n//                      installRootFigure();\n                        if (getFigureCanvas() \u003d\u003d null)\n                                return;\n                        if (getRootFigure() instanceof Viewport)\n                      \ngetFigureCanvas().setViewport((Viewport)getRootFigure());\n                        else\n                            getFigureCanvas().setContents(getRootFigure());\n                        }\n                }  // end of class MyViewer\n\n        // create graphical viewer\n        if (false) {\n                graphicalViewer \u003d new SpatialViewer(this);\n                graphicalViewer.createControl(parent);\n        } else {\n                // Test for Bugzilla 126797, comment #10\n                graphicalViewer \u003d new MyViewer();\n                // Do not call graphicalViewer.createControl, perform the trick in its constructor\n                // graphicalViewer.createControl(parent);\n        }\n\n--------------------------------------------------\n\n"
  ],
  "commentCreationDates": [
    "2006-02-07T20:38:53+01:00",
    "2006-02-07T20:56:58+01:00",
    "2006-02-08T04:54:33+01:00",
    "2006-02-08T04:56:29+01:00",
    "2006-02-08T04:57:17+01:00",
    "2006-02-08T04:58:51+01:00",
    "2006-02-08T14:53:24+01:00",
    "2006-02-09T09:11:59+01:00",
    "2006-02-09T15:28:51+01:00",
    "2006-02-10T12:05:15+01:00",
    "2006-04-06T18:51:50+02:00",
    "2006-04-20T22:38:19+02:00",
    "2006-04-20T22:42:27+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.RuntimeException",
      "message": "Can not set control again once it has been set",
      "elements": [
        {
          "method": "org.eclipse.draw2d.SWTEventDispatcher.setControl",
          "source": "SWTEventDispatcher.java:399"
        },
        {
          "method": "org.eclipse.draw2d.LightweightSystem.setControl",
          "source": "LightweightSystem.java:227"
        },
        {
          "method": "org.eclipse.gef.ui.parts.GraphicalViewerImpl.hookControl",
          "source": "GraphicalViewerImpl.java:256"
        },
        {
          "method": "org.eclipse.gef.ui.parts.AbstractEditPartViewer.setControl",
          "source": "AbstractEditPartViewer.java:598"
        }
      ],
      "number": 0,
      "commentIndex": 9,
      "bugId": "126797",
      "date": "2006-02-10T12:05:15+01:00",
      "product": "GEF",
      "component": "draw2d",
      "severity": "enhancement"
    }
  ],
  "groupId": "126797",
  "bugId": "126797",
  "date": "2006-02-07T20:38:53+01:00",
  "product": "GEF",
  "component": "draw2d",
  "severity": "enhancement"
}