{
  "comments": [
    "\u0027declare parents\u0027 statements are not honored by -XnoWeave.  Take this program:\n\npublic class WhatAmI {\n\t\n  public static void main(String[] args) {\n    System.err.println(\"I\u0027m a main method:\");\n    WhatAmI instance \u003d new WhatAmI();\n\t\t\n    // Should *not* be serializable\n    if (instance instanceof java.io.Serializable)\n\tthrow new RuntimeException(\"I should not be serializable\");\n    }\n}\n\naspect A {\n\tdeclare parents: WhatAmI implements java.io.Serializable;\n}\n\najc WhatAmI.java A.java -XnoWeave\n\njava WhatAmI\n\nreturns:\n\njava.lang.RuntimeException: I should not be serializable\n\tat WhatAmI.main(WhatAmI.java:9)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke\n(NativeMethodAccessorImpl.java:39)\n\nThe problem is that the compilation stage applies the ITD and then generates \ncode for it - meaning the weaver doesn\u0027t have to do it. (and so in the case \nof -noweave the weaver can\u0027t decide *not* to do it!).  This is unlike other \nITDs where although they are \u0027applied\u0027 at compile time to satisfy type checks, \nthe code generator at compile time does not produce code for them - this means \nthe weaver applies them again at weave time and so it can choose not to do it \nin the case of -noweave.",
    "There are two situations to think about:\n\ndeclare parents: Blah extends SuperBlah\n\ndeclare parents: Blah implements IBlah\n\nIn trying to fix the first case I get (at weave time):\n\nerror can\u0027t use declare parents to change superclass of binary form \u0027WhatAmI\u0027 \n(implementation limitation)\n\nwhich might be reasonable but was a surprise I wasnt expecting !\n\nThis compiler limitation doesnt apply for \u0027declare parents: implements\u0027 \nthough.  However, if I can\u0027t fix it in both cases - should I fix it for just \none?  Is it better if we just put out a warning message if using -XnoWeave \nwith \"declare parents:\" that says these features aren\u0027t compatible.\n\nThe other reason I wanted to fix this was -Xreweavable.  The list of aspects \nthat modify a type is collected at weave time - on a subsequent weave we \nverify this list of aspects is around.  In the case of using \"declare \nparents:\" reweavable doesn\u0027t record that an aspect affected a type because it \nwas not done by the weaver.  However, even if I did propagate this knowledge \nfrom compile time-\u003eweave time so it could be recorded in the reweavable state, \nit wouldn\u0027t be useful because when attempting the reweaving and reverting to \nthe \u0027unwoven\u0027 form of the class file, it would have already had the \"declare \nparents:\" declarations applied.  (Am I making sense here?).",
    "Should I just put out an error/warning message when we see this combination of \ninputs (declare parents/XnoWeave) ... ?",
    "declare parents interacts more strongly tightly with the compiler than any \nother construct in AspectJ.  I think that for 1.2 you might have to just make \nit an xlint warning to use it with XnoWeave or Xreweavable.  Not being able to \nuse declare parents with interfaces and reweavable is a real bummer.\n\nHere\u0027s a sketch of what it would take to support declare parents properly in \nthe weaver.\n\n1. The main reason it wasn\u0027t done originally is error checking.  There are a \nlot of checks to make sure that a class properly implements an interface or \ncan extend a different class.  These checks are already implemented for the \neclipse compiler, but they need to be duplicated on ResolvedTypeX\u0027s to make \nsure that declare parents is being used correctly in the weaver.\n\n2. After making this change, you\u0027d need to modify the compiler to emit \nclassfiles with unmodified superclass and interfaces.  This could be tricky.  \nThe current implementation just adds interfaces and a new superclass to the \neclipse SourceTypeBinding objects; however, it doesn\u0027t modify the underlying \nTypeDeclarations.  You\u0027d need a hook to modify the Classfile constructor to \nuse the original interfaces and superclass from the SourceTypeBinding.  This \nis doable, but I\u0027m almost certain would require another patch to the jdt.core \ncode.",
    "I have done the first part of the solution which is to get the compiler to emit\nclass files that don\u0027t have the modified hierarchies.  This was relatively\nstraightforward, I just record the original superclass and interface set before\nany declare parents are processed and when emitting the class file I use the\nrecorded information.\n\nFor declare parents \u0027implements\u0027 I think that is almost enough but declare\nparents extends is much more messy.  I\u0027ve so far found the following checks that\nneed to be implemented if allowing extends at weave time:\n\n- if you inherit methods you cannot override them and reduce their visibility\n- if you inherit methods you cannot have incompatible return types (java1.5 will\nmake this a little messier)\n- if you inherit abstract methods and you are not abstract you need to provide\nan implementation\n- if you inherit abstract methods and don\u0027t provide implementations you have to\nbe abstract\n- if you override an instance method you cannot make your overridden version static\n- you cannot extend a final class\n- the Object class cannot be subject to declare parents extends\n\nI think that covers many cases - of course ITDs have to be taken into account.  \n\nI\u0027ve not looked at field inheritance yet.\n\nI\u0027ve also uncovered a problem to do with\n\ndeclare parents: \u003cSomeType\u003e+ extends \u003cSomeClass\u003e\n\nIf we process a subtype of \u003cSomeType\u003e before we process \u003cSomeType\u003e then you get\nan error (as SomeClass doesn\u0027t typically fit into the extends hierarchy).  If we\nprocess \u003cSomeType\u003e first and it just extends from Object then we can usually put\n\u003cSomeClass\u003e in as its parent, then there is no problem when processing the\nsubtype of \u003cSomeType\u003e because one of its parents already extends \u003cSomeClass\u003e. \nclear? :)\n",
    "*** Bug 74061 has been marked as a duplicate of this bug. ***",
    "Fix available:\n\nBUILD COMPLETE -  build.427\nDate of build: 01/07/2005 09:52:56\nTime to build: 107 minutes 25 seconds\nLast changed: 01/07/2005 08:08:11\nLatest good AspectJ jar available at:\ndownload.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar\n\nModifying super calls in the bytecode were the main bit of implementation - the\nrest of the work is checks to ensure you aren\u0027t violating the rules, as outlined\nin a previous comment in this bug report.  The checks might not currently be\nperfect but they are good enough for a first release of the functionality."
  ],
  "commentCreationDates": [
    "2004-03-29T17:40:31+02:00",
    "2004-03-30T17:39:15+02:00",
    "2004-04-01T17:47:05+02:00",
    "2004-04-05T03:31:42+02:00",
    "2004-08-26T09:17:50+02:00",
    "2004-09-29T10:15:25+02:00",
    "2005-01-07T13:56:17+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.RuntimeException",
      "message": "I should not be serializable",
      "elements": [
        {
          "method": "WhatAmI.main",
          "source": "WhatAmI.java:9"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "56600",
      "date": "2004-03-29T17:40:31+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "56600",
  "bugId": "56600",
  "date": "2004-03-29T17:40:31+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}