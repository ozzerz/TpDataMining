{
  "comments": [
    "This is a timing issue and it\u0027s rather convoluted, but here it is:\n\nBreakpointManager is registered as a resource listener, with the workspace, for events of type IResourceChangeEvent.POST_BUILD.  These events are issued during an auto-build job which is ran after every resource change in workspace (whether auto-build is enabled or not).\n\nThe auto-build job is run with a slight delay (100 ms at most), so that if multiple changes are made before an auto-build job is run, these changes are consolidated into a single delta, when the POST_BUILD event is sent.\n\nNow suppose that a debugger UI creates a breakpoint, then after a slight delay, the debugger back end modifies that breakpoint to denote that the breakpoint is planted on the target.  The normal order of events in this scenario is that:\n1) The breakpoint marker is created and a marker-added event is sent.  This marker event is ignored by breakpoint manager, because the manager doesn\u0027t send breakpoint-added until the breakpoint is added to the manager.\n2) The breakpoint is added to the manager, and the manager sends out a breakpoint-added notification.\n3) The breakpoint is modified by the back-end, and a marker-changed resource event is issued.\n4) The breakpoint receives the resource event, and issues a corresponding breakpoint-changed event.\n\nIn the above scenario everything works find, but under some circumstances the following can happen.\na) The workspace auto-build is already running as a result of a previous workspace change (an old breakpoint removed for example).\n1) The breakpoint marker is created, but the auto-build is delayed 100ms, because the auto-build just ran.  Hence the marker-added event is not sent yet.\n2) The breakpoint is added to bp manager, and the manager sends out the breakpoint-added event.\n3) The debugger back end modifies the breakpoint to mark it as planted, but the marker-changed event is also held up by the auto-build delay.\n4) The auto-build is scheduled, and finally the marker event is issued. BUT (and this is the problem) the marker-added and the marker-changed deltas are rolled into one marker-added delta!\n5) The manager ignores the marker-added delta, because it already sent out a breakpoint-added event previously.\n\n------------------------------------------------\nI attached a hacked PDA example, which marks the BP as planted after planting it, which exhibits this behavior.  To reproduce toggle breakpoint to remove it, then immediately toggle a breakpoint again to create it.  The newly created breakpoint is never marked as planted.  I attached the three files that are modified separately as well.\n\nI can see two options to fix this bug:\n1.\nJust listen to IResourceChangeEvent.POST_CHANGED events instead of POST_BUILD.  These are sent immediately after the change, so they don\u0027t have a chance to be coalesced.  The draw-back is that some debuggers may suffer in performance if the make many breakpoint changes in a row instead of performing these changes in a single workbench operation.  But the upside is that (besides fixing the bug) the breakpoint updates are actually faster and make the UI look more responsive.\n(see patch BreakpointManager.java.1)\n2.\nIssue a breakpoint changed event when the marker-added resource change is received.  The downside is that a breakpoint-changed evnet would be issued after every breakpoint-add, which is rather ugly.  But other than that, events would still be coalesced by auto-build job.\n(see patch BreakpointManager.java.2)",
    "Created an attachment (id\u003d39448)\nHacked PDA example that marks BPs as planted\n\n",
    "Created an attachment (id\u003d39449)\nHacked PDA example that marks BPs as planted - Target marks BP as planted upon breakpoint-added event.\n\n",
    "Created an attachment (id\u003d39450)\nHacked PDA example that marks BPs as planted - BP with setPlanted/isPlanted methods\n\n",
    "Created an attachment (id\u003d39451)\nHacked PDA example that marks BPs as planted - Presentation adds the \"(Planted)\" to label.\n\n",
    "Created an attachment (id\u003d39452)\nFix option 1\n\n",
    "Created an attachment (id\u003d39453)\nFix option 2\n\n",
    "This is a great bug. It has a great detailed description of the problem, examples the cause the problem, and suggested fixes with patches. Great bug.",
    "Thanks Darin!",
    "Moving to 3.3",
    "Unfortunately, changing to a POST_CHANGE notification vs. a POST_BUILD notification has the subtle difference that the workspace/resources are not open for change during a POST_CHANGE (and they are open for change during a POST_BUILD). This can causes problems with existing clients that change breakpoints/resources in response to a change in a breakpoint. For example, this caused problems with the java debugger in the past, and still does today:\n\norg.eclipse.core.internal.resources.ResourceException: The resource tree is locked for modifications.\n\tat org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:94)\n\tat org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:1684)\n\tat org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1732)\n\tat org.eclipse.jdt.internal.debug.ui.JavaDebugOptionsManager.updateBreakpointMessages(JavaDebugOptionsManager.java:765)\n\tat org.eclipse.jdt.internal.debug.ui.JavaDebugOptionsManager.breakpointsChanged(JavaDebugOptionsManager.java:779)\n\tat org.eclipse.debug.internal.core.BreakpointManager$BreakpointsNotifier.run(BreakpointManager.java:860)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n\tat org.eclipse.debug.internal.core.BreakpointManager$BreakpointsNotifier.notify(BreakpointManager.java:879)\n\tat org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:733)\n\tat org.eclipse.debug.internal.core.BreakpointManager.access$1(BreakpointManager.java:720)\n\tat org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:600)\n\tat org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:536)\n\tat org.eclipse.core.internal.events.NotificationManager$2.run(NotificationManager.java:282)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n\tat org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:276)\n\tat org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:148)\n\tat org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:256)\n\tat org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:958)\n\tat org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1746)\n\tat org.eclipse.debug.core.model.Breakpoint.setAttribute(Breakpoint.java:190)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.decrementInstallCount(JavaBreakpoint.java:755)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.deregisterRequest(JavaBreakpoint.java:244)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.removeRequests(JavaBreakpoint.java:673)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.removeFromTarget(JavaBreakpoint.java:616)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.removeFromTarget(JavaLineBreakpoint.java:177)\n\tat org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.removeAllBreakpoints(JDIDebugTarget.java:1379)\n\tat org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.cleanup(JDIDebugTarget.java:1337)\n\tat org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.terminated(JDIDebugTarget.java:1302)\n\tat org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.handleVMDisconnect(JDIDebugTarget.java:903)\n\tat org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:154)\n\tat org.eclipse.jdt.internal.debug.core.EventDispatcher.run(EventDispatcher.java:232)\n\tat java.lang.Thread.run(Thread.java:534)\n\n\nSo, although I like the simplicity of fix 1, we can\u0027t use it. I also don\u0027t like the idea of firing needless change notifications (fix 2). Perhaps we can match up add/register notifications and only send the add notification once a breakpoint is registered and its marker has been added.",
    "This is indeed unfortunate :-(\nI suppose asking the clients to perform their modifications inside a job and using an appropriate scheduling rule is a little too much to ask.  I\u0027m actually really surprised that Workspace.run() doesn\u0027t block until the resource tree is unlocked... even if in this case it would have deadlocked the resource system.\n\nAs an alternative, could the breakpoint manager dispatch the breakpointChanged() events in a separate job?  I think the place to try it would be when BreakpointManagerVisitor.update() is called.  In fact if this job would call the listeners inside of a Workspace.run() operation, it would guarantee that if the listeners modified the resource tree, they would not run into a resource tree blocked exception.  On the downside this is a pretty radical approach, and it would require a lot of testing.  One place where this strategy might run into trouble, is that BreakpointManagerVisitor instance fgVisitor would have to be re-entrant, because it could be called with a marker changed notification, while it\u0027s still processing a previous one.\n\nThe strategy of avoiding sending the added event until the breakpoint is registered would work too, it\u0027s probably the safest change.  On the downside it would still have the occasional delay that is caused by the events being sent as part of the auto-build job.",
    "Fixed. \n\nThe breakpoint manager now registeres a POST_CHANGE listener and a POST_BUILD listener. This way, it can keep track of which breakpoints have changed before we received a \"POST_BUILD add\" notification, and fire a corresponding change notification for breakpoints that have changed since we notified listeners of the \"add\".\n\nWe still only notify listeners during POST_BUILD.",
    "Please verify, Kevin.",
    "verified"
  ],
  "commentCreationDates": [
    "2006-04-25T21:14:13+02:00",
    "2006-04-25T21:15:21+02:00",
    "2006-04-25T21:15:58+02:00",
    "2006-04-25T21:16:43+02:00",
    "2006-04-25T21:17:17+02:00",
    "2006-04-25T21:18:19+02:00",
    "2006-04-25T21:18:35+02:00",
    "2006-04-26T05:51:18+02:00",
    "2006-04-26T23:38:33+02:00",
    "2006-05-08T20:05:10+02:00",
    "2006-06-22T22:37:05+02:00",
    "2006-06-23T00:07:21+02:00",
    "2006-06-23T18:47:34+02:00",
    "2006-06-23T18:47:52+02:00",
    "2006-06-27T20:01:43+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.core.internal.resources.ResourceException",
      "message": "The resource tree is locked for modifications.",
      "elements": [
        {
          "method": "org.eclipse.core.internal.resources.WorkManager.checkIn",
          "source": "WorkManager.java:94"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.prepareOperation",
          "source": "Workspace.java:1684"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.run",
          "source": "Workspace.java:1732"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.ui.JavaDebugOptionsManager.updateBreakpointMessages",
          "source": "JavaDebugOptionsManager.java:765"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.ui.JavaDebugOptionsManager.breakpointsChanged",
          "source": "JavaDebugOptionsManager.java:779"
        },
        {
          "method": "org.eclipse.debug.internal.core.BreakpointManager$BreakpointsNotifier.run",
          "source": "BreakpointManager.java:860"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.debug.internal.core.BreakpointManager$BreakpointsNotifier.notify",
          "source": "BreakpointManager.java:879"
        },
        {
          "method": "org.eclipse.debug.internal.core.BreakpointManager.fireUpdate",
          "source": "BreakpointManager.java:733"
        },
        {
          "method": "org.eclipse.debug.internal.core.BreakpointManager.access$1",
          "source": "BreakpointManager.java:720"
        },
        {
          "method": "org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update",
          "source": "BreakpointManager.java:600"
        },
        {
          "method": "org.eclipse.debug.internal.core.BreakpointManager.resourceChanged",
          "source": "BreakpointManager.java:536"
        },
        {
          "method": "org.eclipse.core.internal.events.NotificationManager$2.run",
          "source": "NotificationManager.java:282"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.core.internal.events.NotificationManager.notify",
          "source": "NotificationManager.java:276"
        },
        {
          "method": "org.eclipse.core.internal.events.NotificationManager.broadcastChanges",
          "source": "NotificationManager.java:148"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.broadcastPostChange",
          "source": "Workspace.java:256"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.endOperation",
          "source": "Workspace.java:958"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.run",
          "source": "Workspace.java:1746"
        },
        {
          "method": "org.eclipse.debug.core.model.Breakpoint.setAttribute",
          "source": "Breakpoint.java:190"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.decrementInstallCount",
          "source": "JavaBreakpoint.java:755"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.deregisterRequest",
          "source": "JavaBreakpoint.java:244"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.removeRequests",
          "source": "JavaBreakpoint.java:673"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.removeFromTarget",
          "source": "JavaBreakpoint.java:616"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.removeFromTarget",
          "source": "JavaLineBreakpoint.java:177"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.removeAllBreakpoints",
          "source": "JDIDebugTarget.java:1379"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.cleanup",
          "source": "JDIDebugTarget.java:1337"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.terminated",
          "source": "JDIDebugTarget.java:1302"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.handleVMDisconnect",
          "source": "JDIDebugTarget.java:903"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch",
          "source": "EventDispatcher.java:154"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.EventDispatcher.run",
          "source": "EventDispatcher.java:232"
        },
        {
          "method": "java.lang.Thread.run",
          "source": "Thread.java:534"
        }
      ],
      "number": 0,
      "commentIndex": 10,
      "bugId": "138473",
      "date": "2006-06-22T22:37:05+02:00",
      "product": "Platform",
      "component": "Debug",
      "severity": "major"
    }
  ],
  "groupId": "138473",
  "bugId": "138473",
  "date": "2006-04-25T21:14:13+02:00",
  "product": "Platform",
  "component": "Debug",
  "severity": "major"
}