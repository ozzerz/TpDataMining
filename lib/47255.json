{
  "comments": [
    "20031121\n\nIf you exit your workbench while a background build is going on it is possible \nto get the following exception\n\nSTEPS\n1) Start an auto build\n2) Exit Eclipse\n\n!SESSION Nov 21, 2003 13:17:04.901 --------------------------------------------\n-\njava.version\u003d1.4.2\njava.vendor\u003dSun Microsystems Inc.\nBootLoader constants: OS\u003dwin32, ARCH\u003dx86, WS\u003dwin32, NL\u003den_US\nCommand-line arguments: -os win32 -ws win32 -arch x86 -install \nfile:D:/R30/1121b/eclipse/\n!ENTRY org.eclipse.pde.core 4 4 Nov 21, 2003 13:17:04.901\n!MESSAGE PDE Core: Runtime support of the wrong type: \norg.eclipse.pde.internal.core.DefaultRuntimeSupport\n!ENTRY org.eclipse.core.resources 4 2 Nov 21, 2003 13:17:04.917\n!MESSAGE Problems occurred when invoking code from plug-\nin: \"org.eclipse.core.resources\".\n!STACK 0\njava.lang.NullPointerException\n\tat org.eclipse.pde.internal.core.PDECore.initializeModels\n(PDECore.java:423)\n\tat org.eclipse.pde.internal.core.PDECore.getModelManager\n(PDECore.java:315)\n\tat org.eclipse.pde.internal.core.PDECore.findPlugin(PDECore.java:300)\n\tat \norg.eclipse.pde.internal.builders.ManifestConsistencyChecker.validateRequires\n(ManifestConsistencyChecker.java:508)\n\tat \norg.eclipse.pde.internal.builders.ManifestConsistencyChecker.validateValues\n(ManifestConsistencyChecker.java:384)\n\tat \norg.eclipse.pde.internal.builders.ManifestConsistencyChecker.validatePlugin\n(ManifestConsistencyChecker.java:259)\n\tat \norg.eclipse.pde.internal.builders.ManifestConsistencyChecker.checkFile\n(ManifestConsistencyChecker.java:221)\n\tat \norg.eclipse.pde.internal.builders.ManifestConsistencyChecker.access$1\n(ManifestConsistencyChecker.java:205)\n\tat \norg.eclipse.pde.internal.builders.ManifestConsistencyChecker$DeltaVisitor.visit\n(ManifestConsistencyChecker.java:59)\n\tat org.eclipse.core.internal.events.ResourceDelta.accept\n(ResourceDelta.java:71)\n\tat org.eclipse.core.internal.events.ResourceDelta.accept\n(ResourceDelta.java:79)\n\tat org.eclipse.core.internal.events.ResourceDelta.accept\n(ResourceDelta.java:52)\n\tat \norg.eclipse.pde.internal.builders.ManifestConsistencyChecker.processDelta\n(ManifestConsistencyChecker.java:194)\n\tat org.eclipse.pde.internal.builders.ManifestConsistencyChecker.build\n(ManifestConsistencyChecker.java:122)\n\tat org.eclipse.core.internal.events.BuildManager$2.run\n(BuildManager.java:482)\n\tat org.eclipse.core.internal.runtime.InternalPlatform.run\n(InternalPlatform.java:1127)\n\tat org.eclipse.core.runtime.Platform.run(Platform.java:464)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild\n(BuildManager.java:130)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild\n(BuildManager.java:201)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild\n(BuildManager.java:156)\n\tat org.eclipse.core.internal.events.BuildManager$1.run\n(BuildManager.java:182)\n\tat org.eclipse.core.internal.runtime.InternalPlatform.run\n(InternalPlatform.java:1127)\n\tat org.eclipse.core.runtime.Platform.run(Platform.java:464)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild\n(BuildManager.java:185)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuildLoop\n(BuildManager.java:219)\n\tat org.eclipse.core.internal.events.BuildManager.build\n(BuildManager.java:247)\n\tat org.eclipse.core.internal.events.AutoBuildJob.doBuild\n(AutoBuildJob.java:76)\n\tat org.eclipse.core.internal.events.AutoBuildJob.run\n(AutoBuildJob.java:112)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:62)",
    "I got a similar NPE in the initalization of PDE models upon exiting, although \nvia a different path, preceded by the message:\n\nError Nov 26, 2003 05:17:41.104 PDE Core: Runtime support of the wrong type: \norg.eclipse.pde.internal.core.DefaultRuntimeSupport\n\nError Nov 26, 2003 05:17:41.114 Problems occurred when invoking code from plug-\nin: \"org.eclipse.core.resources\".\njava.lang.NullPointerException\nat org.eclipse.pde.internal.core.PDECore.initializeModels(PDECore.java:423)\nat org.eclipse.pde.internal.core.PDECore.getWorkspaceModelManager\n(PDECore.java:356)\nat org.eclipse.pde.internal.builders.ManifestConsistencyChecker.build\n(ManifestConsistencyChecker.java:128)\nat org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:482)\nat org.eclipse.core.internal.runtime.InternalPlatform.run\n(InternalPlatform.java:1127)\nat org.eclipse.core.runtime.Platform.run(Platform.java:464)\nat org.eclipse.core.internal.events.BuildManager.basicBuild\n(BuildManager.java:130)\nat org.eclipse.core.internal.events.BuildManager.basicBuild\n(BuildManager.java:201)\nat org.eclipse.core.internal.events.BuildManager.basicBuild\n(BuildManager.java:156)\nat org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:182)\nat org.eclipse.core.internal.runtime.InternalPlatform.run\n(InternalPlatform.java:1127)\nat org.eclipse.core.runtime.Platform.run(Platform.java:464)\nat org.eclipse.core.internal.events.BuildManager.basicBuild\n(BuildManager.java:185)\nat org.eclipse.core.internal.events.BuildManager.basicBuildLoop\n(BuildManager.java:219)\nat org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:247)\nat org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:76)\nat org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:112)\nat org.eclipse.core.internal.jobs.Worker.run(Worker.java:62)\n\n\n",
    "This is really funky...\n\nI have recently changed the code to add a more detailed message. According to \nthe error above, the class \u0027DefaultRuntimeSupport\u0027 is not of the expected \ntype. We expect a class that is instance of IAlternativeRuntimeSupport. But...\n\nDefaultRuntimeSupport DOES implement the expected interface. For some \nreason, \u0027instanceof\u0027 fails i.e. gives a wrong answer.\n\nDJ, Philippe, is there any reason why \u0027instanceof\u0027 applied to a class that \nDOES implement the required interface actually returns false?",
    "I don\u0027t have the code in front of me, but \u0027null\u0027 never answers true to an \ninstanceof check.",
    "That is not the problem. Notice the error before the NULL:\n\nRuntime support of the wrong type: \norg.eclipse.pde.internal.core.DefaultRuntimeSupport\n\nThe code that prints this message is:\n\ntry {\n\tObject cobj \u003d runtime.createExecutableExtension(\"class\");\n\tif (cobj\u003d\u003dnull) {\n\t\tlogErrorMessage(\"PDE Core: Failed to load runtime support.\");\n\t}\n\telse if (cobj instanceof IAlternativeRuntimeSupport) \n\t\truntimeSupport \u003d (IAlternativeRuntimeSupport)cobj;\n\telse {\n\t\tlogErrorMessage(\"PDE Core: Runtime support of the wrong \ntype: \"+cobj.getClass().getName());\n\t}\n} catch (CoreException e) {\n\tlogException(e);\n}\n\nBased on the code and the message, the created object is of the \ntype \u0027org.eclipse.pde.internal.core.DefaultRuntimeSupport\u0027 and the \ntest \u0027instanceof IAlternativeRuntimeSupport\u0027 fails even though I know that \nthis class actually implements the interface. What is funny is that this only \nhappens in certain scenarios - I wasn\u0027t able to reproduce this but others \napparently were. Obviously, a class either implements or does not implement an \ninterface - the answer cannot be different depending on the context.",
    "BTW, the code is at the bottom of PDECore class.",
    "I see. Couldn\u0027t this be a case where 2 occurrences of this type are around, one \ncoming from the workspace and one from the target platform ? I remember you did \nchange things in this area, didn\u0027t you ?\n\n",
    "I think that is unlikely. We have a table of plug-ins we know about, and table \nkeys are plug-in IDs. Each table entry has two references - one for the \nworkspace plug-in, another for the external plug-in (one may be null). Most \noperations in PDE are based on this table and only one of the two possible \nmodels for each entry is used (workspace first, if null, then external). \nTherefore, unless there is a subtle bug somewhere, workspace plug-in \nshould \u0027mask\u0027 the external one all the time.",
    "I just noticed two important conditions for this bug: both scenarios happened \nwhen PDE was loading the runtime support class when Eclipse was exited during \nthe background build. The loading involves finding the extensions that plug \ninto an extension point, picking one and creating a class from the \ncontributing plug-in. That is probably why I never hit the problem - I wait \nuntil the build is done before closing.",
    "There were a couple bugs recently which could be explained by some confusion in \nbetween workspace and external plug-ins (mismatch in source when debugging, and \nsome problem when using the Ant javac adapter). No evidence yet, but it got me \nwondering.",
    "I\u0027m not sure why the discussion has shifted all of a sudden to source lookup \nand workspace vs. external plug-ins.\n\nThere is definitely something fishy with the runtime.createExecutableExtension\n(..) call from comment #4.\nSometimes it returns null, because on occasions I have seen the error \nmessage \"PDE Core: Failed to load runtime support.\". \nOther times, it returns some object that fails the instanceof check, as in the \ncase of Tod\u0027s stack and mine that are pasted in this report.\n\nI could assure you that in my case, because I use dynamic classpaths, there is \nno two copies of IAlternativeRuntimeSupport in my workspace.  The only time \nwhen two copies might exist is if a project has a stale classpath and dynamic \nclasspaths are not used.\nFor example, if in a fresh workspace without classpath containers, I create a \nHello world plug-in, its classpath will contain a reference to external \nruntime.jar.  If I then check out org.eclipse.core.runtime from CVS and do not \nexplicitly update the classpath of the Hello world plug-in, Java Core now sees \ntwo copies of the core.runtime classes: one coming from the project checked \nout from cvs, and the other one coming from the external jar reference.\nIf dynamic classpaths are used, we won\u0027t have such a problem, because upon \nchecking out core.runtime from cvs, the classpath of the hello world plug-in \nwill be dynamically recomputed to drop the reference to the external jar and \nacquire a project reference to the core.runtime project.\n\nHowever, none of this external vs. workspace plug-in talk is relevant to this \nbug, since even if there are two copies of IAlternativeRuntimeSupport indexed \nby jdt core (which there isn\u0027t), I would find it highly unlikely that an \ninstanceof check will fail/pass depending on which copy of \nIAlternativeRuntimeSupport is getting picked up.",
    "The problem could occur if you did compare DefaultRuntimeSupport(1) with \nIAlternativeRuntimeSupport(2).\n\nI am not saying this is what the problem is, just mentionning this. ",
    "Oh, I see.  Thanks for the tip...\nHowever, when I get the npe, it is in my development workspace, not the \nruntime workspace.  So it has nothing to do with self-hosting, jdt core\u0027s \nindexing of my workspace, how many copies of a particular class I have in my \nworkspace, etc.  \nSomething is going wrong during the call that pde core makes to \ncreateExecutableExtension(), and that is what needs to be investigated.",
    "*** Bug 47649 has been marked as a duplicate of this bug. ***",
    "*** Bug 47839 has been marked as a duplicate of this bug. ***",
    "*** Bug 45998 has been marked as a duplicate of this bug. ***",
    "*** Bug 48841 has been marked as a duplicate of this bug. ***",
    "Is the workbench in shutdown mode while we try to build? How exactly are class \nloaders affected when one wants to call \u0027createExecutableExtension\u0027 while the \nworkbench is shutting down? Does this method use some registry services that \nare in the process of being turned off (as part of shutdown procedure)?\n\nBTW, why do we allow the background build to happen after the workbench has \ninitiated the shutdown procedure?",
    "There seems to be a problem with the class loader at shutdown while a build is \ntaking place.\nWe just experienced another instance with the Tomcat plug-in throwing a \nclassloading error upon shutting down.\n\nMoving to Platform Core...\n",
    "*** Bug 49511 has been marked as a duplicate of this bug. ***",
    "Moving to Equinox.  There seem to be problems around calling\ncreateExecutableExtension during shutdown.",
    "Moving to Tom, the classloading guy ;-)",
    "I have not attempted to reproduce this problem on eclipse but have run into \nsimilar problems when running applications on OSGi.  There are several \nsituations that can cause this problem.  All of them involve a Thread that was \nstarted by a bundle and that thread continues to run and load classes after \nthe bundle has been stopped and the classloader for the bundle has been thrown \naway.\n\nWhen the framework is shutting down all bundles are stopped and then the \nclassloaders are closed.  If a thread is still running after the classloaders \nhave been closed and discarded then ClassNotFoundExceptions will start to be \nthrown.  When a bundle is stopped it should ensure that all threads that it \nstarted are terminated.  In the case of background processes the plugin that \ntakes care of the background processes should probably join with the \nbackground processes when stopping.\n\nSimilar problems could happen when updating a bundle.  When a bundle is \nrefreshed all dependent bundles classloaders will be closed and discarded.  If \nthere are any rogue processes from the refreshed bundles then \nClassNotFoundExceptions will start to be thrown if these threads try to load a \nclass.",
    "great summary.  I would add that in the update case, the dependent bundles are \nalso stop()\u0027d before they are trashed so well written plugins that clean up \ntheir threads should behave correctly in both cases.\n\nWhile the current behaviour is likely correct, is there any way to soften the \nfailure mode?\n",
    "We may be able to add some code to the Framework to prevent closing the \nClassLoaders during shutdown.  This will involve adding a check to the bundle \nunload code to see if the framework is shutting down.  If it is shutting down \nthen don\u0027t bother closing the ClassLoader\u0027s.  \n\nI do not really like suggesting this because the Framework is designed to be \nable to shutdown and relaunch without restarting the VM.  If we do not ensure \nall files are closed when we are shutdown then we will have problems \nrelaunching.  If a fix like this goes in I will likely need to define a java \nproperty to enable it and keep it disabled by default.\n\nThis will not solve the update/uninstall/refresh case where we have to close \nthe classloaders inorder to try and GC them.",
    "Stopping and starting without cycling the VM is interesting but I wonder if it \nis really feasible.  Things like the URL management hook can only be set once \nand there are a mess of system properties that get setup along the way.  It is \nalso not clear how (much) this is better than recylcing them (other than cases \nwhere you physically can\u0027t for some reason).\n\nI\u0027m not a huge fan of the not closing the classloaders but it does seem like it \nwould address the issue...  ",
    "What are we going to do here?  \n- don\u0027t close the classloaders:  Seems non-conformant and somewhat questionable\n- leave them open: allowes cases as we have seen\n\nIs this not spec\u0027d in OSGi?  I assume that classloaders must be left open.  \nWhen a bundle is stopped it is supposed to stop its threads?  If that is true \nthen once you have stopped all the bundles, all the threads should be done.  \nHow are we different?\n\nWe should resolve (either way) for 3.0",
    "The problem is not when the bundles are stopped.  When a bundle is stopped the \nclassloader must be left open and continue to load classes and resources.  \nThis is specified in the OSGi spec.\n\nClassloaders are only closed by the Framework when we are trying to clean up \nthe resources for a bundle.  When a bundle is updated or uninstalled we \nattempt to clean up the resources of the \"old\" bundle (we only do this if we \ncan guarantee that no other bundles depend on our shared resources).  This \nfirst involves stopping the bundle and then closing all of its resources so \nGarbage Collection can reclaim the objects.\n\nIf all bundles stop the threads they may have started when Bundle.stop is \ncalled then there should be no threads left in the system that are using the \nbundle\u0027s classloader when we attempt to clean up the bundle classloaders.\n\nI do not think we should prevent classloaders from being closed on bundle \nupdates/uninstalls.  But we should be able to prevent such clean up when the \nFramework is shutting down.\n\nI have checked a fix into HEAD to prevent classloaders from being closed on \nframework shutdown.  Please be aware that if your bundle starts any threads \nbut does not ensure the threads are stopped when your bundle is stopped then \nyou may run into issues when your bundle is updated or uninstalled since we \nstill close classloaders in these cases.",
    "*** Bug 58172 has been marked as a duplicate of this bug. ***",
    "*** Bug 61349 has been marked as a duplicate of this bug. ***",
    "*** Bug 73926 has been marked as a duplicate of this bug. ***"
  ],
  "commentCreationDates": [
    "2003-11-21T18:19:32+01:00",
    "2003-11-26T11:52:54+01:00",
    "2003-11-26T20:46:14+01:00",
    "2003-11-26T22:28:30+01:00",
    "2003-11-26T22:33:53+01:00",
    "2003-11-26T22:34:31+01:00",
    "2003-11-26T22:56:32+01:00",
    "2003-11-26T23:02:28+01:00",
    "2003-11-26T23:06:24+01:00",
    "2003-11-27T00:43:54+01:00",
    "2003-11-27T11:56:23+01:00",
    "2003-11-27T12:33:49+01:00",
    "2003-11-27T12:40:55+01:00",
    "2003-11-27T17:20:33+01:00",
    "2003-12-12T05:35:31+01:00",
    "2003-12-16T07:33:54+01:00",
    "2003-12-17T17:34:15+01:00",
    "2003-12-17T17:45:54+01:00",
    "2004-01-09T09:28:57+01:00",
    "2004-01-09T09:31:48+01:00",
    "2004-02-18T21:34:58+01:00",
    "2004-03-22T21:20:58+01:00",
    "2004-03-23T03:35:58+01:00",
    "2004-03-23T03:51:00+01:00",
    "2004-04-19T17:25:29+02:00",
    "2004-04-19T20:24:14+02:00",
    "2004-04-30T23:38:10+02:00",
    "2004-05-06T20:44:19+02:00",
    "2004-05-07T07:13:10+02:00",
    "2004-05-07T20:17:26+02:00",
    "2004-09-15T15:09:09+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.pde.internal.core.PDECore.initializeModels",
          "source": "PDECore.java:423"
        },
        {
          "method": "org.eclipse.pde.internal.core.PDECore.getModelManager",
          "source": "PDECore.java:315"
        },
        {
          "method": "org.eclipse.pde.internal.core.PDECore.findPlugin",
          "source": "PDECore.java:300"
        },
        {
          "method": "org.eclipse.pde.internal.builders.ManifestConsistencyChecker.validateRequires",
          "source": "ManifestConsistencyChecker.java:508"
        },
        {
          "method": "org.eclipse.pde.internal.builders.ManifestConsistencyChecker.validateValues",
          "source": "ManifestConsistencyChecker.java:384"
        },
        {
          "method": "org.eclipse.pde.internal.builders.ManifestConsistencyChecker.validatePlugin",
          "source": "ManifestConsistencyChecker.java:259"
        },
        {
          "method": "org.eclipse.pde.internal.builders.ManifestConsistencyChecker.checkFile",
          "source": "ManifestConsistencyChecker.java:221"
        },
        {
          "method": "org.eclipse.pde.internal.builders.ManifestConsistencyChecker.access$1",
          "source": "ManifestConsistencyChecker.java:205"
        },
        {
          "method": "org.eclipse.pde.internal.builders.ManifestConsistencyChecker$DeltaVisitor.visit",
          "source": "ManifestConsistencyChecker.java:59"
        },
        {
          "method": "org.eclipse.core.internal.events.ResourceDelta.accept",
          "source": "ResourceDelta.java:71"
        },
        {
          "method": "org.eclipse.core.internal.events.ResourceDelta.accept",
          "source": "ResourceDelta.java:79"
        },
        {
          "method": "org.eclipse.core.internal.events.ResourceDelta.accept",
          "source": "ResourceDelta.java:52"
        },
        {
          "method": "org.eclipse.pde.internal.builders.ManifestConsistencyChecker.processDelta",
          "source": "ManifestConsistencyChecker.java:194"
        },
        {
          "method": "org.eclipse.pde.internal.builders.ManifestConsistencyChecker.build",
          "source": "ManifestConsistencyChecker.java:122"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$2.run",
          "source": "BuildManager.java:482"
        },
        {
          "method": "org.eclipse.core.internal.runtime.InternalPlatform.run",
          "source": "InternalPlatform.java:1127"
        },
        {
          "method": "org.eclipse.core.runtime.Platform.run",
          "source": "Platform.java:464"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:130"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:201"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:156"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$1.run",
          "source": "BuildManager.java:182"
        },
        {
          "method": "org.eclipse.core.internal.runtime.InternalPlatform.run",
          "source": "InternalPlatform.java:1127"
        },
        {
          "method": "org.eclipse.core.runtime.Platform.run",
          "source": "Platform.java:464"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:185"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuildLoop",
          "source": "BuildManager.java:219"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.build",
          "source": "BuildManager.java:247"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.doBuild",
          "source": "AutoBuildJob.java:76"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.run",
          "source": "AutoBuildJob.java:112"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:62"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "47255",
      "date": "2003-11-21T18:19:32+01:00",
      "product": "Equinox",
      "component": "Incubator",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.pde.internal.core.PDECore.initializeModels",
          "source": "PDECore.java:423"
        },
        {
          "method": "org.eclipse.pde.internal.core.PDECore.getWorkspaceModelManager",
          "source": "PDECore.java:356"
        },
        {
          "method": "org.eclipse.pde.internal.builders.ManifestConsistencyChecker.build",
          "source": "ManifestConsistencyChecker.java:128"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$2.run",
          "source": "BuildManager.java:482"
        },
        {
          "method": "org.eclipse.core.internal.runtime.InternalPlatform.run",
          "source": "InternalPlatform.java:1127"
        },
        {
          "method": "org.eclipse.core.runtime.Platform.run",
          "source": "Platform.java:464"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:130"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:201"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:156"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$1.run",
          "source": "BuildManager.java:182"
        },
        {
          "method": "org.eclipse.core.internal.runtime.InternalPlatform.run",
          "source": "InternalPlatform.java:1127"
        },
        {
          "method": "org.eclipse.core.runtime.Platform.run",
          "source": "Platform.java:464"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:185"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuildLoop",
          "source": "BuildManager.java:219"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.build",
          "source": "BuildManager.java:247"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.doBuild",
          "source": "AutoBuildJob.java:76"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.run",
          "source": "AutoBuildJob.java:112"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:62"
        }
      ],
      "number": 1,
      "commentIndex": 1,
      "bugId": "47255",
      "date": "2003-11-26T11:52:54+01:00",
      "product": "Equinox",
      "component": "Incubator",
      "severity": "normal"
    }
  ],
  "groupId": "47255",
  "bugId": "47255",
  "date": "2003-11-21T18:19:32+01:00",
  "product": "Equinox",
  "component": "Incubator",
  "severity": "normal"
}