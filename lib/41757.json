{
  "comments": [
    "Program did not suspend, launch terminated. \n\njunit.framework.AssertionFailedError: Program did not suspend, launch \nterminated.\nat java.lang.Throwable.\u003cinit\u003e(Throwable.java)\nat java.lang.Throwable.\u003cinit\u003e(Throwable.java)\nat junit.framework.AssertionFailedError.\u003cinit\u003e(AssertionFailedError.java)\nat org.eclipse.jdt.debug.tests.AbstractDebugTest.\nlaunchAndWait(AbstractDebugTest.java:170)\nat org.eclipse.jdt.debug.tests.AbstractDebugTest.\nlaunchToBreakpoint(AbstractDebugTest.java:229)\nat org.eclipse.jdt.debug.tests.core.RemoteAttachTests.\ntestAttach(RemoteAttachTests.java:85)\nat java.lang.reflect.AccessibleObject.invokeV(AccessibleObject.java:199)\nat org.eclipse.jdt.debug.tests.AutomatedSuite$1.run(AutomatedSuite.java:161)\nat java.lang.Thread.run(Thread.java:801)",
    "Are we supposed to be resuming the VM as soon as we connect to it?",
    "And why does the failure only occur on linux?",
    "Note that Remote Attach works in general on windows.",
    "It may just be coincedance, but the failure started after the job / launch work.",
    "The problem seems to be with setting the breakpoint. If you open Breakpoints.\njava (the test program) and try to set a breakpoint on line 52, you\u0027ll get the \nerror.",
    "I am not sure this is the same problem.",
    "I don\u0027t think it\u0027s related, it\u0027s a problem with the \u0027add breakpoint\u0027 action in\nthe  ruler (only if the file is not in the classpath, I think).\nThe \u0027add breakpoint\u0027 action in the text editor [Ctrl+Shift+B] works fine.\n\nCreated a new bug report for this problem: bug 41761.",
    "If you set a breakpoint in a class inside a Java project and remote launch, it \nwill suspend as normal. You can\u0027t set a breakpoint in this class, so it never \nsuspends. Is there something I\u0027m missing?",
    "(Luc commented 1 second before me. I\u0027ll poke around some more.)",
    "If it\u0027s not a problem setting the breakpoint, then it\u0027s back to mysteryville. \nSetting the breakpoint via the Run menu and doing a remote attach to the test \nclass works for me.",
    "I\u0027m pretty stumped here. Doing the remote launch myself (using the same \ncommandline the test uses) and connecting with the debugger works fine. \nDebugging through, everything looks alright. Playing with timeouts that should \nreduce the affect of the background launching doesn\u0027t help.",
    "Are you able to reproduce the test failure (by launching the test suite) ?\n\nIt fails the first time I tried, with a \u0027cannot connect to remote vm\u0027 stack\ntrace in the console, but it works fine the other times.",
    "I\u0027ve just been running the RemoteAttachTests class, but I get the failure \nconsistently.",
    "The following is printed to the console from the Eclipse instance under test:\n\n!ENTRY org.eclipse.jdt.debug 4 120 Aug 25, 2003 11:55:35.976\n!MESSAGE Internal error logged from JDI Debug: \n!STACK 1\norg.eclipse.debug.core.DebugException: Breakpoint does not have an associated \nmarker.\n\tat org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:\n258)\n\tat org.eclipse.debug.core.model.Breakpoint$2.run(Breakpoint.java:176)\n\tat org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1574)\n\tat org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1591)\n\tat org.eclipse.debug.core.model.Breakpoint.setAttribute(Breakpoint.java:\n180)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.\nincrementInstallCount(JavaBreakpoint.java:694)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.\nregisterRequest(JavaBreakpoint.java:200)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.\ncreateRequest(JavaBreakpoint.java:363)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.\nhandleClassPrepareEvent(JavaBreakpoint.java:280)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.\nhandleEvent(JavaBreakpoint.java:255)\n\tat org.eclipse.jdt.internal.debug.core.EventDispatcher.\ndispatch(EventDispatcher.java:136)\n\tat org.eclipse.jdt.internal.debug.core.EventDispatcher.run(EventDispatcher.\njava:214)\n\tat java.lang.Thread.run(Thread.java:536)\n!ENTRY org.eclipse.debug.core 4 5012 Aug 25, 2003 11:55:35.976\n!MESSAGE Breakpoint does not have an associated marker.",
    "Are you running into trouble from bug 41755?",
    "I have removed this test from the M3 build. It does not appear to be related to \nbackground launching.",
    "Deferred to M4",
    "I\u0027ve either found the problem or a very sneaky red herring. When we install the breakpoint and try \nto increment the install count, the UISynchronizer gets into an infinite loop in our JDI Event \nDispatch thread.\n\nWhen we set the installed count attribute on the breakpoint\u0027s marker, it causes a resource delta to \nbe fired that the WorkbenchContentProvider hears about. The content provider then performs a \nsynchExec which gets into the following UISynchronizer code which loops until the test \nframework kills Eclipse:\n\n  //even if the UI was not blocked earlier, it might become blocked\n  //before it can serve the asyncExec to do the pending work\n  while (!work.acquire(1000)) {\n    if (lockListener.isUIWaiting())\n      lockListener.interruptUI();\n   }\n\nHere\u0027s what the stack looks like:\n\nThread [org.eclipse.jdt.debug: JDI Event Dispatcher] (Suspended (breakpoint at line 26 in \nSemaphore))\n\tSemaphore.acquire(long) line: 26\n\tUISynchronizer.syncExec(Runnable) line: 42\n\tDisplay.syncExec(Runnable) line: 2287\n\tWorkbenchContentProvider.resourceChanged(IResourceChangeEvent) line: 198\n\tNotificationManager$1.run() line: 179\n\tInternalPlatform.run(ISafeRunnable) line: 1016\n\tPlatform.run(ISafeRunnable) line: 420\n\tNotificationManager.notify(ResourceChangeListenerList$ListenerEntry[], \nIResourceChangeEvent, boolean) line: 173\n\tNotificationManager.broadcastChanges(ElementTree, int, boolean) line: 77\n\tWorkspace.broadcastChanges(int, boolean) line: 155\n\tWorkspace.endOperation(boolean, IProgressMonitor) line: 866\n\tWorkspace.run(IWorkspaceRunnable, ISchedulingRule, IProgressMonitor) line: 1578\n\tWorkspace.run(IWorkspaceRunnable, IProgressMonitor) line: 1588\n\tJavaLineBreakpoint(Breakpoint).setAttribute(String, int) line: 180\n\tJavaLineBreakpoint(JavaBreakpoint).incrementInstallCount() line: 694\n\tJavaLineBreakpoint(JavaBreakpoint).registerRequest(EventRequest, JDIDebugTarget) \nline: 200\n\tJavaLineBreakpoint(JavaBreakpoint).createRequest(JDIDebugTarget, ReferenceType) \nline: 363\n\tJavaLineBreakpoint(JavaBreakpoint).handleClassPrepareEvent(ClassPrepareEvent, \nJDIDebugTarget) line: 280\n\tJavaLineBreakpoint(JavaBreakpoint).handleEvent(Event, JDIDebugTarget) line: 255\n\tEventDispatcher.dispatch(EventSet) line: 136\n\tEventDispatcher.run() line: 214\n\tThread.run() line: 536\n\nMeanwhile, the UI thread is blocked listening to a workspace runnable. The main thread looks like \nso:\n\nThread [main] (Suspended)\n\tSemaphore.release() line: 55\n\tUILockListener.doPendingWork() line: 104\n\tUILockListener.aboutToWait(Thread) line: 86\n\tLockManager.aboutToWait(Thread) line: 76\n\tImplicitJobs$ThreadJob.joinRun() line: 50\n\tImplicitJobs.begin(ISchedulingRule) line: 138\n\tJobManager.beginRule(ISchedulingRule) line: 111\n\tWorkManager.checkIn(ISchedulingRule) line: 80\n\tWorkspace.prepareOperation(ISchedulingRule) line: 1536\n\tWorkspace.run(IWorkspaceRunnable, ISchedulingRule, IProgressMonitor) line: 1568\n\tWorkspace.run(IWorkspaceRunnable, IProgressMonitor) line: 1588\n\tBreakpointManager.removeBreakpoints(IBreakpoint[], boolean) line: 354\n\tRemoteAttachTests(AbstractDebugTest).removeAllBreakpoints() line: 555\n\tRemoteAttachTests.testAttach() line: 111\n\tNativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native \nmethod]\n\tNativeMethodAccessorImpl.invoke(Object, Object[]) line: 39\n\tDelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 25\n\tMethod.invoke(Object, Object[]) line: 324\n\tRemoteAttachTests(TestCase).runTest() line: 154\n\tRemoteAttachTests(TestCase).runBare() line: 127\n\tTestResult$1.protect() line: 106\n\tTestResult.runProtected(Test, Protectable) line: 124\n\tTestResult.run(TestCase) line: 109\n\tRemoteAttachTests(TestCase).run(TestResult) line: 118\n\tTestSuite.runTest(Test, TestResult) line: 208\n\tTestSuite.run(TestResult) line: 203\n\tRemotePluginTestRunner(RemoteTestRunner).runTests(String[], String) line: 395\n\tRemotePluginTestRunner(RemoteTestRunner).run() line: 279\n\tRemotePluginTestRunner.main(String[]) line: 30\n\tUITestApplication.runEventLoop(Window$IExceptionHandler) line: 35\n\tUITestApplication(Workbench).run(Object) line: 2019\n\tInternalBootLoader.run(String, URL, String, String[], Runnable) line: 858\n\tBootLoader.run(String, URL, String, String[], Runnable) line: 461\n\tNativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native \nmethod]\n\tNativeMethodAccessorImpl.invoke(Object, Object[]) line: 39\n\tDelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 25\n\tMethod.invoke(Object, Object[]) line: 324\n\tMain.basicRun(String[]) line: 295\n\tMain.run(String[]) line: 751\n\tMain.main(String[]) line: 587\n",
    "From the stack traces, it looks like UI code fighting UI code. Can someone have a look?",
    "This looks like a lock issue with the UILockListener which is supplied by \nCore. Moving to Core",
    "Jared, can you describe how I can setup this test case?  Is it only on GTK? \nWhat VM and build of Eclipse are you using?  Are you saying this is somehow\nlooping and not completely deadlocked?\n\nThe stack trace looks completely normal: the Event Dispatcher thread is running\nan operation, and when it syncExecs, the UI is processing the syncExec requests\nin that loop that you show. One possibility is that the background thread is\nflooding the UI with syncExec requests (due to workspace operations not being\nbatched), which is delaying the UI thread which is also trying to modify the\nworkspace.\n\nI think I need to run the test case myself to further understand what is happening.",
    "Sorry, I should have been more clear about the looping. The code:\n  while (!work.acquire())\nkeeps looping in the same call. work.acquire() keeps failing so the loop keeps \ngoing.\n\nAs for reproducing the problem, we\u0027ve only seen it on Linux-GTK. I\u0027ve been able \nto reproduce the problem 100% of the time on my machine at home and at the \noffice and the test was always failing during the builds, but Luc reported that \nhe couldn\u0027t get it all the time. I set up my workspace with the following \nplugins as source:\n  org.eclipse.ant.core\n  org.eclipse.ant.tests.core\n  org.eclipse.ant.tests.ui\n  org.eclipse.ant.ui\n  org.eclipse.debug.core\n  org.eclipse.debug.ui\n  org.eclipse.jdt.debug\n  org.eclipse.jdt.debug.core\n  org.eclipse.jdt.debug.core.tests\n  org.eclipse.jdt.debug.ui\n  org.eclipse.jdt.launching\n  org.eclipse.jdt.launching.j9\n  org.eclipse.pde.junit\n  org.eclipse.releng\n  org.eclipse.ui.externaltools\n\nI have the remaining Eclipse plugins imported as binary using the import \nwizard\u0027s default settings. To run the test, open RemoteAttachTests then Run As \n(or Debug As)-\u003eJUnit Plug-in Test.",
    "The test fails for me every time, on both GTK and Win2k.  In fact, I don\u0027t\nunderstand how this test could ever have passed.  Here is what\u0027s happening\n(based on my somewhat fuzzy understanding of the debug component):\n\nThe UI thread launches a test VM, and then waits for an event\n(DebugEventWaiter.waitForEvent).  This puts the UI thread to sleep on the wait\ncall for 30 seconds.\n\nMeanwhile, the forked VM sends a JDI event to install a breakpoint. This causes\nthe JDI Event Dispatcher thread to increment the marker\u0027s install count.  This\nresults in a workspace resource change event.  One of the listeners (the\nWorkbenchContentProvider that updates the Navigator view), does a syncExec. \nNow, since the UI thread is asleep, the syncExec will never get processed. So,\nnow the JDI Event Thread is frozen.\n\nI\u0027m guessing that since the JDI Event Thread is dead, that the UI thread,\nwaiting for a debug event, will never get the event it is waiting for. \nEventually, the UI thread times out and the test fails.\n\nAfter the assertion failure (the assertNotNull in\nAbstractDebugTest.launchAndWait), it enters the finally block in\nRemoteAttachTests.testAttach.  This finally block tries to remove all\nbreakpoints (this is the point where it is suspended in Jared\u0027s stack trace). At\nthis point, we have a special handler (UISynchronizer) to prevent the imminent\ndeadlock: the UI thread is trying to modify the workspace, but the workspace\nlock is owned by a thread that is trying to syncExec.  Our handler allows the\nsyncExec to proceed, so the JDI Event Thread finally gets to run its syncExec\n(too late to be of any use).\n\nSo, I don\u0027t know why this test is only failing now.  The UI handler to avoid\ndeadlock has always been there, so that\u0027s not the problem. The problem is that\nthe test is running in the UI thread, so syncExecs never get processed.  I\u0027m\ngrasping at straws, but maybe the new PDE JUnit behaves differently, causing the\nworkbench components to be active and thus listening to resource change events\nwhen they weren\u0027t before?  It looks like this test is meant to be run headless?\n\nAnyway, no problem found in core... back to debug.",
    "John - we run our test suite in a non-UI thread. @see AutomatedSuite.run(..) in \norg.eclipse.jdt.debug.tests.",
    "I was just following Jared\u0027s steps, which didn\u0027t involve AutomatedSuite.run.  I\nguess i just wasted two hours ;(",
    "Jared - is this the problem you are having with the test - i.e. running it in \nthe UI thread?",
    "Sorry, John. My fault. I had no idea that the test suite was doing this.\n\nI mentioned back in comment #13 that I was just running the test class. We\u0027ve discussed running \nindividual test classes (which usually works) before and the ui thread versus non-ui thread issue \nhas never come up. Lesson learned (at your expense :(  ).\n\nThis puts us back at the place we started - the test runs fine when we launch it in our automated \nsuite, but it was failing consistently during the builds. Any chance the build process is doing \nsomething with a similar effect?",
    "Nope - the build just runs our automated suite. All the tests that launch a VM \nwould fail if that were the case.",
    "The remote attach tests have been added to the \"Manual\" debug test suite (@see \nManualSuite). We should determine why this test was failing in the automated \ntest suite.",
    "deferred",
    "Closing",
    "Closing"
  ],
  "commentCreationDates": [
    "2003-08-20T22:10:27+02:00",
    "2003-08-20T22:11:57+02:00",
    "2003-08-20T22:17:30+02:00",
    "2003-08-20T22:23:32+02:00",
    "2003-08-20T22:26:55+02:00",
    "2003-08-20T22:37:40+02:00",
    "2003-08-20T22:45:18+02:00",
    "2003-08-20T23:07:55+02:00",
    "2003-08-20T23:08:56+02:00",
    "2003-08-20T23:09:55+02:00",
    "2003-08-20T23:16:40+02:00",
    "2003-08-20T23:46:06+02:00",
    "2003-08-20T23:56:08+02:00",
    "2003-08-21T00:16:42+02:00",
    "2003-08-25T20:52:23+02:00",
    "2003-08-25T21:55:18+02:00",
    "2003-08-25T23:56:20+02:00",
    "2003-08-27T16:12:12+02:00",
    "2003-09-12T00:18:03+02:00",
    "2003-09-12T00:20:02+02:00",
    "2003-09-12T15:09:50+02:00",
    "2003-09-12T16:03:40+02:00",
    "2003-09-12T16:51:08+02:00",
    "2003-09-12T20:34:46+02:00",
    "2003-09-12T20:42:02+02:00",
    "2003-09-12T20:51:17+02:00",
    "2003-09-12T20:59:34+02:00",
    "2003-09-12T23:09:20+02:00",
    "2003-09-12T23:12:48+02:00",
    "2003-11-24T20:52:12+01:00",
    "2004-05-12T17:20:49+02:00",
    "2007-06-08T19:04:00+02:00",
    "2007-06-08T19:04:21+02:00"
  ],
  "traces": [
    {
      "exceptionType": "junit.framework.AssertionFailedError",
      "message": "Program did not suspend, launch  terminated.",
      "elements": [
        {
          "method": "java.lang.Throwable.\u003cinit\u003e",
          "source": "Throwable.java"
        },
        {
          "method": "java.lang.Throwable.\u003cinit\u003e",
          "source": "Throwable.java"
        },
        {
          "method": "junit.framework.AssertionFailedError.\u003cinit\u003e",
          "source": "AssertionFailedError.java"
        },
        {
          "method": "org.eclipse.jdt.debug.tests.AbstractDebugTest.launchAndWait",
          "source": "AbstractDebugTest.java:170"
        },
        {
          "method": "org.eclipse.jdt.debug.tests.AbstractDebugTest.launchToBreakpoint",
          "source": "AbstractDebugTest.java:229"
        },
        {
          "method": "org.eclipse.jdt.debug.tests.core.RemoteAttachTests.testAttach",
          "source": "RemoteAttachTests.java:85"
        },
        {
          "method": "java.lang.reflect.AccessibleObject.invokeV",
          "source": "AccessibleObject.java:199"
        },
        {
          "method": "org.eclipse.jdt.debug.tests.AutomatedSuite$1.run",
          "source": "AutomatedSuite.java:161"
        },
        {
          "method": "java.lang.Thread.run",
          "source": "Thread.java:801"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "41757",
      "date": "2003-08-20T22:10:27+02:00",
      "product": "JDT",
      "component": "Debug",
      "severity": "normal"
    },
    {
      "exceptionType": "org.eclipse.debug.core.DebugException",
      "message": "Breakpoint does not have an associated  marker.",
      "elements": [
        {
          "method": "org.eclipse.debug.core.model.Breakpoint.ensureMarker",
          "source": "Breakpoint.java: 258"
        },
        {
          "method": "org.eclipse.debug.core.model.Breakpoint$2.run",
          "source": "Breakpoint.java:176"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.run",
          "source": "Workspace.java:1574"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.run",
          "source": "Workspace.java:1591"
        },
        {
          "method": "org.eclipse.debug.core.model.Breakpoint.setAttribute",
          "source": "Breakpoint.java: 180"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.incrementInstallCount",
          "source": "JavaBreakpoint.java:694"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.registerRequest",
          "source": "JavaBreakpoint.java:200"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.createRequest",
          "source": "JavaBreakpoint.java:363"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.handleClassPrepareEvent",
          "source": "JavaBreakpoint.java:280"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.handleEvent",
          "source": "JavaBreakpoint.java:255"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch",
          "source": "EventDispatcher.java:136"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.EventDispatcher.run",
          "source": "EventDispatcher. java:214"
        },
        {
          "method": "java.lang.Thread.run",
          "source": "Thread.java:536"
        }
      ],
      "number": 1,
      "commentIndex": 14,
      "bugId": "41757",
      "date": "2003-08-25T20:52:23+02:00",
      "product": "JDT",
      "component": "Debug",
      "severity": "normal"
    }
  ],
  "groupId": "41757",
  "bugId": "41757",
  "date": "2003-08-20T22:10:27+02:00",
  "product": "JDT",
  "component": "Debug",
  "severity": "normal"
}