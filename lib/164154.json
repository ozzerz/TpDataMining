{
  "comments": [
    "When I create all possible Containers for the purpose of finding out which ones support IBulletinBoardContainerAdapter, I get the following error when that process is run for the second time:\n\nIt seems that the first time the container is created, a port is opened and it can\u0027t be opened again the second time.\n\norg.eclipse.ecf.core.ContainerCreateException: Exception creating generic container\n\tat org.eclipse.ecf.provider.generic.GenericContainerInstantiator.createInstance(GenericContainerInstantiator.java:165)\n\tat org.eclipse.ecf.core.ContainerFactory.createContainer(ContainerFactory.java:241)\n\tat org.eclipse.ecf.core.ContainerFactory.createContainer(ContainerFactory.java:259)\n\tat org.eclipse.ecf.examples.bbreader.wizards.NewBBWizardPage.createControl(NewBBWizardPage.java:59)\n\tat org.eclipse.jface.wizard.Wizard.createPageControls(Wizard.java:259)\n\tat org.eclipse.jface.wizard.WizardDialog.createPageControls(WizardDialog.java:629)\n\tat org.eclipse.jface.wizard.WizardDialog.setWizard(WizardDialog.java:1028)\n\tat org.eclipse.jface.wizard.WizardDialog.updateForPage(WizardDialog.java:1080)\n\tat org.eclipse.jface.wizard.WizardDialog.access$2(WizardDialog.java:1077)\n\tat org.eclipse.jface.wizard.WizardDialog$4.run(WizardDialog.java:1067)\n\tat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)\n\tat org.eclipse.jface.wizard.WizardDialog.showPage(WizardDialog.java:1065)\n\tat org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:777)\n\tat org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:363)\n\tat org.eclipse.jface.dialogs.Dialog$3.widgetSelected(Dialog.java:638)\n\tat org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)\n\tat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3463)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3077)\n\tat org.eclipse.jface.window.Window.runEventLoop(Window.java:820)\n\tat org.eclipse.jface.window.Window.open(Window.java:796)\n\tat org.eclipse.ui.actions.NewWizardAction.run(NewWizardAction.java:182)\n\tat org.eclipse.jface.action.Action.runWithEvent(Action.java:499)\n\tat org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:539)\n\tat org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)\n\tat org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)\n\tat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3463)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3077)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1924)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1888)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:419)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:95)\n\tat org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:78)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:104)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:74)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:348)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:165)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.eclipse.core.launcher.Main.invokeFramework(Main.java:341)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:285)\n\tat org.eclipse.core.launcher.Main.run(Main.java:987)\n\tat org.eclipse.core.launcher.Main.main(Main.java:962)\nCaused by: java.net.BindException: Address already in use: JVM_Bind\n\tat java.net.PlainSocketImpl.socketBind(Native Method)\n\tat java.net.PlainSocketImpl.bind(PlainSocketImpl.java:359)\n\tat java.net.ServerSocket.bind(ServerSocket.java:319)\n\tat java.net.ServerSocket.\u003cinit\u003e(ServerSocket.java:185)\n\tat java.net.ServerSocket.\u003cinit\u003e(ServerSocket.java:141)\n\tat org.eclipse.ecf.provider.comm.tcp.Server.\u003cinit\u003e(Server.java:43)\n\tat org.eclipse.ecf.provider.generic.TCPServerSOContainerGroup.putOnTheAir(TCPServerSOContainerGroup.java:78)\n\tat org.eclipse.ecf.provider.generic.TCPServerSOContainer.\u003cinit\u003e(TCPServerSOContainer.java:60)\n\tat org.eclipse.ecf.provider.generic.TCPServerSOContainer.\u003cinit\u003e(TCPServerSOContainer.java:101)\n\tat org.eclipse.ecf.provider.generic.GenericContainerInstantiator.createInstance(GenericContainerInstantiator.java:158)\n\t... 48 more",
    "Hi Erkki,\n\nThis is because the generic server container, when created, tries to open up a default port for listening (3282).  When the first one succeeds, the second one fails.\n\nMy first temptation was to modify the generic server creation behavior so that it would never fail on construction, but I realized that for other (unknown) providers it could *always* be the case that the provider IContainerInstantiator would throw a ContainerCreateException...and any code that took the strategy that your code takes (create a container and then look for certain interface(s) on it) could fail in this way frequently only because other providers threw this exception for other reasons.\n\nSo I think that to use this strategy you are going to have to catch the ContainerCreateException and only check the container if the createContainer method doesn\u0027t throw.\n\nAnother way to deal with this issue, however, is to enhance the provider interface (IContainerInstantiator) so that it can be queried for the interfaces it supports...by adding a method like this:\n\nIContainerInstantiator\n\npublic Class[] getSupportedAdapters();\n\nWhat do you think of this as an approach?  If we are going to do this, then now would be the time (before 0.9.3 is done and released).\n\nLet me know what you think.\n\nThanks,\n\nScott\n\n\n(In reply to comment #0)\n\u003e When I create all possible Containers for the purpose of finding out which ones\n\u003e support IBulletinBoardContainerAdapter, I get the following error when that\n\u003e process is run for the second time:\n\u003e \n\u003e It seems that the first time the container is created, a port is opened and it\n\u003e can\u0027t be opened again the second time.\n\u003e \n\u003e org.eclipse.ecf.core.ContainerCreateException: Exception creating generic\n\u003e container\n\u003e         at\n\u003e org.eclipse.ecf.provider.generic.GenericContainerInstantiator.createInstance(GenericContainerInstantiator.java:165)\n\u003e         at\n\u003e org.eclipse.ecf.core.ContainerFactory.createContainer(ContainerFactory.java:241)\n\u003e         at\n\u003e org.eclipse.ecf.core.ContainerFactory.createContainer(ContainerFactory.java:259)\n\u003e         at\n\u003e org.eclipse.ecf.examples.bbreader.wizards.NewBBWizardPage.createControl(NewBBWizardPage.java:59)\n\u003e         at org.eclipse.jface.wizard.Wizard.createPageControls(Wizard.java:259)\n\u003e         at\n\u003e org.eclipse.jface.wizard.WizardDialog.createPageControls(WizardDialog.java:629)\n\u003e         at\n\u003e org.eclipse.jface.wizard.WizardDialog.setWizard(WizardDialog.java:1028)\n\u003e         at\n\u003e org.eclipse.jface.wizard.WizardDialog.updateForPage(WizardDialog.java:1080)\n\u003e         at\n\u003e org.eclipse.jface.wizard.WizardDialog.access$2(WizardDialog.java:1077)\n\u003e         at org.eclipse.jface.wizard.WizardDialog$4.run(WizardDialog.java:1067)\n\u003e         at\n\u003e org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)\n\u003e         at\n\u003e org.eclipse.jface.wizard.WizardDialog.showPage(WizardDialog.java:1065)\n\u003e         at\n\u003e org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:777)\n\u003e         at\n\u003e org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:363)\n\u003e         at org.eclipse.jface.dialogs.Dialog$3.widgetSelected(Dialog.java:638)\n\u003e         at\n\u003e org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)\n\u003e         at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n\u003e         at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)\n\u003e         at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3463)\n\u003e         at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3077)\n\u003e         at org.eclipse.jface.window.Window.runEventLoop(Window.java:820)\n\u003e         at org.eclipse.jface.window.Window.open(Window.java:796)\n\u003e         at org.eclipse.ui.actions.NewWizardAction.run(NewWizardAction.java:182)\n\u003e         at org.eclipse.jface.action.Action.runWithEvent(Action.java:499)\n\u003e         at\n\u003e org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:539)\n\u003e         at\n\u003e org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)\n\u003e         at\n\u003e org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)\n\u003e         at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n\u003e         at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)\n\u003e         at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3463)\n\u003e         at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3077)\n\u003e         at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1924)\n\u003e         at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1888)\n\u003e         at\n\u003e org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:419)\n\u003e         at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)\n\u003e         at\n\u003e org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:95)\n\u003e         at\n\u003e org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:78)\n\u003e         at\n\u003e org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:104)\n\u003e         at\n\u003e org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:74)\n\u003e         at\n\u003e org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:348)\n\u003e         at\n\u003e org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:165)\n\u003e         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\u003e         at\n\u003e sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\u003e         at\n\u003e sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\u003e         at java.lang.reflect.Method.invoke(Method.java:585)\n\u003e         at org.eclipse.core.launcher.Main.invokeFramework(Main.java:341)\n\u003e         at org.eclipse.core.launcher.Main.basicRun(Main.java:285)\n\u003e         at org.eclipse.core.launcher.Main.run(Main.java:987)\n\u003e         at org.eclipse.core.launcher.Main.main(Main.java:962)\n\u003e Caused by: java.net.BindException: Address already in use: JVM_Bind\n\u003e         at java.net.PlainSocketImpl.socketBind(Native Method)\n\u003e         at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:359)\n\u003e         at java.net.ServerSocket.bind(ServerSocket.java:319)\n\u003e         at java.net.ServerSocket.\u003cinit\u003e(ServerSocket.java:185)\n\u003e         at java.net.ServerSocket.\u003cinit\u003e(ServerSocket.java:141)\n\u003e         at org.eclipse.ecf.provider.comm.tcp.Server.\u003cinit\u003e(Server.java:43)\n\u003e         at\n\u003e org.eclipse.ecf.provider.generic.TCPServerSOContainerGroup.putOnTheAir(TCPServerSOContainerGroup.java:78)\n\u003e         at\n\u003e org.eclipse.ecf.provider.generic.TCPServerSOContainer.\u003cinit\u003e(TCPServerSOContainer.java:60)\n\u003e         at\n\u003e org.eclipse.ecf.provider.generic.TCPServerSOContainer.\u003cinit\u003e(TCPServerSOContainer.java:101)\n\u003e         at\n\u003e org.eclipse.ecf.provider.generic.GenericContainerInstantiator.createInstance(GenericContainerInstantiator.java:158)\n\u003e         ... 48 more\n\u003e \n\n",
    "I think that\u0027s a good idea.",
    "(In reply to comment #2)\n\u003e I think that\u0027s a good idea.\n\u003e \n\nOK, I implemented the following method as an addition to org.eclipse.ecf.core.ContainerTypeDescription:\n\n\t/**\n\t * Get array of supported adapters for the given container type description.\n\t * Providers can implement this method to allow clients to inspect the\n\t * adapter types implemented by the container described by the given\n\t * description.\n\t * \n\t * Note that the returned types do not guarantee that a subsequent call to\n\t * {@link IContainer#getAdapter(Class)} with the same type name as a\n\t * returned value will return a non-null result.\n\t * \u003ccode\u003eIContainer.getAdapter\u003c/code\u003e may still return \u003ccode\u003enull\u003c/code\u003e. *\n\t * \n\t * @return Class[] of supported adapters. Null will be returned if no\n\t *         adapters are supported\n\t */\n\tpublic String[] getSupportedAdapterTypes();\n\nNow callers can get an array of Strings that give the classnames of the interfaces supported as adapters for a given ContainerTypeDescription.  See \nContainerFactory.getDescriptionForName(String) to get ContainerTypeDescription instance for given String name.\n\nThis allows callers to get the list of supported adapter types (as String []) and to look for a specific supporting adapter type (e.g. IPresenceContainerAdapter.class) *before* creating an IContainer instance.\n\nMarking bug resolved.\n",
    "I don\u0027t know that much about the nuances of Java class loading -- is the reason for returning String[] instead of Class[] that otherwise all possible container adapter classes would have to be loaded?\n\nI want to clarify: the String[] should contain fully qualified class names?\n\nPS. there\u0027s an inconsistency in the contract:\n\t * This method should *not return*\n\t * null, but rather an *empty String[]* if no adapters are exposed.\n\t * \n\t * @param description\n\t *            the ContainerTypeDescription to report adapters for\n\t * @return String[] of supported adapter types.  If no\n\t *         adapters supported, will *return null*\n",
    "Hi Erkki,\n\n(In reply to comment #4)\n\u003e I don\u0027t know that much about the nuances of Java class loading -- is the reason\n\u003e for returning String[] instead of Class[] that otherwise all possible container\n\u003e adapter classes would have to be loaded?\n\nYes...pretty much.  \n\n\u003e \n\u003e I want to clarify: the String[] should contain fully qualified class names?\n\nYes, I\u0027ve added to the javadocs on this point...thanks.\n\n\u003e \n\u003e PS. there\u0027s an inconsistency in the contract:\n\u003e          * This method should *not return*\n\u003e          * null, but rather an *empty String[]* if no adapters are exposed.\n\u003e          * \n\u003e          * @param description\n\u003e          *            the ContainerTypeDescription to report adapters for\n\u003e          * @return String[] of supported adapter types.  If no\n\u003e          *         adapters supported, will *return null*\n\u003e \n\nRight...this was just a mistake my part.  I\u0027ve corrected the contract so that the IContainerInstantiator.getSupportedAdapterTypes() *may* return null (implemented by providers), but the ContainerTypeDescription (used by client)\nwill not return null.\n\nThanks",
    "(In reply to comment #5)\n\u003e Right...this was just a mistake my part.  I\u0027ve corrected the contract so that\n\u003e the IContainerInstantiator.getSupportedAdapterTypes() *may* return null\n\u003e (implemented by providers), but the ContainerTypeDescription (used by client)\n\u003e will not return null.\nRight now IContainerInstantiator\u0027s API for getSupportedAdapterTypes(ContainerTypeDescription) reads:\n\n* This method should not return null, but rather an empty String[] if no\n* adapters are exposed.\n* \n* @param description\n*            the ContainerTypeDescription to report adapters for. Must not\n*            be null\n* @return String[] of supported adapters. The entries in the returned array\n*         will be the fully qualified class names of adapters supported by\n*         the given description. Null may be returned if adapter types are\n*         supported.\n\nThis still seems inconsistent/confusing to me. Especially the \"Null may be returned if adapter types are supported\" bit.",
    "Documentation re-fixed :).  Sorry about confusion.\n\n(In reply to comment #6)\n\u003e (In reply to comment #5)\n\u003e \u003e Right...this was just a mistake my part.  I\u0027ve corrected the contract so that\n\u003e \u003e the IContainerInstantiator.getSupportedAdapterTypes() *may* return null\n\u003e \u003e (implemented by providers), but the ContainerTypeDescription (used by client)\n\u003e \u003e will not return null.\n\u003e Right now IContainerInstantiator\u0027s API for\n\u003e getSupportedAdapterTypes(ContainerTypeDescription) reads:\n\u003e \n\u003e * This method should not return null, but rather an empty String[] if no\n\u003e * adapters are exposed.\n\u003e * \n\u003e * @param description\n\u003e *            the ContainerTypeDescription to report adapters for. Must not\n\u003e *            be null\n\u003e * @return String[] of supported adapters. The entries in the returned array\n\u003e *         will be the fully qualified class names of adapters supported by\n\u003e *         the given description. Null may be returned if adapter types are\n\u003e *         supported.\n\u003e \n\u003e This still seems inconsistent/confusing to me. Especially the \"Null may be\n\u003e returned if adapter types are supported\" bit.\n\u003e \n\n",
    "Wait, did anything change at all?\n\nThis method shouldn\u0027t return null but an empty String[] if no adapters are exposed. But for @return it says null returned if no adapters supported. Or is exposed and supported two different meanings in this context?\n\n * This method should not return null, but rather an empty String[] if no\n * adapters are exposed.\n * \n * @param description\n *            the ContainerTypeDescription to report adapters for. Must not\n *            be null\n * @return String[] of supported adapters. The entries in the returned array\n *         will be the fully qualified class names of adapters supported by\n *         the given description. Null returned if no adapters are supported\n *         for given description.",
    "Hi Remy,\n\nI screwed up the javadocs changes because the IContainerInstantiator.getAdapterTypes (the method implemented by the provider) and the ContainerTypeDescription (the method implemented in ECF core that calls the IContainerInstantiator.getAdapterTypes have different return value contracts.  For the IContainerInstantiator.getAdapterTypes can return null to indicate no supported adapters.  The ContainerTypeDescription must always return String[0] rather than null.\n\nFixed documentation on both IContainerInstantiator and ContainerTypeDescription to describe appropriate contract.\n\n\nIn reply to comment #8)\n\u003e Wait, did anything change at all?\n\u003e \n\u003e This method shouldn\u0027t return null but an empty String[] if no adapters are\n\u003e exposed. But for @return it says null returned if no adapters supported. Or is\n\u003e exposed and supported two different meanings in this context?\n\u003e \n\u003e  * This method should not return null, but rather an empty String[] if no\n\u003e  * adapters are exposed.\n\u003e  * \n\u003e  * @param description\n\u003e  *            the ContainerTypeDescription to report adapters for. Must not\n\u003e  *            be null\n\u003e  * @return String[] of supported adapters. The entries in the returned array\n\u003e  *         will be the fully qualified class names of adapters supported by\n\u003e  *         the given description. Null returned if no adapters are supported\n\u003e  *         for given description.\n\u003e \n\n"
  ],
  "commentCreationDates": [
    "2006-11-10T18:27:29+01:00",
    "2006-11-10T21:11:53+01:00",
    "2006-11-10T23:29:53+01:00",
    "2006-11-11T06:44:23+01:00",
    "2006-11-11T12:02:16+01:00",
    "2006-11-11T18:10:23+01:00",
    "2006-11-21T07:14:46+01:00",
    "2006-11-21T14:48:04+01:00",
    "2007-01-04T23:06:31+01:00",
    "2007-01-05T08:57:24+01:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.ecf.core.ContainerCreateException",
      "message": "Exception creating generic container",
      "elements": [
        {
          "method": "org.eclipse.ecf.provider.generic.GenericContainerInstantiator.createInstance",
          "source": "GenericContainerInstantiator.java:165"
        },
        {
          "method": "org.eclipse.ecf.core.ContainerFactory.createContainer",
          "source": "ContainerFactory.java:241"
        },
        {
          "method": "org.eclipse.ecf.core.ContainerFactory.createContainer",
          "source": "ContainerFactory.java:259"
        },
        {
          "method": "org.eclipse.ecf.examples.bbreader.wizards.NewBBWizardPage.createControl",
          "source": "NewBBWizardPage.java:59"
        },
        {
          "method": "org.eclipse.jface.wizard.Wizard.createPageControls",
          "source": "Wizard.java:259"
        },
        {
          "method": "org.eclipse.jface.wizard.WizardDialog.createPageControls",
          "source": "WizardDialog.java:629"
        },
        {
          "method": "org.eclipse.jface.wizard.WizardDialog.setWizard",
          "source": "WizardDialog.java:1028"
        },
        {
          "method": "org.eclipse.jface.wizard.WizardDialog.updateForPage",
          "source": "WizardDialog.java:1080"
        },
        {
          "method": "org.eclipse.jface.wizard.WizardDialog.access$2",
          "source": "WizardDialog.java:1077"
        },
        {
          "method": "org.eclipse.jface.wizard.WizardDialog$4.run",
          "source": "WizardDialog.java:1067"
        },
        {
          "method": "org.eclipse.swt.custom.BusyIndicator.showWhile",
          "source": "BusyIndicator.java:67"
        },
        {
          "method": "org.eclipse.jface.wizard.WizardDialog.showPage",
          "source": "WizardDialog.java:1065"
        },
        {
          "method": "org.eclipse.jface.wizard.WizardDialog.nextPressed",
          "source": "WizardDialog.java:777"
        },
        {
          "method": "org.eclipse.jface.wizard.WizardDialog.buttonPressed",
          "source": "WizardDialog.java:363"
        },
        {
          "method": "org.eclipse.jface.dialogs.Dialog$3.widgetSelected",
          "source": "Dialog.java:638"
        },
        {
          "method": "org.eclipse.swt.widgets.TypedListener.handleEvent",
          "source": "TypedListener.java:90"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java:66"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:925"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java:3463"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:3077"
        },
        {
          "method": "org.eclipse.jface.window.Window.runEventLoop",
          "source": "Window.java:820"
        },
        {
          "method": "org.eclipse.jface.window.Window.open",
          "source": "Window.java:796"
        },
        {
          "method": "org.eclipse.ui.actions.NewWizardAction.run",
          "source": "NewWizardAction.java:182"
        },
        {
          "method": "org.eclipse.jface.action.Action.runWithEvent",
          "source": "Action.java:499"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection",
          "source": "ActionContributionItem.java:539"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.access$2",
          "source": "ActionContributionItem.java:488"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem$5.handleEvent",
          "source": "ActionContributionItem.java:400"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java:66"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:925"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java:3463"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:3077"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1924"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1888"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:419"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:149"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:95"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:78"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication",
          "source": "EclipseAppLauncher.java:104"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start",
          "source": "EclipseAppLauncher.java:74"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:348"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:165"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:585"
        },
        {
          "method": "org.eclipse.core.launcher.Main.invokeFramework",
          "source": "Main.java:341"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:285"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:987"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:962"
        }
      ],
      "causedBy": {
        "exceptionType": "java.net.BindException",
        "message": "Address already in use: JVM_Bind",
        "elements": [
          {
            "method": "java.net.PlainSocketImpl.socketBind",
            "source": "Native Method"
          },
          {
            "method": "java.net.PlainSocketImpl.bind",
            "source": "PlainSocketImpl.java:359"
          },
          {
            "method": "java.net.ServerSocket.bind",
            "source": "ServerSocket.java:319"
          },
          {
            "method": "java.net.ServerSocket.\u003cinit\u003e",
            "source": "ServerSocket.java:185"
          },
          {
            "method": "java.net.ServerSocket.\u003cinit\u003e",
            "source": "ServerSocket.java:141"
          },
          {
            "method": "org.eclipse.ecf.provider.comm.tcp.Server.\u003cinit\u003e",
            "source": "Server.java:43"
          },
          {
            "method": "org.eclipse.ecf.provider.generic.TCPServerSOContainerGroup.putOnTheAir",
            "source": "TCPServerSOContainerGroup.java:78"
          },
          {
            "method": "org.eclipse.ecf.provider.generic.TCPServerSOContainer.\u003cinit\u003e",
            "source": "TCPServerSOContainer.java:60"
          },
          {
            "method": "org.eclipse.ecf.provider.generic.TCPServerSOContainer.\u003cinit\u003e",
            "source": "TCPServerSOContainer.java:101"
          },
          {
            "method": "org.eclipse.ecf.provider.generic.GenericContainerInstantiator.createInstance",
            "source": "GenericContainerInstantiator.java:158"
          }
        ],
        "number": 0,
        "commentIndex": 0
      },
      "number": 0,
      "commentIndex": 0,
      "bugId": "164154",
      "date": "2006-11-10T18:27:29+01:00",
      "product": "ECF",
      "component": "ecf.core",
      "severity": "major"
    },
    {
      "exceptionType": "org.eclipse.ecf.core.ContainerCreateException",
      "message": "Exception creating generic \u003e container \u003e         at \u003e org.eclipse.ecf.provider.generic.GenericContainerInstantiator.createInstance(GenericContainerInstantiator.java:165) \u003e         at \u003e org.eclipse.ecf.core.ContainerFactory.createContainer(ContainerFactory.java:241) \u003e         at \u003e org.eclipse.ecf.core.ContainerFactory.createContainer(ContainerFactory.java:259) \u003e         at \u003e org.eclipse.ecf.examples.bbreader.wizards.NewBBWizardPage.createControl(NewBBWizardPage.java:59) \u003e",
      "elements": [
        {
          "method": "org.eclipse.jface.wizard.Wizard.createPageControls",
          "source": "Wizard.java:259"
        }
      ],
      "number": 1,
      "commentIndex": 1,
      "bugId": "164154",
      "date": "2006-11-10T21:11:53+01:00",
      "product": "ECF",
      "component": "ecf.core",
      "severity": "major"
    },
    {
      "exceptionType": "java.net.BindException",
      "message": "Address already in use: JVM_Bind \u003e",
      "elements": [
        {
          "method": "java.net.PlainSocketImpl.socketBind",
          "source": "Native Method"
        }
      ],
      "number": 2,
      "commentIndex": 1,
      "bugId": "164154",
      "date": "2006-11-10T21:11:53+01:00",
      "product": "ECF",
      "component": "ecf.core",
      "severity": "major"
    }
  ],
  "groupId": "164154",
  "bugId": "164154",
  "date": "2006-11-10T18:27:29+01:00",
  "product": "ECF",
  "component": "ecf.core",
  "severity": "major"
}