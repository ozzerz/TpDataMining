{
  "comments": [
    "The task list spents a lot of CPU time in AbstractTaskContainter.contains() on refresh. AbstractTaskContainter.containsHelper() and AbstractTaskContainter.getChildren() need to be optimized.",
    "I see four callers of AbstractTaskContainer.contains(), can you tell me the main caller causing this?\nPerhaps the check for no cycles is performed more than once per iteration?",
    "Created an attachment (id\u003d81457)\nApplying brains to problem:\n\n3 out of 4 possible steps implemented, please test this.",
    "Created an attachment (id\u003d81458)\nmylyn/context/zip\n\n",
    "BTW, I think contains() methods should not use getChildren() call, which will create a temporary collection that is thrown away after getting its size.",
    "Maarten, could you please outline how your patch addresses the problem mentioned in the description?",
    " (In reply to comment #5)\n\u003e Maarten, could you please outline how your patch addresses the problem mentioned\n\u003e in the description?\nThe helper contains superfluous tests and recurses only to return again. \nI\u0027ve tried to remove those, but I don\u0027t have access to a profiler: bug 68111 :-(.\n\n (In reply to comment #4)\n\u003e BTW, I think contains() methods should not use getChildren() call, which will\n\u003e create a temporary collection that is thrown away after getting its size.\nI\u0027ll look at getChildren() next, it\u0027s called  twice now: once to see its not null, once to find the size.\nI cache the intermediate result to remve one call.\n\nAfter this I need to compare the performance with the new method countChildren, that does not allocate and dispose an intermediate result HashSet on every invocation, but just counts.\nIs a unit test already available for this as basis for a performance test??",
    "Created an attachment (id\u003d81482)\npatch with one call to getChildren removed.\n\nThank you Eugene and Steffen for feedback",
    "Maarten, it would help the review process and the project most if open questions were discussed first before patches are attached to an issue. The review of a complete and polished patch will require much less time than reviewing multiple incomplete patches and increase the chances a patch to get merged.\n\nI am not sure if these methods can be optimized without looking at the detailed profiling results. Please also note Eugene\u0027s comment on bug 194430 .\n",
    "Yesterday I created a junit test for this bug to test different implementations of the containsHelper() function.\ncaching the result of getChildren gives a 50% improvement but still gives long times for large (dipe/wide) trees.\nThis morning I woke up with the solution: this function must recurse when it hasChildren(), the count is irrelevant!\nAnd hasChildren() is cheap, it can return as soon as there is a single child!!\n\n\tprivate boolean containsHelperB(String handle, int depth) {\n\t\tif (depth \u003e\u003d MAX_SUBTASK_DEPTH) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tdepth++;\n\t\t\tfor (AbstractTask child : children) {\n\t\t\t\tString childLabel \u003d child.getHandleIdentifier();\n\t\t\t\tif (handle.equals(childLabel)) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if ( child.hasChildren()) {\n\t\t\t\t\tif (((AbstractTaskContainer)child).containsHelperB(handle, depth)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic boolean hasChildren() {\n\t\tfor (AbstractTask child : children) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nWhen describing the problem properly, the method name reveals itself!\n\nThe unit test gives the following results for a reasonably deep and wide test case: \n\nTime spent with current contains()         : 54297 ms\nTime spent with caching containsA()        : 27835 ms\nTime spent with hasChildren(() containsB() : 642 ms\n\nHow common are cyclic structures, do they need testing as well?",
    "Maarten, thanks for investigating that. It looks like in the current implementation the list of children is indeed build up three times. It should be trivial to make that significantly faster with a simple fix.",
    "Created an attachment (id\u003d81609)\ntest case with cycle\n\nMik, it turns out that the code is also not working as expected. Please see the attached test case which has a cycle in the subtask hierarchy. It throws a StackOverflowError.",
    "Created an attachment (id\u003d81610)\nmylyn/context/zip\n\n",
    " (In reply to comment #11)\n\u003e Mik, it turns out that the code is also not working as expected. Please see the\n\u003e attached test case which has a cycle in the subtask hierarchy. It throws a\n\u003e StackOverflowError.\nNo chocking with stack overflow on my modified code using hasChildren()...",
    " (In reply to comment #11)\n\u003e It throws a StackOverflowError.\nWell getChildren() calls contains() inside a loop AND contains() calls containsHelper() which calls getChildren() twice in the if test and calls itself recursively once.",
    "Created an attachment (id\u003d81699)\nrecursion, why doesn\u0027t Eclipse warn against this?\n\nThe source of the performance problems...",
    "getChildren() does NOT recurse and return a set with all children, grandChildren, and so on.\nYet this is what the javadoc comment leads you to believe... :-(\n\nNew hypothesis:\nThis may very well be the cause of  many bugs with improper display of Grouped Subtasks like \n- bug 205202: subtasks causing false guaranteed visibility for their parent tasks\n- bug 204699: Group subtasks hides scheduled tasks in Focus on Workweek\n\ntree/graph querying and navigation is a lot more complex than simple list navigation.\nThe valid desire to group subtasks and show dependencies creates increased complexity and cost (CPU) problems\n\nSolution:\nThe API should differentiate between looking for direct children and a deeper search:\ngetChildren() is not the same as getDescendants()",
    "Mik, please clarify what you want getChildren() to do, it has over a 100 callers so it must be something important!\n\nthe contains() optimization is almost done, using a cheaper hasChildren() method that can be used in more places where ...getChildren.size() \u003e 0 is or ...getChildren().isEmpty() is used now.\n\nI think in some of the callers are interested in the children only, while others want to see all descendants with, cycles are a problem only to the recursive implementation.\n\ntest case: task1 -\u003e task2 -\u003e task3 -\u003e (task1)\n\ntask1.getChildren() returns [task2]\ntask1.hasChildren() returns true\ntask1.countChildren() returns 1\ntask1.getDescendants() returns [task2, task3]\n\nMore insidious is:\ntest case: task1 -\u003e (task1)\n\ntask1.getChildren() returns [] OR [task1]\ntask1.hasChildren() returns false OR true\ntask1.countChildren() returns 0 OR 1\ntask1.getDescendants() returns [] OR [task1]\n\nPersonally I think direct self reference should be prevented at creation or addition, throwing IllegalStateException",
    "Mik,\n\nI think you (sometimes) want getChildren to do this:\n\n\t/**\n\t * @return an expanded set of all descendants, excluding itself;\n\t */\n\tpublic Set\u003cAbstractTask\u003e getDescendants() {\n\t\tSet\u003cAbstractTask\u003e childrenWithoutCycles \u003d new HashSet\u003cAbstractTask\u003e();\n\t\tthis.getDescendantsHelper(childrenWithoutCycles, this);\n\t\treturn Collections.unmodifiableSet(childrenWithoutCycles);\n\t}\n\n\tprotected void getDescendantsHelper(Set\u003cAbstractTask\u003e visited, AbstractTaskContainer root) {\n\t\tfor (AbstractTask child : children) {\n\t\t\tif (!visited.contains(child) \u0026\u0026 child !\u003d root) {\n\t\t\t\tvisited.add(child);\n\t\t\t\tchild.getDescendantsHelper(visited, root);\n\t\t\t}\n\t\t}\n\t}\n",
    "Created an attachment (id\u003d81838)\noptimized contains()\n\nLess expensive contains with less stack overflow problems.\nAlso added hasChildren() to replace ...getChildren().size() \u003e 0 and ...getChildren.isEmpty();\nAlso added getDescendants() to get a set of all descendants in a container.\n\nAlso added performance Unit Test to do some load testing. Parameters to be set.",
    "Created an attachment (id\u003d81839)\nmylyn/context/zip\n\n",
    "I fully agree that we need to optimize this and some related parts of the code.  As with testing, I want us to follow Platform\u0027s example and ensure that important optimizations of this sort are captured by repeatable performance tests.  These will not only help us get rid of some of the hotspots, but will also provide long-term value to the project and help avoid future performance regressions.\n\nMaarten: it\u0027s great to see your interest in this.  Would you like to contribute a performance tests that highlights the underlying problem?  There\u0027s a great tutorial on how to do this linked from bug 116487.",
    "OK, I installed the test.performance stuff, wrote some test, and ran them. Quite easy actually.\n\nI\u0027ve described prerequisites in bug 116487.\n\nOutput of current version of containsHelper()\nScenario \u0027org.eclipse.mylyn.tasks.tests.performance.Bug207659Test#testContainsPerformanceMany()\u0027 (average over 2000 samples):\n  System Time:               1ms        (95% in [1ms, 1ms])            Measurable effect: 0ms (0.1 SDs)\n  Used Java Heap:         -195          (95% in [-162.39K, 162.01K])   Measurable effect: 327.01K (0.1 SDs) (required sample size for an effect of 5% of stdev: 6400)\n\nScenario \u0027org.eclipse.mylyn.tasks.tests.performance.Bug207659Test#testContainsPerformanceFew()\u0027 (average over 2000 samples):\n  System Time:              24ms        (95% in [24ms, 24ms])          Measurable effect: 0ms (0.1 SDs)\n  Used Java Heap:         2.44K         (95% in [-299.32K, 304.2K])    Measurable effect: 608.39K (0.1 SDs) (required sample size for an effect of 5% of stdev: 6401)\n\n\nVersion with optimized containsHelper()\n\nScenario \u0027org.eclipse.mylyn.tasks.tests.performance.Bug207659Test#testContainsPerformanceMany()\u0027 (average over 2000 samples):\n  System Time:               0ms        (95% in [0ms, 0ms])            Measurable effect: 0ms (0.1 SDs) (required sample size for an effect of 5% of stdev: 6401)\n  Used Java Heap:         1.51K         (95% in [-13.67K, 16.69K])     Measurable effect: 30.6K (0.1 SDs) (required sample size for an effect of 5% of stdev: 6401)\n\nScenario \u0027org.eclipse.mylyn.tasks.tests.performance.Bug207659Test#testContainsPerformanceFew()\u0027 (average over 2000 samples):\n  System Time:               0ms        (95% in [0ms, 0ms])            Measurable effect: 0ms (0.1 SDs) (required sample size for an effect of 5% of stdev: 6400)\n  Used Java Heap:        -4.96K         (95% in [-26.32K, 16.41K])     Measurable effect: 43.07K (0.1 SDs) (required sample size for an effect of 5% of stdev: 6400)\n\nI think the biggest problem in the current code is the risk of stack overflow and excessive heap usage. I propose attached patch that does not change functionality be applied asap.\nSo its more a functionality issue/breaker than a performance issue.\n\n (In reply to comment #11)\n\u003e Mik, it turns out that the code is also not working as expected. Please see the\n\u003e attached test case which has a cycle in the subtask hierarchy. It throws a\n\u003e StackOverflowError.\n\nPlease specify the desired behaviour in the javadoc comment, especially with regard to cyclic structures. I can then work on both functional and performance tests.",
    "Created an attachment (id\u003d82532)\nResolving performance issue in contains()\n\nFunctionality still to be resolved.\nChange is to build up the set only once instead of three times.",
    "Created an attachment (id\u003d82533)\nmylyn/context/zip\n\n",
    "Maarten, could you attach the tests you created?",
    "Created an attachment (id\u003d82572)\nChanged AbstractTaskContainer plus test\n\nI\u0027ve got a 15 trial of the YourKit profiler :-)\nThe main caller of getChildren is CustomTaskListDecorator.hasIncoming() taht may also be optimized...",
    "Created an attachment (id\u003d82573)\nmylyn/context/zip\n\n",
    "Steffen: assigning to you for review.",
    " (In reply to comment #26)\n\u003e The main caller of getChildren is CustomTaskListDecorator.hasIncoming() that may\n\u003e also be optimized...\nIndeed hasIncoming is building the getChildren list three times as well, where once would suffice...\nHow serious are these performance problems and do we need a fix for 2.2?\n\nThen this is an easy improvement:\n\tprivate boolean hasIncoming(AbstractTaskContainer container) {\n\t\tfor (AbstractTask task : container.getChildren()) {\n\t\t\tif (task !\u003d null) {\n\t\t\t\tAbstractTask containedRepositoryTask \u003d task;\n\t\t\t\tif (containedRepositoryTask.getSynchronizationState() \u003d\u003d RepositoryTaskSyncState.INCOMING) {\n\t\t\t\t\treturn true;\n//\t\t\t\t} else if (task.getChildren() !\u003d null \u0026\u0026 task.getChildren().size() \u003e 0 \u0026\u0026 hasIncoming(task)) {\n\t\t\t\t} else if (task.hasChildren() \u0026\u0026 hasIncoming(task)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\nI suspect adding grouped tasks presentation with subtasks beneath tasks introduced recursion performance problems in many places.\nMaybe we should introduce the optimized getDescendants(), see comment 18, and use that wherepossible in place of the current getChildren in another recursion.\n",
    "Created an attachment (id\u003d82946)\npatch in case changes need to be reverted\n\n",
    "Created an attachment (id\u003d82947)\nmylyn/context/zip\n\n",
    "Maarten, I have committed changes that are along the lines of your patches. I will iterate more on this and plan to setup the performance test suite within the next few weeks so we can collect a few numbers.",
    " (In reply to comment #32)\nOK I see you\u0027ve merged my ideas well. Now that this more hierarchical TaskList is here to stay, I think that AbstractRepositoryContainer should allow the visitor pattern for various checks.\n So it should have an accept() method, with a visitor that includes a Object placeholder in the arguments for collecting a subset. like children or incoming, or whatever.\n The visitor visit() method would be a more general case of the containsHelper(). What do you think of this?",
    " (In reply to comment #17)\n\u003e I think in some of the callers are interested in the children only, while others\n\u003e want to see all descendants with, cycles are a problem only to the recursive\n\u003e implementation.\n\u003e \n\u003e test case: task1 -\u003e task2 -\u003e task3 -\u003e (task1)\n\u003e \n\u003e task1.getChildren() returns [task2]\n\u003e task1.hasChildren() returns true\n\u003e task1.countChildren() returns 1\n\u003e task1.getDescendants() returns [task2, task3]\n\u003e \n\u003e More insidious is:\n\u003e test case: task1 -\u003e (task1)\n\u003e \n\u003e task1.getChildren() returns [] OR [task1]\n\u003e task1.hasChildren() returns false OR true\n\u003e task1.countChildren() returns 0 OR 1\n\u003e task1.getDescendants() returns [] OR [task1]\nStill to do:\nWhat do we want to happen when we call getChildren on a cyclic structure? I think it should return all the children, but only once.",
    "We will review these APIs for Mylyn 3.0 when we will be able to make larger changes to the task list model. Using a visitor or iterator for traversing the task list graph is certainly a possibility that will be considered.\n\nFor the record here is the stack trace I encountered when I had a cycle in the task list:\n\n-- Error Log --\nDate: Thu Nov 15 02:47:00 GMT 2007\nMessage: Unhandled event loop exception\nSeverity: Error\nPlugin ID: org.eclipse.ui\nStack Trace:\norg.eclipse.swt.SWTException: Failed to execute runnable (java.lang.StackOverflowError)\nat org.eclipse.swt.SWT.error(SWT.java:3706)\nat org.eclipse.swt.SWT.error(SWT.java:3624)\nat org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:133)\nat org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3312)\nat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2985)\nat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2395)\nat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2359)\nat org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2225)\nat org.eclipse.ui.internal.Workbench$4.run(Workbench.java:468)\nat org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:288)\nat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:463)\nat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)\nat org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:106)\nat org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:193)\nat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:106)\nat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:76)\nat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:362)\nat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:175)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\nat java.lang.reflect.Method.invoke(Method.java:597)\nat org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:515)\nat org.eclipse.equinox.launcher.Main.basicRun(Main.java:455)\nat org.eclipse.equinox.launcher.Main.run(Main.java:1193)\nat org.eclipse.equinox.launcher.Main.main(Main.java:1169)\nCaused by: java.lang.StackOverflowError\nat org.eclipse.mylyn.tasks.core.AbstractTaskContainer.containsHelper(AbstractTaskContainer.java:91)\nat org.eclipse.mylyn.tasks.core.AbstractTaskContainer.contains(AbstractTaskContainer.java:87)\nat org.eclipse.mylyn.tasks.core.AbstractTaskContainer.getChildren(AbstractTaskContainer.java:74)\nat org.eclipse.mylyn.tasks.core.AbstractTaskContainer.containsHelper(AbstractTaskContainer.java:98)\nat org.eclipse.mylyn.tasks.core.AbstractTaskContainer.contains(AbstractTaskContainer.java:87)\nat org.eclipse.mylyn.tasks.core.AbstractTaskContainer.getChildren(AbstractTaskContainer.java:74)\n[...]",
    "Steffen: in case you haven\u0027t already, please make sure that the end result of this chnage doesn\u0027t blow up the UI when there is a cycle.  It\u0027s not common, but possible to get into the scenario where a partially synched set of tasks forms a cycle.  Until we make this safe there has to be a safeguard somewhere.",
    "Sorry, I should have pointed that out more clearly. The fix I made was to gracefully handle cycles that I had in my tasklist which could cause StackOverflowExceptions before (stacktrace on bug 35). I have added a test case to verify that this works now.",
    "Fyi, committed a change to not look down tree viewer in order to determine when to draw the incoming indicator on queries and categories."
  ],
  "commentCreationDates": [
    "2007-10-27T08:35:28+02:00",
    "2007-10-29T14:57:33+01:00",
    "2007-10-29T15:26:09+01:00",
    "2007-10-29T15:26:17+01:00",
    "2007-10-29T17:13:01+01:00",
    "2007-10-29T18:20:41+01:00",
    "2007-10-29T18:43:45+01:00",
    "2007-10-29T18:45:27+01:00",
    "2007-10-29T19:02:52+01:00",
    "2007-10-30T12:52:37+01:00",
    "2007-10-30T18:38:44+01:00",
    "2007-10-30T19:06:10+01:00",
    "2007-10-30T19:06:12+01:00",
    "2007-10-30T22:45:25+01:00",
    "2007-10-31T09:43:36+01:00",
    "2007-10-31T09:45:57+01:00",
    "2007-10-31T11:00:58+01:00",
    "2007-10-31T12:23:13+01:00",
    "2007-10-31T15:12:40+01:00",
    "2007-11-01T08:51:24+01:00",
    "2007-11-01T08:51:26+01:00",
    "2007-11-08T23:39:41+01:00",
    "2007-11-09T13:55:19+01:00",
    "2007-11-09T13:57:52+01:00",
    "2007-11-09T13:57:55+01:00",
    "2007-11-09T18:51:24+01:00",
    "2007-11-09T20:57:26+01:00",
    "2007-11-09T20:57:28+01:00",
    "2007-11-10T03:15:28+01:00",
    "2007-11-12T13:49:33+01:00",
    "2007-11-15T07:07:03+01:00",
    "2007-11-15T07:07:29+01:00",
    "2007-11-15T07:10:58+01:00",
    "2007-11-15T08:16:26+01:00",
    "2007-11-15T08:21:49+01:00",
    "2007-11-15T20:42:00+01:00",
    "2007-11-16T06:20:11+01:00",
    "2007-11-16T06:39:00+01:00",
    "2007-11-22T00:40:28+01:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.swt.SWTException",
      "message": "Failed to execute runnable (java.lang.StackOverflowError)",
      "elements": [
        {
          "method": "org.eclipse.swt.SWT.error",
          "source": "SWT.java:3706"
        },
        {
          "method": "org.eclipse.swt.SWT.error",
          "source": "SWT.java:3624"
        },
        {
          "method": "org.eclipse.swt.widgets.Synchronizer.runAsyncMessages",
          "source": "Synchronizer.java:133"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runAsyncMessages",
          "source": "Display.java:3312"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:2985"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:2395"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:2359"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.access$4",
          "source": "Workbench.java:2225"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench$4.run",
          "source": "Workbench.java:468"
        },
        {
          "method": "org.eclipse.core.databinding.observable.Realm.runWithDefault",
          "source": "Realm.java:288"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:463"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:149"
        },
        {
          "method": "org.eclipse.ui.internal.ide.application.IDEApplication.start",
          "source": "IDEApplication.java:106"
        },
        {
          "method": "org.eclipse.equinox.internal.app.EclipseAppHandle.run",
          "source": "EclipseAppHandle.java:193"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication",
          "source": "EclipseAppLauncher.java:106"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start",
          "source": "EclipseAppLauncher.java:76"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:362"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:175"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:597"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.invokeFramework",
          "source": "Main.java:515"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.basicRun",
          "source": "Main.java:455"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.run",
          "source": "Main.java:1193"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.main",
          "source": "Main.java:1169"
        }
      ],
      "causedBy": {
        "exceptionType": "java.lang.StackOverflowError",
        "elements": [
          {
            "method": "org.eclipse.mylyn.tasks.core.AbstractTaskContainer.containsHelper",
            "source": "AbstractTaskContainer.java:91"
          },
          {
            "method": "org.eclipse.mylyn.tasks.core.AbstractTaskContainer.contains",
            "source": "AbstractTaskContainer.java:87"
          },
          {
            "method": "org.eclipse.mylyn.tasks.core.AbstractTaskContainer.getChildren",
            "source": "AbstractTaskContainer.java:74"
          },
          {
            "method": "org.eclipse.mylyn.tasks.core.AbstractTaskContainer.containsHelper",
            "source": "AbstractTaskContainer.java:98"
          },
          {
            "method": "org.eclipse.mylyn.tasks.core.AbstractTaskContainer.contains",
            "source": "AbstractTaskContainer.java:87"
          },
          {
            "method": "org.eclipse.mylyn.tasks.core.AbstractTaskContainer.getChildren",
            "source": "AbstractTaskContainer.java:74"
          }
        ],
        "number": 0,
        "commentIndex": 0
      },
      "number": 0,
      "commentIndex": 35,
      "bugId": "207659",
      "date": "2007-11-15T20:42:00+01:00",
      "product": "Mylyn",
      "component": "Tasks",
      "severity": "critical"
    }
  ],
  "groupId": "207659",
  "bugId": "207659",
  "date": "2007-10-27T08:35:28+02:00",
  "product": "Mylyn",
  "component": "Tasks",
  "severity": "critical"
}