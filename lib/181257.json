{
  "comments": [
    "Build ID:  M20070212-1330\n\nSteps To Reproduce:\nRun several ExtractTempRefactorings repeatedly on the same ICompilationUnit from an open editor.  A NullPointerException is thrown after a few (variable) refactorings.\n\nMore information:\nBecause ExtractTempRefactoring calls RefactoringASTParser.parseWithASTProvider(...), sometimes the returned AST is stale (not updated after the previous refactoring).\n\nTestCase: (sorry about the JavaTestProject - use whatever project creator you have on hand)\n\npublic void testRace() throws Exception{\n\t\n\tString testClass \u003d \n\t\t\"class Test{\"+\n\t\t\" void method(){\"+\n\t\t\"   int x \u003d 0+1+2+3+4+5+6+7+8+9;\"+\n\t\t\" }\"+\n\t\t\"}\";\n\n\tIPackageFragment fragment \u003d createPackage();\n\t\n\tICompilationUnit cu \u003d \n\t\tfragment.createCompilationUnit(\"Test.java\", testClass, true, null);\n\t\n\tJavaUI.openInEditor(cu);\n\t\n\tIProgressMonitor pm \u003d new NullProgressMonitor();\n\t\n\tfor(int i \u003d 0; i\u003c10; i++){\n\t\t\n\t\t\tint varIndex \u003d cu.getSource().indexOf(\"\"+i);\n\t\n\t\t\tExtractTempRefactoring refactoring \u003d \n\t\t\t\tnew ExtractTempRefactoring(cu,varIndex,1);\n\t\t\trefactoring.setTempName(\"a\"+i);\n\t\t\t\trefactoring.checkAllConditions(pm);\n\t\t\n\t\t\trefactoring.createChange(pm).perform(pm);\n\t\t\tSystem.out.println(i);\n\t}\n}\n\nprivate IPackageFragment createPackage() throws Exception {\n\tJavaTestProject p \u003d new JavaTestProject();\n\treturn p.createPackage(\"pkg\");\n}",
    "Created an attachment (id\u003d63071)\nExposes bug by throwing NullPointerException\n\n",
    "Can also be reproduced without running test\n\n1) Copy the following method into an existing class:\n\nint x(){\n  return 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9;\n}\n\n2) Apply the Extract Local refactoring to each integer, so you are left with 9 local variables.\n\n3) Create a refactoring script with those 9 refactorings.\n\n4) Undo your refactoring changes.\n\n5) Apply the refactoring script without previewing changes (Finish) to the original code from (1).  Wizard says \"An expression must be selected to activate this refactoring.\"",
    "Benno, can you investigate?",
    "Created an attachment (id\u003d63491)\ntest case\n\nExtracting 1000 local variables. Non failing.",
    "Sorry, but I can not reproduce this in I20070410-1043. Even extracting a 1000 local variables in a row does not reveal a bug.\n\nIs the status returned by refactoring.checkAllConditions(pm); ok for you in your example?",
    "I\u0027ll run your test when I get I20070410-1043 downloaded, but in the mean time, there\u0027s one big difference between your test and my test - the ICU is open in an editor.  Benno, if you\u0027re still around and have a minute, add this line before the main loop:\n\nJavaUI.openInEditor(cu);\n\nAs I said, I\u0027ll do it just as soon as I can.",
    "(In reply to comment #6)\n\u003e I\u0027ll run your test when I get I20070410-1043 downloaded, but in the mean time,\n\u003e there\u0027s one big difference between your test and my test - the ICU is open in\n\u003e an editor.  Benno, if you\u0027re still around and have a minute, add this line\n\u003e before the main loop:\n\u003e \n\u003e JavaUI.openInEditor(cu);\n\u003e \n\u003e As I said, I\u0027ll do it just as soon as I can.\n\u003e \n\nIt would be great if you could try it too. I tested it with and without the cu open in editor. In the junit test as well as with the refactoring script. No NPE...",
    "Created an attachment (id\u003d63523)\nSlightly modifed version of Benno\u0027s patch, with opening an editor\n\n",
    "When I apply the new patch, I get the following stack trace:\n\n        junit.framework.ComparisonFailure: expected:\u003c...a0001\u003d 1;\n\t\tint a000[2\u003d 2;\n\t\tint a0003\u003d 3];\n\t\treturn a0001 + a...\u003e but was:\u003c...a0001\u003d 1;\n\t\tint a000[3\u003d 3;\n\t\tint a0002\u003d 2];\n\t\treturn a0001 + a...\u003e\n\tat junit.framework.Assert.assertEquals(Assert.java:81)\n\tat junit.framework.Assert.assertEquals(Assert.java:87)\n\tat org.eclipse.jdt.ui.tests.refactoring.ExtractTempTests.test101(ExtractTempTests.java:692)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat junit.framework.TestCase.runTest(TestCase.java:164)\n\tat junit.framework.TestCase.runBare(TestCase.java:130)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:120)\n\tat junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)\n\tat junit.extensions.TestSetup$1.protect(TestSetup.java:21)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.extensions.TestSetup.run(TestSetup.java:25)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:58)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication$1.run(UITestApplication.java:122)\n\tat org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)\n\tat org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:123)\n\tat org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3650)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3287)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2361)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2325)\n\tat org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2200)\n\tat org.eclipse.ui.internal.Workbench$4.run(Workbench.java:466)\n\tat org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:289)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:461)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)\n\tat org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:101)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication.start(UITestApplication.java:52)\n\tat org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:153)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:106)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:76)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:359)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:174)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:474)\n\tat org.eclipse.equinox.launcher.Main.basicRun(Main.java:414)\n\tat org.eclipse.equinox.launcher.Main.run(Main.java:1139)\n\tat org.eclipse.equinox.launcher.Main.main(Main.java:1114)\n\nBut that\u0027s sort of a trivial problem, so when I edit out that assertion, I get the following:\n\njunit.framework.AssertionFailedError: activation was supposed to be successful\n\tat junit.framework.Assert.fail(Assert.java:47)\n\tat junit.framework.Assert.assertTrue(Assert.java:20)\n\tat org.eclipse.jdt.ui.tests.refactoring.ExtractTempTests.helper1(ExtractTempTests.java:111)\n\tat org.eclipse.jdt.ui.tests.refactoring.ExtractTempTests.test101(ExtractTempTests.java:670)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat junit.framework.TestCase.runTest(TestCase.java:164)\n\tat junit.framework.TestCase.runBare(TestCase.java:130)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:120)\n\tat junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)\n\tat junit.extensions.TestSetup$1.protect(TestSetup.java:21)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.extensions.TestSetup.run(TestSetup.java:25)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:58)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication$1.run(UITestApplication.java:122)\n\tat org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)\n\tat org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:123)\n\tat org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3650)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3287)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2361)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2325)\n\tat org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2200)\n\tat org.eclipse.ui.internal.Workbench$4.run(Workbench.java:466)\n\tat org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:289)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:461)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)\n\tat org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:101)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication.start(UITestApplication.java:52)\n\tat org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:153)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:106)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:76)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:359)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:174)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:474)\n\tat org.eclipse.equinox.launcher.Main.basicRun(Main.java:414)\n\tat org.eclipse.equinox.launcher.Main.run(Main.java:1139)\n\tat org.eclipse.equinox.launcher.Main.main(Main.java:1114)\n\nSo in answer to your previous question, no, refactoring.checkAllConditions(pm) does not return OK, it returns:\n\n\u003cFATALERROR\n\t\nFATALERROR: An expression must be selected to activate this refactoring.\nContext: \u003cUnspecified context\u003e\ncode: none\nData: null\n\u003e",
    "Created an attachment (id\u003d63609)\nminimal test case\n\nThis test fails every time for me and shows the problem",
    "Thanks Emerson!\n\nThe debug output for ASTProvider is:\n1* main - ASTProvider \u003e about to reconcile: E1.java\nmain - ASTProvider \u003e caching AST: null for: E1.java\nmain - ASTProvider \u003e caching AST: null for: E1.java\nmain - ASTProvider \u003e active editor is: E1.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E1.java\nmain - ASTProvider \u003e about to reconcile: E1.java\nmain - ASTProvider \u003e caching AST: null for: E1.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E1.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E1.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E1.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E1.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E1.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E1.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E1.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E1.java\nJavaReconciler - ASTProvider \u003e reconciled: E1.java, AST: E1\n2* JavaReconciler - ASTProvider \u003e caching AST: E1 for: E1.java\n3* main - ASTProvider \u003e returning cached AST:E1 for: E1.java\nCached AST:\npackage test1;\npublic class E1 {\n}\n\nCU:\npackage test1;\npublic class E1 {\n  private int a0000\u003d1;\n  private int a0001\u003d1;\n  private int a0002\u003d1;\n  private int a0003\u003d1;\n  private int a0004\u003d1;\n  private int a0005\u003d1;\n  private int a0006\u003d1;\n  private int a0007\u003d1;\n  private int a0008\u003d1;\n}\n\nOpening the CU in an editor does result in aboutToRecocile (1*) resulting in invalidating the cached AST.\nThen a couple of changes are made to the CU (fields added)\nThen in 2* the CU is reconciled and the AST returned to the test case (3*) but it is the AST of the CU as it was back then when it was opened in the editor and not the most recent.\n\nIMHO the reconciler should stop and restart reconciling as soon as the CU he is reconciling is changed.",
    "Created an attachment (id\u003d63617)\nfix\n\nThis does \"fix\" the bug. But the real problem is, that fThread.isActive is false when it shouldn\u0027t. Alse the Code nearby:\n\nfIsActive\u003d true;\nif (fProgressMonitor !\u003d null)\n    fProgressMonitor.setCanceled(false);\n\nHas a bad race condition smell.",
    "Dani, I\u0027m assigning this one to you since you seam to be the men for the AbstractReconciler. And I\u0027m not really understanding what is going on there...",
    "Created an attachment (id\u003d66291)\nRevised fix\n\nThe problem is that the document gets changed during initialProcess(). The 100% fix would be to wait until initialProcess() is finished but this can easily lead to deadlocks. Instead we now cancel the progress monitor when this happens.\n\nBenno please approve.",
    "Created an attachment (id\u003d66312)\nmodified test case\n\nI know it is mean;-) but slightly modifying the test makes it failing again. But I think it is possible that the following is another bug, or at least requires another fix:\n\nmain - ASTProvider \u003e about to reconcile: E0054.java\nmain - ASTProvider \u003e don\u0027t cache AST for inactive: E0054.java\nmain - ASTProvider \u003e caching AST: null for: E0054.java\nmain - ASTProvider \u003e active editor is: E0054.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E0054.java\nmain - ASTProvider \u003e about to reconcile: E0054.java\nmain - ASTProvider \u003e caching AST: null for: E0054.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E0054.java\nmain - ASTProvider \u003e returning null (WAIT_NO) for: E0054.java\norg.eclipse.jdt.internal.ui.text.JavaReconciler - ASTProvider \u003e reconciled: E0053.java, AST: null\norg.eclipse.jdt.internal.ui.text.JavaReconciler - ASTProvider \u003e   ignoring AST of out-dated editor\norg.eclipse.jdt.internal.ui.text.JavaReconciler - ASTProvider \u003e reconciled: E0054.java, AST: E0054\norg.eclipse.jdt.internal.ui.text.JavaReconciler - ASTProvider \u003e caching AST: E0054 for: E0054.java\nmain - ASTProvider \u003e returning cached AST:E0054 for: E0054.java\nCached AST:\npackage test;\npublic class E0054 {\n  private int a0000\u003d1;\n}\n\nCU:\npackage test;\npublic class E0054 {\n  private int a0000\u003d1;\n  private int a0001\u003d1;\n  private int a0002\u003d1;\n}\n\norg.eclipse.jdt.internal.ui.text.JavaReconciler - ASTProvider \u003e reconciled: E0054.java, AST: E0054\norg.eclipse.jdt.internal.ui.text.JavaReconciler - ASTProvider \u003e caching AST: E0054 for: E0054.java\norg.eclipse.jdt.internal.ui.text.JavaReconciler - ASTProvider \u003e disposing AST: E0054 for: E0054.java ",
    "The initial problem is fixed. The second one repeats the first test 100 times i.e. 100 CUs get created and opened. This rather looks like a problem in the ASTProvider or the UI events being sent.\n\nAlso note that the test is not 100% accurate as it completely blocks the UI and doesn\u0027t give cycles to the UI thread. Hence not a very common scenario.\n\nI suggest to fix the first case only. Benno, feel free to open a new bug to be investigate for 3.4 if you think this is a real scenario.",
    "Verified in I20070515-0010.",
    "I\u0027m sorry, but I can\u0027t really follow what you guys are talking about.  \n\nThe bug I described isn\u0027t fixed (I20070517-1700).  As near I can tell, the difference between my original test case and \"minimal test case\" is the refactoring.  I\u0027ve validated that the problem occurs with Extract Temp, Inline Temp, and Extract Method (but not Rename and this AddField, for some reason).  \n\nPlease try to reproduce with comment #2.\n\n",
    "No further changes to the reconciler at this point.",
    "Created an attachment (id\u003d68832)\nRevised test case\n\nThe AddFieldRefactoring gets its AST with the ASTProvider.WAIT_NO flag, but the ExtractMethodRefactoring, InlineTempRefactoring, and  ExtractTempRefactoring all use ASTProvider.WAIT_ACTIVE_ONLY.  This patch reflects this, and in turn fails:\n\njunit.framework.ComparisonFailure: expected:\u003c...;\npublic class E1 {\n[}\n  private int a0000\u003d1;]\n\u003e but was:\u003c...;\npublic class E1 {\n[  private int a0000\u003d1;\n}]\n\u003e\n\tat junit.framework.Assert.assertEquals(Assert.java:81)\n\tat junit.framework.Assert.assertEquals(Assert.java:87)\n\tat org.eclipse.jdt.ui.tests.core.ASTProviderTest.testBug181257(ASTProviderTest.java:141)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat junit.framework.TestCase.runTest(TestCase.java:164)\n\tat junit.framework.TestCase.runBare(TestCase.java:130)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:120)\n\tat junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)\n\tat junit.extensions.TestSetup$1.protect(TestSetup.java:21)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.extensions.TestSetup.run(TestSetup.java:25)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:58)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication$1.run(UITestApplication.java:122)\n\tat org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)\n\tat org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:123)\n\tat org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3650)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3287)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2389)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2353)\n\tat org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2219)\n\tat org.eclipse.ui.internal.Workbench$4.run(Workbench.java:466)\n\tat org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:289)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:461)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)\n\tat org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:106)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication.start(UITestApplication.java:52)\n\tat org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:153)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:106)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:76)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:363)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:176)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:497)\n\tat org.eclipse.equinox.launcher.Main.basicRun(Main.java:436)\n\tat org.eclipse.equinox.launcher.Main.run(Main.java:1162)\n\tat org.eclipse.equinox.launcher.Main.main(Main.java:1137)\n\n"
  ],
  "commentCreationDates": [
    "2007-04-05T19:43:11+02:00",
    "2007-04-05T19:44:43+02:00",
    "2007-04-05T20:38:34+02:00",
    "2007-04-10T19:26:02+02:00",
    "2007-04-11T14:43:36+02:00",
    "2007-04-11T14:46:50+02:00",
    "2007-04-11T17:40:42+02:00",
    "2007-04-11T18:14:47+02:00",
    "2007-04-11T19:25:53+02:00",
    "2007-04-11T19:33:09+02:00",
    "2007-04-12T16:33:11+02:00",
    "2007-04-12T17:04:26+02:00",
    "2007-04-12T17:16:54+02:00",
    "2007-04-12T17:20:33+02:00",
    "2007-05-08T16:33:24+02:00",
    "2007-05-08T17:51:21+02:00",
    "2007-05-09T10:59:31+02:00",
    "2007-05-15T11:57:26+02:00",
    "2007-05-22T20:28:42+02:00",
    "2007-05-22T20:48:47+02:00",
    "2007-05-25T23:10:24+02:00"
  ],
  "traces": [
    {
      "exceptionType": "junit.framework.AssertionFailedError",
      "message": "activation was supposed to be successful",
      "elements": [
        {
          "method": "junit.framework.Assert.fail",
          "source": "Assert.java:47"
        },
        {
          "method": "junit.framework.Assert.assertTrue",
          "source": "Assert.java:20"
        },
        {
          "method": "org.eclipse.jdt.ui.tests.refactoring.ExtractTempTests.helper1",
          "source": "ExtractTempTests.java:111"
        },
        {
          "method": "org.eclipse.jdt.ui.tests.refactoring.ExtractTempTests.test101",
          "source": "ExtractTempTests.java:670"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "junit.framework.TestCase.runTest",
          "source": "TestCase.java:164"
        },
        {
          "method": "junit.framework.TestCase.runBare",
          "source": "TestCase.java:130"
        },
        {
          "method": "junit.framework.TestResult$1.protect",
          "source": "TestResult.java:106"
        },
        {
          "method": "junit.framework.TestResult.runProtected",
          "source": "TestResult.java:124"
        },
        {
          "method": "junit.framework.TestResult.run",
          "source": "TestResult.java:109"
        },
        {
          "method": "junit.framework.TestCase.run",
          "source": "TestCase.java:120"
        },
        {
          "method": "junit.extensions.TestDecorator.basicRun",
          "source": "TestDecorator.java:24"
        },
        {
          "method": "junit.extensions.TestSetup$1.protect",
          "source": "TestSetup.java:21"
        },
        {
          "method": "junit.framework.TestResult.runProtected",
          "source": "TestResult.java:124"
        },
        {
          "method": "junit.extensions.TestSetup.run",
          "source": "TestSetup.java:25"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run",
          "source": "JUnit3TestReference.java:130"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.TestExecution.run",
          "source": "TestExecution.java:38"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:460"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:673"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run",
          "source": "RemoteTestRunner.java:386"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main",
          "source": "RemotePluginTestRunner.java:58"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.UITestApplication$1.run",
          "source": "UITestApplication.java:122"
        },
        {
          "method": "org.eclipse.swt.widgets.RunnableLock.run",
          "source": "RunnableLock.java:35"
        },
        {
          "method": "org.eclipse.swt.widgets.Synchronizer.runAsyncMessages",
          "source": "Synchronizer.java:123"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runAsyncMessages",
          "source": "Display.java:3650"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:3287"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:2361"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:2325"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.access$4",
          "source": "Workbench.java:2200"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench$4.run",
          "source": "Workbench.java:466"
        },
        {
          "method": "org.eclipse.core.databinding.observable.Realm.runWithDefault",
          "source": "Realm.java:289"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:461"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:149"
        },
        {
          "method": "org.eclipse.ui.internal.ide.application.IDEApplication.start",
          "source": "IDEApplication.java:101"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.UITestApplication.start",
          "source": "UITestApplication.java:52"
        },
        {
          "method": "org.eclipse.equinox.internal.app.EclipseAppHandle.run",
          "source": "EclipseAppHandle.java:153"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication",
          "source": "EclipseAppLauncher.java:106"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start",
          "source": "EclipseAppLauncher.java:76"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:359"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:174"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.invokeFramework",
          "source": "Main.java:474"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.basicRun",
          "source": "Main.java:414"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.run",
          "source": "Main.java:1139"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.main",
          "source": "Main.java:1114"
        }
      ],
      "number": 0,
      "commentIndex": 9,
      "bugId": "181257",
      "date": "2007-04-11T19:33:09+02:00",
      "product": "JDT",
      "component": "Text",
      "severity": "normal"
    }
  ],
  "groupId": "181257",
  "bugId": "181257",
  "date": "2007-04-05T19:43:11+02:00",
  "product": "JDT",
  "component": "Text",
  "severity": "normal"
}