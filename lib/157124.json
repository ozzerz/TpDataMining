{
  "comments": [
    "This patch makes several improvements to SubProgressMonitor.\n\nPerformance:\n- When two or more SubProgressMonitors are chained together, they report progress directly to the root rather than delegating to one another. This means all methods run in O(1) rather than O(n), where n is the length of the chain.\n\n- SubProgressMonitor filters out redundant operations, so even when SPM is parented below a slow IProgressMonitor implementation it will run quickly.\n\n- SubProgressMonitor never performs any floating-point operations as long as nobody ever calls internalWorked(...).\n\n- Added new factory methods that can avoid creating instances if the new instance couldn\u0027t possibly report any progress to the root.\n\n\nBugfixes:\n- Fixed a bug where, when creating a SubProgressMonitor with a small number of ticks, this would also reduce the resolution of all child SubProgressMonitors.\n\n\nEnhancements:\n\n1. Added SubProgressMonitor.newChild(int). This constructs a new child progress monitor which does not require its done() method to be called. The next time the parent monitor is touched, the child\u0027s done method is called automatically. This is also more efficient since, if the child would report less than 1 unit of work in the root monitor, a shared null progress monitor is returned rather than allocating a new instance.\n\nFor example:\n\n// Old way:\nSubProgressMonitor child \u003d new SubProgressMonitor(parent, 50);\ntry {\n   child.beginTask(\"\", 100);\n   doSomething(child, 100);\n} finally {\n   child.done();\n}\n\n// New way:\nSubProgressMonitor child \u003d parent.newChild(50);\nchild.setWorkRemaining(100);\ndoSomething(child, 100);\n\n\n2. Adds a factory method that obtains a SubProgressMonitor from a (possibly null) IProgressMonitor. The resulting instance does not require its done method to be called. This takes less code, shares instances where possible, and returns a concrete SubProgressMonitor, making it easy to access the other convenience methods.\n\nOld way:\nvoid myMethod(IProgressMonitor monitor) {\n    if (monitor \u003d\u003d null) {\n         monitor \u003d new NullProgressMonitor();\n    }\n    monitor.beginTask(\"Task name\", 100);\n    try {\n        // Use the monitor...\n    } finally {\n        monitor.done();\n    }\n}\n\n// New way:\nvoid myMethod(IProgressMonitor monitor) {\n    SubProgressMonitor myMonitor \u003d SubProgressMonitor.begin(monitor, \"Task name\", 100);\n    try {\n        // Use the myMonitor\n    } finally {\n        monitor.done();\n    }\n}\n\n\n3. Adds a setWorkRemaining(int) method, which resets the available ticks in the SubProgressMonitor:\n\n// Old way:\nvoid doSomething(IProgressMonitor mon) {\n    mon.beginTask(\"\", 100);\n    try {\n       doSomeWork(new SubProgressMonitor(mon, 20));\n       if (someCondition) {\n          doSomeWork(new SubProgressMonitor(mon, 50));\n       } else {\n          // Undesirable: causes the progress bar to jump suddenly\n          mon.worked(50);\n       }\n       doSomeWork(new SubProgressMonitor(mon, 30));\n    } finally {\n       mon.done();\n    }\n}\n\n// New way:\nvoid doSomething(IProgressMonitor mon) {\n    SubProgressMonitor monitor \u003d SubProgressMonitor.begin(mon, 100);\n    try {\n       doSomeWork(monitor.newChild(20));\n       if (someCondition) {\n          doSomeWork(monitor.newChild(50));\n       }\n       // Much better: regardless of the branch, makes the remainder of the\n       // progress bar available for the next method call\n       monitor.setWorkRemaining(30);\n       doSomeWork(monitor.newChild(30));\n    } finally {\n       mon.done();\n    }\n}\n\n\n4. Adds several JUnit and performance tests",
    "Created an attachment (id\u003d50004)\nImplementation of this enhancement\n\n",
    "Created an attachment (id\u003d50005)\nNew JUnit tests and performance suites\n\nNote: The correctness JUnit tests run and pass, but I haven\u0027t been able to get the performance test harness to run on my machine. Feel free to disable the performance suites if they cause any problems.\n\nThe correctness JUnits are enough to verify the performance improvements of the patch: each one times itself and writes the result to stdout. Here\u0027s the output, running with and without the patch.\n\nBefore patch:\nSubProgressTest#testTypicalUsage elapsed time: 97.65s\nSubProgressTest#testCreateTree elapsed time: 24.875s\nSubProgressTest#testCreateChildrenUnderCustomParent elapsed time: 1.789s\nSubProgressTest#testWorked elapsed time: 30.794s\nSubProgressTest#testInternalWorked elapsed time: 30.729s\nSubProgressSmallTicksTest#testWorked elapsed time: 0.0010s\nSubProgressSmallTicksTest#testInternalWorked elapsed time: 0.0s\n\nAfter patch using the existing APIs:\nSubProgressTest#testTypicalUsage elapsed time: 3.576s\nSubProgressTest#testCreateTree elapsed time: 2.422s\nSubProgressTest#testCreateChildrenUnderCustomParent elapsed time: 3.564s\nSubProgressTest#testWorked elapsed time: 0.434s\nSubProgressTest#testInternalWorked elapsed time: 0.515s\nSubProgressSmallTicksTest#testWorked elapsed time: 0.0s\nSubProgressSmallTicksTest#testInternalWorked elapsed time: 0.0s\n\nAfter patch and with the new APIs:\nNewSubProgressTest#testTypicalUsage elapsed time: 1.988s\nNewSubProgressTest#testCreateTree elapsed time: 0.839s\nNewSubProgressTest#testCreateChildrenUnderCustomParent elapsed time: 0.474s\nNewSubProgressTest#testSetWorkRemaining elapsed time: 0.0080s\n",
    "Most of the tests are 10x to 30x faster with the patch. \n\nI intentionally wrote testCreateChildrenUnderCustomParent to identify the one case where the patch reduces performance by about 2x - creating a single child of a custom (non-chainable) progress monitor. However, this should not affect overall performance since most progress monitors are SubProgressMonitors and the calls to worked() tend to exceed the calls to SubProgressMonitor\u0027s constructor by a wide margin.\n",
    "Note: the patch accidentally included a new class called CopyOfSubProgressMonitor. It\u0027s not supposed to be there. Just delete it.",
    "Created an attachment (id\u003d50109)\nImproved patch\n\nImproved patch for this enhancement:\n\n- calling done() now cleans up any unused work in all children (including those that were created with the public constructor)\n\n- fixed a bug whereby a progress monitor in floating-point mode wouldn\u0027t redistribute its progress properly to a child created with the default constructor.\n\n- SubProgressMonitors created with the public constructor will now be completed automatically as long as their beginTask method was touched.\n",
    "Created an attachment (id\u003d50110)\nNew tests patch\n\nAdds regression tests for the changes above",
    "Hi Stefan,\nThanks for the contribution! \n\nAfter I run the updated runtime JUnits with patches from September 13, I get the following exception:\n\njava.lang.NullPointerException\n\tat org.eclipse.core.runtime.SubProgressMonitor.isCanceled(SubProgressMonitor.java:522)\n\tat org.eclipse.core.tests.runtime.ProgressMonitorWrapperTest.testProgressMonitorWrapper(ProgressMonitorWrapperTest.java:47)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:58)\n\tat org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)\n\tat org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:78)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:104)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:74)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:177)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat org.eclipse.core.launcher.Main.invokeFramework(Main.java:336)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:280)\n\tat org.eclipse.core.launcher.Main.run(Main.java:977)\n\tat org.eclipse.core.launcher.Main.main(Main.java:952)\n\n",
    "Created an attachment (id\u003d50680)\nBugfixed patch\n\nMy apollogies. I ran AllTests but forgot to run AutomatedTests. This will fix it. \n\nTo ensure I didn\u0027t miss any other cases, I\u0027ve updated the JUnit tests to bring us up to almost 100% line coverage in the test suites (the only lines not hit by the JUnit tests now are the one-line branches on lines 442, 468, and 570).\n\nSee the following attachment.",
    "Created an attachment (id\u003d50681)\nImuroved JUnit patch\n\nBrings the line coverage for the JUnit tests of SubProgressMonitor up to 99.9%",
    "Oleg has reviewed the patch and made the following suggestions:\n1. The backwards-compatibility code for SubProgressMonitor makes things more complex. Rather than try for compatibility, create SubProgressMonitor2.\n2. Simplify the implementation by removing the integer mode\n\nAfter turning it over in my head for a bit, I think I could make the same simplifications to the implementation without creating a SPM2 class if I didn\u0027t try to make the old constructor make use of the new optimizations.\n\nI\u0027m going to try this first and see how it looks.\n",
    "Created an attachment (id\u003d51266)\nSimplified patch\n\nHere\u0027s a simpler patch to SubProgressMonitor. It removes:\n- The integer progress mode (this simplifies a lot of code and removes the special cases for subclasses of SubProgressMonitor).\n- All optimizations for SubProgressMonitors created with the default constructor (existing progress monitors won\u0027t go any faster, but progress monitors created with the new factory methods will). This removes the need for lazy initialization and merging of style bits.\n- The factory method that takes a task name but no work (since it\u0027s not very useful, anyway).\n\nIt also makes the following stylistic changes:\n- setWorkRemaining(int) was renamed to setTicks(int)\n- added a getTicks() method\n\nHopefully, this will meet the simplicity criteria without creating a need for a new class. If not, I\u0027ll try the new class.",
    "Created an attachment (id\u003d51267)\nTests patch 4\n\n",
    "Created an attachment (id\u003d51269)\nTests patch 4 (correct attachment)\n\nSorry - that last attachment for the test suites was the wrong version. Use this one.",
    "I would prefer to have this as a new class:\n- Looking at the diff, the \"new\" code has very little to do with the \"old\" code. It is not a modification of the old code, but rather a different implementation of the ProgressMonitor.\n- The SubProgressMonitor is not a final class. It is very hard to introduce a revwrite of a non-final class and guarantee that all existing subclasses continue to work as they are. \n- It is my undestarnding that to take advantage of the new functionality, new code patterns have to be used. If so, existing users of the SubProgressMonitor will get only limited benefits unless thay change the way they use the SubProgressMonitor?\n\nI would create a new final class \"SubProgressMonitor2\" or \"SubMonitor\" or something else and would deprecate SubProgressMonitor with clear indication and examples on how user code shoudl be changed to take advantage of the new functionality. \n\n\nNow for the code itself:\n\nConceptual:\n- It took me quite a bit of time to figure out different ways to create a new SubProgressMonitor. Is it possible to list in the Javadoc the ways to create a new SubProgressMonitor and when to use them? So far, I found:\na) \"Old\" direct constructors:\n      SubProgressMonitor(IProgressMonitor monitor, int ticks)\n      SubProgressMonitor(IProgressMonitor monitor, int ticks, int style)\nb) \"New\" convenice begin() methods:\n      begin(IProgressMonitor monitor)\n      begin(IProgressMonitor monitor, int work)\n      begin(IProgressMonitor monitor, String taskName, int work)\nc) Creating a child of existing SubProgressMonitor: \n      newChild(int totalWork)\n\n- What are the preconditions / postconditions? If my method gets a monitor, who should call #begingTask() / #done() ? In which conditions exactly I don\u0027t need to call #begingTask() / #done()? When is it safe to make and extra call to those methods? What is it safe to skip the calls to those methods?\n\n- New begin() methods don\u0027t accept style anymore. Is this a dead concept?\n\n- #newChild(int totalWork). There is a comment in the Javadoc: \"Only one child may be constructed at a time using this method\". This is a rather strange constraint on use. It needs to be either dropped or enforced.\n\n- Javadoc for RootInfo says that \"All children of a SubProgressMonitor instance point to the same RootInfo struct\". It seems that this is true only for the instances created via newChild(). \n\n\n- begin() methods: \na) Should they be called something like \"newSubMonitor()\"? \nb) should they return IProgressMonitor? \nc) Should they be final? \nd) The following Javadoc was added to define the precondition on the begin() method: \"The caller must not have called beginTask on the given monitor already.\"\nIf my method gets a monitor from somebody else, how would I know if #beginTask() was called or not?\n\nImplementation:\n- Would somebody still use \"old\" style public constructors? If no, let\u0027s deprecate them. [Or remove if we create a new class]\n- Do we really need 3 begin() methods? Is begin(IProgressMonitor monitor) useful?\n- The #begin(IProgressMonitor monitor, String taskName, int work) says that it is not needed to call \"done\" on the result. Is this true if the monitor it gets as an argument is not a SubProgressMonitor?\n- if #begin(IProgressMonitor monitor, String taskName, int work) method gets a SubProgressMonitor, it returns the same monitor reset to a new number of work. Unless I control the parent monitor, I really don\u0027t understand what this means.\n- getNullLeafNode(): [This won\u0027t be relevant if a new SubProgressMonitor2 class is created]\na) Is it possible to use a NullProgressMonitor instead (see begin() methods: question (b))?\nb) Reusing the same instance kind of breaks contract of the number of calls to beginTask(). Also, it is not crystal clear how it is going to work for users who would subclass SubProgressMonitor.\n- #setTicks(): I personally liked the privious title of this method \"setWorkRemaining()\". Kind of easier to understand what it is about.\n- #getTicks(): Is this useful? If we don\u0027t have the need for it now, let\u0027s not add it into an API.\n\n\nTechnical detais:\n- Could you move the \"1000\" constant into something like private static int MINIMUM_SOMETHING\n- usedForParent is not initialized in the constructor (it is set to 0 by JVM, but it would be nice to actually initialize it explicitly)\n- begin(IProgressMonitor monitor, String taskName, int work): the NullProgressMonitor() is created and wasted if the monitor \u003d\u003d null\n- Could you make the following fields final to clarify how they are used: \nRootInfo.root\nRootInfo.useScaling\nRootInfo.scaleFactor\n\n",
    "Your suggestions are good. I\u0027ll answer your questions now and try to get an improved patch to you over the weekend.\n\n\u003e - The SubProgressMonitor is not a final class. It is very hard to\n\u003e introduce a revwrite of a non-final class and guarantee that all\n\u003e existing subclasses continue to work as they are. \n\nI\u0027d like to think I did a pretty darn good job, but I agree. We\u0027ll go with a new final class.\n\n\n\u003e - Javadoc for RootInfo says that \"All children of a SubProgressMonitor \n\u003e instance point to the same RootInfo struct\". It seems that this is \n\u003e true only for the instances created via newChild(). \n\nGood point. I\u0027ll fix it.\n\n\n\u003e - #newChild(int totalWork). There is a comment in the Javadoc: \"Only one \n\u003e child may be constructed at a time using this method\". This is a rather\n\u003e strange constraint on use. It needs to be either dropped or enforced.\n\nI should clarify the javadoc, then. It\u0027s not meant to be a constraint on use so much as an explanation of behavior.\n\nSubProgressMonitor spm1 \u003d parent.newChild(50);\n\n// No work has been reported yet on parent\n\nSubProgressMonitor spm2 \u003d parent.newChild(50);\n\n// 50 units have been consumed on the parent. The act of creating a new child\n// has caused spm1.done() to be called.\n\nThis is what I meant by \"only one child at a time\". It is the property that makes it unnecessary to explicitly call the done() method. I will try to clarify the JavaDoc. \n\n\n\u003e I would create a new final class \"SubProgressMonitor2\" or \"SubMonitor\" or\n\nSubMonitor it is. The next version of the patch will have the new monitor class and the deprecation on the old one.\n\n\n\u003e getTicks(): Is this useful? If we don\u0027t have the need for it now, let\u0027s not\n\u003e add it into an API.\n\nDmitry asked me for a solution to the following problem:\n\n// Perform a loop which might do no work on some iterations\nmonitor.setTicks(max);\nfor (int i \u003d 0; i \u003c max; i++) {\n   if (canskip(i)) {\n      // If the loop did no work on this iteration, just redistribute\n      // the space in the monitor without reporting work\n      monitor.setTicks(monitor.getTicks() - 1);\n   } else {\n      doSomeWork(monitor.newChild(1));\n   }\n}\n\nHaving a getTicks() method saves him from having to keep a separate counter - which is redundant since the same counter is being maintained within the monitor. Now that I\u0027ve explained the intended usage, I\u0027ll let you decide whether to keep it or not.\n\n\n\u003e a) \"Old\" direct constructors:\n\nIt shouldn\u0027t ever be necessary to use them in new code. I\u0027ll make sure the new class doesn\u0027t have them.\n\n\u003e b) \"New\" convenice begin() methods:\n\nThey convert an unknown (possibly null) IProgressMonitor instance into a SubProgressMonitor instance, so that you gain access to the new API without a lot of boilerplate at the start of each method. Call them once at the start of every method that takes an IProgressMonitor:\n\nvoid myMethod(IProgressMonitor monitor) {\n    SubProgressMonitor progress \u003d SubProgressMonitor.begin(monitor);\n\n    // Now I have a non-null SubProgressMonitor instance, with all the\n    // stronger invariants and on which I can call newChild and setTicks\n}\n\n\n\u003e c) Creating a child of existing SubProgressMonitor: \n\u003e      newChild(int totalWork)\n\nThis is the normal way to obtain a new SubProgressMonitor instance.\n\n\n\u003e If my method gets a monitor, who should call #begingTask() / #done()? \n\nI\u0027ll add this to the JavaDoc. This is up to each method to decide in its contract, but my recommendation is the following:\n\n- The method itself calls beginTask\n- The caller calls done()\n\nSince the caller can choose to pass in a SubProgressMonitor (which won\u0027t require done() to be called), this means that in practise nobody ever needs to call done().\n\n\n\u003e In which conditions exactly I don\u0027t need to call #beginTask() / #done()? \n\nI\u0027ll add this to the javadoc. If you\u0027re dealing with an unknown IProgressMonitor, you must always call beginTask and done exactly once each. \n\nIf you know you\u0027re using a SubProgressMonitor, you must call either beginTask or setTicks before reporting any work and you never need to call done. If you know you have a SubProgressMonitor, you may call beginTask() or done() multiple times... however any reported work will be ignored before the first call to beginTask or after the first call to done().\n\nSince SubProgressMonitor has a more relaxed contract than IProgressMonitor, you need some way to guarantee that you\u0027re dealing with an SPM so that you can code against the simpler contract. That\u0027s why I have the static begin(...) methods that convert unknown monitors into SPMs.\n\n\n\u003e New begin() methods don\u0027t accept style anymore. Is this a dead concept?\n\nYes. They\u0027re rarely used, and there are other more general ways to do the same thing.\n\n\n\u003e - begin() methods: \n\u003e a) Should they be called something like \"newSubMonitor()\"? \n\nHmm. Their purpose is more akin to conversion than creation... I went with \"begin\" because \"SubProgressMonitor.begin(monitor, \"Stuff\", 100)\" has essentially the same semantics as \"monitor.beginTask(\"Stuff\", 100)\" except the former also converts the argument into a concrete SubProgressMonitor instance. However, I don\u0027t feel strongly about the method names. Now that I\u0027ve explained the justification for the method name, I will wait to hear your recommendation.\n\n\n\u003e b) should they return IProgressMonitor? \n\nNo. Their primary function is to convert an unknown IProgressMonitor into a concrete SubProgressMonitor so that you can then call newChild and setTicks on it and rely on its relaxed contract.\n\n\n\u003e c) Should they be final? \n\nSure. Sorry, I didn\u0027t realize this made a difference with static methods. I guess this won\u0027t be a problem when we make the whole class final.\n\n\n\u003e d) The following Javadoc was added to define the precondition on the begin()\nmethod...\n\nYou\u0027re right: I\u0027ll remove that from the JavaDoc. It\u0027s unnecessary.\n\n\n\u003e Is begin(IProgressMonitor monitor) useful?\n\nProbably not. I\u0027ll punt it. I think the remaining two are, though.\n\n\n\u003e - The #begin(IProgressMonitor monitor, String taskName, int work) says \n\u003e that it is not needed to call \"done\" on the result. Is this true if\n\u003e the monitor it gets as an argument is not a SubProgressMonitor?\n\nYes. It is always true. However, you would still need to call done on the argument:\n\nvoid myMethod(IProgressMonitor monitor) {\n  SubProgressMonitor spm \u003d SubProgressMonitor.begin(monitor, 100);\n  try {\n     // do something\n  } catch {\n     // No need to call spm.done() since it was obtained from begin(...)\n     monitor.done();\n  }\n}\n\nOr, if one takes my recommendation and leaves the call to done() up to the caller, then it looks like this. (Note the caller can always do the same thing, so in the end nobody needs to call done())\n\nvoid myMethod(IProgressMonitor monitor) {\n  SubProgressMonitor spm \u003d SubProgressMonitor.begin(monitor, 100);\n\n  // do something\n}\n\n\n\u003e - if #begin(IProgressMonitor monitor, String taskName, int work) method gets\n\u003e a SubProgressMonitor, it returns the same monitor reset to a new number of\n\u003e work. Unless I control the parent monitor, I really don\u0027t understand what \n\u003e this means.\n\nI\u0027ll rephrase the JavaDoc like this:\n\n\"\u003cp\u003ebegin(...) converts an unknown IProgressMonitor into a SubProgressMonitor containing the given number of ticks. It is not necessary to call done() on the result. \u003c/p\u003e\n\n\u003cp\u003eMore precisely, begin(...) will call beginTask on the argument and return a non-null SubProgressMonitor instance allocated with the given number of ticks that will consume all the ticks from its parent.\u003c/p\u003e\"\n\n\nIn the case where the argument is already a SubProgressMonitor, no conversion is necessary so it doesn\u0027t need to create a new instance. All it needs to do is downcast the argument and call beginTask on it. Callers shouldn\u0027t care whether it creates a new instance or not. All they know is that they need to call done on the argument and not the result, the result will have the given number of ticks, and that they need not call beginTask on either monitor.\n\n\n\u003e Reusing the same instance kind of breaks contract of the number of calls \n\u003e to beginTask().\n\nThat is a contract on IProgressMonitor. SubProgressMonitor relaxes the contract, and the multiple calls to beginTask will only occur when we\u0027re reusing a SubProgressMonitor.\n\n\n\u003e - #setTicks(): I personally liked the privious title of this method\n\u003e \"setWorkRemaining()\". Kind of easier to understand what it is about.\n\nI will change it back to setWorkRemaining in the next version.\n\n\n\u003e Technical detais:\n\n...all of them good. I will add all of those to the next version of the patch.\n",
    "Created an attachment (id\u003d52002)\nNew patch to equinox common\n\nOkay, let\u0027s try this one.\n\n- Creates a new final SubMonitor class.\n- Deprecates SubProgressMonitor\n- Renames \"begin\" to \"convert\" to correctly represent its semantics\n- Renames \"setTicks\" to \"setWorkRemaining\"\n- Removes the optimization for the shared null leaf node\n- Removes the public constructors and style flags\n- Adds plenty of JavaDoc and examples describing the intended usage, who should call beginTask/done, etc.\n- Removes the one-argument version of \"begin\"\n",
    "Created an attachment (id\u003d52003)\nAdopts the latest patch in the test suites\n\n",
    "Created an attachment (id\u003d52004)\nOops. Tagged the wrong attachment as obsolete. He\u0027re\u0027s the right one.\n\n",
    "Sorry, it looks to me like the last three patches all contain changes to the test suits, but not to the equinox.common?\n",
    "Created an attachment (id\u003d52814)\nSubMonitor patch\n\nOh my goodness. I wonder how I managed to attach the same wrong attachment twice in a row? I mean, you\u0027d think that would take a special kind of stupid. Heh. Very sorry.\n\nI\u0027m going to open this one twice after I attach it to make sure it\u0027s right.",
    "Yep. Triple checked. That last attachment has code for equinox common.",
    "Created an attachment (id\u003d53386)\nCosmetically modified patch combines 52003 and 52814\n\nI am impressed by the amount of Javadocs and JUnits in the last patches! \n\nDid some slight cosmetic modifications - reformatted to fit Equinox standards, removed warnings. The only place of interest is the change from \n   if (monitor.getClass() \u003d\u003d SubMonitor.class)\nto use \"instanceof\" (now that it is a new final class this should work?).\n\n",
    "Created an attachment (id\u003d53479)\nPatch\n\nThe patch adds suggestions from John:\n- Don\u0027t deprecate SubProgressMonitor just yet as it will cause a lot of work for a lot of people. The Javadoc for the SubProgressMonitor gets a line \"consider using SubMonitor for new implementations\"\n- Makes SubMonitor implement IProgressMonitorWithBlocking; the calls to setBlocked(IStatus) / clearBlocked() are forwarded to the RootInfo which forwards them to the parent monitor\n\nI left \"deprecated\" tags in the JUnit tests as I think that we will eventually want to deprecate SubProgressMonitor and then those will come handy.\n\nIf there is a feeling that SubMonitor API might change, we can mark its Javadoc as \"provisional\" - let me know.\n",
    "I just looked over your code changes: they look good to me.\n\nGiven that three of us have scrutinized this patch extensively, I\u0027d say that there\u0027s probably no need for the provisional tag.\n",
    "Created an attachment (id\u003d53565)\nMinor update to comment\n\nMinor update after discussing with Stefan.  The \"anti-pattern\" example3 in the newChild javadoc doesn\u0027t actually fail because method arguments are guaranteed to evaluate from left to right. This update switches the order of the method arguments to ensure that the \"wrong way\" example will fail.",
    "It is my great pleasure to say that patch 53565 was released into CVS Head. Great job!\n",
    "Thanks, Oleg. It\u0027s been a pleasure.",
    "[contributed patch applied]\n"
  ],
  "commentCreationDates": [
    "2006-09-13T04:47:14+02:00",
    "2006-09-13T04:48:38+02:00",
    "2006-09-13T05:00:40+02:00",
    "2006-09-13T05:07:09+02:00",
    "2006-09-13T20:34:20+02:00",
    "2006-09-14T03:05:22+02:00",
    "2006-09-14T03:06:39+02:00",
    "2006-09-21T16:50:29+02:00",
    "2006-09-22T01:52:41+02:00",
    "2006-09-22T01:55:26+02:00",
    "2006-10-02T15:54:02+02:00",
    "2006-10-02T18:39:41+02:00",
    "2006-10-02T18:40:16+02:00",
    "2006-10-02T18:44:49+02:00",
    "2006-10-11T16:38:33+02:00",
    "2006-10-12T01:46:10+02:00",
    "2006-10-16T01:32:45+02:00",
    "2006-10-16T01:33:41+02:00",
    "2006-10-16T01:35:06+02:00",
    "2006-10-23T20:35:33+02:00",
    "2006-10-27T05:39:23+02:00",
    "2006-10-27T05:40:12+02:00",
    "2006-11-07T16:44:46+01:00",
    "2006-11-08T18:41:50+01:00",
    "2006-11-08T19:15:29+01:00",
    "2006-11-09T19:01:29+01:00",
    "2006-11-09T21:43:18+01:00",
    "2006-11-10T00:49:08+01:00",
    "2007-03-08T16:44:01+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.core.runtime.SubProgressMonitor.isCanceled",
          "source": "SubProgressMonitor.java:522"
        },
        {
          "method": "org.eclipse.core.tests.runtime.ProgressMonitorWrapperTest.testProgressMonitorWrapper",
          "source": "ProgressMonitorWrapperTest.java:47"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "junit.framework.TestCase.runTest",
          "source": "TestCase.java:154"
        },
        {
          "method": "junit.framework.TestCase.runBare",
          "source": "TestCase.java:127"
        },
        {
          "method": "junit.framework.TestResult$1.protect",
          "source": "TestResult.java:106"
        },
        {
          "method": "junit.framework.TestResult.runProtected",
          "source": "TestResult.java:124"
        },
        {
          "method": "junit.framework.TestResult.run",
          "source": "TestResult.java:109"
        },
        {
          "method": "junit.framework.TestCase.run",
          "source": "TestCase.java:118"
        },
        {
          "method": "junit.framework.TestSuite.runTest",
          "source": "TestSuite.java:208"
        },
        {
          "method": "junit.framework.TestSuite.run",
          "source": "TestSuite.java:203"
        },
        {
          "method": "junit.framework.TestSuite.runTest",
          "source": "TestSuite.java:208"
        },
        {
          "method": "junit.framework.TestSuite.run",
          "source": "TestSuite.java:203"
        },
        {
          "method": "junit.framework.TestSuite.runTest",
          "source": "TestSuite.java:208"
        },
        {
          "method": "junit.framework.TestSuite.run",
          "source": "TestSuite.java:203"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run",
          "source": "JUnit3TestReference.java:128"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.TestExecution.run",
          "source": "TestExecution.java:38"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:460"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:673"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run",
          "source": "RemoteTestRunner.java:386"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main",
          "source": "RemotePluginTestRunner.java:58"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run",
          "source": "CoreTestApplication.java:24"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:78"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication",
          "source": "EclipseAppLauncher.java:104"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start",
          "source": "EclipseAppLauncher.java:74"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:401"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:177"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.core.launcher.Main.invokeFramework",
          "source": "Main.java:336"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:280"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:977"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:952"
        }
      ],
      "number": 0,
      "commentIndex": 7,
      "bugId": "157124",
      "date": "2006-09-21T16:50:29+02:00",
      "product": "Platform",
      "component": "Runtime",
      "severity": "enhancement"
    }
  ],
  "groupId": "157124",
  "bugId": "157124",
  "date": "2006-09-13T04:47:14+02:00",
  "product": "Platform",
  "component": "Runtime",
  "severity": "enhancement"
}