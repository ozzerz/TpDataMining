{
  "comments": [
    "N20050519-0010\n\nWith unparameterized types, generalize type can be activated by placing the\ncaret anywhere inside an unqualified type. With parameterized types, the whole\ntype must be selected. The refactoring should automatically detect the\ngeneralizable type around the caret location\n\nSometimes, not even selecting the whole type works (e.g. selecting the type\n\"List\u003cObject\u003e\" (second parameter of method test2(..))).\n\nAnd with qualified type names (even unparameterized), the refactoring spits:\norg.eclipse.jdt.internal.corext.Assert$AssertionFailedException: assertion\nfailed;No constraint variable matches the selected ASTNode.\n\tat org.eclipse.jdt.internal.corext.Assert.isTrue(Assert.java:139)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.structure.ChangeTypeRefactoring.findConstraintVariableForSelectedNode(ChangeTypeRefactoring.java:880)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.structure.ChangeTypeRefactoring.computeValidTypes(ChangeTypeRefactoring.java:416)\n\tat\norg.eclipse.jdt.internal.ui.refactoring.ChangeTypeWizard$1.run(ChangeTypeWizard.java:195)\n\tat\norg.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)\n\nHere\u0027s an example class to play around:\n\npublic class Dummy {\n    String fValue2 \u003d \"Eclipse\";\n    List\u003cString\u003e fValue \u003d Arrays.asList(\"Eclipse\");\n    \n    String test(String arg) { return null;}\n    List\u003cString\u003e test2(java.util.List\u003cObject\u003e aList, List\u003cObject\u003e l){\n        return null;\n    }\n}",
    "Frank, can you please investigate.",
    "Created an attachment (id\u003d21635)\npatch for bug 95928\n\npatch for bug 95928",
    "Created an attachment (id\u003d21637)\npatch for tests\n\npatch for tests",
    "Hi Dirk,\n\nHere you go. I hope this will do it for you, because I don\u0027t have any more time\nin the next few days.\n\nregards,\n\n  -Frank",
    "Frank, I looked at the patch and the only piece of code that I don\u0027t fully\nunderstand is \n\n// adjustment needed if part of a qualified name is selected\nif ((node.getNodeType() \u003d\u003d ASTNode.QUALIFIED_NAME) ||\n    (parent.getNodeType() \u003d\u003d ASTNode.QUALIFIED_NAME)){\n\tASTNode current\u003d parent;\n\twhile (current.getNodeType() \u003d\u003d ASTNode.QUALIFIED_NAME){\n\t\tcurrent\u003d current.getParent();\n\t}\n\tAssert.isTrue(current.getNodeType() \u003d\u003d ASTNode.SIMPLE_TYPE);\n\tnode\u003d current.getParent(); \n}\n\nTwo questions:\n\n- why is it save to put the assert here. Wouldn\u0027t it be better to return a \n  message from the method since the message will be turned into a fatal\n  error anways\n\n- node.getNodeType() \u003d\u003d ASTNode.QUALIFIED_NAME equals true then the current\n  will be set to parent even if parent isn\u0027t a qualified name. Can\u0027t this\n  result in a problem ?",
    "Frank, there is indeed a problem. In the following case:\n\npublic class A {\n\tprivate static Object field;\n\tpublic void foo() {\n\t\tA.field\u003d null;\n\t}\n}\n\nfully select A.field and execute change type. This results in an exception.",
    "Created an attachment (id\u003d21739)\nnew patch\n\nnew patch",
    "Created an attachment (id\u003d21740)\nnew tests patch, with additional test for Dirk\u0027s test case\n",
    "Thanks for for updated patches !!\n\nFixed.",
    "Verifying...",
    "In comment 0, everything now works as expected in I20050527-1300, except that in\ntype java.util.List\u003cString\u003e, the carat must be on List or String for Generalize\nType refactoring to be activated, not java or util.  Markus, if this meets the\nspirit of the bug for you, please mark as VERIFIED."
  ],
  "commentCreationDates": [
    "2005-05-19T14:37:02+02:00",
    "2005-05-19T15:46:47+02:00",
    "2005-05-24T17:49:57+02:00",
    "2005-05-24T17:50:22+02:00",
    "2005-05-24T17:51:16+02:00",
    "2005-05-25T14:59:56+02:00",
    "2005-05-25T15:04:35+02:00",
    "2005-05-25T18:22:42+02:00",
    "2005-05-25T18:23:11+02:00",
    "2005-05-26T11:10:54+02:00",
    "2005-05-30T15:49:47+02:00",
    "2005-05-30T15:51:30+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.jdt.internal.corext.Assert$AssertionFailedException",
      "message": "assertion failed;No constraint variable matches the selected ASTNode.",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.corext.Assert.isTrue",
          "source": "Assert.java:139"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.refactoring.structure.ChangeTypeRefactoring.findConstraintVariableForSelectedNode",
          "source": "ChangeTypeRefactoring.java:880"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.refactoring.structure.ChangeTypeRefactoring.computeValidTypes",
          "source": "ChangeTypeRefactoring.java:416"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.refactoring.ChangeTypeWizard$1.run",
          "source": "ChangeTypeWizard.java:195"
        },
        {
          "method": "org.eclipse.jface.operation.ModalContext$ModalContextThread.run",
          "source": "ModalContext.java:113"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "95928",
      "date": "2005-05-19T14:37:02+02:00",
      "product": "JDT",
      "component": "UI",
      "severity": "normal"
    }
  ],
  "groupId": "95928",
  "bugId": "95928",
  "date": "2005-05-19T14:37:02+02:00",
  "product": "JDT",
  "component": "UI",
  "severity": "normal"
}