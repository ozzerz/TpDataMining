{
  "comments": [
    "This bug is related to a cluster of bugs already reported, all to do with \nIllegalStateException thrown by EclipsePreferences.checkRemoved(); easiest way \nto see some of the cluster is to search on \"checkRemoved\" in comments.  The \ncanonical one is perhaps Bug 68993.\n\nThis could be fixed (and in many places has been) in client code, but I am \nreporting this against Platform because I think there is an underlying Platform \nproblem that is tripping up a number of downstream consumers.  I suggest \nsolutions at the end of this bug report.\n\n   *** REPRO ***\n\nOne repro scenario follows:\n1. Start with a workspace that contains a Java project, and with JDT core \nsettings all set to defaults (workspace and project).  \n2. View workspace settings, go to the Java / Compiler pane, and change compiler \ncompliance at the workspace level to 5.0 (so that there\u0027s a workspace node).  \n3. Select \"configure project specific settings\" and select the project.  In \nproject settings, uncheck \"preserve unused local variables\" (so there\u0027s a \nproject node).  \n4. Ok the project-specific dialog; ok the workspace dialog.  \n5. Now, again view workspace settings.  Select \"configure project specific \nsettings\" and select the project.  \n6. In project settings, click \"Restore Defaults\".  \n7. Ok the project-specific dialog; ok the workspace dialog.  \n\nNote that the error log now contains two errors, an \"unhandled loop exception\" \nand \"preference node org.eclipse.jdt.core has been removed\".\n\n   *** EXPLANATION ***\n\nHere\u0027s why I think it\u0027s happening in this particular case.  For readability \nI\u0027ve abbreviated some type names:\n\nEP  \u003d org.eclipse.core.internal.preferences.EclipsePreferences\nPP  \u003d org.eclipse.core.internal.resources.ProjectPreferences\nWCM \u003d org.eclipse.ui.internal.preferences.WorkingCopyManager\nOCB \u003d org.eclipse.jdt.internal.ui.preferences.OptionsConfigurationBlock\n\nOCB is used to create preferences panes for certain JDT settings.  (We also use \nit as a base class for the jdt.apt settings, which is how I found this; see Bug \n106111.)  An OCB owns a WCM.  WCM owns a map of WCP.  Nothing is ever removed \nfrom this map.\n\nOCB is used to create both the workspace and project-specific panes.  Because \nthose dialogs are cross-linked, it is possible to nest a project-specific \ninstance of OCB within a workspace-prefs instance of OCB, by first viewing a \nworkspace pref pane and then linking to a project-specific pref pane.\n\nWhen the \"Configure project specific settings\" link on the workspace-prefs \ninstance is clicked, OCB.hasProjectSpecificOptions() is called.  In figuring \nout which projects have options, it inadvertently brings project-specific nodes \ninto the WCM\u0027s map - that is, the WCM belonging to the parent (workspace) OCB.\n\nLater, when the nested (project-specific) OCB is ok\u0027ed, if the changes cause \nthere to be no non-default settings under the project-specific node, then \nPP.save() deletes the whole project-specific preference file.  This results in \nthe file\u0027s resource listener being called.  Ultimately, that results in a call \nto PP.deleted(IFile), which calls PP.removeNode() to remove the corresponding \nproject-specific prefs node.\n\nEven later, when the parent (workspace) OCB is ok\u0027ed, it calls WCM.applyChanges\n().  This flushes every WCP in its map, which includes the project-specific \nWCP.  When a WCP is flushed, it calls PP.flush() on the \"original\" node that \nbacks it.  This results in a call to checkRemove(), which throws an exception \nif the node has been removed.\n\nBut in this case, the node that backs the project-specific WCP has already been \nremoved.  So, the exception is thrown.\n\n   *** SOLUTIONS ***\n\nIn a nutshell, the problem is that WCM is inadvertently caching project pref \nnodes, but those project nodes can get deleted by underlying code.\n\nOne workaround would be that in OCB, we could implement \nhasProjectSpecificSettings() differently, without using a WorkingCopyManager \n(since we\u0027re never interested in actually changing the settings discovered \nthere, there\u0027s no point in wrapping them in WCM).  But that would only fix the \nproblem in one place; Bugzilla contains many instances of people tripping over \nthe same core problem, which is that it\u0027s bad to cache pref nodes.\n\nI would suggest instead one of two fixes.\n\nMinimally, WCM and WCP could be changed to install listeners on the nodes they \ncache, to remove the WCP from WCM\u0027s map if the underlying node is changed.  \nThis would solve the WCM problem, but it would still not solve other caching \nproblems.\n\nMore deeply, I wonder whether it is right for EclipsePreferences to be throwing \nexceptions when removed nodes are flushed.  Perhaps it would be better to just \nsilently ignore attempts to flush removed nodes?  If even the developers of \nWCM/WCP (in the platform code) make the mistake of caching preference nodes, it \nmay be unreasonable to expect better of downstream consumers.",
    "DJ, it would be good if you could have a look at this.\nThe quick summary is: The preference page builds a working copy preference\n(WCP1) on top of the original preference store (PS). The page now opens a\nproperty page out of the first page that builds a new, unrelated WCP2. That WCP2\nis then commited, makes changes to the PS, in particular removing a node. WCS1\ndoesn\u0027t know of this and still holds on the removed node. Any attempt to change\nthe \u0027removed\u0027 node later result in IAExceptions.\n\nThis all comes from the scenario \u0027open a property page out of the preference\npage\u0027. The first question is, shouldn\u0027t we really have two different WCSs, or\nshould we share? Sharing would definitly have a benefit, although the nested\npage has to be carful to only commit its own changes, and not yet committing the\nother pages changes (would work in our scenario, but tricky in general). We\ncould also think of stacked WCP, where a WCP2 sits on top of WCP1. There it\nisn\u0027t clear to me if the user would understand that pressiong ok on the nested\npage would not really save the preferences until ok on the top page has been\npressed.\nAll that could be easely done in platform.UI by having a stack/instance of the\ncurrent WCM\n\nPossibility 2 is to keep the current separation, but fix the removedNode problem.\nA node can only be removed if no working copy node refers to it anymore. \nI guess as the WCP is currently in platform.ui, it has to become a remove\nlistener on the original. But why not using this opportunity to move the WCP\ndown to runtime :-)\n\nPossibility 3 is that we change our code to force an apply before opening the\nproperty page out of the preference page. This sounds like a bit nasty for the\nuser, but might be the right thing to do if we don\u0027t have sharing as suggested\nin proposal 1.\n(the remove bug should still be fixed, however)\n\n",
    "This problem is fixed in both 3.1.2 and 3.2. I can\u0027t find any core changes in these builds related to this, so it must have been with the property and preference pages themselves? Tod and I guess that the WCM was being queried for the wrong nodes.\n\nbtw, we can\u0027t change the behaviour of EclipsePreference#flush as it is spec\u0027d to throw the exception if the node has been removed.\n\nMartin do you feel that there is any more work to be done here or can this be closed? How many WCM instances do you use? Is it just one or multiple?",
    "This seems indeed be fixed. I think there were more removed\u003d true calls before. But i can\u0027t track back due to the move.\n\nIt would feel natural if a property page is opened out of a preference page they use the same WCS. But it\u0027s ok to me not not try that now.\n",
    "Ok, closing. We\u0027ll keep and eye open and if something else in this area surfaces we will open another report. Thanks.",
    "\u003eIt would feel natural if a property page is opened out of a preference page\n\u003ethey use the same WCS. \n\nI would disagree as you may be modifying the same preference on a preference different node (that is exactly what you are doing now).",
    "Yes, that\u0027s exacly the problem. Now two instances have different copies, so the one who flushes last, wins. \n\nIn our case, when pressing \u0027default\u0027 on a project, we show you the settings of the workbench. But these are actually not the (unsaved) setting currenly in the preference dialog, but the ones on disk.\n\nThe fix for us is to always save the settings before opening a property page out of a preference page.\n\nIt\u0027s a minor bug, but in fact I think the right solution is to share the store. ",
    "It seems that this bug is still alive, see bug 127986. I suggest to reopen.",
    "*** Bug 127986 has been marked as a duplicate of this bug. ***",
    "I am seeing this error in I20060315-1200 - same steps as Walter\u0027s original steps.  I reverted some project specific preferences to default, and then clicked ok in the preference dialog to get this error:\n\njava.lang.IllegalStateException: Preference node \"org.eclipse.jdt.core\" has been removed.\nat org.eclipse.core.internal.preferences.EclipsePreferences.checkRemoved(EclipsePreferences.java:157)\nat org.eclipse.core.internal.preferences.EclipsePreferences.flush(EclipsePreferences.java:326)\nat org.eclipse.core.internal.resources.ProjectPreferences.flush(ProjectPreferences.java:566)\nat org.eclipse.ui.internal.preferences.WorkingCopyPreferences.flush(WorkingCopyPreferences.java:516)\nat org.eclipse.ui.preferences.WorkingCopyManager.applyChanges(WorkingCopyManager.java:58)\nat org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.okPressed(FilteredPreferenceDialog.java:385)\nat org.eclipse.jface.preference.PreferenceDialog.buttonPressed(PreferenceDialog.java:225)\nat org.eclipse.jface.dialogs.Dialog$3.widgetSelected(Dialog.java:652)\nat org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)\nat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\nat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)\nat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3340)\nat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2960)\nat org.eclipse.jface.window.Window.runEventLoop(Window.java:820)\nat org.eclipse.jface.window.Window.open(Window.java:796)\nat org.eclipse.ui.dialogs.PropertyDialogAction.run(PropertyDialogAction.java:156)\nat org.eclipse.jface.action.Action.runWithEvent(Action.java:499)\nat org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:539)\nat org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)\nat org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)\nat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\nat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)\nat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3340)\nat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2960)\nat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1909)\nat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1873)\nat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:418)\nat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)\nat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:107)\nat org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:78)\nat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)\nat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)\nat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:374)\nat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:169)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:85)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:58)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:60)\nat java.lang.reflect.Method.invoke(Method.java:391)\nat org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)\nat org.eclipse.core.launcher.Main.basicRun(Main.java:282)\nat org.eclipse.core.launcher.Main.run(Main.java:977)\nat org.eclipse.core.launcher.Main.main(Main.java:952)\n",
    "Created an attachment (id\u003d36815)\npatch for ui.workbench\n\nHere is a patch for WorkingCopyManager which checks to see if any of the nodes in its cache have been removed from underneath it.\n\nAnother alternative is to register a listener on the original nodes. We will discuss this....after lunch. :-)\n",
    "Assigning to Tod to release the patch.",
    "Fixed for build \u003e20060327",
    "Verified in 20060328-0100",
    "Please note very similar bug 137398."
  ],
  "commentCreationDates": [
    "2005-09-29T22:57:57+02:00",
    "2005-11-10T10:20:46+01:00",
    "2006-01-18T21:20:55+01:00",
    "2006-01-18T22:42:48+01:00",
    "2006-01-18T22:52:37+01:00",
    "2006-01-19T12:55:38+01:00",
    "2006-01-19T14:40:03+01:00",
    "2006-02-16T08:54:15+01:00",
    "2006-02-16T08:54:33+01:00",
    "2006-03-17T20:10:49+01:00",
    "2006-03-23T17:07:00+01:00",
    "2006-03-27T12:39:37+02:00",
    "2006-03-27T14:05:38+02:00",
    "2006-03-28T20:28:03+02:00",
    "2006-04-19T01:06:27+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.IllegalStateException",
      "message": "Preference node \"org.eclipse.jdt.core\" has been removed.",
      "elements": [
        {
          "method": "org.eclipse.core.internal.preferences.EclipsePreferences.checkRemoved",
          "source": "EclipsePreferences.java:157"
        },
        {
          "method": "org.eclipse.core.internal.preferences.EclipsePreferences.flush",
          "source": "EclipsePreferences.java:326"
        },
        {
          "method": "org.eclipse.core.internal.resources.ProjectPreferences.flush",
          "source": "ProjectPreferences.java:566"
        },
        {
          "method": "org.eclipse.ui.internal.preferences.WorkingCopyPreferences.flush",
          "source": "WorkingCopyPreferences.java:516"
        },
        {
          "method": "org.eclipse.ui.preferences.WorkingCopyManager.applyChanges",
          "source": "WorkingCopyManager.java:58"
        },
        {
          "method": "org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.okPressed",
          "source": "FilteredPreferenceDialog.java:385"
        },
        {
          "method": "org.eclipse.jface.preference.PreferenceDialog.buttonPressed",
          "source": "PreferenceDialog.java:225"
        },
        {
          "method": "org.eclipse.jface.dialogs.Dialog$3.widgetSelected",
          "source": "Dialog.java:652"
        },
        {
          "method": "org.eclipse.swt.widgets.TypedListener.handleEvent",
          "source": "TypedListener.java:90"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java:66"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:925"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java:3340"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:2960"
        },
        {
          "method": "org.eclipse.jface.window.Window.runEventLoop",
          "source": "Window.java:820"
        },
        {
          "method": "org.eclipse.jface.window.Window.open",
          "source": "Window.java:796"
        },
        {
          "method": "org.eclipse.ui.dialogs.PropertyDialogAction.run",
          "source": "PropertyDialogAction.java:156"
        },
        {
          "method": "org.eclipse.jface.action.Action.runWithEvent",
          "source": "Action.java:499"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection",
          "source": "ActionContributionItem.java:539"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.access$2",
          "source": "ActionContributionItem.java:488"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem$5.handleEvent",
          "source": "ActionContributionItem.java:400"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java:66"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:925"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java:3340"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:2960"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1909"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1873"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:418"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:143"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:107"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:78"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication",
          "source": "EclipseAppLauncher.java:92"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start",
          "source": "EclipseAppLauncher.java:68"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:374"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:169"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:85"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:58"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:60"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:391"
        },
        {
          "method": "org.eclipse.core.launcher.Main.invokeFramework",
          "source": "Main.java:338"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:282"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:977"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:952"
        }
      ],
      "number": 0,
      "commentIndex": 9,
      "bugId": "111144",
      "date": "2006-03-17T20:10:49+01:00",
      "product": "Platform",
      "component": "UI",
      "severity": "normal"
    }
  ],
  "groupId": "111144",
  "bugId": "111144",
  "date": "2005-09-29T22:57:57+02:00",
  "product": "Platform",
  "component": "UI",
  "severity": "normal"
}