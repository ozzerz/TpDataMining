{
  "comments": [
    "This problem was reported on wtp 1.5.5 200707121554\n\nWhile I still try to gather information from the user, I think the scenario is that the user was trying to have the Web service client wizard to create the Web project and the EAR project.  For some reason, the ear association was not visible when module publishing was taking place.  I am still trying to get confirmation from the user whether this is reproducable and it is the Web service wizard creating the modules.\n\nThis is the stacktrace of the problem:\n\n    ... at some extender code to add ear to server\n    at org.eclipse.wst.server.core.internal.ServerWorkingCopy.modifyModules(ServerWorkingCopy.java:498)\n    at org.eclipse.wst.server.core.ServerUtil.modifyModules(ServerUtil.java:379)\n    at org.eclipse.jst.ws.internal.consumption.command.common.AddModuleToServerCommand.execute(AddModuleToServerCommand.java:101)\n    at org.eclipse.jst.ws.internal.consumption.ui.extension.PreClientInstallCommand.execute(PreClientInstallCommand.java:77)\n    at org.eclipse.wst.command.internal.env.core.fragment.CommandFragmentEngine.runCommand(CommandFragmentEngine.java:414)\n    at org.eclipse.wst.command.internal.env.core.fragment.CommandFragmentEngine.visitTop(CommandFragmentEngine.java:354)\n    at org.eclipse.wst.command.internal.env.core.fragment.CommandFragmentEngine.moveForwardToNextStop(CommandFragmentEngine.java:252)\n    at org.eclipse.wst.command.internal.env.ui.widgets.SimpleCommandEngineManager$5.run(SimpleCommandEngineManager.java:250)\n    at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:369)\n    at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:313)\n    at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:851)\n    at org.eclipse.wst.command.internal.env.ui.widgets.SimpleCommandEngineManager.runForwardToNextStop(SimpleCommandEngineManager.java:220)\n    at org.eclipse.wst.command.internal.env.ui.widgets.WizardPageManager.runForwardToNextStop(WizardPageManager.java:95)\n    at org.eclipse.wst.command.internal.env.ui.widgets.WizardPageManager.getNextPage(WizardPageManager.java:146)\n    at org.eclipse.wst.command.internal.env.ui.widgets.SimpleWizardPage.getNextPage(SimpleWizardPage.java:136)\n    at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:751)\n    at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:351)\n    at org.eclipse.jface.dialogs.Dialog$3.widgetSelected(Dialog.java:660)\n    at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)\n    at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n    at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:928)\n    at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3348)\n    at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2968)\n    at org.eclipse.jface.window.Window.runEventLoop(Window.java:820)\n    at org.eclipse.jface.window.Window.open(Window.java:796)\n    at org.eclipse.wst.command.internal.env.ui.widgets.popup.DynamicPopupWizard.run(DynamicPopupWizard.java:130)\n    at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:254)\n    at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:539)\n    at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)\n    at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)\n    at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n    at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:928)\n    at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3348)\n    at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2968)\n    at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1930)\n    at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1894)\n    at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:422)\n    at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)\n    at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:95)\n    at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:78)\n    at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)\n    at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)\n    at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)\n    at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:177)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:615)\n    at org.eclipse.core.launcher.Main.invokeFramework(Main.java:336)\n    at org.eclipse.core.launcher.Main.basicRun(Main.java:280)\n    at org.eclipse.core.launcher.Main.run(Main.java:977)\n    at org.eclipse.core.launcher.Main.main(Main.java:952)",
    "This seems to be an intermittent problem.  In this scenario, the Web services wizard create the Web project, adds the Web project to the EAR and then add the EAR to the server.  We suspect that the problem occurs if at the point when the wizard calls AddModuleToServerCommand to add the EAR module to the server, the autobuild that updates the J2EE model after adding module to EAR has not completed yet, then the EAR does not know about the Web module and resulted in the error:\n\n    org.eclipse.core.runtime.CoreException: Cannot add an EAR project to the server unless it contains a Web, EJB, or Connector module.\n    at org.eclipse.wst.server.core.internal.ServerWorkingCopy.modifyModules(Unknown Source)\n    at org.eclipse.wst.server.core.ServerUtil.modifyModules(Unknown Source)\n    at org.eclipse.jst.ws.internal.consumption.command.common.AddModuleToServerCommand.execute(Unknown Source)\n",
    "In AssociateModuleWithEARCommand, we call the execute method of AddComponentToEnterpriseApplicationDataModelProvider to add module to an EAR.  Then we call AddModuleToServerCommand to add the EAR module to the server.  I had a discussion with Carl and he suggested adding the following to where we call AddComponentToEnterpriseApplicationDataModelProvider to force a refresh so that the J2EE model is updated with the correct information before we proceed with adding the EAR to server:\n\nIDataModel addComponentToEARDataModel \u003d DataModelFactory.createDataModel(new AddComponentToEnterpriseApplicationDataModelProvider());\n// ...\nlong oldModStamp \u003d DependencyGraphManager.getInstance().getModStamp();\naddComponentToEARDataModel.getDefaultOperation().execute(null, null);\nif (oldModStamp \u003d\u003d DependencyGraphManager.getInstance().getModStamp()){\n\tDependencyGraphManager.getInstance().forceRefresh();\n}\n\nI think these kind of code to check if we need to force refresh should be handled when the execute method in AddComponentToEnterpriseApplicationDataModelProvider is called, not by the caller of the operation.  The caller should be able to count on the fact that once execute returns, the module has been added to the EAR and any required model update has taken place.\n\nRerouting to J2EE team.",
    "This is the same problem that is causing 4 test case failures in 1.5.5.",
    "We need to make DependencyGraphManager.metadataChanged() public, and add this as an additional check for EARVirtualComponent\u0027s cache.",
    "Created an attachment (id\u003d74627)\nAdd a better check to EARVirtualComponent\u0027s cache.\n\n",
    "This bug was caused by a performance enhancement to EARVirtualComponent, but the cache may not be detected as stale if it is used too quickly.  There is no workaround, and it appears as if the change to the reference changes that just occurred have not occurred.  The fix has been tested by hand and by running the entire JUnit AllTestsSuite.  (And this fixes 4 failures in the current WTP 1.5.5 JUnit bucket.)\nCurrently, the cache in EARVirtualComponent only checks the modStamp of DependencyGraphManager to see if it is out of date... but that time stamp is not updated until a resource change event comes through.  In the above case (and the JUnits), the getReferences() is called after the references are changed, but before the resource change event has been processed.  All we did was made DependencyGraphManager.metadataChanged() a public method (it was private), and added a call to that in EARVirtualComponent.checkIfStillValid().\nChuck Bridgham has reviewed this fix.\nThe only risk associated with this is a small performance regression from the gain we received (between when the reference is changed and the resource change event comes through), but the majority of the performance benefit is maintained.",
    "Chuck reviewed this, and wanted it in tonight (to fix the 4 JUnits), so it has his approval... can we get this reviewed by the PMC, and I will get Chuck to put his official stamp on this ASAP?  (We need the JUnits clean tonight.)",
    "I would approve this as-is, but seems that instead of changing \"metadataChanged\" to be public, a better encapsulated design would be to add a \"checkIfStillValid (long timestamp)\" to DependencyGraphManager, which does all that \"internal stuff\" itself, hidden from clients, and EARVirtualComponent.checkIfStillValid could just defer to DependancyGraphManager.checkIfStillValid.  \n\nSeems conceptually cleaner, at least, and exposes less internal data of DependancyChecker. \n\n\n",
    "Carl, could you please also export the plugin JAR containing the fix and attach it to this bug so that the adoptor who reported the bug can verify that it does fix the problem rather than waiting for the WTP 1.5.5 build and the adoptor product to pick up that build?",
    "Created an attachment (id\u003d74661)\nUpdated patch as per David Williams suggestion\n\n",
    "Please make sure to put this fix in the R2_0_maintenance stream so that WTP 2.0.1 picks it up as well.",
    "Yep looks good - eliminated the time issue by pulling directly from the source of the cache\n\napproved",
    "Committed to both 1.5.5 and 2.0.1.",
    "Verified in the WTP155m0817 driver."
  ],
  "commentCreationDates": [
    "2007-07-25T00:04:31+02:00",
    "2007-07-25T21:03:32+02:00",
    "2007-07-25T23:00:27+02:00",
    "2007-07-25T23:11:01+02:00",
    "2007-07-25T23:12:58+02:00",
    "2007-07-25T23:13:48+02:00",
    "2007-07-25T23:21:09+02:00",
    "2007-07-25T23:25:26+02:00",
    "2007-07-25T23:48:23+02:00",
    "2007-07-26T04:23:50+02:00",
    "2007-07-26T11:02:30+02:00",
    "2007-07-26T16:29:44+02:00",
    "2007-07-26T17:17:45+02:00",
    "2007-07-26T17:35:55+02:00",
    "2007-08-30T20:54:41+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.core.runtime.CoreException",
      "message": "Cannot add an EAR project to the server unless it contains a Web, EJB, or Connector module.",
      "elements": [
        {
          "method": "org.eclipse.wst.server.core.internal.ServerWorkingCopy.modifyModules",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.wst.server.core.ServerUtil.modifyModules",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.jst.ws.internal.consumption.command.common.AddModuleToServerCommand.execute",
          "source": "Unknown Source"
        }
      ],
      "number": 0,
      "commentIndex": 1,
      "bugId": "197721",
      "date": "2007-07-25T21:03:32+02:00",
      "product": "Web Tools",
      "component": "jst.j2ee",
      "severity": "major"
    }
  ],
  "groupId": "197721",
  "bugId": "197721",
  "date": "2007-07-25T00:04:31+02:00",
  "product": "Web Tools",
  "component": "jst.j2ee",
  "severity": "major"
}