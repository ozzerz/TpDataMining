{
  "comments": [
    "When opening the workspace of a Java 1.5 project developed under Eclipse 3.1 under the latest 3.2RC4 (3.2.0 Build I20060512-1600) an internal compiler error is reported via an error marker highlighting the first character of a Java source file.  The stack trace contained within the marker is as follows:\n\nInternal compiler error\njava.lang.NullPointerException\n\tat org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.computeInheritedMethods(MethodVerifier.java:507)\n\tat org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.computeInheritedMethods(MethodVerifier.java:392)\n\tat org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:636)\n\tat org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.verify(MethodVerifier15.java:544)\n\tat org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods(SourceTypeBinding.java:1594)\n\tat org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.verifyMethods(CompilationUnitScope.java:756)\n\tat org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:591)\n\tat org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:411)\n\tat org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:300)\n\tat org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:217)\n\tat org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:237)\n\tat org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:56)\n\tat org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:249)\n\tat org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:169)\n\tat org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:603)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:167)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:201)\n\tat org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:230)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:233)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:252)\n\tat org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:285)\n\tat org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:145)\n\tat org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:208)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)\n\nThe class in the source file is defined:\n  public class Child extends Parent\u003cType\u003e {}\n\nThe parent source is defined:\n  public abstract class Parent\u003cType\u003e extends Grandparent\u003cType\u003e implements IParent {} \n\nRemoving the \u0027extends Parent\u0027 inheritence from the child gets rid of the internal compiler error, but generates a different one in another class:\n\nInternal compiler error\njava.lang.NullPointerException\n\tat org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.implementsInterface(ReferenceBinding.java:812)\n\tat org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith0(ReferenceBinding.java:937)\n\tat org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith(ReferenceBinding.java:890)\n\tat org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:215)\n\tat org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:432)\n\tat org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:179)\n\tat org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:403)\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1047)\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1094)\n\tat org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:353)\n\tat org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:594)\n\t: (continues as previous trace)\n\t\nAs it stands I cannot continue development in this version of Eclipse and I have to revert to my previous configuration.",
    "Please provide steps to reproduce.\nToo late for RC5 anyway.\n\n",
    "Please reopen once steps are available.",
    "The problem seems to be caused by Eclipse not gracefully handling an inconsistent type hierarchy.  I can recreate the first internal error by defining the following classes and interfaces in separate files:\n\npublic class Child extends Parent\u003cObject\u003e {}\npublic abstract class Parent\u003cT\u003e extends Grandparent\u003cT\u003e implements IParent {}\npublic interface IParent\u003cT\u003e extends IGrandparent\u003cT\u003e {}\npublic abstract class Grandparent\u003cT\u003e implements IGrandparent\u003cT\u003e {}\npublic interface IGrandparent\u003cT\u003e {}\n\nIn this case Eclipse points out the inconsistent type hierarchy with a marker on Parent.java (\"The interface IGrandparent cannot be implemented more than once with different arguments: IGrandparent\u003cT\u003e and IGrandparent\").  (No such error was given in my original code - the only error was the internal compiler fault).\n\nAn error can be seen on \"line 0\" of Child.java as before:\n\nInternal compiler error\njava.lang.NullPointerException\n\tat org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.computeInheritedMethods(MethodVerifier.java:507)\n\t:\n\t\nThe error in the source can be resolved by modifying the Parent to use type parameters in its interface implementation:\n\npublic abstract class Parent\u003cT\u003e extends Grandparent\u003cT\u003e implements IParent\u003cT\u003e {}\n\nMaking a similar correction in my project also stops this internal error.  I have been unable to reproduce the second stack trace, however.",
    "The two cases are consequence of the same bug. An array of superinterfaces contain null values.\n\nThese are likely coming from the collision detected before (cannot implement twice the same interface in different parameterized form).",
    "The problem comes from late removal of colliding superinterfaces from the type binding; at a stage where parameterized type instances already got created way before this (and did not get readjusted).\n\nGiven this change was made late, and also causes grief to other places, e.g. DOM AST; I believe we should reintroduce them back and improve the verifier to ignore them.",
    "One thing to consider is having colliding superinterfaces being persisted in (problem) classfiles. This shouldn\u0027t be an issue, since through binary compatibility scenari, the same may occur with valid classfiles (i.e. forgot to recompile some supertype after a subclass change).\n\nTagging for 3.2.1. Though the situation is not ideal, this is a sensitive change to perform, and we need to check for ripples, even in dependent components (what about refactoring etc...). \nCurrently, we have an internal exception when compiling incorrect code, resulting in an extra marker being created. We are not rejecting valid code, but rather are not optimally handling incorrect code. Still we want to address it asap, but I don\u0027t think it qualifies as a stop ship issue for 3.2.0.",
    "Created an attachment (id\u003d42000)\nProposed patch\n\nThe patch is no longer altering the binding superinterfaces as a side effect of the collision check.\nIt also defers the check until method verification occurs, since this is where the non colliding interface list is needed to avoid complaining unnecessarily about nameclash issues...",
    "Kent - what do you think ?",
    "Added GenericTypeTest#test0989-0992 + MethodVerifyTest#test088",
    "Created an attachment (id\u003d42001)\nBetter patch\n\nSlight improvement, avoid unnecessary work when compliance \u003c 1.5",
    "Reassign to Kent. After discussion, we will make the fix a little bit better to reduce noise in case of collisions.\ne.g.\nimport java.util.*;\npublic class X extends X2 {}\nabstract class X2 extends X3 implements List\u003cString\u003e {}\nabstract class X3 implements List\u003cThread\u003e {}\n\nhere we shouldn\u0027t report any missing method implementation, until the collisions have been addressed. With RC4, we complain about missing List\u003cThread\u003e methods, with my patch we complain about missing List\u003cThread\u003e AND List\u003cString\u003e methods.\n\nAlso, once this bug is addressed, we should close bug 138671 (DOM with proper test), and bug 138887. \nBug 138671 is a regression over 3.1, and we need to double check that JDT/UI is correctly behaving (in case they worked around the regression).\nCC\u0027ing Martin about later concern.\n",
    "Because of NPE possibilities, I am wondering about the consequences on DOM clients, like refactoring. We may want to address this for 3.2RC6.",
    "Created an attachment (id\u003d42060)\nPatch\n\nPhilippe - please check this patch. It finds all the superinterfaces and skips the ones that have the same erasure.\n\npasses all of your new tests without any secondary errors",
    "Patch looks good. Shouldn\u0027t you use a tagbit to retain the presence of collisions, and thus avoid expensive work during method verification ?",
    "Note: The bit usage would only be a small performance improvement. Nothing critical (ie. could occur post 3.2.0).",
    "Martin/Dani - would you vote for fixing this in RC6 ?",
    "Dani/Martin - current behavior (NPE) is a regression over 3.1.2.",
    "Mike - pls cast your vote for RC6.\n\nBasically, in RC1 another fix did introduce a regression in a negative scenario; resulting in causing a NPE in the compiler. \n\nWith the patch, the behavior is even better than in 3.1, since less secondary errors are being produced (ie. no complaint for unimplemented abstract methods from offending superinterfaces). The fix is safe.\n\nThis fix could either go in for 3.2.0 or 3.2.1; candidating for RC6 since the regression got promptly identified, and we have a good fix at hand.\nAlso this is correcting the DOM AST defficiency (small contract change) introduced at RC1 as well, and documented in bug 138671 (DOM) and bug 138887. ",
    "Discussed the patch with Philippe, I couldn\u0027t prove him wrong (So far! :-)).\n\n+1 for 3.2 RC6 as the current code (introduced in Rc2) would return \u0027null\u0027 elements as super interfaces. According to Philippe, this would also be visible in the DOM AST which would be unexpected and result in NPE\u0027s in our code.\n\nI wouldn\u0027t mind having a more minimal patch at this stage, e.g. don\u0027t try to reduce the number of emmited \u0027type contains unimplemented methods\u0027 errors.",
    "Kent - what about only fixing ClassScope for 3.2.0, and the method verifier for 3.2.1 ? Afterall, minimizing secondary errors is deluxe... in 3.1 we had half the secondary issues.\n\nI would second this request for RC6; since this makes the fix much safer/simpler.",
    "\u003eI wouldn\u0027t mind having a more minimal patch at this stage,\nSame here. Could we see a patch that only contains the minimum to fix the reported NPE? More clean up can be done post 3.2.",
    "I\u0027ll look into the smaller fix, but the patch is not that scary.\n\n90% of the code in findSuperinterfaceCollisions is copied from computeInheritedMethods and over half of the patch is new tests.",
    "I\u0027ll leave it to the rest of you to decide whether a more minimal patch is a better answer at this point. I reviewed the latest patch with Kent, and agree that it looks scarier than it really is.\n\nI\u0027m also a bit worried that, for people who actually hit the problem, the secondary errors that will be produced without the verifier fix will be confusing.",
    "The smallest possible change is a one line change to ClassScope in this block of code in checkParameterizedSuperTypeCollisions():\n\nnextOtherInterface: for (int j \u003d 0; j \u003c i; j++) {\n  ReferenceBinding two \u003d interfaces[j];\n  if (two \u003d\u003d null) continue nextOtherInterface;\n  if (hasErasedCandidatesCollisions(one, two...)) {\n    interfaces[i] \u003d null; \u003c\u003c\u003c\u003c should be j instead of i\n    count--;\n    continue nextInterface;\n  }\n}\n\nBut given bug 138671, we should at least take the full change to ClassScope from the existing patch, which no longer removes the interface.\n\nI would prefer not to remove the changes to the MethodVerifier15, but if we do then 2 of the tests in the patch need to be modified to report 4 \u0026 6 additional secondary errors that make it more difficult to see the root cause of the problem (the duplicate interfaces with different arguments).\n\nThe changes to the verifier are mostly copied code from computeInheritedMethods so they are not as scary as they look.",
    "\u003eBut given bug 138671, we should at least take the full change to ClassScope\n\u003efrom the existing patch, which no longer removes the interface.\nI\u0027d vote for the minimal patch in ClassScope for 3.2 RC6 and doing the full fix in 3.2.1.",
    "+1 to take full change to ClassScope from the existing patch and leave the MethodVerifiers as is. \nI also reviewed the full patch and believe that the changes in MethodVerifier15 are all fine, but I wouldn\u0027t want to take the risk that interfaces are wrongly eliminated and no \u0027unimplemented method\u0027 error is generated.",
    "this makes sense to me. +1 to putting in the reduced patch for now, and the rest for 3.2.1",
    "Released ClassScope only change with additional secondary errors in tests to HEAD for RC6.\n\nReleased ClassScope + MethodVerifier changes to 3.2.1 branch.\n\nClosed bug 138671 and bug 138887 since they are fixed with the ClassScope change.",
    "Verified in I20060526-0010 for 3.2RC6"
  ],
  "commentCreationDates": [
    "2006-05-18T23:50:26+02:00",
    "2006-05-18T23:56:07+02:00",
    "2006-05-19T00:05:20+02:00",
    "2006-05-19T01:07:48+02:00",
    "2006-05-19T09:15:45+02:00",
    "2006-05-19T10:16:08+02:00",
    "2006-05-19T12:33:34+02:00",
    "2006-05-19T12:58:26+02:00",
    "2006-05-19T12:58:48+02:00",
    "2006-05-19T13:00:15+02:00",
    "2006-05-19T13:04:57+02:00",
    "2006-05-19T18:17:19+02:00",
    "2006-05-19T18:18:18+02:00",
    "2006-05-19T20:26:04+02:00",
    "2006-05-19T21:53:04+02:00",
    "2006-05-22T16:11:33+02:00",
    "2006-05-22T16:25:33+02:00",
    "2006-05-22T16:30:11+02:00",
    "2006-05-22T16:37:41+02:00",
    "2006-05-22T18:04:49+02:00",
    "2006-05-22T18:20:47+02:00",
    "2006-05-22T18:27:28+02:00",
    "2006-05-23T15:54:20+02:00",
    "2006-05-23T19:44:04+02:00",
    "2006-05-23T20:02:15+02:00",
    "2006-05-24T09:13:43+02:00",
    "2006-05-24T10:32:54+02:00",
    "2006-05-24T15:38:12+02:00",
    "2006-05-24T17:21:21+02:00",
    "2006-05-26T17:33:43+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.computeInheritedMethods",
          "source": "MethodVerifier.java:507"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.computeInheritedMethods",
          "source": "MethodVerifier.java:392"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify",
          "source": "MethodVerifier.java:636"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.verify",
          "source": "MethodVerifier15.java:544"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods",
          "source": "SourceTypeBinding.java:1594"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.verifyMethods",
          "source": "CompilationUnitScope.java:756"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.process",
          "source": "Compiler.java:591"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:411"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:300"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile",
          "source": "BatchImageBuilder.java:217"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:237"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build",
          "source": "BatchImageBuilder.java:56"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll",
          "source": "JavaBuilder.java:249"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.JavaBuilder.build",
          "source": "JavaBuilder.java:169"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$2.run",
          "source": "BuildManager.java:603"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:167"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:201"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$1.run",
          "source": "BuildManager.java:230"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:233"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuildLoop",
          "source": "BuildManager.java:252"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.build",
          "source": "BuildManager.java:285"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.doBuild",
          "source": "AutoBuildJob.java:145"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.run",
          "source": "AutoBuildJob.java:208"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "142653",
      "date": "2006-05-18T23:50:26+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "major"
    },
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.implementsInterface",
          "source": "ReferenceBinding.java:812"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith0",
          "source": "ReferenceBinding.java:937"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith",
          "source": "ReferenceBinding.java:890"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve",
          "source": "ReturnStatement.java:215"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements",
          "source": "AbstractMethodDeclaration.java:432"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements",
          "source": "MethodDeclaration.java:179"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve",
          "source": "AbstractMethodDeclaration.java:403"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:1047"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:1094"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve",
          "source": "CompilationUnitDeclaration.java:353"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.process",
          "source": "Compiler.java:594"
        }
      ],
      "number": 1,
      "commentIndex": 0,
      "bugId": "142653",
      "date": "2006-05-18T23:50:26+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "major"
    },
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.computeInheritedMethods",
          "source": "MethodVerifier.java:507"
        }
      ],
      "number": 2,
      "commentIndex": 3,
      "bugId": "142653",
      "date": "2006-05-19T01:07:48+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "major"
    }
  ],
  "groupId": "142653",
  "bugId": "142653",
  "date": "2006-05-18T23:50:26+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "major"
}