{
  "comments": [
    "For an enum containing an abstract method with a non-primitive return type: if\nany of the enum elements implements the method with a covariant return type, an\nAbstractMethodError will be thrown when the method is invoked on that element.\n\nThe following test case succeeds when compiled with the Sun JDK compiler, but\nfails when compiled in Eclipse.\n\nTested against Eclipse 3.1_I20050126-0800\n\n---- EnumElementCovariantReturnTest.java ----\n\nimport junit.framework.TestCase;\n\npublic class EnumElementCovariantReturnTest extends TestCase {\n  // this test passes\n  public void testEnumElementNormalReturn() {\n    E.ITEM_1.x();\n  }\n\n  // this test fails due to covariant return value in ITEM_2\n  public void testEnumElementCovariantReturn() {\n    E.ITEM_2.x();\n  }\n\n  static class X {}\n  static class Y extends X {}\n\n  enum E {\n    ITEM_1() {\n      // regular return value -- works as expected\n      public X x() { return new Y(); }\n    },\n    ITEM_2() {\n      // covariant return -- AbstractMethodError\n      public Y x() { return new Y(); }\n    };\n\n    public abstract X x();\n  }\n}\n\n---- End of EnumElementCovariantReturnTest.java ----\n\nNow replace the abstract declaration of x() with the following:\n\npublic X x() {\n  throw new UnsupportedOperationException();\n}\n\nRun the test case, and an UnsupportedOperationException will be thrown.  It\nseems the compiler does not recognize that E.ITEM_2.x() is overriding E.x(). \nTherefore it would also seem in the original test case above that the compiler\ndoes not recognize that ITEM_2.x() is implementing the abstract method E.x().",
    "We can\u0027t be sure this bug is really fixed until 83901 is fixed.",
    "I\u0027m encountering an AbstractMethodError involving a covariant return override as\nwell. Mine has nothing to do with enums, and is with build I20050202-0800. My\nclass hierarchy is very complex, and I don\u0027t have a small reproducer yet, but a\nsummary is:\n\ninterface Visibility {}\ninterface NamedObject {}\ninterface Function extends NamedObject {}\ninterface ClassMember { Visibility getVisibility(); }\n\nclass FooVisibility implements Visibility  {}\nclass FooFunction implements Function { FooVisibility getVisibility(); }\ninterface FooClassMember { FooVisibility getVisibility(); }\nclass FooMemberFunction extends FooFunction implements FooClassMember {}\n\nvoid foo(NamedObject o)\n{\n  ClassMember member \u003d (ClassMember) o;\n  member.getVisibility(); // AbstractMethodError\n}",
    "Forgot to add: foo() is called with a FooMemberFunction object.\n",
    "Here\u0027s a reproducer:\n\npublic final class Bug83902\n{\n    public interface Visibility\n    {\n    }\n\n    public interface Function\n    {\n    }\n\n    public interface ClassMember\n    {\n        Visibility getVisibility();\n    }\n\n    public interface MemberFunction\n        extends Function, ClassMember\n    {\n    }\n\n    public static class FooVisibility\n        implements Visibility\n    {\n        public static final FooVisibility PUBLIC \u003d new FooVisibility();\n    }\n\n    public static class FooFunction\n        implements Function\n    {\n        public FooVisibility getVisibility()\n        {\n            return FooVisibility.PUBLIC;\n        }\n    }\n\n    interface FooClassMember\n        extends ClassMember\n    {\n        FooVisibility getVisibility();\n    }\n\n    public static class FooMemberFunction\n        extends FooFunction\n        implements MemberFunction, FooClassMember\n    {\n    }\n\n    public static void main(String[] args)\n    {\n        FooMemberFunction fmf \u003d new FooMemberFunction();\n        fmf.getVisibility(); // OK\n        FooClassMember fcm \u003d fmf;\n        fcm.getVisibility(); // OK\n        ClassMember cm \u003d fmf;\n        cm.getVisibility(); // AbstractMethodError\n    }\n}\n\nException in thread \"main\" java.lang.AbstractMethodError:\nBug83902$FooMemberFunction.getVisibility()LBug83902$Visibility;\n\tat Bug83902.main(Bug83902.java:55)\n",
    "On second scenario, we are missing one bridge method on FooMemberFunction:\n  public bridge synthetic X.IVisibility getVisibility();",
    "the problem in comment 0 is fixed.\n\nthe missing bridge method problem in comment 4 can be reproduced with:\n\npublic class X {\n  interface I {}\n  interface J { I getVisibility(); }\n\n  static class A implements I {}\n  static class B { public A getVisibility() { return null; } }\n  static class C extends B implements J {}\n\n  public static void main(String[] args) {\n    C c \u003d new C();\n    c.getVisibility(); // OK\n    J j \u003d c;\n    j.getVisibility(); // AbstractMethodError\n  }\n}\n\nWe are missing the bridge method on the class C because of the inherited \nmethods from B \u0026 J",
    "Added EnumTest test076 for comment 0.\n\nAdded MethodVerifyTest test041 for comment 6",
    "Verified in I20050215-2300"
  ],
  "commentCreationDates": [
    "2005-01-28T02:39:13+01:00",
    "2005-01-28T02:49:40+01:00",
    "2005-02-04T22:39:00+01:00",
    "2005-02-04T22:41:51+01:00",
    "2005-02-04T22:59:57+01:00",
    "2005-02-08T11:01:01+01:00",
    "2005-02-09T22:57:20+01:00",
    "2005-02-11T18:52:24+01:00",
    "2005-02-16T14:21:01+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.AbstractMethodError",
      "message": "Bug83902$FooMemberFunction.getVisibility()LBug83902$Visibility;",
      "elements": [
        {
          "method": "Bug83902.main",
          "source": "Bug83902.java:55"
        }
      ],
      "number": 0,
      "commentIndex": 4,
      "bugId": "83902",
      "date": "2005-02-04T22:59:57+01:00",
      "product": "JDT",
      "component": "Core",
      "severity": "critical"
    }
  ],
  "groupId": "83902",
  "bugId": "83902",
  "date": "2005-01-28T02:39:13+01:00",
  "product": "JDT",
  "component": "Core",
  "severity": "critical"
}