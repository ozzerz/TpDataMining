{
  "comments": [
    "I\u0027m porting Eclipse to MacOS X and I\u0027m running into a problem with Eclipse\u0027s dependency \non a non-standard JDI library that implements a 1.4.x method even if running on 1.3.1:\n\nWhenever I debug from within Eclipse on MacOS X I get the following stacktrace:\n\njava.lang.NoSuchMethodError\n    at \norg.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsJDKHotCodeReplac\ne(JDIDebugTarget.java:560)\n    at \norg.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsHotCodeReplace(JD\nIDebugTarget.java:533)\n    ...\n\nThe method that cannot be found is VirtualMachine.canRedefineClasses().\nIt is a 1.4.x method that is implemented in Eclipse\u0027s implementation of the JDI library and \nit is assumed that this library hides any standard 1.3.1 JDI library available on the \nplatform.\n\nOn MacOS X however, the standard library is loaded very early in the startup process \nfrom the boot classpath (I\u0027m not really sure why, but I cannot prevent it). So the Eclipse \nclassloader has no chance to hide the standard library with the Eclipse version. Because \nthe standard library conforms to the 1.3.1 specs and does not define the \nVirtualMachine.canRedefineClasses() method the error occurs.\n\nThe workaround is to prepend Eclipse\u0027s implementation of the JDI library (jdi.jar) to the \nbootclasspath via the -Xbootclasspath/p: commmand line option. But this does not seem \nto be a robust solution.\n\nWouldn\u0027t it be possible to use reflection to find out whether hot code replacement is \navailable? The debugger seems to depend only on a single non-standard method. So \nthe additional reflection code to protect this call seems to be fairly small. The benefit \nwould be to eliminate any dependencies on a non-standard library and to make the \ndebugger less brittle.",
    "There is actually more than one method that we use in JDI 1.4... However, if \none method is missing, we can assume they are all missing. As well, we rely on \nour JDI implementation to handle communication timeouts, which is not part of \nthe standard JDI.\n\nOne of our goals is to have our debugger support other JDI implementations. For \nnow, the workaround is to place our JDI jar on the bootpath.",
    "Exactly which VM are you running? The fact that the VM is loading its own \ntools.jar (or whichever jar it has the JDI interfaces in) sounds like a bug \nthat should be filed against the VM vendor.\n\n(In response to Andre) there\u0027s nothing \"non-standard\" about our JDI \nlibrary. It is as compatible with the JDI spec as any other implementation. \nYour VM\u0027s JDI library is just another JDI library; it\u0027s no more \"standard\" \nthan ours. The only non-standard behavior here is the fact that the VM is \nloading its own JDI interfaces.\n\nIf this is the only VM available on MacOS 10, then we should address the \nissue either by tweaking the Eclipse launcher on MacOS 10 to prepend our \njdi.jar (preferred) or by adding some defense to our debug model against \nold interfaces.\n\nIt\u0027s probably worth noting here that we\u0027ve seen this problem before when \nusers tried to prepend a JDK 1.3.x tools.jar to their bootpath to get \nclasses from the tools.jar that were not related to debugging. We\u0027ve \ntraditionally considered this bad behavior, but if we fix the problem for \nOS 10, we\u0027ll be fixing the general tools.jar problem.",
    "Current solution is to add our JDI impl on classpath before Mac impl. Unclear \nif Java debugger will support JDI v1.3 yet.\n\nMarking as \"later\"",
    "Re-open to mark as dup",
    "This bug is a duplicate. Our JDI implementation now supports Sun\u0027s 1.4 \nimplementation, with the recent fix of bug# 23040.\n\n*** This bug has been marked as a duplicate of 10670 ***"
  ],
  "commentCreationDates": [
    "2002-08-21T09:48:20+02:00",
    "2002-08-21T14:38:40+02:00",
    "2002-08-21T16:30:50+02:00",
    "2002-08-28T20:27:08+02:00",
    "2002-09-03T22:00:15+02:00",
    "2002-09-03T22:02:59+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NoSuchMethodError",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsJDKHotCodeReplace",
          "source": "JDIDebugTarget.java:560"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsHotCodeReplace",
          "source": "JD IDebugTarget.java:533"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "22611",
      "duplicateId": "10670",
      "date": "2002-08-21T09:48:20+02:00",
      "product": "JDT",
      "component": "Debug",
      "severity": "enhancement"
    }
  ],
  "groupId": "10670",
  "bugId": "22611",
  "duplicateId": "10670",
  "date": "2002-08-21T09:48:20+02:00",
  "product": "JDT",
  "component": "Debug",
  "severity": "enhancement"
}