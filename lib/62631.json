{
  "comments": [
    "Weaving a simple aspect into a weblogic generated stub class results in a \ncorrupt class file.  Loading the class fails with \"Illegal constant pool index\".\n\nException in thread \"main\" java.lang.VerifyError: (class: tavant/POCSessionBean_\nsvxh3d_EOImpl_812_WLStub, method: isIdentical signature: (Ljavax/ejb/EJBObject;)\nZ) Illegal constant pool index\n        at java.lang.Class.forName0(Native Method)\n        at java.lang.Class.forName(Unknown Source)\n        at TestLoad.main(TestLoad.java:8)",
    "Created an attachment (id\u003d10760)\nContains the class file \u0026 the required jars to reproduce the problem\n\nI have attached a zip file with all the necessary files to reproduce the issue.\nThe readme.txt explains the purpose of each file and the sequence of commands\nto reproduce the issue.",
    "I have tested this with aspectj 1.2 as well. The problem reproduces in 1.2 as \nwell.",
    "Looks like a silent compilation failure leaves a broken class file on disk - \nthe class file is truncated at a method boundary.",
    "\nPlease can you tell me which Java compiler (IBM/SUN/JDT/etc???) and which \nversion of that compiler you used to build the stub into a class file? thanks.\n\nI currently suspect this is a BCEL bug.  But I\u0027m having trouble making \nprogress.  I have tried decompiling the stub class and then doing the \ncompilation using the source rather than a binary weave, and that doesn\u0027t fail.\n\nI find that I can make the aspect much more simple and still get the problem, \nI can just use before or after advice, I don\u0027t need both.  I find I can target \nsingle methods in the stub and sometimes the weave works, sometimes it fails - \nhaven\u0027t found the pattern yet ...",
    "The stub class file is generated using the weblogic appc command. I tried \nvarious options but couldn\u0027t get hold of the source file.\n\nIt appears that the stub class file is generated on the fly based on another \nclass file without going through the step of first generating a source file and \nthen compiling it.",
    "Got it !\n\nDefinetly worth a nice write up.\n\nThe class file is not truncated but it does contain a bit of garbage that \nchokes the JVM or various decompilers (e.g. jad).  The problem only occurs if \nyou weave a method that contains a certain bytecode pattern.  The appc tool \nthat is constructing the class file in question puts in this particular \nbytecode sequence:\n\n   32:  ldc_w   #10; //String tavant.POCSession\n   35:  invokestatic    #165; //Method class$:(Ljava/lang/String;)\nLjava/lang/Class;\n\nWhich translates to:   19,0,10,184,165\n\nldc_w takes the following two bytes to construct an index into the constant \npool (byte1\u003c\u003c8+byte2).\n\nIt is only when we weave a method that we let BCEL process the method, because \nwe are going to munge the bytecodes in some way.  BCEL sees the code sequence \nabove and tries to be \u0027clever\u0027.  It sees an ldc_w, it then pulls in the 0 and \n10.  The actual code that does it is (from LDC_W.java):\n\nprotected void initFromFile(ByteSequence bytes, boolean wide) throws \nIOException {\n    setIndex(bytes.readUnsignedShort());\n    // Override just in case it has been changed\n    opcode \u003d org.apache.bcel.Constants.LDC_W;\n}\n\nsetIndex() is in the superclass of LDC_W, called LDC.  setIndex() calls setSize\n() in LDC which contains this piece of code:\n\n  protected final void setSize() {\n    if(index \u003c\u003d org.apache.bcel.Constants.MAX_BYTE) { // Fits in one byte?\n      opcode \u003d org.apache.bcel.Constants.LDC;\n      length \u003d 2;\n    } else {\n      opcode \u003d org.apache.bcel.Constants.LDC_W;\n      length \u003d 3;\n    }\n  }\n\nHere there is an optimization attempted.  If it is an LDC_W instruction but \nthe constant pool index is less than one byte, transform it into an LDC \ninstruction which only needs a single byte index after it.  It remembers that \nit made this optimization by setting the length to 2.  Of course, we then come \nout of setSize(), back up to initFromFile() which then does this:\n\n    // Override just in case it has been changed\n    opcode \u003d org.apache.bcel.Constants.LDC_W;\n\nwhich resets the opcode back again !  So now we have stored an LDC_W \ninstruction that takes a single byte.  When we write this sequence out onto \ndisk using this method:\n\n  public void dump(DataOutputStream out) throws IOException {\n    out.writeByte(opcode);\n\n    if(length \u003d\u003d 2)\n      out.writeByte(index);\n    else // Applies for LDC_W\n      out.writeShort(index);\n  }\n\nWe get:   19,10,184,165\n\nand of course, you give this to a JVM or a decompiler and it sees:\n\nLDC_W 2744\nIF_ACMPEQ\n\n(2744 is 10\u003c\u003c8+184)\n\nOf course, there aren\u0027t 2744 entries in the constant pool and we blow up.\n\nThe fix is to comment out the line that resets the opcode back to LDC_W if we \nhave made the optimization.\n\nSo, you see this bug if:\n- You used a compiler or tool to generate the class file that didn\u0027t already \nmake the optimization.\n- You weave a method containing the unoptimized bytecode sequence.\n\n",
    "Fix checked in.  Fix will be in AspectJ 1.2 final."
  ],
  "commentCreationDates": [
    "2004-05-18T15:02:45+02:00",
    "2004-05-18T15:06:17+02:00",
    "2004-05-18T15:08:55+02:00",
    "2004-05-18T17:30:48+02:00",
    "2004-05-19T14:10:12+02:00",
    "2004-05-19T15:08:51+02:00",
    "2004-05-20T14:57:47+02:00",
    "2004-05-24T18:23:26+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.VerifyError",
      "message": "(class: tavant/POCSessionBean_ svxh3d_EOImpl_812_WLStub, method: isIdentical signature: (Ljavax/ejb/EJBObject;) Z) Illegal constant pool index",
      "elements": [
        {
          "method": "java.lang.Class.forName0",
          "source": "Native Method"
        },
        {
          "method": "java.lang.Class.forName",
          "source": "Unknown Source"
        },
        {
          "method": "TestLoad.main",
          "source": "TestLoad.java:8"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "62631",
      "date": "2004-05-18T15:02:45+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "62631",
  "bugId": "62631",
  "date": "2004-05-18T15:02:45+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}