{
  "comments": [
    "This was highlighted when running the AJDT core tests with the latest aspectj. \n\nThe failing test (AJBuilderTest.testIncrementalBuildWithSrcFolder) uses the TJP Example, adds a comment to the Demo.java file and saves. It then checks that an incremental build happened. With the latest AspectJ this fails since a full build occurs instead. Unfortunately this test only fails when run as part of AJBuilderTest rather than on its own.\n\nThe reason this is happening is the change to the logic in AjCompilerAdapter.weave() line 288. If there have been changes marked against the weaver and we\u0027re not a batch build then we used to just add all the classes to the list of classes to weave and continue. What now happens is that we force a full build because we believe an aspect has changed.\n\nThe reason we believe that an aspect has changed comes from the call to AjState.getModifiedFiles(long lastBuildTime). Here we iterate over the files in the build config and check whether they were last modified before or after the lastBuildTime. The logic is:\n\nlong modTime \u003d file.lastModified();\n// need to add 1000 since lastModTime is only accurate to a second on some (all?) platforms\nif (modTime + 1000 \u003e lastBuildTime) {\n    ret.add(file);\n}\n\nIn the failing case, modTime \u003c lastBuildTime but modTime + 1000 \u003e lastBuildTime for the aspect. Therefore, it\u0027s added to the list of modified files and the test fails. When run on its own the aspect returns modTime + 1000 \u003e lastBuildTime so we only think we\u0027ve modified a class - which is correct. Clearly, removing the \"+ 1000\" fixes the problem and running the AJ test suite against this causes no failures. However, this doesn\u0027t fix the problem that the \"+1000\" was put in to fix. Doing the same thing and running the AJDT core test suite on my linux box does occasionally cause a failure with one of the tests - we didn\u0027t notice that the file had changed because of the timestamp, didn\u0027t do a build and consequently the test failed. This again is not recreatable on its own and if you add print statments.\n\nThis is not a new bug since I\u0027ve run the ajdt test suite against the AJ 1.5.0 release and even though we\u0027re saying we want to reweave the world we\u0027re not doing a full build. Therefore there could have been cases where we were weaving everything when we needn\u0027t have - the changes to go back to source if an aspect changed have just hightlighted the problem.\n\nFinally, I have been unable as yet to write a filing testcase for the AJ testsuite for this bug.",
    "Another thing I found out.....\n\nAs mentioned when I raised the bug, the reason for the full build is that the weaver is asked if it should reweave the world. This returns true and we\u0027re not a batch build so we force a full build. The code is:\n\nweaver.prepareForWeave();\nif (weaver.needToReweaveWorld()) {\n    if (!isBatchCompile) addAllKnownClassesToWeaveList(); \n}\n\nIn the call to weaver.prepareForWeave() we go through the list of added classes (which includes both the class and the aspect). If its an aspect then we set the needToReweaveWorld field using the following: \n\nneedToReweaveWorld |\u003d xcutSet.addOrReplaceAspect(type);\n\nThis returns true even though it probably shouldn\u0027t. Following this through, the \"true\" comes from CrosscuttingMembers.repace(CrosscuttingMembers). In here, the perClause, shadowMungers and typeMungers of the two crosscuttingmembers are checked for equality (amoung other things). However, these all return that they\u0027re not equal - the question is why they should do this considering nothing has changed. Looking further, there\u0027s no implementation of the equals method in PerClause, plus shadowMungers and typeMungers are using the List equals methods.\n\nJust ignoring these three checks causes the tests to pass.",
    "Implementing the equals and hashCode methods in PerClause (which should probably be moved down into the subclasses) and changing the shadowMungers and typeMungers fields in CrosscuttingMembers to be Sets rather than Lists (so the Set equals method is used) means that all AJDT tests pass.\n\nUnfortunately, moving this over to AspectJ causes several test failures:\n\nTests which fail because they\u0027re expecting a particular order in sysout \n-----------------------------------------------------------------------\n\n* testAnnotatedITDFs_pr114005_1 (in 150 testsuite)\n* testAnnotatedITDFs_pr114005_2 (in 150 testsuite)\n* XXXJoinPoint,java - part of testRunThemAllWithJavacCompiledAndLTW\n* AfterXTest.java - part of testRunThemAllWithJavacCompiledAndLTW\n\n\nThere are also some failures in the incremental testsuite:\n----------------------------------------------------------\n\n* testPr125405 - this expected 2 compiles and 1 weave, however is now getting 1 compile and 1 weave (as it was before the go back to source changes were made). This test consists of one aspect which is made generic and then back again.\n\n* testPr113257 - this expected a full build however its now an incremental build (as it was before the go back to source changes were made). This tests consists of an aspect and class which are built using a full build. An aspect which does nothing is then added. This now results in an incremental build\n\n* testPr123612 - this expected a full build however its now an incremental build (as it was before the go back to source changes were made). This test consists of one file which contains an aspect, interface and class. Originally the aspect has a declare @type statement. This statement is then removed which now causes an incremental build.\n\nLooking into testPr123612 - the reason we\u0027re now returning that we shouldn\u0027t reweave the world (and consequently not forcing a full build) regardless of the fact that the aspect has changed is possibly due to the call to addCrosscuttingStructures(..) in AjLookupEnvironment.collectAllITDsAndDeclares(). This calls down to the CrosscuttingMembers.replaceWith(..) method and notices that the list of declareAnnotationsOnType is different (note that the typeMungers aren\u0027t different), however, the next time this method is called via the weaver.prepareForWeave() method this list seems to have been reset as there\u0027s nothing in the old list of declareAnnotationsOnType and we return that there are no changes. The reason this was previously causing a full build (after the back to source changes) was that the two perclauses were always deemed to be not equal. ",
    "testPr123612:\n-------------\n\nTo clarify....after the declare @ type has been commented out in the testcase and we\u0027re rebuilding, the first time we enter CrosscuttingMembers.replaceWith(..) \"this\" has the declare @type recorded against it, but \"other\" doesn\u0027t. Since these don\u0027t match, we return that there is a change, however, the \"other\" declare @type value (namely no value) replaces the \"this\" one. This is why when we come to see if there are any changes in order to check whether we need to reweave the world we return that there aren\u0027t any.\n\ntestPr113257:\n-------------\n\nAlthough we\u0027ve added an aspect, \"needToReweaveWorld\" is still false because it\u0027s just been added so comparing the crosscuttingMembers returns that nothing has changed. \n\ntestPr125405:\n-------------\n\nEach time the crosscuttingMembers are compared in the CrosscuttingMembers.replaceWith(..) method we return that nothing has changed. This is both when this is called via AjLookupEnvironment.collectAllITDsAndDeclares() and weaver.prepareForWeave(). \n\n\nAlthough with the implementation of equals in PerClause and the use of set equality rather than list equality on the surface we\u0027re returning the same as before the \"back to source\" changes, namely that we\u0027re doing an incremental build and that we\u0027re only weaving one thing, underneath we\u0027re actually doing something different. Because checking the equality of the perClauses always returned that something had changed we always thought that we would reweave the world. This used to be that we then added all classes to the list of classes to reweave, so although we didn\u0027t rebuild, we did weave everything. This no longer happens - instead we just weave those things which have changed. ",
    "Note.....Since the test for pr123612 contains all its types within the same file, all three classes are rewoven. As soon as this is split up into different files, only the aspect is rewoven.\n\n ",
    "Making the change to keep the shadowMungers and typeMungers in a list within CrosscuttingMembers and only convert to a set when we want to check for equality within replaceWith(..) means that the only failing tests are now the incremental ones.",
    "Ok....an update on progress before I forget what I\u0027ve done...\n\nThe AspectJ tests have been fixed by keeping a record of whether or not we\u0027ve ever found any changes when calling CrosscuttingMembers.replaceWith(..).  This has been implemented by adding a field in CrosscuttingMembersSet called \"changedSinceLastReset\". This is updated if something has changed from within addOrReplaceAspect() and is reset before the call to collectAllITDsAndDeclares(..) in AjLookupEnvironment.completeTypeBindings().\n\nUnfortuntately, although all the AspectJ tests now pass, this causes 4 failures within the AJDT core tests. The failures are all that an incremental build is expected but a full build happens. The scenarios are:\n\n1. A comment is added to a class file which results in a full build even though no aspect has been changed. This is partly a timing problem since the aspect is added to the list of files which have changed only when all tests are run together. This is the same scenario for two of the failing tests (one is with a src folder and one isn\u0027t)\n\n2. There are two projects where A depends on B and the contents of a method in B is changed which has no references to anything else. This results in a full build of A.\n\n3. There are two projects where A depends on B and the contents of a method in B is changed which is referenced by something in A. This results in a full build of A. The reference is in a class not an aspect.\n\n\nLooking into scenario 1. the shadowmungers and typemungers have changed the first time replaceWith is called on the incremental build. The recorded list contains two entries and the current list contains nothing. Therefore, the recorded list is replaced and we remember that things have changed. The next time replaceWith is called (when we\u0027re preparing to weave), the recorded list is nothing (as expected since it changed last time) but the current list has the same to entries that we had to begin with. This is the same for both the shadowmungers and typemungers lists. Looking into this further, this is because there is cflow in the pointcut. This means that these typemungers are created from shadowmungers and so haven\u0027t been created the first time around but have been by the second time around. Therefore, it seems that the first time we enter we don\u0027t care about the shadowmungers. By adding an extra boolean flag to the method signature of replaceWith(..) saying whether or not we care about the shadowmungers or typemungers still does not solve the problem. This is because various equals methods have either not been implemented correctly or are not implemented at all. Fixing this in Advice, MemberImpl, BcelTypeMunger and ResolvedTypeMunger does fix the problem in scenario 1. \n\nNote, in its current state, this is a short term solution as we really should check the typemungers on both calls to replaceWith. There should be a flag set against each of them saying whether or not we should care about them (we don\u0027t care if they are created via a shadowmunger) and then check each of the ones we care about.",
    "The remaining failing tests are different. The steps the test seems to be taking are as follows:\n\n- test starts\n- create project bug99133b\n- full build of project B occurs where we notice that we need to reweave the world and that we\u0027re a batchCompile - full build successful\n- create project bug99133a\n- full build of project bug99133a occurs where we notice that we need to reweave the world and that we\u0027re a batch compile - full build successful\n- full build of project bug99133a occurs again....notice that we need to reweave the world and that we\u0027re a batch compile - full build successful\n- we add sysout to the method body of a method within a class C.java in project bug99133b - nothing else has changed\n- incremental build of bug99133b is tried\n- we notice that nothing has changed and consequently that we don\u0027t need to reweave the world - this incremental build is successful\n- we then try to incrementally build project bug99133a \n- in AjState.prepareForNextBuild() we get the AjState for outputlocation C:\\eclipse_installations\\ajdt\\eclipse31\\junit-workbench-workspace\\bug99133b\\bin\n- we decide that there have in fact been structural changes to A1.class (which is the aspect within bug99133b that hasn\u0027t been touched at all)\n- we retry building bug99133a as a full build.\n- test fails because we do a full build rather than an incremental one\n\nUnfortunately, this test doesn\u0027t always fail, although at least it fails more times than it passes :-)\n\nAlso, I haven\u0027t yet been able to write a failing test to fit within the AspectJ testsuite.\n",
    "Running these failing tests agaist the 1.5.0 Aspectj returns that there are no changes so continues with an incremental build.",
    "Further info....\n\nThe reason we\u0027re returning that there are structural changes is that within AjState.hasStructuralChanges(..) the ClassFileReader is reporting that there are two fields: FieldInfo with name ajc$initFailureCause and FieldInfo with name ajc$perSingletonInstance, whereas the CompactStructureRepresentation is reporting that there aren\u0027t any fields. This comparison returns that structural changes have happened and so the aspect A1 is added to the list of structuralChangesSinceLastFullBuild. \n\nThis is all coming from the AjState.noteResult(InterimCompilationResult) method with the aspect having been recorded as the unwoven classfile. Previously (AJ 1.5.0), the unwoven classfile that is recorded against the interimCompilationResult is the class which has changed - C1. In the new case (post AspectJ 1.5.0) there is no record that the last thing built was C1...its all in terms of A1.\n\nThe problem is coming from what we record at the end of the first incremental build (after we\u0027ve incrementally built the class file C1 which has changed). Somewhere down the line I noticed that we do correctly record that there are no structural changes in the class file C1, we\u0027re just not doing the correct thing with the aspect. If we didn\u0027t record that anything structural had changed in the aspect then I believe we would be ok since we would then continue with an incremental build.",
    "This sounds like you\u0027re getting close to a solution. I\u0027m not sure I fully understand your last comment Helen, but I do get the gist of it (and I certainly understand noteResult and the compact structure representation stuff). It looks like we might be able to crack this tomorrow if we teamed up on it. Look out for me on \u0027sametime\u0027 and maybe we can have an impromptu call and get this nailed...\nThks, A.",
    "The \u0027fields\u0027 part of this problem is because at the time the compact structure is created, we ask the EclipseSourceType for its declared fields and getDeclaredFields() fills in its result \u0027on demand\u0027.  Unfortunately someone called getDeclaredFields() earlier, when there were none, then the code generators in the AspectDeclaration added the ajc$perSingletonInstance and the ajc$initFailureCause, but they are never accessible through getDeclaredFields().  The fix for this appears to be that EclipseSourceType.getDeclaredFields() also checks if the number of the fields on the backing binding has changed since it last worked out its answer, if it has then recalculate our answer.  Of course, all this never used to be a problem because we operated on the bytecode produced at the end of compilation when all the fields have been correctly stored in the class file and we reparsed it to determine what fields there were.\n\nAfter fixing fields, naturally methods is also broken - but its more serious this time as the methods set is built from the declaration.methods array, when our new methods (ajclinit, aspectOf, hasAspect) have been created as binding entries and not methoddeclarations...",
    "(capture of an IM discussion)\n\nI wondered about a different approach:                      \ninstead of making sure we always see the generated members   \nwhat if we ignored them during the comparison?               \n\nfor fields, I almost managed to convince myself that was safe last night \nit does make the \u0027has it changed\u0027 method more expensive, since we can\u0027t just compare lengths first\n...but we only do that for the small # of things that we think have changed since the last increment, so that\u0027s not so bad\n\nie. we filter the collections to take out ajc$*, aspectOf, hasAspect\n\nSince we are interested in structural changes from the perspective of the user program code, and these things are generated, they can never affect that.",
    "we may then have problems with clinit and init - possibly they can be \u0027ignored\u0027 too ... maybe \u003cinit\u003e if it is the default one and we\u0027re in an aspect.",
    "Filtering out the fields which start with \"ajc$\" and those methods whose name contains either \"aspectOf\", \"hasAspect\", \"clinit\" or \"ajc$\" means that the AJDT core tests now all pass.",
    "As expected migrating the changes over to AspectJ causes AJ test failures :-(\n\nThe implementation of the various equals methods is causing two test failures:\n\n* Ajc150Tests.testGenericAspects_pr115237 - this is now failing with a \"NoAspectBoundException\"\n* MultiProjectIncrementalTests.testPr114875 - this was expecting a full build but is now returning that nothing has changed.\n\nIn the case of the multiproject test I believe this is reasonable and the test should be changed to check for an incremental build. The scenario is that there is an @AJ aspect called Base which is built (full build). A new @AJ aspect is added which again forces a full build (as expected). However, the final step is to include an exact copy of the original Base aspect. We now (through the implementation of the various equals methods) think that these are the same thing and so dont go back to source and do a full build.\n\nAs for the NoAspectBoundException.......",
    "The NoAspectBoundsException is coming from the implementation of equals and hashcode in ResolvedTypeMunger.",
    "The failing testcase is:\n\npublic class pr115237 {\n\tpublic static void main(String[] args) {\n\t\tC c \u003d new C();\n\t\tc.go();\n\t\tA a \u003d A.aspectOf(c);\n\t\tB b \u003d B.aspectOf(c);   \u003c------- causing NoAspectBoundsException\n\t}\n\tstatic class C {\n\t\tvoid go() {}\t\t\n\t}\n\t\n\tabstract static aspect AA pertarget(pc()) {\n\t\tabstract pointcut pc();\n\t\tbefore() : pc() {\n\t\t\tSystem.out.println(\"go()\");\n\t\t}\n\t}\n\tstatic aspect A extends AA {\n\t\tpointcut pc() : call(void C.go());\n\t}\n\t\n\tabstract static aspect BB\u003cT\u003e pertarget(pc()) {\n\t\tabstract pointcut pc();\n\t\tbefore() : pc() {\n\t\t\tSystem.out.println(\"go()\");\n\t\t}\n\t}\n\tstatic aspect B extends BB\u003cC\u003e {\n\t\tpointcut pc() : call(void C.go());\n\t}\n}\n\nThe implementation of equals in ResolvedTypeMunger is returning true in all cases when it used to return false when it was using Objects\u0027s equals method.",
    "The fix is to move the equals implementation from ResolvedTypeMunger down into its subtypes. With this there all are no AJ test failures.\n\nIts now a case of splitting all these changes into consumable patches....",
    "Created an attachment (id\u003d35752)\nzip containing first part of fix\n\nThe attached zip contains two patches:\n\n* pr129163-weaver-patch-perClauseEquals.txt - apply to the weaver project. This patch adds equals and hashCode methods to the different perClause classes\n\n* pr129163-test-patch-perClauseEquals.txt - apply to the tests project. This patch makes changes to three tests. The first is legitimate in that we now compile once rather than twice, however, the second two comment out the check for a full build. This should be reinstated when other patches relating to this bug are applied and has only been included so that all the changes required for this bug can be applied incrementally.\n\n",
    "Created an attachment (id\u003d35754)\nbetter test patch than last time\n\nThis is a better patch for the tests project than the one contained in the zip file. The two tests which have been ammended will fail when the other changes are in (shadowmunger/typemunger checking) which will remind us to switch them back.",
    "first patches in for perclause hashcode/equals",
    "Created an attachment (id\u003d35757)\npatch containing fix to AjState\n\nApply patch to the org.aspectj.ajdt.core project.\n\nThis patch contains the changes required to AjState and EclipseSourceType - see comment #14",
    "Created an attachment (id\u003d35759)\nzip containing patches for maintaining a record about whether anything has changed\n\nThis zip contains three patches:\n\n* pr129163-tests-patch-maintainRecord.txt - apply to the tests project. This patch returns the two multiproject incremental tests back to checking for a full build rather than an incremental one (reverses the previous test patch)\n\n* pr129163-ajdt-patch-maintainRecord.txt - apply to the org.aspectj.ajdt.core project.\n\n* pr129163-weaver-patch-maintainRecord.txt - apply to the weaver project. \n\nThis fixes the problems described in comment #2 to comment #6",
    "patch from comment 22 integrated.",
    "patch from comment 23 integrated",
    "Created an attachment (id\u003d35826)\npatch containing implementation of remaining equals/hashCode\n\nApply this patch to the weaver project.\n\nThis patch contains the remaining implemenations of equals and hashCode.",
    "With all these patches applied there are two remaining failing AJDT tests: AJBuidler.testIncrementalBuildWithSrcFolder and AJBuilder.testIncrementalBuildWithoutSrcFolder. These are failing because the typeMungers are being compared and we\u0027re coming to the conclusion that things have changed when they haven\u0027t.",
    "patch from comment 26 integrated ... one to go",
    "Created an attachment (id\u003d35841)\npatch for checking if we really care about the typemungers\n\nApply this patch to the weaver project.\n\nThis patch contains the work for checking the typeMungers. If we don\u0027t care about the shadowmungers then we remove those type mungers which are created to help with the implementation of shadowmungers from the sets we compare in CrosscuttingMembers.replaceWith(..). Otherwise we include them. \n\nHopefully thats the last patch since now both the AJDT and AspectJ tests pass :-)",
    "patch from comment 29 committed.\n\nthat should be it - the AJDT containing this is going to behave very very differently ... but hopefully in a good way.",
    "Unfortunately with the latest AspectJ which contains all the attached patches one of the AJDT visual tests fails with the following NPE:\n\njava.lang.NullPointerException\nat org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.findReferenceContextFor(WeaverMessageHandler.java:188)\nat org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.handleMessage(WeaverMessageHandler.java:105)\nat org.aspectj.weaver.Lint$Kind.signal(Lint.java:273)\nat org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsForMissingType(WildTypePattern.java:817)\nat org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFromFullyQualifiedTypeName(WildTypePattern.java:696)\nat org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(WildTypePattern.java:622)\nat org.aspectj.weaver.patterns.SignaturePattern.resolveBindings(SignaturePattern.java:82)\nat org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(KindedPointcut.java:259)\nat org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:194)\nat org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.finishResolveTypes(PointcutDesignator.java:84)\nat org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration.resolveStatements(PointcutDeclaration.java:209)\nat org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)\nat org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration.resolvePointcut(PointcutDeclaration.java:190)\nat org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:422)\nat org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:234)\nat org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)\nat org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)\nat org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:843)\nat org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:268)\nat org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)\nat org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)\nat org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)\n\nNullPointerException thrown: null\n\nI have, however, been able to recreate this as an AspectJ testcase.",
    "Created an attachment (id\u003d35899)\nfailing testcase which produces NPE\n\nApply this patch to the tests project.\n",
    "The NPE is occuring because during the incremental build (in the initialisation of AjCompilerAdapter) we reset the compiler instance within WeaverMessageHandler to be null. Consequently, when we come to calculate the warning an NPE occurs when we try to ask the compiler instance for the unitsToProcess.\n\nJust as a note, the failing testcase adds the following pointcut:\n\npointcut p2(): call(* File.*(..));\n\nwithout adding an import for File. We fail whilst trying to report the warning.",
    "Created an attachment (id\u003d35905)\nimproved failing testcase which shows NPE\n\nApply to the tests project.\n\nThis test improves on the last one supplied by checking the warning output.",
    "Created an attachment (id\u003d35906)\npatch containing fix for NPE\n\nApply this patch to the org.aspectj.ajdt.core project.\n\nThis patch contains the fix for the NPE. Rather than passing null through when the compiler is reset, pass through the new compiler instance.",
    "comment 34,35 patches committed",
    "With all these changes there is one remaining failing test: an XReference visual test. Looking into this I believe its a failure in the xref view updating logic. Strangely, this test is also failing for me now when I run it against the existing code in the 1.3 ajdt brach. What\u0027s happening is that an aspect is opened in the editor which populates the xref view. Then we navigate to the line containing the declare warning statement. We then uncheck \"link with editor\" in the xref view, comment out the declare warning statement and save. This forces a build which forces an update of the xref view which should remove the declare warning relationships. However, it doesn\u0027t do this. This is because the xref view doesn\u0027t register that the last thing that was selected before it decided to uncheck \"link with editor\" was the aspect (coming from navigating to the line of the declare warning statement). It therefore thinks that the last thing that was selected was the package declaration. Consequently, when it comes to calculate whether anythings changed, it thinks that we\u0027ve selected something different and so doesn\u0027t update the view. When following these steps manually in a runtime workbench everything works as expected. Therefore I believe this is a timing issue with the xref visual test. I\u0027ve raised AJDT bug 131090 to cover this and to make the testcase more robust.\n\nAll this means that all tests are now passing :-)",
    "Wahey.....aspectj has been checked into the AJDT 1.3 branch. Therefore, closing this bug as fixed.",
    "what a monster... I do hope memory usage is better in Aj ;) thanks for persisting with this bug Helen. ",
    "it\u0027s a new record for most commented aspectj bug (or so I believe)!\n\nThanks Helen for perserving with this. The change in AjState that kicked all this off was only 5-10 lines of code!\n\nHere\u0027s hoping that AJDT is significantly improved after all this effort - it should certainly be noticeable.",
    "Created an attachment (id\u003d36053)\npatch containing tests which follow the AJDT test failures\n\nApply this patch to the tests project.\n\nI\u0027m really not sure why I couldn\u0027t write AJ tests which were failing in the same way as the AJDT ones when I last tried......I tried again this morning and succeeded without too much problem. Hmmm...it would have been much easier if I\u0027d managed to do that first time around.....Oh well :-(\n\nThis patch contains two tests which follow the two failing scenarios that were seen in AJDT. Firstly, the scenario which was mentioned when this bug was raised, and secondly the one mentioned in comment #6 and comment #7. The tests fail against a \u0027pre-any fixes for this bug\u0027 aspectj workspace and then behave exactly as the AJDT ones when the same steps are applied that are detailed in this bug."
  ],
  "commentCreationDates": [
    "2006-02-23T14:55:27+01:00",
    "2006-02-23T15:12:26+01:00",
    "2006-02-24T16:37:57+01:00",
    "2006-02-27T10:40:31+01:00",
    "2006-02-27T11:21:14+01:00",
    "2006-02-27T13:03:17+01:00",
    "2006-03-02T14:11:51+01:00",
    "2006-03-02T14:41:21+01:00",
    "2006-03-02T14:58:10+01:00",
    "2006-03-02T18:33:51+01:00",
    "2006-03-02T19:55:46+01:00",
    "2006-03-03T09:45:04+01:00",
    "2006-03-03T09:52:46+01:00",
    "2006-03-03T10:13:44+01:00",
    "2006-03-03T11:24:33+01:00",
    "2006-03-03T13:37:26+01:00",
    "2006-03-03T13:54:38+01:00",
    "2006-03-03T14:20:48+01:00",
    "2006-03-03T17:14:12+01:00",
    "2006-03-06T09:17:01+01:00",
    "2006-03-06T10:14:15+01:00",
    "2006-03-06T12:02:00+01:00",
    "2006-03-06T13:35:16+01:00",
    "2006-03-06T14:46:09+01:00",
    "2006-03-06T16:07:36+01:00",
    "2006-03-07T11:06:58+01:00",
    "2006-03-07T13:22:38+01:00",
    "2006-03-07T13:48:49+01:00",
    "2006-03-07T16:06:57+01:00",
    "2006-03-07T16:12:25+01:00",
    "2006-03-07T17:07:55+01:00",
    "2006-03-08T10:26:17+01:00",
    "2006-03-08T10:32:05+01:00",
    "2006-03-08T10:44:12+01:00",
    "2006-03-08T12:54:12+01:00",
    "2006-03-08T12:55:17+01:00",
    "2006-03-08T13:52:09+01:00",
    "2006-03-09T14:21:43+01:00",
    "2006-03-09T15:47:08+01:00",
    "2006-03-09T15:49:48+01:00",
    "2006-03-10T08:09:53+01:00",
    "2006-03-10T13:27:25+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.findReferenceContextFor",
          "source": "WeaverMessageHandler.java:188"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.handleMessage",
          "source": "WeaverMessageHandler.java:105"
        },
        {
          "method": "org.aspectj.weaver.Lint$Kind.signal",
          "source": "Lint.java:273"
        },
        {
          "method": "org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsForMissingType",
          "source": "WildTypePattern.java:817"
        },
        {
          "method": "org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFromFullyQualifiedTypeName",
          "source": "WildTypePattern.java:696"
        },
        {
          "method": "org.aspectj.weaver.patterns.WildTypePattern.resolveBindings",
          "source": "WildTypePattern.java:622"
        },
        {
          "method": "org.aspectj.weaver.patterns.SignaturePattern.resolveBindings",
          "source": "SignaturePattern.java:82"
        },
        {
          "method": "org.aspectj.weaver.patterns.KindedPointcut.resolveBindings",
          "source": "KindedPointcut.java:259"
        },
        {
          "method": "org.aspectj.weaver.patterns.Pointcut.resolve",
          "source": "Pointcut.java:194"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.finishResolveTypes",
          "source": "PointcutDesignator.java:84"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration.resolveStatements",
          "source": "PointcutDeclaration.java:209"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve",
          "source": "AbstractMethodDeclaration.java:400"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration.resolvePointcut",
          "source": "PointcutDeclaration.java:190"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations",
          "source": "AjLookupEnvironment.java:422"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings",
          "source": "AjLookupEnvironment.java:234"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile",
          "source": "Compiler.java:301"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:315"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation",
          "source": "AjBuildManager.java:843"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild",
          "source": "AjBuildManager.java:268"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild",
          "source": "AjBuildManager.java:170"
        },
        {
          "method": "org.aspectj.ajde.internal.CompilerAdapter.compile",
          "source": "CompilerAdapter.java:117"
        },
        {
          "method": "org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run",
          "source": "AspectJBuildManager.java:191"
        }
      ],
      "number": 0,
      "commentIndex": 31,
      "bugId": "129163",
      "date": "2006-03-08T10:26:17+01:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "129163",
  "bugId": "129163",
  "date": "2006-02-23T14:55:27+01:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}