{
  "comments": [
    "This enhancement is intended to make AspectJ expose join points for synchronized code and define the pointcuts that will match on these join points.  \n\nJonas has a nice blog article on the issues:\n\nhttp://jonasboner.com/2005/07/18/semantics-for-a-synchronized-block-join-point/\n\nCurrent thoughts for an implementation are:\n\n- transform synchronized methods to a method containing a synchronized block\n- pointcuts for monitorentry and monitorexit, exposing what-is-being-sync\u0027d on as context\n\nCurrent worries, please append more as you think of them:\n\n- transforming methods and \u0027removing\u0027 the synchronized flag alters the declared signature...\n- are their subtle JVM differences in how a JVM treats synchronized methods and methods containing synchronized blocks - I cant find any differences, but you never know.\n- can you use \u0027proceed\u0027 in an around advice to lock on a different object - is this good/bad...",
    "Another concern is to ensure that creating the necessary join points for synchronized methods does not affect matching by other pointcuts either during the same or subsequent weaving steps i.e. the following advice will be invoked from _within_ the expanded sychronization block not at the start and end of the method:\nafter () : execution(synchronized * *(..)) {}",
    "Created an attachment (id\u003d37732)\nShock horror, some design notes\n\nPulling together some thoughts on a possible design and the problems it raises...",
    "Slide comments:\n5. Additional potential use cases (that need consistent before lock() advice):\n   - Deadlock detection/avoidance\n   - Deadlock diagnosis\n10. Prefer lock() \u0026 unlock()\n12. As far as I can tell synchronized methods and blocks are semantically identical and must be matched as such if the identified use cases are to work. This means auto transformation is required perhaps only with a privileged aspects because method signatures can be modified). However the weaving of one aspect should never (correct me if I am wrong) affect whether pointcuts in another match, regardless of when the weaving takes place i.e. at the same time or separately.\n14. New slide for advice: before/after/after throwing\n\n",
    "Design discussion meeting minutes ;)\n\nFriday 7th April 05:\n\n(14:40:57) Adrian Colyer: 123759 yes?\n(14:41:46) Andy Clement: yes 123759\n(14:42:49) Adrian Colyer: oooh. funky template\n(14:45:30) Adrian Colyer: slide 10....\n(14:45:50) Adrian Colyer: I would have expected the lock object to be bound in args\n(14:46:00) Adrian Colyer: you have synchronized(obj)\n(14:46:07) Adrian Colyer: obj is like the argument to me\n(14:46:23) Adrian Colyer: and then this and target would both be the same as for an execution jp\n(14:46:23) Andy Clement: yes, I think you are right, that\u0027s a mistake\n(14:46:46) Andy Clement: i think i was worrying more about the other problems when I was writing it.\n(14:47:07) Adrian Colyer: on slides 8 and 9... where you say 2 exit join points. at runtime only one would ever occur right?\n(14:47:17) Adrian Colyer: it 2 *shadows* that have to be woven?\n(14:47:30) Andy Clement: yes, 2 exit join points - i think only one occurs\n(14:47:43) Andy Clement: 2 shadows to weave\n(14:48:10) Andy Clement: that was my biggest worry I think, seeing \u0027two matches\u0027 (not in the gutter but in the showweaveinfo) would be confusing\n(14:48:57) Adrian Colyer: for after returning we must have a potentially similar situation?\n(14:49:00) Andy Clement: i need to double check ... but if it was a finally block rather than an exception block, they might both execute.\n(14:49:29) Adrian Colyer: have a mismatched number of lock and unlock join points would be very confusing\n(14:49:33) Adrian Colyer: if it happens at runtime\n(14:49:47) Andy Clement: the JVM may consider it fine to unlock something already unlocked.\n(14:50:01) Andy Clement: i was surprised to see two monitorexits.\n(14:50:29) Adrian Colyer: I\u0027m very nervous about transformation\n(14:50:39) Adrian Colyer: I would leave that until a later iteration\n(14:51:18) Adrian Colyer: even though it\u0027s clearly desirable from a language perspective\n(14:51:31) Andy Clement: i am nervous about transformation too\n(14:51:59) Adrian Colyer: aha, you have that phasing anyway\n(14:52:07) Andy Clement: oh, i thought you\u0027d seen that ;)\n(14:52:21) Adrian Colyer: phase 1 looks fine as a -X option\n(14:52:42) Adrian Colyer: phase 2 needs some hard thought, and probably a 1.6 item because of the change in semantics\n(14:53:55) Adrian Colyer: moving advice from inside to outside of a lock is very serious\n(14:54:11) Andy Clement: i agree\n(14:55:10) Adrian Colyer: I think it is an aj-transformed method, then we still have to put execution advice inside the aj -generated sync block\n(14:55:39) Adrian Colyer: lock / unlock would be different join point kinds\n(14:55:43) Andy Clement: not impossible, but not trivial\n(14:55:46) Adrian Colyer: so you can never have execution \u0026\u0026 lock\n(14:56:02) Adrian Colyer: so therefore just lock and unlock would have the outside / inside semantics\n(14:56:30) Adrian Colyer: I really don\u0027t think we can do it unless execution semantics are preserved\n(14:56:38) Andy Clement: i think that is a reasonable limitation isnt it? monitor\u003cthing\u003e is a kinded PCD, so cant be used with the other kinded pointcuts.\n(14:56:50) Adrian Colyer: It\u0027s necessary\n(14:57:04) Adrian Colyer: you can do within etc.\n(14:57:07) Andy Clement: yes\n(14:57:13) Adrian Colyer: but not any other kinded jp\n(14:57:43) Adrian Colyer: then we can define the semantics of lock and unlock jps precisely (for both blocks and sync methods)\n(14:58:05) Adrian Colyer: and keep the semantics of execution as they are now\n(14:58:22) Adrian Colyer: more work on the implementation, but the only way that transformation can be acceptable i fear\n(14:58:37) Andy Clement: execution(synchronized * *(..)) would match these transformed things then?\n(14:58:47) Adrian Colyer: yes\n(14:58:50) Adrian Colyer: it would have to\n(14:59:13) Andy Clement: it\u0027ll need more than a few testcases...\n(14:59:22) Adrian Colyer: the synchronized bit is held as a modifier, and we already have modifier massaging code for some jps don\u0027t we?\n(14:59:30) Adrian Colyer: itd visibility and stuff\n(14:59:38) Andy Clement: yes kind of.\n(15:00:27) Adrian Colyer: it\u0027s a lot of effort for the \"debugging-my-locking\" use case\n(15:00:32) Adrian Colyer: is there another good one?\n(15:01:16) Andy Clement: another use case? monitoring-my-locking? ;)\n(15:01:34) Adrian Colyer: of course, silly m\n(15:01:35) Adrian Colyer: e\n(15:01:42) Adrian Colyer: we could trace-my-locking too\n(15:02:47) Adrian Colyer: after() returning : unlock(xxx) would have to be immediately after the monitorexit instruction\n(15:02:52) Adrian Colyer: why is that hard?\n(15:03:00) Andy Clement: which monitorexit instruction?\n(15:03:13) Adrian Colyer: both of them, if they both execute\n(15:03:33) Andy Clement: and so you get two weave info messages when all you had in the original source was one synchronized block.\n(15:04:35) Andy Clement: after() returning : execution() knows that all RETURNS from the method mean the same thing \u003d\u003e one showweaveinfo, advice stuffed in multiple places\n(15:04:36) Adrian Colyer: If we don\u0027t do that, we have to create an abstraction over the byte code, and weave against that abstraction, and I think that will get hard very quickly in non-trivial cases\n(15:04:55) Andy Clement: i agree, i dont want to get more complicated than necessary.\n(15:05:06) Adrian Colyer: so your only issue is actually managing the messages we put out???\n(15:05:15) Adrian Colyer: surely that can be done!\n(15:06:21) Andy Clement: As we cannot tell the monitorexits are from the same block - without analysis - we will think they are different and advise both. now in the gutter view of course its the same \u0027line\u0027 so you don\u0027t see multiple gutters, but you will see multiple messages.\n(15:06:49) Adrian Colyer: but we see multiple returns and advise both, but only give one message\n(15:07:07) Andy Clement: yes, because RETURNS are all the same from a method, they mean leave the method.\n(15:07:27) Andy Clement: i dont know if you have two monitors or one monitor in the synchronized case.\n(15:07:51) Andy Clement: so we can advise all RETURNS and just put out a message/gutter saying - yes done that.\n(15:08:03) Adrian Colyer: if the block can throw exceptions that can escape the block, I bet you get multiple\n(15:08:23) Adrian Colyer: or maybe it\u0027s arranged like finally\n(15:08:36) Adrian Colyer: but then we\u0027re depending on a particular compilers compilation strategy\n(15:08:41) Adrian Colyer: which isn\u0027t right\n(15:08:49) Adrian Colyer: so we have to allow for an arbitrary number\n(15:08:56) Andy Clement: i will dig a bit more on the spec to see if its written down.\n(15:09:15) Andy Clement: but i hope you can see why its causing me concerns :(\n(15:09:35) Adrian Colyer: it will certainly confuse a lot of users\n(15:10:09) Andy Clement: \u003cdirty hack\u003e if both monitorexits have the same line number entry then they are for the same block\u003c/dirtyhack\u003e ;)\n(15:10:44) Adrian Colyer: it\u0027s a bit analogous to building up Strings with + and then being surprised that there are join points for calls to StringBuffer / Builder\n(15:10:58) Adrian Colyer: the abstraction in the source code doesn\u0027t map quite so neatly to the bytecode in both cases\n(15:11:14) Adrian Colyer: but this one will happen more often and be more surprising I think\n(15:11:35) Adrian Colyer: \u003cdirty-hack/\u003e sounds like it would tackle a very large % the real-world cases\n(15:11:42) Andy Clement: well... i have to dash, thanks so much for going through the charts ... keep it rattling round your brains for a few days and let me know if you think of something elegant to solve it.\n(15:11:48) Andy Clement: i will rattle it round mine too.\n(15:12:00) Andy Clement: go walk the dog or something ;)",
    "It seems to me that the new lock() and unlock() pointcuts are a hybrid of call(), handler() and something else:\n-\tcall(): this() is bound to the currently executing object in a non-static method, target() is unbound (like a static method call) and args() is bound to the lock. You should also be able to use within() and withincode().\n-\thandler(): the pointcut should take the form ?lock/unlock(TypePat)? e.g. ?lock(HelloWorld+)? so that specific types or type hierarchies can be targeted, especially with synchronized methods as opposed to blocks, without expensive residue.\n-\tThe declaring type for the join point is tricky and perhaps should be java.lang.Object\n\nI very much doubt that monitorexit is called twice (see below for my analysis of the byte-code) because locks can be nested and a count is kept by the JVM. While monitorenter/exit be called separately in native code (http://java.sun.com/j2se/1.5.0/docs/guide/jni/spec/functions.html#wp5256) I strongly suspect that a strict FILO model is required in byte-code, something that is enforced by the synchronized() construct and if violated could cause a VerifyError (which we could check).\n\nUsing a simple HelloWorld example I got close to the bytecode generated for a synchronized block. It seems to take the form of a try/catch with the caught exception rethrown in a try/finally. \n\npublic class HelloWorld {\n\n\tpublic void println () throws Throwable {\n//\tpublic void println () {\n\t\tlock(this);\n\t\ttry {\n\t\t\tSystem.out.println(\"Hello World!\");\n\t\t\tif (Math.random() \u003c 1) throw new RuntimeException();\n\t\t\tunlock(this);\n\t\t}\n\t\tcatch (Throwable th) {\n\t\t\ttry {\n\t\t\t\tunlock(this);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthrow th;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static void lock (Object lock) {\n\t}\n\t\n\tprivate static void unlock (Object lock) {\n\t}\n\t\n\tpublic static void main(String[] args) throws Throwable {\n\t\tnew HelloWorld().println();\n\t}\n\n\tprivate Object that \u003d new String(\"that\");\n\t\n\tpublic void printlnMultiSynchronizedBlock () {\n\t\tsynchronized(this) {\n\t\t\tsynchronized (that) {\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tSystem.out.println(\"Hello World!\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nAs you can see the real fun comes with trying to match monitorenter/exit for nested sycnchronized() blocks. The Aspect shows how lock/unlock() is similar to call():\n\npublic aspect Aspect {\n\n\tprivate pointcut lock (Object lock) :\n//\t\tlock(Object)\n\t\tcall(private void lock(Object)) \n\t\t\u0026\u0026 args(lock);\n\t\n\tbefore (Object lock) : lock(lock) {\n\t\tSystem.out.println(\"Aspect.beforeLock() this\u003d\" + thisJoinPoint.getThis() + \", lock\u003d\" + lock);\n\t}\n\n\tprivate pointcut unlock (Object lock) :\n//\t\tunlock(Object)\n\t\tcall(private void unlock(Object))\n\t\t\u0026\u0026 args(lock);\n\t\n\tafter (Object lock) : unlock(lock) {\n\t\tSystem.out.println(\"Aspect.afterUnlock() this\u003d\" + thisJoinPoint.getThis() + \", lock\u003d\" + lock);\n\t}\n\t\n\tbefore (Object ex) : handler(Exception+) \u0026\u0026 args(ex) {\n\t\tSystem.out.println(\"Aspect.beforeHandler() this\u003d\" + thisJoinPoint.getThis() + \", target\u003d\" + thisJoinPoint.getTarget() + \", ex\u003d\" + ex  + \", sig\u003d\" + thisJoinPoint.getSignature() + \", type\u003d\" + thisJoinPoint.getSignature().getDeclaringType());\n\t}\n}\n\nWhen run it ensures unlock() is called and the caught exception propagated:\n\nAspect.beforeLock() this\u003dHelloWorld@276af2, lock\u003dHelloWorld@276af2\nHello World!\nAspect.afterUnlock() this\u003dHelloWorld@276af2, lock\u003dHelloWorld@276af2\nException in thread \"main\" java.lang.RuntimeException\n\tat HelloWorld.println(HelloWorld.java:19)\n\tat HelloWorld.main(HelloWorld.java:39)\n\nThe byte-code (without aspect) for println() looks like this:\n\npublic void println()   throws java.lang.Throwable;\n  Code:\n   0:\taload_0\n   1:\tinvokestatic\t#46; //Method lock:(Ljava/lang/Object;)V\n   4:\tgetstatic\t#31; //Field java/lang/System.out:Ljava/io/PrintStream;\n   7:\tldc\t#33; //String Hello World!\n   9:\tinvokevirtual\t#38; //Method java/io/PrintStream.println:(Ljava/lang/String;)V\n   12:\tinvokestatic\t#52; //Method java/lang/Math.random:()D\n   15:\tdconst_1\n   16:\tdcmpg\n   17:\tifge\t28\n   20:\tnew\t#54; //class java/lang/RuntimeException\n   23:\tdup\n   24:\tinvokespecial\t#55; //Method java/lang/RuntimeException.\"\u003cinit\u003e\":()V\n   27:\tathrow\n   28:\taload_0\n   29:\tinvokestatic\t#58; //Method unlock:(Ljava/lang/Object;)V\n   32:\tgoto\t46\n   35:\tastore_1\n   36:\taload_0\n   37:\tinvokestatic\t#58; //Method unlock:(Ljava/lang/Object;)V\n   40:\tgoto\t44\n   43:\tpop\n   44:\taload_1\n   45:\tathrow\n   46:\treturn\n  Exception table:\n   from   to  target type\n     4    35    35   Class java/lang/Throwable\n\n    36    43    43   any\n",
    "\u003e - call(): this() is bound to the currently executing object in a\n\u003e non-static method, target() is unbound (like a static method call) and args()\n\u003e is bound to the lock. You should also be able to use within() and withincode().\n\nYes.\n\n\u003e - handler(): the pointcut should take the form ?lock/unlock(TypePat)?\n\u003e e.g. ?lock(HelloWorld+)? so that specific types or type hierarchies can be\n\u003e targeted, especially with synchronized methods as opposed to blocks, without\n\u003e expensive residue.\n\nIt isn\u0027t quite the same so i can\u0027t do that - we know something about the exception being caught at a handler join point, so can support handler(TypePat) and reduce the residue.  For a monitorentry/exit, we know *nothing* about the argument to the call apart from that it is an \u0027Object\u0027.  The argument is on the stack.  So, you will have to rely on args() to pick it out (and the residue that comes with it).  So the forms will have to be \u0027lock()\u0027 and \u0027unlock()\u0027.\n\n\u003e - The declaring type for the join point is tricky and perhaps should be\njava.lang.Object\n\nyes, i think Object is probably safest\n\nHere is the progress so far this morning:\n\u003d\u003d\u003d\u003d8\u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// Exploring synchronization\n\naspect LockMonitor {\n\tlong locktimer \u003d 0;\n\tint iterations \u003d 0;\n\tObject currentObject \u003d null;\n\tlong activeTimer;\n\t\n\tbefore(Useful2 o ): lock() \u0026\u0026 args(o) {\n\t\tactiveTimer \u003d System.currentTimeMillis();\n\t\tcurrentObject \u003d o;\n\t}\n\t\n\tafter(Useful2 o ): unlock() \u0026\u0026 args(o) {\n\t\tif (o!\u003dcurrentObject) { \n\t\t\tthrow new RuntimeException(\"Unlocking on incorrect thing?!?\");\n\t\t}\n\t\tif (activeTimer!\u003d0) {\n\t\t\tlocktimer+\u003d(System.currentTimeMillis()-activeTimer);\n\t\t\titerations++;\n\t\t\tactiveTimer\u003d0;\n\t\t}\n\t}\n\t\n\tafter() returning: execution(* main(..)) {\n\t\tSystem.err.println(\"Average time spent with lock over \"+iterations+\" iterations is \"+\n\t\t\t\t(((double)locktimer)/\n\t\t\t\t ((double)iterations))+\"ms\");\n\t}\n}\n\npublic class Useful2 {\n\tpublic static void main(String[] args) {\n\t\tUseful2 u \u003d new Useful2();\n\t\t\n\t\tfor (int i \u003d 0; i \u003c 20; i++) {\n\t\t\tu.methodWithSynchronizedBlock();\n\t\t}\n\t}\n\t\n\tpublic void methodWithSynchronizedBlock() {\n\t\tsynchronized (this) {\n\t\t\tfor (int ii\u003d0;ii\u003c1000000;ii++);\n\t\t}\n\t}\n\n}\n\u003d\u003d\u003d\u003d\u003d8\u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nCompiling:\n\nweaveinfo Join point \u0027method-execution(void Useful2.main(java.lang.String[]))\u0027 in Type \u0027Useful2\u0027 (Useful2.java:33) advised by afterReturning advice from \u0027LockMonitor\u0027 (Useful2.java:25)\nweaveinfo Join point \u0027monitor-enter(void java.lang.Object.monitorenter(java.lang.Object))\u0027 in Type \u0027Useful2\u0027 (Useful2.java:42) advised by before advice from \u0027LockMonitor\u0027 (Useful2.java:9) [with runtime test]\nweaveinfo Join point \u0027monitor-exit(void java.lang.Object.monitorexit(java.lang.Object))\u0027 in Type \u0027Useful2\u0027 (Useful2.java:42) advised by after advice from \u0027LockMonitor\u0027 (Useful2.java:14) [with runtime test]\nweaveinfo Join point \u0027monitor-exit(void java.lang.Object.monitorexit(java.lang.Object))\u0027 in Type \u0027Useful2\u0027 (Useful2.java:42) advised by after advice from \u0027LockMonitor\u0027 (Useful2.java:14) [with runtime test]\n\nThe two weave info messages for exit as expected.  Confusing because they both give the same line number.  I guess my dirtyhack to suppress messages for the same source line could solve this (when debug is turned on... which is likely to be the usual case).\n\nWhen run:\n\n\"Average time spent with lock over 20 iterations is 38.05ms\"\n\nI\u0027m not happy about the signature in the joinpoint though:\n\nmonitor-enter(void java.lang.Object.monitorenter(java.lang.Object))\n\nyuck - other options? maybe:\n\nmonitor-enter(java.lang.Object)",
    "or maybe it should be\n\nlock(java.lang.Object) \n\nand\n\nunlock(java.lang.Object)",
    "\u003e\u003e - handler(): the pointcut should take the form ?lock/unlock(TypePat)?\n\u003e\u003e e.g. ?lock(HelloWorld+)? so that specific types or type hierarchies can be\n\u003e\u003e targeted, especially with synchronized methods as opposed to blocks, without\n\u003e\u003e expensive residue.\n\n\u003eIt isn\u0027t quite the same so i can\u0027t do that - we know something about the\n\u003eexception being caught at a handler join point, so can support \n\u003ehandle(TypePat) and reduce the residue.  For a monitorentry/exit, we know \n\u003e*nothing* about the argument to the call apart from that it is an \u0027Object\u0027.  \n\u003eThe argument is on the stack.  So, you will have to rely on args() to pick it \n\u003eout (and the residue that comes with it).  So the forms will have to be \n\u003e\u0027lock()\u0027 and \u0027unlock()\u0027.\n\nYou do for synchronized methods which is probably the most frequent case. With\nmy performance hat on I am concerned with the impact of an aspect that\nunecessarily advises every monitorenter/exit a code path I know to be very\nhighly optimized.\n\n\u003eor maybe it should be\n\n\u003elock(java.lang.Object) \n\n\u003eand\n\n\u003eunlock(java.lang.Object)\nI was about to say the same thing and we collided",
    "Interesting discovery, the line number entries for a synchronized block indicate that the monitorentry and monitorexit both occur on the line where the word \u0027synchronized () {\u0027 occurs.  Looks a little peculiar when expecting unlock() advice to occur (in terms of \u0027sourcelocation\u0027) on a line after the body of the block.  Here is a woven method showing it - the advice always works as expected, it just appears a little unusual when asking the joinpoint for its source location. \n\npublic void nonstaticM();\n  org.aspectj.weaver.MethodDeclarationLineNumber: length \u003d 0x8\n   00 00 00 10 00 00 01 48\n  Code:\n   Stack\u003d5, Locals\u003d2, Args_size\u003d1\n   0:   aload_0\n   1:   dup\n   2:   astore_1\n   3:   monitorenter\n   4:   getstatic       #23; //Field java/lang/System.err:Ljava/io/PrintStream;\n   7:   ldc     #25; //String non-static method running\n   9:   invokevirtual   #31; //Method java/io/PrintStream.println:(Ljava/lang/String;)V\n   12:  aload_1\n   13:  invokestatic    #48; //Method CombiningPCDs2.aspectOf:()LCombiningPCDs2;\n   16:  aload_0\n   17:  getstatic       #50; //Field ajc$tjp_0:Lorg/aspectj/lang/JoinPoint$StaticPart;\n   20:  invokevirtual   #54; //Method CombiningPCDs2.ajc$before$CombiningPCDs2$1$3c1deed3:(LCombiningPCDs2$Foo;Lorg/aspectj/lang/J\noinPoint$StaticPart;)V\n   23:  monitorexit\n   24:  goto    40\n   27:  aload_1\n   28:  invokestatic    #48; //Method CombiningPCDs2.aspectOf:()LCombiningPCDs2;\n   31:  aload_0\n   32:  getstatic       #57; //Field ajc$tjp_1:Lorg/aspectj/lang/JoinPoint$StaticPart;\n   35:  invokevirtual   #54; //Method CombiningPCDs2.ajc$before$CombiningPCDs2$1$3c1deed3:(LCombiningPCDs2$Foo;Lorg/aspectj/lang/J\noinPoint$StaticPart;)V\n   38:  monitorexit\n   39:  athrow\n   40:  return\n  Exception table:\n   from   to  target type\n     4    24    27   any\n    27    39    27   any\n  LocalVariableTable:\n   Start  Length  Slot  Name   Signature\n   0      41      0    this       LCombiningPCDs2$Foo;\n  LineNumberTable:\n   line 17: 0\n   line 18: 4\n   line 17: 12\n   line 20: 40",
    "\u003e You do for synchronized methods which is probably the most frequent case. With\n\u003e my performance hat on I am concerned with the impact of an aspect that\n\u003e unecessarily advises every monitorenter/exit a code path I know to be very\n\u003e highly optimized.\n\nI am kind of avoiding thinking about any of that transformation stuff at the moment - it will be a nightmare to get right - I just want the basics to work here with the new join points.  But I take your point - on my run it occurred to me that there are other simple optimizations (for some of the common cases), for example in a non-static method an aload_0 as the instruction before indicates (un)locking on \u0027this\u0027.\n\nA common pattern would seem to be combining it with \u0027withincode\u0027 when you can to limit the set of monitor calls you match on.",
    "WRT line numbers both the weaveInfo message and gutter annotation for the execution PCD relate to the source line containing the method declaration, regardless of whether before and/or after advice is used, and not the closing brace so the sitution for sychronized() is not unique.",
    "\u003eA common pattern would seem to be combining it with \u0027withincode\u0027 when you can\n\u003eto limit the set of monitor calls you match on.\nYou are right although the semantics of \"lock(Foo+)\" and \"lock() \u0026\u0026 within(Foo+)\" are different.\n\nI realize that you are concentrating on phase one but I am concerned we don\u0027t restrict ourselves when deciding on the form of the new PCDs.",
    "There are some problems with around() advice on these new join points.  it is far too easy to get \u0027IllegalMonitorStateException\u0027 using around advice\n\n(Exception means: \"Thrown to indicate that a thread has attempted to wait on an object\u0027s monitor or to notify other threads waiting on an object\u0027s monitor without owning the specified monitor.\")\n\nAnd this relates to something Sam Pullara said in Jonas\u0027 blog:\n\"JVMs will puke on them not being paired with the same method\"\n\nThe extraction of the MONITORENTER or MONITOREXIT instruction into a method which is then delegated to via proceed causes this problem.\n\nWith around advice on lock() - If you don\u0027t proceed in the advice then the code will run, missing the MONITORENTER call.  If you do put proceed in, you will fail IllegalMonitorState.\n\nWith around advice on unlock() - If you don\u0027t proceed in the advice then the program will hang.  If you do proceed the advice will loop continuously (I dont quite understand what is happening in this final case)\n\nThe only thing that works is around advice on lock \u0026 unlock without proceed in either - skipping all the MONITOR instructions.",
    "the restriction that the monitor calls need to be in the same method appears to be a SUN limitation.  The woven code works fine on an IBM vm (both 1.5) - I\u0027ve not tried other VMs.\n\nOn the transform:\n- matthew suggested a way to preserve execution() is by extracting the body of a synchronized method into some ajc$ method and making the original a forwarding method.  Ensure the execution() matches on the original.  this would avoid intricate manipulation of the body of the method to ensure the advice for execution is called in the right place relative to the monitor instructions that will replace the synchronized method.\n- removing the synchronized bit and stashing it away will potentially affect all signature matching, since we will have to check for a modifier match and then check wherever we have stashed this \u0027bit\u0027\n- presumably we only need transform synchronized methods if they are going to be matched by a lock() pointcut.  Doing it for everything could adversely affect performance since synchronized methods will be implemented more efficiently than monitor based code.  Keeping track of what we do/dont need to transform could be tricky.",
    "The jpsig for this is going to be a little ugly, similar to handler which is:\n\nexception-handler(void A.\u003ccatch\u003e(A$MyException))\n\nwe have\n\nlock(void java.lang.Object.\u003clock\u003e(java.lang.Object))\nunlock(void java.lang.Object.\u003cunlock\u003e(java.lang.Object))\n\nthe infrastructure (which I don\u0027t want to change right now...) wants a member signature in the parentheses, hence you see \u0027void A.\u003ccatch\u003e(A$MyException)\u0027 in the handler case.",
    "First bunch of code is all in - including quite a few tests.\n\nThe implementation is discussed in the file SynchronizationTests - in there you can see the tasks involved in implementing it and it lists the outstanding tasks that remain before it can be made a non -X option.  The critical ones are:\n\n- support around advice on these join points\n- ensure advice matching on method-execution against a synchronized method continues to execute within the lock rather than outside.\n\nFor these kinds of current limitation new messages have been added so users will *know* what is going on if they choose to play with -Xjoinpoints:synchronization",
    "Maybe I\u0027m missing something but I just finished reading the JCIP book and it says that future VMs can and will do funky things with monitors, like handle them differently for contended/uncontended cases, change their scope or remove them completely when they are not needed. How will this affect the joinpoint execution model?\n",
    "Being a -X option means we have put it out there for people to try -\nit may get promoted to being a core part of AspectJ, it may not -\ndepending on the feedback we get.  (Similarly, we have also added the\noption for -Xjoinpoints:arrayconstruction).  Some of the problems and\nrestrictions we have in the current implementation (like comment #13\nwith around advice - which is only a problem on some VMs and not\nothers) may prove too much and we\u0027ll drop this feature.\n\nIt may be that some of the other concerns you raise will also cause us\nto rethink what we do in this space - so if you have more information\nplease provide it.  We can\u0027t keep on top of every \u0027aspect\u0027 of the VM\nso to some degree rely on our users to supply information...",
    "WRT Comment #17 I have not read the book (I assume it\u0027s this one http://www.javaconcurrencyinpractice.com/) but what you refer to probably concerns the actually implementation of a monitor which already varies considerably from one JVM to another. The AspectJ feature discribed in this report relies on the JVM specification. The join point(s) which the new pointcut matches are determined by that specification.\n\nAs the implementation of Java concurrency evolves, like the introduction of java.util.concurrent, then we will have to evolve AspectJ.",
    "(In reply to comment #17)\n\u003e Maybe I\u0027m missing something but I just finished reading the JCIP book and it\n\u003e says that future VMs can and will do funky things with monitors, like handle\n\u003e them differently for contended/uncontended cases, change their scope or remove\n\u003e them completely when they are not needed. How will this affect the joinpoint\n\u003e execution model?\n\nI think in his book Brian was referring to actual memory model and optimizations taken by hot spot JVM. Stuff ajc does just let you to hook up to the logical place where lock is being defined (monitorenter/monitorexit opcodes). So, even physical lock is skipped by JVM, advice on logical lock will be called, which is not necessary a bad thing.\n\nBy the way, I wonder what kind of practical use cases AspectJ was considering when implementing this feature?\n\n",
    "Yes, you make some valid points there.  It could mean we will have to clarify the difference for end users in our doc: for example, just because their advice is called won\u0027t necessarily mean the VM is taking a lock.\n\nSome examples of usage are in the powerpoint slides attached to this bug.\n\n?time taken to acquire the lock?\n  requires either:\n    before and after the lock taken\n    around the lock being taken\n?time spent with the lock (ownership)?\n   Advice after it is taken and advice before/after it is released\n?change lock implementation?\n   Maybe to switch to distributed locks of some kind\n   around advice on lock(), unlock()",
    "I\u0027ve been looki ng trough slides and would like to make some remarks in regards to synchronized methods. One of the slides says that it is complicated to do the full implementation for synchronized methods. \n\nSuch conclusion is probably based on BCEL experience, since it should be rather trivial to introduce new try/finally block for the whole method body using ASM. \n\nAnother option (widely used by AW) is to rename existing method and create new non-syncronized method that would have code for all the advices (including around, etc) and will call renamed method appropriately. This option is probably easier to implement with BCEL.",
    "\u003e Such conclusion is probably based on BCEL experience, since it should be\n\u003e rather trivial to introduce new try/finally block for the whole method body\n\u003e using ASM. \n\nthis was with respect to managing the ordering of all the entries in the exception table.  it is not hard to add a simple finally block, but it is hard to add in and not adversely disturb the rest of the exception table because AspectJ itself currently provides minimal support for prioritizing exceptions appropriately - so we don\u0027t mess with that table if we don\u0027t have to (there are numerous bugs over the years related to making mistakes in that table) - AspectJ needs an overhaul in this area.  My statement was not related to the mechanism used to manipulate the bytecode.\n\n\u003e Another option (widely used by AW) is to rename existing method and create new\n\u003e non-syncronized method that would have code for all the advices (including\n\u003e around, etc) and will call renamed method appropriately. This option is\n\u003e probably easier to implement with BCEL.\n\nof course - but that will have larger ramifications through AJ, in terms of making sure join points in the existing method look like they occurred in the scope of the original method (that\u0027s what the user would expect) and being careful for any new joinpoints we introduce into the new forwarding method.  Hence, we haven\u0027t done that right now because I was in a hurry - when I have more time I may investigate this option - possibly depends what we decide to do for the around advice problem.",
    "Hi all.\n\nI have a quick question about the current -X implementation of this pointcut in ajc. What syntax did you finally decide on? Is it \"lock(x)\" or \"lock() \u0026\u0026 args(x)\"? Also, are any values bound to this/target/args? Do you allow around advice on those pointcuts? (I know, it could work but it probably does not make sense very often to do this in an unstructured manner.)\n\nI am just asking because I implemented monitorenter/exit pointcuts in abc a couple of weeks ago and before I release them I want to make sure that the syntax and semantics are in sync with your\u0027s. ",
    "Hi all.\n\nMatthew and I had some discussion on the aspectj-users list recently about this warning message that ajc generates:\n\nadvice matching the synchronized method shadow \u0027method-execution(void MonitorAjc$Test.foo())\u0027 will be executed outside the lock rather than inside (compiler limitation)\n\nApparently this only happens when -Xjoinpoints:synchronization is enabled. Matthew  mentioned in his posting that ajc apparently in this case restructures methods of the form...\n\nsynchronized void foo() {}\n\n... to methods of the form ...\n\nvoid foo() {\n    synchronized(this){}\n} \n\n... which then leads to the fact that when using an advice \"before(): execution(synchronized * *.*(..)) ...\" code is woven *before* the synchronized block, which then in turn leads to the warning.\n\nSo what I don\u0027t understand about this behavior is: Why do you need this restructuring at all? I guess, right now, this is done to capture locks that are taken when entering synchronized methods but those locks can always be exposed the following way:\n\nbefore(Object o):\n        execution(synchronized * *.*(..)) \u0026\u0026 this(o) \u0026\u0026 scope() {\n        //locked o\n}\n\nafter(Object o):\n        execution(synchronized * *.*(..)) \u0026\u0026 this(o) \u0026\u0026 scope() {\n        //locked o\n}\n\nSo why should lock(*) capture synchronized method executions at all? I think it should only match monitorenter statements, not more.",
    "(In reply to comment #25)\n\u003e So why should lock(*) capture synchronized method executions at all? I think it\n\u003e should only match monitorenter statements, not more.\n\nPlease read the design notes. Remember that\n\n\tprivate synchronized void println1 () {\n\t\tSystem.out.println(\"Hello World!\");\n\t}\n\nand\n \n\tprivate void println2 () {\n\t\tsynchronized(this) {\n\t\t\tSystem.out.println(\"Hello World!\");\n\t\t}\n\t}\n\nare semantically identical. If we don\u0027t match synchronized methods (which have an implicit monitor_enter/exit) then most of the requirements for this enhancement would not be met.",
    "(In reply to comment #26)\n\u003e Please read the design notes. Remember that\n\u003e \n\u003e         private synchronized void println1 () {\n\u003e                 System.out.println(\"Hello World!\");\n\u003e         }\n\u003e \n\u003e and\n\u003e \n\u003e         private void println2 () {\n\u003e                 synchronized(this) {\n\u003e                         System.out.println(\"Hello World!\");\n\u003e                 }\n\u003e         }\n\nAh, ok that explains where this comes from... Yet, I don\u0027t agree with the way this is currently implemented. You can compare this situation quite a bit with the following one:\n\nYou have a pointcut execution(* *(..)) and then this code:\n\nvoid foo() {\n  doSomething();\n}\n\ncompared to:\n\nvoid foo() {\n  bar(); \n}\n\nprivate void bar() {\n  doSomething();\n}\n\nIn the former case, the pointcut would match at two shadows in the latter at three, although the codes are functionally equivalent. All this to say that AspectJ never cared about functional equivalence. AspectJ matching was always defined in term of structure. Hence, I don\u0027t think it\u0027s a good thing to now break with that rule for synchronization pointcuts. I would instead just rely on programmers being capable of writing two pointcuts, one capturing calls of synchronized methods and one capturing synchronized blocks. That way there would be no need no more for any magic in the backend and also the problem of non-synchronized advice execution would go away.",
    "\u003e Ah, ok that explains where this comes from... Yet, I don\u0027t agree with the way\n\u003e this is currently implemented. You can compare this situation quite a bit with\n\u003e the following one:\n\u003e You have a pointcut execution(* *(..)) and then this code:\n\u003e void foo() {\n\u003e   doSomething();\n\u003e }\n\u003e compared to:\n\u003e void foo() {\n\u003e   bar(); \n\u003e }\n\u003e private void bar() {\n\u003e   doSomething();\n\u003e }\n\u003e In the former case, the pointcut would match at two shadows in the latter at\n\u003e three, although the codes are functionally equivalent. All this to say that\n\u003e AspectJ never cared about functional equivalence. AspectJ matching was always\n\u003e defined in term of structure. Hence, I don\u0027t think it\u0027s a good thing to now\n\u003e break with that rule for synchronization pointcuts. I would instead just rely\n\u003e on programmers being capable of writing two pointcuts, one capturing calls of\n\u003e synchronized methods and one capturing synchronized blocks. That way there\n\u003e would be no need no more for any magic in the backend and also the problem of\n\u003e non-synchronized advice execution would go away.\n\nNo, that is an incorrect analogy. Pointcuts match join points (not shadows which are woven to facilitate advice). The lock() and unlock() pointcuts select the event where the monitor associated with an object is acquired and released respectively regardless of how it is implemented either by the programmer or the JVM. Why should AspectJ match synchronized blocks but not methods? How would you implement the use case examples provided if you only matched a (small) subset of the join points?\n\n\u003eAspectJ matching was always defined in term of structure.\nNo, it is defined in terms of events.\n\n\u003eI would instead just rely\n\u003eon programmers being capable of writing two pointcuts, one capturing calls of\n\u003esynchronized methods and one capturing synchronized blocks.\nPlease read the design documentation. You _cannot_ reliably weave a synchronized method without the transformation because you may not be able to weave the method call join point shadow. Besides as a programmer if I write \"lock()\" I expect AspectJ to match all the joint points no matter how tricky that might be not \"part of this problem is left to the reader\"!",
    "(In reply to comment #28)\n\u003e How\n\u003e would you implement the use case examples provided if you only matched a\n\u003e (small) subset of the join points?\nYou can always use the execution pointcuts to match on synchronized method executions. So you could definitely implement all use cases with lock/unlock only matching on synchronized *blocks*.\n\n\u003e Please read the design documentation. You _cannot_ reliably weave a\n\u003e synchronized method without the transformation because you may not be able to\n\u003e weave the method call join point shadow. Besides as a programmer if I write\n\u003e \"lock()\" I expect AspectJ to match all the joint points no matter how tricky\n\u003e that might be not \"part of this problem is left to the reader\"!\n\nBut then ajc should rather rewrite the pointcut instead of the base code, I believe. An advice of the form...\n\nbefore(Foo f): lock(f) { ...\n\n... should be interpreted internally as ...\n\nbefore(Foo f): monitorenter(f) || execution(* *.(..)) \u0026\u0026 this(f) { ...\n\n(where monitorenter(f) only matches synchronized blocks, not method executions). That way there would no need for restructuring IMHO.\n\nEric",
    "(In reply to comment #29)\n\u003e before(Foo f): monitorenter(f) || execution(* *.(..)) \u0026\u0026 this(f) { ...\n\nThere I actually meant:\n\nbefore(Foo f): monitorenter(f) || execution(synchronized * *.(..)) \u0026\u0026 this(f) { ...",
    "Please tell me how \"before() : lock()\" is equivalent to \"before() : execution(synchronized ...)\". In the former the advice is called __before__ monitorenter while in the latter it is called __after__. This is because the JVM takes the object lock (read design notes pretty please) __before__ entering the body of the method. As an AspectJ programmer if I write \"before() : lock()\" I mean __before__!",
    "(In reply to comment #31)\n\u003e In the former the advice is called __before__\n\u003e monitorenter while in the latter it is called __after__. \n\nAh, I think that\u0027s the crucial point I was missing. Thanks for the clarification. Ok, now I agree with you.",
    "The 1.5.3 implementation of this experimental feature is providing \"0\" as the line number (thisJoinPointStaticPart.getSourceLocation()) for all synchronized methods, the blocks appear to return the correct line number.\n\nFor example I get:\n\n- com.surelogic.dynamic.test.IntrinsicLocking@f0d7b0 at IntrinsicLocking.java:0\n- java.lang.Object@9319f9 at IntrinsicLocking.java:22\n\nfor a call to the method (within a class called IntrinsicLocking.java):\n\n21  synchronized void lock() {\n22    synchronized (lock) {\n23      System.out.println(\"lock()\");\n24    }\n25  }",
    "We (the abc group) are currently looking into the problem of avoiding the restructuring of synchronized methods that\u0027s currently necessary at the moment, for the following reasons:\n\n1.) it leads to advice code induced by execution-joinpoints being executed outside the lock (ajc at the moment gives a warning in those cases)\n2.) we saw benchmarks that run about 10% slower only because synchronized methods were replaced by monitorenter/exit statements\n\nWe do have an implementation scheme that would avoid generating monitorenter/exit statements and hence would yield better performance. Also, this would be capable of consistently executing the advice code for execution-joinpoints inside the lock. *However* it would forbid the use of around-advice in combination lock/unlock pointcuts.\n\nThe synchronized method foo()...\n\nsynchronized void foo() {\n  //body\n}\n\n... would be replaced by:\n\npublic void foo() {\n  //(1)\n  original$foo(); //(2)\n  //(3)\n}\n\nprivate synchronized void original$foo() {\n  //(4)\n  //original method body\n  //(5)\n}\n\nThis has the following implications:\n\n* we would not need to introduce any monitorenter/exit statements\n  which means we would presumably get better performance\n* we could weave advice code before monitorenter, this would go to location (1)\n* we could weave advice code after monitorexit, this would go to location (3)\n* we could weave advice code after monitorenter, this would go to location (4)\n* we could weave advice code before monitorexit, this would go to location (5)\n* code matching on the original method via execution-pointcuts would have to be\n  woven within original$foo() instead of foo()\n\nSo my question is whether anybody does actually have a compelling use case for around advice on those joinpoints. To me it does not make sense to just blindly remove synchronization so this might not be a good use case. Omitting a monitorenter but not the matching monitorexit would be an error anyway, equally the other way around. Proceeding *more* than once also seems to make no sense and proceeding exactly once can always be implemented via before/after.\n\nSo maybe it would make sense to just not allow messing around with \"around\", if that buys us a more efficient and consistent solution?"
  ],
  "commentCreationDates": [
    "2006-01-13T14:19:45+01:00",
    "2006-01-13T14:58:02+01:00",
    "2006-04-05T16:12:55+02:00",
    "2006-04-10T16:59:44+02:00",
    "2006-04-10T19:25:07+02:00",
    "2006-04-11T12:52:28+02:00",
    "2006-04-11T13:36:54+02:00",
    "2006-04-11T14:58:59+02:00",
    "2006-04-11T15:11:03+02:00",
    "2006-04-11T15:44:53+02:00",
    "2006-04-11T15:50:23+02:00",
    "2006-04-11T16:04:54+02:00",
    "2006-04-11T16:12:54+02:00",
    "2006-04-12T10:00:50+02:00",
    "2006-04-12T15:55:19+02:00",
    "2006-04-19T18:30:37+02:00",
    "2006-06-08T14:00:14+02:00",
    "2006-07-12T18:48:50+02:00",
    "2006-07-13T09:51:23+02:00",
    "2006-07-13T10:24:37+02:00",
    "2006-07-13T16:02:12+02:00",
    "2006-07-13T16:18:29+02:00",
    "2006-07-18T18:41:46+02:00",
    "2006-07-18T19:03:54+02:00",
    "2007-03-03T14:57:13+01:00",
    "2007-04-04T18:32:52+02:00",
    "2007-04-10T13:19:28+02:00",
    "2007-04-10T15:02:19+02:00",
    "2007-04-10T16:38:21+02:00",
    "2007-04-10T16:49:05+02:00",
    "2007-04-10T16:50:29+02:00",
    "2007-04-10T17:14:19+02:00",
    "2007-04-10T17:18:24+02:00",
    "2007-04-18T23:45:01+02:00",
    "2007-05-18T22:15:33+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.RuntimeException",
      "elements": [
        {
          "method": "HelloWorld.println",
          "source": "HelloWorld.java:19"
        },
        {
          "method": "HelloWorld.main",
          "source": "HelloWorld.java:39"
        }
      ],
      "number": 0,
      "commentIndex": 5,
      "bugId": "123759",
      "date": "2006-04-11T12:52:28+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "enhancement"
    }
  ],
  "groupId": "123759",
  "bugId": "123759",
  "date": "2006-01-13T14:19:45+01:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "enhancement"
}