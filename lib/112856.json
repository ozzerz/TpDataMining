{
  "comments": [
    "At present, bundle com.acme can contribute extensions only to its own namespace \n(i.e. qualified names of all of its extension points will be \"com.acme.ABC\"). \nWhile this is generally seems to be a good practice, this behavior is likely \ntoo restrictive in the long run.\n\nThe specific use case in which this became a problem for me was the \"old\" \nbundle that was split into several \"new\" bundles. To maintain backward \ncompatibility, however, all extensions points had to be left in the \"old\" \nbundle - even as they clearly should be declared now by other newly created \nbundles.\n\nI think it would be nice to remove this restriction.",
    "For eRCP we would like to have a smaller org.eclipse.ui plugin that has \nfewer graphics and only a subset of extension points. However, producing a \nplugin with the same symbolic name but different content does not seem \nlike a good practice since the two plugins could potentially be confused. \nThe problem is that Extension Points are known by their \"plugin symbolic \nname\" + \"extension name\". Thus, Extensions Points can not be provided by \nanother plugin and still be found.",
    "\u0026ltextension-point  /\u0026gt",
    "Oops, sorry about that - literally lost my internet service for a bit.  \u0027Meant to post:\n\nIt seems to me that the resolution of this issue is to create a means to gracefully decouple the implicit dependency between an extension-point name and the plugin name.  I.E. right now, the \u0027fully-qualified\u0027 name of an extension point is derived using the declaring plugin id.   If anything, that seems only necessary as a developer convenience.\n\nOne solution to me seems to be to modify the schema for \u003cextension-point\u003e slightly.  I can think of three options:\n\n1) Add an optional attribute that indicates that the id attribute is fully-qualified already.  Example:\n    \u003cextension-point id\u003d\"com.acme.coolpoint\" fully-qualified\u003d\"true\" ... /\u003e\n\n2) Add an optional attribute that allows you to specify the namespace qualifier seperately.  If not specified, uses the declaring plugin id.  Example:\n    \u003cextension-point id\u003d\"coolpoint\" namespace\u003d\"com.acme\" ... /\u003e\n\n3) Allow a different attribute for specifying the id that is always interpreted as fully-qualified.   Example:\n    \u003cextension-point symbolic-name\u003d\"com.acme.coolpoint\" ..../\u003e\n\nNone of these should break existing stuff.   Personnally, I prefer options (2) or (3).\n\nTo fully address all the issues, it would also be a good thing to start to allow specifying an optional version and match rule attributes in the \u003cextension-point\u003e as well as in the \u003cextension\u003e declarations. ",
    "alternatively, we can just remove the restriction that the id attribute be a simple identifier.  We currently have checks that look to see if there are \u0027.\u0027s and spank you if you do.  Relaxing that should be close to sufficient.",
    "But would just relaxing that constraint result in a fully-qualified specification independent of the declaring plugin?  Or would that just result in a fully-qualified ID of \"\u003cplugin id\u003e.\u003cmy.id.with.dots\u003e\" ?\n\nWould you just make it implicit that \u0027if there are periods in the id, then assume it is fully-qualified\u0027 ?   I don\u0027t personally like implicit behavior like that very much.  I would much prefer an explicit model.",
    "To me, it seems that Jeff\u0027s approach fits better in the picture we have today.\n\nThere is already an instance where we add namespace to the \"simple\" name if it doesn\u0027t have dots (if extension doesn\u0027t provide qualified name for the extension point, the current namespace is added).\n\nMore importantly, IExtensionPoint has methods getSimpleIdentifier() and getUniqueIdentifier() that internally presume that SimpleId is the portion of the UniqueId after the last \".\" which contradicts suggestion (1).\n\nInternally, we only store UniqueID so there is no advantage to explicitly separating namespace portion of the Id from the \"simple\" Id (suggestion (2)) - only UniqueID is necessary, but not the way it was formed.\n\nLet me rewrite the Jeff\u0027s suggestion in a more specific manner:\n\n- if extension point ID has no \".\", it is assumed that it implicitly belongs the namespace of the provider\n- if extension point ID has \".\", the portion after the last \".\" is assumed to be a \"simple\" ID and the rest is the namespace\n\nThis change should fit will into existing functionality. Logically, at present only \"simple\" ID can be specified (and it should not contain dots). With this change implemented, it will be possible to specify either a \"fully qualified\" ID - should you decide to do it.\n\nNote, however, that Javadoc for the APIs IExtensionPoint.getSimpleIdentifier() and IExtensionPoint.getUniqueIdentifier() would have to be modified as scope of uniqueness conditions on IDs will be slightly altered (not affecting any practical use cases).\n\n",
    "regarding comment #6\n\n]More importantly, IExtensionPoint has methods getSimpleIdentifier() and\n]getUniqueIdentifier() that internally presume that SimpleId is the portion of\n]the UniqueId after the last \".\" which contradicts suggestion (1).\n\nI understand that this is what it is doing.  But that behavior is purely in the implementation (\"internally presume\") and is not explicitely part of the API.  Functionally, there is no reason that the simple name could not be stored internally separate of the namespace.  If it was, that would remove the arbitrariness of the use of the last \".\" to define the simple name.  And if it was, that would not change the api behavior right now in any way.\n\nI am mainly advocating that api\u0027s should have an explicit, parametrically complete form, even if you also allow forms that result in implicit, default behaviors.  Implicit behavior is just plain bad and always bites folks that depend on it.\n\nThe only thing that is impacted by my suggestion above is that the \u0027getSimpleIdentifier()\u0027 would need to be implemented differently internally (by storing the simple identifier separate of the namespace) _OR_ explicitely defined as only returning the portion of the fully-qualified name to the right of the last \".\" (even if that is not the complete simple name).\n\nNote that from a performance viewpoint, storing the namespace and the simple identifier separately does not really take up more memory, especially if you intern() (pool) the namespace string (in which case it should take less).\n",
    "Regarding comment #7:\n\nThe \"Implicit behavior is just plain bad\" is quite a strong statement. In fact, \"implicit behavior\" is the way we (humans) think and how pretty much all things are done. What was the last time you specified how CPU registers are used in the a \u003d b + c ? When you are asked to pick up some milk on the way home, is you reaction an example of implicit behavior?\n\n(And I hope we are differentiating here the \"implicit\" and \"undocumented\" behavior.)\n",
    "your are right - it was a strong statement.  Probably stronger than I meant.  To be more specific, I believe API signatures should be as explicit as possible.  Yes they should be documented. But even documented behavior should avoid being dependent on contextual nuances that aren\u0027t readily specifiable in the parameters.  Yes, it is a useful programming convenience to povide an overload that defaults one or more parameters to their most common values, but it should always be possible to express them explicitely and completely.  Obviously, I\u0027m not saying you have to break things all the way down to discrete bits in the signature.  That would be silly.  I don\u0027t want to get into a big philosophical debate here, though.  I\u0027m just expressing my opinion that explicit, parametrically complete signatures are a good thing.\n\n",
    "Just to be clear, the registry API purely reflects the content of XML markup.  The nature of that markup is defined in the schema for the plugin manifest file.  See http://help.eclipse.org/help31/topic/org.eclipse.platform.doc.isv/reference/misc/plugin_manifest.html\nIn there the id attribute is clearly and explicitly specified to \n\"id - simple id token, unique within this plug-in. The token cannot contain dot (.) or whitespace. \"\n\ngetSimpleIdentifier() is a straigth accessor to the id attribute (from the point of view of the user).  getUniqueIdentifier() is a helper function that concatenates the two (from the user point of view).  The intenal implementation details are not exposed so the id maybe one or many strings.\n\nThere does not seem to be any usecase for allowing the result of getSimpleIdentifier() to return a string that includes \u0027.\u0027.  As such, we have two similar options for solving the problem at hand.\n   \u003cextnesion id\u003d\"org.example.foo\" \u003e\nor \n   \u003cextension id\u003d\"foo\" namespace\u003d\"org.example\"\u003e\n\nI don;t feel particularly strong about one or the other.\n\nDefining the simple id of the element as unambiguously the last element of the potentially dotted id string is bascially equivalent to relative paths in java.io.File.  This is widely understood and accepted.\n\nHaving said that, that apporach may be slightly more prone to misuse where people needlessly spec the fully qualified value in the \"id\" attribute and then plugin renaming etc is harder.  The (weak) premise here is that people are less likely to spec an additional attribute.\n\nNow, having said that, the id\u003d\"org.example.foo\" approach would be easier for us to implement and the tooling may well just need to have some checks removed.\n\nWe should consult with Wassim to see how this kind of change would affect PDE.",
    "I like the story outlined in comment 6 and then repeated in comment 10.  No new attributes are necessary.\n\nComment 10 however has typos in it.  The \u003cextension\u003e elements should be \u003cextension-point\u003e elements.\n\nOnce the fully-qualified id approach is implemented, PDE would have to modify its validation of extension points.\n\nRight now, we slap you with a warning if the id contains a dot.  \nWe will relax it so that if there is a dot,\nwe split the id into two tokens:\n1. everything up until the last dot is assumed to be a plug-in id.  We would flag it if it denotes a non-existing plug-in\n2. everything from the last dot until the dot must be a simple id as per the plugin.dtd.\n\nIncidentally, extension point search will have to modified also to account for the new format.",
    "actaully I meant \u003cextension\u003e elements.  I was just incomplete wrt the point attribute etc.  In any event, both \u003cextension\u003e and \u003cextension-point\u003e elements have id attributes that are affected by this change.",
    "Uncle.  I can live with this solution.  \u0027Not what I\u0027d call ideal, and I don\u0027t really understand what barriers might be in the way of doing it the way I suggested.  However, I am more interested in there being any sort of solution than arguing over the api semantics.  However arbitrary it might be, I can live without periods in my simple identifiers.  :-)\n\n",
    "re: comment#11\nYou wrote:\n\n] 1. everything up until the last dot is assumed to be a plug-in id.  We would\n] flag it if it denotes a non-existing plug-in\n\nShouldn\u0027t this be:\n\n1. everything up until the last dot is assumed to the extension-registry namespace identifier.  This may or may not match an existing plugin id.\n\nIn other words, remove the requirement that the namespace corresponds to an existing plugin id.  To force this to match an existing plugin id would defeat the purpose of this enhancement request.  In other words, it should be possible to publish extension points and consume extensions to those points without having to be tied to specific plugins being present in the runtime.\n\n",
    "re comment 14.\n\nWhat you are suggesting requires less work for PDE, which I certainly don\u0027t mind.\n\nBut what if you have a typo in the plug-in id?  good luck trying to catch it with the naked eye.",
    "Well,  I guess that means that in your \u003cextension-point\u003e declaration you will have declared a distinct namespace.  :-)  This is only a problem when the \u003cextensions\u003e don\u0027t line-up because they might not have the same typo in their point\u003d\"\" declarations.  \n\nBut technically right now, couldn\u0027t the latter have typos in them so that they don\u0027t match a (correctly) declared point -\u003e How do we currently flag that error (Which in terms of N order, is more likely to occur.)?\n\nBoth situations really just mean one has to have appropriate diagnostic tools available such as easily being able to see in a runtime how many extension contributions there are for each extension-point or that an extension contribution is dangling because there is no matching extension-point.\n",
    "After some more discussion we decided to do it by using the approach proposed in the comments 4, 6, and 10.\n\nThe changes on the registry side should be available in a day or two. \n\nIn addition to the registry changes, some changes on the PDE side will be needed to make this capability fully available:\n\na) New extension point / new extension wizard - make a warning if the \"namespace\" portion of the Id is not in the workspace.\nb) plugin.xml editor - same as (a), would need a new warning\nc) [maybe later?] update registry view - it is going to show a view based on namespace rather than on contributor - may be we could have two views there (one view organized by bundles and another view organized by namespaces)?\n\nFrom my viewpoint, items (a) and (b) would be highly desirable; item (c) would be nice to have, but it can be added later.\n\nNote that in this approach (a) and (b) would present warnings, not errors if the referred bundle is not available in the workspace or target.\n\nLet me know if you\u0027d like me to create a separate enhancement request(s) for PDE portions.\n",
    "Thanks Oleg.  This all seems reasonable.  Once the runtime changes are in HEAD, please open separate bug reports against PDE.",
    "Created an attachment (id\u003d33511)\nPatch for the org.eclipse.equinox.registry and org.eclipse.core.tests.runtime\n\nThe patch allows registry to support namespace separation as described in the comments above. The fully qualified IDs are supported for extension points and extensions.\n\nOn a technical note, a new registry cache table is created and maintained to index registry contents by namespace to facilitate efficient retrieval from the registry. \n\nThe new table occupies about 6K of the disk space for Eclipse SDK. Performance for the \"-clean\" startup of the Eclipse SDK decreases by about 1% with this patch. Performance of the warm startup with \"Welcome\" screen remains unchanged. Performance of the warm startup with the registry viewer open remains unchanged as well.\n\nTwo new tests are added to the JUnits.\n",
    "The first thing to notice with this new support is that this scheme no guarantees the uniqueness of extension and extension-point across the registry (for example I can now define in a plug-in P1 an extension \"X\", and in a plugin P2 an extension named \"P1.x\").\nThis may also break the wrong but possible assumptions that some users could have  been making regarding the fact that the namespace of an extension / extension-point is the symbolic name of the bundle that contained the xml markup. So one question now is to know whether or not we need a getContributor() API on the registry objects?\n\nReviewing the code I discovered two bugs:\n- IConfigurationElement.getNamespace() returns the name of the entity that contained the XML. Instead it should return the namespace of the extension that contains it.\n- The recording of the delta for extension is not done against the correct namespace, nor is the value returned. See ExtensionRegistry.recordChange(XPT, EXT, kind). This particular case will have to be captured in a test case as it is too nasty.\n\nOther points:\n- Contribution.getNamespace() no longer has a meaning. We should remove it. At a first glance all calls seems to be discardable.\n- RegistryIndex as a classname is confusing.\n- See we gain anything in creating a common super-class to extension and extension point?\n- Is it possible to have the code that removes elements from the index of namespaces in symmetrical place to the code that deals with the add.\n- Make sure that there is no concurrent modification of the registry index / registry index children objects.\n- Need to see how big the namespace index grows on large configurations",
    "On the subject of getContributor(): this is the area that is not well exposed at present. Currently, it is expected that registry implementers would override RegistryStrategy and provide RegistryStrategy.getNamespace() which is actually expected to return a contributor name based on the contributor Id.\n\nProbably, it would be better to start explicitly exposing contributors and keeping a table of {ContributorId, ContributorName} around. We could create a public class RegistryContributor that would have the following public APIs:\n\nstatic RegistryContributor registerContributor(String id, String name)\nstatic boolean unregisterContributor(String id)\nstatic RegistryContributor findContributor(String id)\nString getName()\n\nIf we proceed with this change:\n- We could make RegistryContributor rather than ContributorId an argument for IExtensionRegistry#addContribution()\n- We can remove RegistryStrategy#getNamespace() \n- We provide more logical and complete picture to the non-OSGi users.\n\n(Notes: on the implementation side, we will need to add another registry cache table to store RegistryContributors; also, I\u0027d like to clean up the way contributorId and contributorNames are stored by registry elements).\n",
    "Regarding concerns expressed in the comment #20:\n\n1. No guarantees the uniqueness of extension and extension-point across the registry\n\nYes, that\u0027s true. I would like to add that, strictly speaking, that is the same situation that we have today - uniqueness of IDs for the extensions and extension points is implied, but never actually verified. Today you can create two extensions or extension points with the same IDs in a plugin.xml (if you so desire :-)). The behavior for extension point is that the last extension point is effectively pushes out the first extension point (or in more details: both extension points exist in the cache, but only the last one appears in the extension point table). For the extensions, both extensions would exist in the cache, but attempt to retrieve the extension by ID would result in the first extension returned.\n\nThis behavior (for better or for worse :-)) is not modified by this patch.\n\nThat said, the change proposed in this enhancement, promotes this situation form the rank of \"ridiculous\" to the rank of \"unwize\" :-) and, therefore, might be addressed. I would prefer not to bloat this patch (it is rather complicated as it is), but create a separate bug saying \"Provide checks and feedback to detect duplicate IDs of extensions and extension points\". \n\n2. Adding getContributor()\nYes, I agree that this is the logical step. - Details in the comment #21. As above, I would prefer to have a separate enhancement request and separate patch for this to avoid bloating the current patch.\n\n3. Bug in IConfigurationElement.getNamespace() \nYes, I will fix it.\n\n4. Bug in recording of the delta for extension \nActually, this is the way it works today. Listeners are expected to listen to the extension point namespace, not to the namespaces of the individual extensions.\n\n5. Contribution.getNamespace()  no longer has a meaning\nYes, I\u0027ll remove it\n\n6. RegistryIndex as a classname is confusing\nI could rename it to RegistryIndexElement (let me know if you have a better name in mind)\n\n7. Creating a common super-class to extension and extension point\nYes - in general, but I didn\u0027t want to include it in this patch (same goes for the Contribution cleanup). I\u0027d suggest doing it later as it won\u0027t affect APIs or behavior.\n\n8. No concurrent modification of the registry index / registry index children objects\nThat should be the case. Let me know if there is any specific place that causes concerns.\n\n9 Need to see how big the namespace index grows on large configurations\nIn a fairly large existing application the contribution table size is 27K or 0.8% of the cache size. The new namespace index table should be about the same size so, I\u0027d say, it is reasonably small. \n",
    "We had a discussion with Pascal around the getContributor() and I\u0027d like to capture some ideas from it (this superceeds proposal in the comment #20).\n\nFirst, why is it necessary to create getContributor() APIs. The existing IExtensionPoint, IExtension, and IConfigurationElement interfaces have \"getNamespace()\" method. However, from the API description and from the patterns it is used, the \"getNamespace()\" is mostly used to get a contributor for the registry element.\n\nWhile there was no difference between contributor name and namespace name in the past, once this patch is applied the two names become unrelated.\n\nThe immediate solution to this is to say that \"getNamespace()\" functions contiue to return contributor name and becomes deprecated. Instead, we introduce two new mathods: getContributor() and getNamespaceName(). \n\nHowever, now we need a way to get the contributor name (i.e. \"org.eclipse.runtime\") while, in fact, we store only the contributor ID in the cache (i.e. \"12\"). \n\nSo, we need a cache table that records pairs of {contributor id; contributor name}.\n\nMoreover, at this point of design, we might explicitly describe how to get a contributor (the present picture is certainly not clear).\n\nThere would be two ways to get a contributor:\n\n1. The getContributor() method on the IExtension/ IExtensionPoint/ IConfigurationElement would return RegistryContributor for that element. \n\nThe RegistryContributor would have a method \"getName()\" returning the contributor name (\"org.eclipse.runtime\"). \n\n2. IExtensionRegistry.findOrCreateContributor(Object) would register a contributor based on the Object passed in and the information supplied by the RegistryStrategy. Most likely, Object\u0027s package name will be used by the default registry implementation and Object\u0027s Bundle will be used by OSGi implementation.\n\nThe RegistryContributor will be used as an argument to the IExtensionRegistry.addContribution() replacing \"String contributorId\".\n\nWhile there still a few details to be ironed out (i.e. how to unregister contributor), this approach seems to make sense.\n\nTo recap, the plan is to create an explicit \"RegistryContributor\" object that could be obtained from abother registry object or from the registry itself; we will store a table of {contributor id, contributor name} in the cache; we will create new methods on the IExtension/ IExtensionPoint / IConfigurationElement explicitly providing namespace names and contributors; and we will adjust RegistryStrategy to provide a means of registering contributors.\n",
    "Created an attachment (id\u003d34445)\nPatch for the namespace separation\n\nThe patch updates the first patch and adds getContributor() and related functionality as described in the comments above. \n\nThe patch affects the following bundles:\norg.eclipse.core.contenttype\norg.eclipse.core.runtime\norg.eclipse.core.runtime.compatibility.registry\norg.eclipse.core.tests.runtime\norg.eclipse.equinox.preferences\norg.eclipse.equinox.registry\n\nThe nice thing is that changes in this patch finally provide us with an explanation for what is the registry contributor and where do we get it from. As a consequence, RegistryStrategy becomes more logical.\n",
    "Review:\nIConfigurationElement.getNamespaceName() is a very good name but might need some improvement \u003cg\u003e What about getRegistryNamespace()?\nWhy is IRegistryContribor not called IContributor\n\nIRegistryContributor:\n- Do not talk about the registry strategy in the doc. Clients are not supposed to know.\n- Is the relation getHostId() / getId() the same than bundle / fragment?\n   - if so, why is it exposed here?\n   - I think the distinction between host / fragment should not be made available on the registry contributor\n- RegistryContributor needs to be SPI since registrystrategies have to create it. If made SPI make it final.\n- Why does it not go into the cache with extension and extension points? It is the same kind of object.\n\n\nIExtensionRegistry\n- Do we want to have a way to not throw an exception if the contributorid can\u0027t be determined?\n- Do we want getcontributors() to allow people to find about all the contributors\n- Change getNamespaces() to return all the namespaces contributed\n- Do we want getExtensionPoints(contributor) and getExtensions(contributor). The question here is how much do we want to expose the contributors and not only show the registry namespace\n\nContribution\n- Don\u0027t declare a variable in the middle of a class (defaultNamespace)\n- Since newContributions / formerContributions contains the contributor ids. Do we still need the contributors table?\n\n\nExtensionParser\n- the variable named namespace is confusing\n\nTableReader\n- change the version of the cache\n\nIPluginDescriptor\n- What is returned by getExtension / getExtensionPoint? Should we fix it?\n",
    "+1 on \u0027getRegistryNamespace()\u0027 rather than \u0027getNamespaceName()\u0027  :-)",
    "Created an attachment (id\u003d34613)\nPatch for the namespace separation III\n\nThe updated patch that addresses concerns above. \n\nThe patch affects the following bundles:\norg.eclipse.core.contenttype\norg.eclipse.core.runtime\norg.eclipse.core.runtime.compatibility.registry\norg.eclipse.core.tests.runtime\norg.eclipse.equinox.preferences\norg.eclipse.equinox.registry\n\n",
    "The patch contains changes to the org.eclipse.test.registry project.\n\n1). does this project exist or is it new?\n2). are we allowed to create a project in this namespace or do we have to use org.eclipse.equinox.test.registry?\n",
    "Regarding comment # 28: sorry, my mistake. Those are the changes for the JUnits for the \"simple\" registry that currently reside in the local CVS. The JUnits will be added to the core runtime JUnits in the future. Please ignore those changes for now.",
    "Created an attachment (id\u003d34672)\nPatch for the namespace separation IV\n\nCreated patch that is the same as above plus addresses the following concerns:\n\n- getRegistryNamespace() sounds too broad. Perhaps relate this to the other get*Identifier methods.  Something like getIdentifierNamespace().  This fits nicely with the story told in the getUniqueIdentifier Javadoc (ie.., the unique identifier is the simple identifier plus the namespace).  That is, the namespace is the namespace of the identifier.\n\u003d\u003e renamed to getNamespaceIndetifier() to fit into existing getUniqueIdentifier() and getSimpleIdentifier().\n\n- the ContributorFactories should be API (rather than SPI no)?  Clients of add() have to use that\n\u003d\u003e made ContributorFactories a provisional APIs \n\n- ContributorFactory: is it actualy needed?  Seems like it wouldn\u0027t do anthing since all you get is the toString of the object.  Consider removing.  In any event, the Javadoc is too strong.  If we keep it, perhaps change is name to ContributorFactoryBasic or something so it does not appear to be a parent of any other contributor factory.  Is there a related strategy that would use tihs contributor factory?\n\u003d\u003e This might simplify a life of somebody who just warnt to use a simple registry (or add a contributor not based on an OSGi bundle to the Eclipse registry). Renamed to ContributorFactorySimple.\n\n\n- I\u0027m still unclear on the value of RegistryUtils.  Seems like the set and get could be on RegistryFactory and callers of the create could just call the constructor.\n\u003d\u003e Merged methods into the RegistryFactory, marked individual methods as provisional.\n\n- RegistryStrategy.createEE() takes a RegistryContributor rather than an IContributor.  Seems to only use it for error reporting.  Could this be IContributor.getName()?  The OSGi createEE() could use getName() as well as it is just looking up a bundle.\n\u003d\u003e Yes, I think we need this - IContributor provides only a name that might not be unique; while RegistryContributor has getId() that needs to be unique. The difference is probably not essential for the existig OSGi implementation, but makes much more sense in a general case.\n\n- RegistryContributor still has the notions of host and ids and names.  Do we still need this? I thought we were able to reduce down to just the name (or at most name and id).  Actually, should this class be part of the SPI?\n\u003d\u003e Yes and yes: the IContributor (API) has just a getName(), but RegistryContributor (SPI) has all four fields. Service providers might need to create RegistryContributors on their own. In general, we expose IContributor with limited functionality to everybody and RegistryContributor with more extended functionality to Service Providers.\n\n- RegistryIndexChildren : there is an EMPTY_ARRAY constant yet everwhere the code checks for null to indicate no children.  Why not just put the empty array in the children slot and remove all the null checks?  Note that unlinkChild does not handle the case where you remove the last child consistently.  This leaves an empty array in children.  \n- In linkChildren the if() condition (and the true/false code) should be flipped to be a positive test\n- in unlinkChildren() avoid the continue by testing for !\u003d -1\n\u003d\u003e Fixed\n\n- RegistyIndexElement and RegistryIndexChildren are not particularly compelling names.  \n\u003d\u003e Sorry, but that\u0027s the best I can think of. Any suggestions are welcome :-).\n",
    "Created an attachment (id\u003d34686)\nNamespace separation patch V\n\nSame patch as above but with updated copies of the IExtension and IExtensionPoint in the registry compatibility fragment - thanks DJ!\n\nThe patch affects the following bundles:\norg.eclipse.core.contenttype\norg.eclipse.core.runtime\norg.eclipse.core.runtime.compatibility.registry\norg.eclipse.core.tests.runtime\norg.eclipse.equinox.preferences\norg.eclipse.equinox.registry\n",
    "Created an attachment (id\u003d34733)\nLast namespace patch with some changes\n\nThe attached patch contains some changes (mostly renaming) that DJ and I have done. We have not released the code because of errors while running the tests.\nTo reproduce: remove the jobs tests from the AutomatedTests class and run.\nYou will get:\njunit.framework.AssertionFailedError\n\tat junit.framework.Assert.fail(Assert.java:47)\n\tat junit.framework.Assert.assertTrue(Assert.java:20)\n\tat junit.framework.Assert.assertNotNull(Assert.java:220)\n\tat junit.framework.Assert.assertNotNull(Assert.java:213)\n\tat org.eclipse.core.tests.internal.registry.ExtensionRegistryStaticTest.testExtensionPoint(ExtensionRegistryStaticTest.java:43)\n\tat org.eclipse.core.tests.internal.registry.ExtensionRegistryStaticTest.testBFromCache(ExtensionRegistryStaticTest.java:63)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)\n\tat org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:57)\n\tat org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)\n\tat org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:99)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:374)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:169)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:282)\n\tat org.eclipse.core.launcher.Main.run(Main.java:977)\n\tat org.eclipse.core.launcher.Main.main(Main.java:952)\n\n\nand \n\norg.osgi.framework.BundleException: Bundle \"NonSingleton\" version \"1.0.0\" has already been installed from: file:/D:/dev/runtime/org.eclipse.core.tests.runtime/Plugin_Testing/registry/testB/2/\n\tat org.eclipse.osgi.framework.internal.core.Framework.createAndVerifyBundle(Framework.java:557)\n\tat org.eclipse.osgi.framework.internal.core.Framework.installWorkerPrivileged(Framework.java:824)\n\tat org.eclipse.osgi.framework.internal.core.Framework$1.run(Framework.java:709)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat org.eclipse.osgi.framework.internal.core.Framework.installWorker(Framework.java:790)\n\tat org.eclipse.osgi.framework.internal.core.Framework.installBundle(Framework.java:704)\n\tat org.eclipse.osgi.framework.internal.core.BundleContextImpl.installBundle(BundleContextImpl.java:202)\n\tat org.eclipse.core.tests.harness.BundleTestingHelper.installBundle(BundleTestingHelper.java:45)\n\tat org.eclipse.core.tests.harness.BundleTestingHelper.installBundle(BundleTestingHelper.java:38)\n\tat org.eclipse.core.tests.internal.registry.ExtensionRegistryStaticTest.testNonSingletonBundle(ExtensionRegistryStaticTest.java:304)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)\n\tat org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:57)\n\tat org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)\n\tat org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:99)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:374)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:169)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:282)\n\tat org.eclipse.core.launcher.Main.run(Main.java:977)\n\tat org.eclipse.core.launcher.Main.main(Main.java:952)\n\n\n",
    "Created an attachment (id\u003d34735)\nupdate to the updated patch\n\nUpdated patch using the standard template to express experimental API.",
    "I just tried eclipse-SDK-I20060215-0800-win32.zip and I am getting those errors right away, without the patch applied. (Needed to comment out the Jobs tests for the errors to show up).\n",
    "It seems that we get the same test failures when runing against HEAD with the Jobs tests disabled. \n\nOleg and I have run the runtime tests several times (with the Jobs tests enabled) and we\u0027ve had not problems. I will open a new bug report for the test failures with jobs disabled.\n\nThe latest patch has been released to HEAD and tagged for the midnight build.",
    "The test failures were unrelated to this change. \nSee bug 128138.",
    "Important: \n\nAs of the Eclipse 3.2 M5a build, to use this new namespace support, you must increment the Eclipse version tag in your plugin or fragment xml to be 3.2.\n  \u003c?eclipse version\u003d\"3.2\"?\u003e\n\nSee bug 128866 for details.\n",
    "*** Bug 78952 has been marked as a duplicate of this bug. ***"
  ],
  "commentCreationDates": [
    "2005-10-17T22:15:41+02:00",
    "2005-11-29T21:33:34+01:00",
    "2005-12-09T19:22:19+01:00",
    "2005-12-12T16:44:57+01:00",
    "2005-12-12T22:43:00+01:00",
    "2005-12-13T14:16:18+01:00",
    "2006-01-12T17:07:07+01:00",
    "2006-01-12T17:33:32+01:00",
    "2006-01-12T19:20:59+01:00",
    "2006-01-12T22:20:12+01:00",
    "2006-01-13T04:36:32+01:00",
    "2006-01-13T04:57:18+01:00",
    "2006-01-13T05:06:25+01:00",
    "2006-01-13T17:31:35+01:00",
    "2006-01-16T18:38:46+01:00",
    "2006-01-16T22:34:49+01:00",
    "2006-01-17T14:15:41+01:00",
    "2006-01-23T22:51:22+01:00",
    "2006-01-23T23:52:24+01:00",
    "2006-01-24T14:57:26+01:00",
    "2006-01-26T04:01:49+01:00",
    "2006-02-05T19:41:37+01:00",
    "2006-02-06T16:48:09+01:00",
    "2006-02-06T20:49:18+01:00",
    "2006-02-09T20:30:01+01:00",
    "2006-02-10T15:59:28+01:00",
    "2006-02-10T18:02:49+01:00",
    "2006-02-13T21:03:31+01:00",
    "2006-02-14T14:47:32+01:00",
    "2006-02-14T14:53:18+01:00",
    "2006-02-14T15:40:01+01:00",
    "2006-02-14T16:51:50+01:00",
    "2006-02-15T01:48:06+01:00",
    "2006-02-15T02:22:37+01:00",
    "2006-02-15T23:03:17+01:00",
    "2006-02-16T02:14:54+01:00",
    "2006-02-23T16:42:45+01:00",
    "2006-02-23T16:43:47+01:00",
    "2006-11-21T19:08:30+01:00"
  ],
  "traces": [
    {
      "exceptionType": "junit.framework.AssertionFailedError",
      "elements": [
        {
          "method": "junit.framework.Assert.fail",
          "source": "Assert.java:47"
        },
        {
          "method": "junit.framework.Assert.assertTrue",
          "source": "Assert.java:20"
        },
        {
          "method": "junit.framework.Assert.assertNotNull",
          "source": "Assert.java:220"
        },
        {
          "method": "junit.framework.Assert.assertNotNull",
          "source": "Assert.java:213"
        },
        {
          "method": "org.eclipse.core.tests.internal.registry.ExtensionRegistryStaticTest.testExtensionPoint",
          "source": "ExtensionRegistryStaticTest.java:43"
        },
        {
          "method": "org.eclipse.core.tests.internal.registry.ExtensionRegistryStaticTest.testBFromCache",
          "source": "ExtensionRegistryStaticTest.java:63"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "junit.framework.TestCase.runTest",
          "source": "TestCase.java:154"
        },
        {
          "method": "junit.framework.TestCase.runBare",
          "source": "TestCase.java:127"
        },
        {
          "method": "junit.framework.TestResult$1.protect",
          "source": "TestResult.java:106"
        },
        {
          "method": "junit.framework.TestResult.runProtected",
          "source": "TestResult.java:124"
        },
        {
          "method": "junit.framework.TestResult.run",
          "source": "TestResult.java:109"
        },
        {
          "method": "junit.framework.TestCase.run",
          "source": "TestCase.java:118"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:478"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run",
          "source": "RemoteTestRunner.java:344"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main",
          "source": "RemotePluginTestRunner.java:57"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run",
          "source": "CoreTestApplication.java:24"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:99"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication",
          "source": "EclipseAppLauncher.java:92"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start",
          "source": "EclipseAppLauncher.java:68"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:374"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:169"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.core.launcher.Main.invokeFramework",
          "source": "Main.java:338"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:282"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:977"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:952"
        }
      ],
      "number": 0,
      "commentIndex": 32,
      "bugId": "112856",
      "date": "2006-02-15T01:48:06+01:00",
      "product": "Equinox",
      "component": "Bundles",
      "severity": "enhancement"
    },
    {
      "exceptionType": "org.osgi.framework.BundleException",
      "message": "Bundle \"NonSingleton\" version \"1.0.0\" has already been installed from: file:/D:/dev/runtime/org.eclipse.core.tests.runtime/Plugin_Testing/registry/testB/2/",
      "elements": [
        {
          "method": "org.eclipse.osgi.framework.internal.core.Framework.createAndVerifyBundle",
          "source": "Framework.java:557"
        },
        {
          "method": "org.eclipse.osgi.framework.internal.core.Framework.installWorkerPrivileged",
          "source": "Framework.java:824"
        },
        {
          "method": "org.eclipse.osgi.framework.internal.core.Framework$1.run",
          "source": "Framework.java:709"
        },
        {
          "method": "java.security.AccessController.doPrivileged",
          "source": "Native Method"
        },
        {
          "method": "org.eclipse.osgi.framework.internal.core.Framework.installWorker",
          "source": "Framework.java:790"
        },
        {
          "method": "org.eclipse.osgi.framework.internal.core.Framework.installBundle",
          "source": "Framework.java:704"
        },
        {
          "method": "org.eclipse.osgi.framework.internal.core.BundleContextImpl.installBundle",
          "source": "BundleContextImpl.java:202"
        },
        {
          "method": "org.eclipse.core.tests.harness.BundleTestingHelper.installBundle",
          "source": "BundleTestingHelper.java:45"
        },
        {
          "method": "org.eclipse.core.tests.harness.BundleTestingHelper.installBundle",
          "source": "BundleTestingHelper.java:38"
        },
        {
          "method": "org.eclipse.core.tests.internal.registry.ExtensionRegistryStaticTest.testNonSingletonBundle",
          "source": "ExtensionRegistryStaticTest.java:304"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "junit.framework.TestCase.runTest",
          "source": "TestCase.java:154"
        },
        {
          "method": "junit.framework.TestCase.runBare",
          "source": "TestCase.java:127"
        },
        {
          "method": "junit.framework.TestResult$1.protect",
          "source": "TestResult.java:106"
        },
        {
          "method": "junit.framework.TestResult.runProtected",
          "source": "TestResult.java:124"
        },
        {
          "method": "junit.framework.TestResult.run",
          "source": "TestResult.java:109"
        },
        {
          "method": "junit.framework.TestCase.run",
          "source": "TestCase.java:118"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:478"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run",
          "source": "RemoteTestRunner.java:344"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main",
          "source": "RemotePluginTestRunner.java:57"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run",
          "source": "CoreTestApplication.java:24"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:99"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication",
          "source": "EclipseAppLauncher.java:92"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start",
          "source": "EclipseAppLauncher.java:68"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:374"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:169"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.core.launcher.Main.invokeFramework",
          "source": "Main.java:338"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:282"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:977"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:952"
        }
      ],
      "number": 1,
      "commentIndex": 32,
      "bugId": "112856",
      "date": "2006-02-15T01:48:06+01:00",
      "product": "Equinox",
      "component": "Bundles",
      "severity": "enhancement"
    }
  ],
  "groupId": "112856",
  "bugId": "112856",
  "date": "2005-10-17T22:15:41+02:00",
  "product": "Equinox",
  "component": "Bundles",
  "severity": "enhancement"
}