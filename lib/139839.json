{
  "comments": [
    "I am seeing this on Windows XP with Eclipse 3.2 RC2.  If I pause at any\nbreakpoint in code, then terminate the application being debugged in the Debug\nwindow, then a blank editor window is opened in the workspace with red text\n\"Source not found\" and a button, \"Edit Source Lookup Path...\"\n\n\n!ENTRY org.eclipse.pde.ui 4 2 2006-05-01 17:36:23.937\n!MESSAGE Problems occurred when invoking code from plug-in:\n\"org.eclipse.pde.ui\".\n!STACK 1\norg.eclipse.debug.core.DebugException: com.sun.jdi.VMDisconnectedException: Got\nIOException from Virtual Machine occurred while retrieving value.\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIDebugElement.throwDebugException(JDIDebugElement.java:207)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIDebugElement.requestFailed(JDIDebugElement.java:162)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIDebugElement.targetRequestFailed(JDIDebugElement.java:147)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue(JDIVariable.java:69)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue(JDIVariable.java:89)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.getObject(PDESourceLookupQuery.java:114)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.findSourceElement(PDESourceLookupQuery.java:99)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.run(PDESourceLookupQuery.java:77)\n        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupDirector.getSourceElement(PDESourceLookupDirector.java:52)\n        at\norg.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility.lookup(SourceLookupFacility.java:147)\n        at\norg.eclipse.debug.ui.DebugUITools.lookupSource(DebugUITools.java:681)\n        at\norg.eclipse.debug.internal.ui.elements.adapters.StackFrameSourceDisplayAdapter$SourceLookupJob.run(StackFrameSourceDisplayAdapter.java:100)\n        at org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)\norg.eclipse.debug.core.DebugException[5010]:\ncom.sun.jdi.VMDisconnectedException: Got IOException from Virtual Machine\n        at\norg.eclipse.jdi.internal.connect.PacketSendManager.sendPacket(PacketSendManager.java:80)\n        at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:170)\n        at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:192)\n        at\norg.eclipse.jdi.internal.ObjectReferenceImpl.getValues(ObjectReferenceImpl.java:246)\n        at\norg.eclipse.jdi.internal.ObjectReferenceImpl.getValue(ObjectReferenceImpl.java:190)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIFieldVariable.retrieveValue(JDIFieldVariable.java:78)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue(JDIVariable.java:67)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue(JDIVariable.java:89)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.getObject(PDESourceLookupQuery.java:114)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.findSourceElement(PDESourceLookupQuery.java:99)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.run(PDESourceLookupQuery.java:77)\n        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupDirector.getSourceElement(PDESourceLookupDirector.java:52)\n        at\norg.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility.lookup(SourceLookupFacility.java:147)\n        at\norg.eclipse.debug.ui.DebugUITools.lookupSource(DebugUITools.java:681)\n        at\norg.eclipse.debug.internal.ui.elements.adapters.StackFrameSourceDisplayAdapter$SourceLookupJob.run(StackFrameSourceDisplayAdapter.java:100)\n        at org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)\n!SUBENTRY 1 org.eclipse.jdt.debug 4 5010 2006-05-01 17:36:23.937\n!MESSAGE com.sun.jdi.VMDisconnectedException: Got IOException from Virtual\nMachine occurred while retrieving value.\n!STACK 0\ncom.sun.jdi.VMDisconnectedException: Got IOException from Virtual Machine\n        at\norg.eclipse.jdi.internal.connect.PacketSendManager.sendPacket(PacketSendManager.java:80)\n        at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:170)\n        at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:192)\n        at\norg.eclipse.jdi.internal.ObjectReferenceImpl.getValues(ObjectReferenceImpl.java:246)\n        at\norg.eclipse.jdi.internal.ObjectReferenceImpl.getValue(ObjectReferenceImpl.java:190)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIFieldVariable.retrieveValue(JDIFieldVariable.java:78)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue(JDIVariable.java:67)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue(JDIVariable.java:89)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.getObject(PDESourceLookupQuery.java:114)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.findSourceElement(PDESourceLookupQuery.java:99)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.run(PDESourceLookupQuery.java:77)\n        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupDirector.getSourceElement(PDESourceLookupDirector.java:52)\n        at\norg.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility.lookup(SourceLookupFacility.java:147)\n        at\norg.eclipse.debug.ui.DebugUITools.lookupSource(DebugUITools.java:681)\n        at\norg.eclipse.debug.internal.ui.elements.adapters.StackFrameSourceDisplayAdapter$SourceLookupJob.run(StackFrameSourceDisplayAdapter.java:100)\n        at org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)\n!SUBENTRY 1 org.eclipse.jdt.debug 4 5010 2006-05-01 17:36:23.937\n!MESSAGE com.sun.jdi.VMDisconnectedException: Got IOException from Virtual\nMachine occurred while retrieving value.\n!STACK 0\ncom.sun.jdi.VMDisconnectedException: Got IOException from Virtual Machine\n        at\norg.eclipse.jdi.internal.connect.PacketSendManager.sendPacket(PacketSendManager.java:80)\n        at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:170)\n        at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:192)\n        at\norg.eclipse.jdi.internal.ObjectReferenceImpl.getValues(ObjectReferenceImpl.java:246)\n        at\norg.eclipse.jdi.internal.ObjectReferenceImpl.getValue(ObjectReferenceImpl.java:190)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIFieldVariable.retrieveValue(JDIFieldVariable.java:78)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue(JDIVariable.java:67)\n        at\norg.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue(JDIVariable.java:89)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.getObject(PDESourceLookupQuery.java:114)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.findSourceElement(PDESourceLookupQuery.java:99)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.run(PDESourceLookupQuery.java:77)\n        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n        at\norg.eclipse.pde.internal.ui.launcher.PDESourceLookupDirector.getSourceElement(PDESourceLookupDirector.java:52)\n        at\norg.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility.lookup(SourceLookupFacility.java:147)\n        at\norg.eclipse.debug.ui.DebugUITools.lookupSource(DebugUITools.java:681)\n        at\norg.eclipse.debug.internal.ui.elements.adapters.StackFrameSourceDisplayAdapter$SourceLookupJob.run(StackFrameSourceDisplayAdapter.java:100)\n        at org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)\n\nThis does not happen in Eclipse 3.1",
    "From bug 136731",
    "And again in RC3.  I\u0027m getting it pretty much everytime I set a breakpoint, and then Terminate the app.",
    "Will this one be fixed for Eclipse 3.2?  It seems quite important?\n\nPB",
    "Samantha, can you investigate this one. PDE could catch the \"disconnect\" exception, but I think the bug is that we\u0027re asking PDE to lookup source when we should not be (i.e. the program is terminated, and the debug context should be \"empty\").",
    "This bug is related to bug 139079.  The #preserveSelection call makes the viewer thinks that there is a selection changed.  As a result, it triggers a source lookup on a stack frame whose parent thread is already terminated.\n\nHowever, fixing bug 139079 would not fix this problem.  I tried removing #preserveSelection from #handleEvent but the problem was still there.  It turns out that when the debug session is terminated, it also triggers a number of node remove requests in the AsynchronousTreeModel.  The #remove method also preserves selection which causes source lookup to occur after the terminate.\n\nI searched for references to #preserveSelection, they are called from:\n* AsynchronousModel#setChildren\n* AsynchronousTreeModel#add\n* AsynchronousTreeModel#remove\n* AsynchronousTreeModel#setIsContainer\n\nIs #preserveSelection needed in all these places?  Why does #setIsContainer need to preserve selection as it is not likely to change the selection?\n\nIn addition, I am wondering if we could add a check in AsynchronousViewer#updateSelection.  This method simply remembers the selection and fire a selection changed event without checking if the new selection is valid in the viewer.  In the case when the debug session is terminated, the old selection should no longer be valid  (since the stackframe is already gone), in that case the viewer should not fire a selection changed event.  (But in the async world, we may not be able to determine if a selection is valid since it may not be mapped yet?)\n",
    "In \u0027AsynchronousViewer.restoreSelection(...)\u0027 we check the model to see if the \u0027selectionExists(...)\u0027. In this case, the model is claiming that the stack frame is still in the model (which is quite possible - it has not been cleaned up yet).\n\nAn alternate fix is to not perform source lookup for terminated frames.",
    "Created an attachment (id\u003d40780)\npatch\n\n",
    "Fixing in the source lookup adapter is a much smaller and localized changed.  So, it should be safer.\n\nBut I just want to clarify, the selection changed did not result from the #setSelection call after #selectionExists(...).\n\nInstead, in #restoreSelection, the viewer checks to see if the new selection is the same as the old selection.  If not, it calls #handleInvalidSelection which causes the selection changed event to be fired.  The reason why the new and old selections are different is because the JDIThread object from the tree path selection has changed.  Everything else was the same, i.e. the tree path selection points to the same stackframe, but it\u0027s parent thread object is different.\n\nMaybe we need to call #selectionExists before calling #handleInvalidSelection?  In this case, the new selection reported by the tree widget is no longer valid in the model. (Looks like the tree widget is reporting an \"old\" selection.  The model is already updated to not contain the stackframe, but the tree widget still thinks that it has the stackframe as the selection.)  ",
    "I saw this before - where the parent thread was wrong for the stack frame. I\u0027m not sure how that happens.",
    "I found out how the parent thread could be wrong.\n\nThe tree itemds widget were mapped like this:\n\nLaunch\n  Debug Target\n    \"Main\" Thread\n       Stackframe where the suspend happened\n    \"Signal Dispatch\" Thread\n    \"State Data Manager\" Thread\n    :\n    :\n\nWhen the debug session is terminated, the \"main\" thread is terminated first which triggers a remove model delta.  The model removes the corresponding node.  The viewer then did an internal update and preserve selection while doing so.  This preserve selection is ok since the selection has not really changed and this will not trigger a selection changed in the viewer.\n\nAs a result of the remove, the next thread becomes visible which triggers a setData event.  (In my case, this is the \"Signal Dispatch Thread\".)  The viewer is able to locate this node from the model and map the thread to the widget which was originally mapped to the \"main\" thread.  \n\nSo, the tree item widgets look like this now:\n\nLaunch\n  Target\n    Signal Dispatch Thread\n       Stackframe where the suspend happened\n    \"State Data Manager\" Thread\n    :\n    :\n\nNext, the \"Signal Dispatch\" thread is terminated and triggered another remove in the viewer.  When this remove event happened, the viewer would also try to preserve the selection.  \n\nThe \"old\" selection before the code is run is set as:\nLaunch, Target, \"Main\" Thread, Stackframe\n\nIn restore selection, when checking to see if the selection is restored correctly, the viewer gets the current selection from the widgets and build a path to it.  The new selection is:\nLaunch Target, \"Signal Dispatch\" Thread, Stackframe\n\nBecause the current seleciton is not the same as the old selection that it tries to preserve, the viewer calls #handleInvalidSelection which causes a selection changed event to happen.\n\nThe selection changed is for a stackframe which triggers a source lookup during terminate.\n\nQuestion:  When a remove happens and if the selection is removed, the viewer should clear the selection so that preserve selection does not trigger selection changed event unnecessarily?",
    "Please don\u0027t think I\u0027m being impatient as I can see that you are getting to the bottom of this, but do you think this bug will be fixed before the final release of 3.2? \n\n:-)\n\nMany thanks!\n\nPB\n",
    "Created an attachment (id\u003d41745)\npatch\n\nThis patch addresses two problems:\n\n(1) Source lookup should not be performed on terminated frames/threads. The patch does not schedule source lookup/display when a frame becomes terminated, and cancels pending source display job when a frame becomes terminated after lookup has started/completed and before display has begun.\n\n(2) The viewer should not send selection change events for selections that do not exist. I updated \u0027restoreSelection\u0027 in the base viewer and \u0027selectionExists\u0027 in the tree viewer. The tree viewer needs to specialize \u0027selectionExists\u0027 as it must verify the tree path is valid (not just that the element is in the model). When a selection is being restored, but the current widget selection does not exist, it is in a transisent state, and the selection should be \u0027empty\u0027.\n",
    "Marking as critical, as source lookup performed on terminated frames causes a memory leak. The frame ends up in the \u0027instruction pointer manager\u0027 and never gets removed, as the \u0027terminate event\u0027 has already been processed (never comes again to clear the frame). So, we need to cancel/avoid source lookup for terminated frames.\n\nSamantha, can you please verify the patch?\n\nMarking as RC5 candidate, as fixing the leak is critical.",
    "Created an attachment (id\u003d41768)\nenhanced patch \u0026 test\n\nThis patch improves on the previous:\n\n- avoids call to \u0027IStackFrame.isTerminated()\u0027 in UI thread by making the check in the source lookup job, rather than while scheduling the job\n- accounts for termination occurring while source display is running (so we check for cancellation before and after the source display job, and remove the instruction pointer if required)\n- cleans up the instruction pointer cache of targets that have no threads with pointers\n\n- adds a test to the suite to ensure no targets are leaked in the insturction pointer cache during the test suite (this was failing with a non-zero number before the patch, and now the test passes - i.e. 0 leaks).",
    "Risk assessment:\n\nThe fix is more than one line of code, but each change is simple and explainable. In its entirety, the fix addresses an important leak, and removes \u0027left overs\u0027 from the debug UI (instruction pointers and left over variables in the variables view when a target has termianted). The automated test helps assure us that the leak has been fixed.\n\nCC\u0027ing Philippe, Martin \u0026 Wassim for RC5 approval.",
    "(Samantha, please add your assessment of the latest patch, and testing results. Thanks).",
    "*  Verified that the exception and the source not found editor is no longer displayed.\n*  Verified that source lookup no longer happens when a debug target is terminated.\n* Verified that the instruction pointer manager leak is gone.\n* Verified that the viewer is firing out am \"empty selection\" when the tree selection is no longer valid in the model.  \n\nI am a bit concerned with firing out an empty selection when the tree selection is no longer valid.  \n\nWhen the viewer is in transient state, it fires empty selection changed event which causes the Variables View to flash when the Debug View is in transient state. \n\nI tried this testcase.  Put the breakpoint where indicated and when the debug session is suspended, just wait.  When threads from the top are terminated and removed, variables from the Variables View disappear.  I think it\u0027s a result of the empty selection in #restoreSelection.  Sometimes it flashes when the Variables View gets the correct context actived event.  \n\nI tried the same thing without the patch, and the Variables View did not flash as threads are removed from the top.\n\nThis affects debugging multi-threaded application as the user can no longer look at variables reliably as threads get removed.    \n\nNote, the Variables View does not flash if threads from below the suspended thread are removed.  In that case, it did not affect the tree path of the selection from the Debug View.\n\nTestcase:\n\tpublic static void main(String[] args) {\n\n\t\tfor (int i \u003d 0; i \u003c 200; i++) {\n\t\t\tnew Thread() {\n\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (Thread.currentThread().getName().endsWith(\"-150\") || Thread.currentThread().getName().endsWith(\"-24\"))\n// add a breakpoint on the following line\n\t\t\t\t\t\t\tThread.sleep(3000);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tThread.sleep(30000);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}.start();\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch (InterruptedException e) {}\n\t\t}\n\n\t}\n}",
    "Created an attachment (id\u003d41840)\npatch\n\nThanks Samantha. I made a slight modification to the patch:\n\n* when restoring selection, if the new \u0027widget\u0027 selection does not exist in the model, but the selection we are trying to restore still exists in the model, we pretend there was no selection change (because we\u0027re in a transisent state that\u0027s about to be fixed)\n* if neither the \u0027widget\u0027 selection or the previous (selection we\u0027re trying to restore) exist in the model, we change to an empty selection.\n\nThis avoids the flashing.",
    "+1 for 3.2RC5, a leak scenario is critical.",
    "Looked at the new patch.  The flashing is gone, but I encountered another problem.\n\nI modified the thread testcase so I am only stopping at Thread 24.\n\nThe problem is, if I am suspended at thread 24 and as threads from the top got removed, Thread 24 eventually disappears from the screen as it gets moved up.  When Thread 24 becomes hidden, the variables from the Variables View disappear too.\n\nThe Variables View got an empty selection changed event when the thread is hidden.  I traced it back to #restoreSelection where calling newSelectionFromWidget returns an empty selection.  \n\nBecause we don\u0027t check the selection if the current selection is empty, the empty selection gets through and a selection changed event is fired.\n\nI removed the empty selection check from \n\nif (!fCurrentSelection.isEmpty() \u0026\u0026 !selectionExists(fCurrentSelection)) {\n\nand it solved the problem.  So, what was the reason of doing an empty selection check here?  I am not sure if it\u0027s safe to remove this check.  What if the empty selection should really be the new selection?  We may be overriding it back to an old selection that the user is trying to get rid of.\n\nThanks...\nSamantha\n\npublic class TestManyThreads {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tfor (int i \u003d 0; i \u003c 200; i++) {\n\t\t\tnew Thread() {\n\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (Thread.currentThread().getName().endsWith(\"-24\"))\n\t\t\t\t\t\t\t// add a breakpoint on the following line\n\t\t\t\t\t\t\tThread.sleep(3000);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tThread.sleep(30000);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()\n\t\t\t\t\t\t\t+ \" done\");\n\t\t\t\t}\n\n\t\t\t}.start();\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\n\t}\n}",
    "Created an attachment (id\u003d41892)\npatch\n\nYour fix is correct, Samantha. In the case of an empty \u0027widget\u0027 selection, if the old selection still exists in the model, we should maintain it, otherwise, the selection will be set to the empty selection by our code anyway.\n\nUpdated patch.\n\nReady for votes from Martin and Wassim.",
    "+1",
    "+1",
    "happy with the latest patch... :)\nSam",
    "Applied patch.",
    "Way to go!\n\nNow that\u0027s what I call bug-fixing!\n\n:-)",
    "*** Bug 142539 has been marked as a duplicate of this bug. ***",
    "Verified in RC5"
  ],
  "commentCreationDates": [
    "2006-05-02T22:58:46+02:00",
    "2006-05-02T23:01:44+02:00",
    "2006-05-06T21:01:40+02:00",
    "2006-05-09T10:18:16+02:00",
    "2006-05-09T16:47:32+02:00",
    "2006-05-09T19:09:11+02:00",
    "2006-05-09T19:33:16+02:00",
    "2006-05-09T19:33:51+02:00",
    "2006-05-09T20:54:41+02:00",
    "2006-05-09T21:26:42+02:00",
    "2006-05-10T20:02:00+02:00",
    "2006-05-14T16:23:43+02:00",
    "2006-05-17T18:29:53+02:00",
    "2006-05-17T18:32:40+02:00",
    "2006-05-17T20:15:10+02:00",
    "2006-05-17T20:23:54+02:00",
    "2006-05-17T20:24:51+02:00",
    "2006-05-17T22:39:53+02:00",
    "2006-05-18T04:50:07+02:00",
    "2006-05-18T10:27:24+02:00",
    "2006-05-18T16:10:47+02:00",
    "2006-05-18T16:57:16+02:00",
    "2006-05-18T17:00:30+02:00",
    "2006-05-18T17:09:22+02:00",
    "2006-05-18T17:15:13+02:00",
    "2006-05-18T17:17:19+02:00",
    "2006-05-18T18:33:06+02:00",
    "2006-05-18T19:04:01+02:00",
    "2006-05-19T14:40:02+02:00"
  ],
  "traces": [
    {
      "exceptionType": "com.sun.jdi.VMDisconnectedException",
      "message": "Got IOException from Virtual Machine occurred while retrieving value.",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIDebugElement.throwDebugException",
          "source": "JDIDebugElement.java:207"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIDebugElement.requestFailed",
          "source": "JDIDebugElement.java:162"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIDebugElement.targetRequestFailed",
          "source": "JDIDebugElement.java:147"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue",
          "source": "JDIVariable.java:69"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue",
          "source": "JDIVariable.java:89"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.getObject",
          "source": "PDESourceLookupQuery.java:114"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.findSourceElement",
          "source": "PDESourceLookupQuery.java:99"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.run",
          "source": "PDESourceLookupQuery.java:77"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupDirector.getSourceElement",
          "source": "PDESourceLookupDirector.java:52"
        },
        {
          "method": "org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility.lookup",
          "source": "SourceLookupFacility.java:147"
        },
        {
          "method": "org.eclipse.debug.ui.DebugUITools.lookupSource",
          "source": "DebugUITools.java:681"
        },
        {
          "method": "org.eclipse.debug.internal.ui.elements.adapters.StackFrameSourceDisplayAdapter$SourceLookupJob.run",
          "source": "StackFrameSourceDisplayAdapter.java:100"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "139839",
      "date": "2006-05-02T22:58:46+02:00",
      "product": "Platform",
      "component": "Debug",
      "severity": "critical"
    },
    {
      "exceptionType": "com.sun.jdi.VMDisconnectedException",
      "message": "Got IOException from Virtual Machine",
      "elements": [
        {
          "method": "org.eclipse.jdi.internal.connect.PacketSendManager.sendPacket",
          "source": "PacketSendManager.java:80"
        },
        {
          "method": "org.eclipse.jdi.internal.MirrorImpl.requestVM",
          "source": "MirrorImpl.java:170"
        },
        {
          "method": "org.eclipse.jdi.internal.MirrorImpl.requestVM",
          "source": "MirrorImpl.java:192"
        },
        {
          "method": "org.eclipse.jdi.internal.ObjectReferenceImpl.getValues",
          "source": "ObjectReferenceImpl.java:246"
        },
        {
          "method": "org.eclipse.jdi.internal.ObjectReferenceImpl.getValue",
          "source": "ObjectReferenceImpl.java:190"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIFieldVariable.retrieveValue",
          "source": "JDIFieldVariable.java:78"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue",
          "source": "JDIVariable.java:67"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue",
          "source": "JDIVariable.java:89"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.getObject",
          "source": "PDESourceLookupQuery.java:114"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.findSourceElement",
          "source": "PDESourceLookupQuery.java:99"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.run",
          "source": "PDESourceLookupQuery.java:77"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupDirector.getSourceElement",
          "source": "PDESourceLookupDirector.java:52"
        },
        {
          "method": "org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility.lookup",
          "source": "SourceLookupFacility.java:147"
        },
        {
          "method": "org.eclipse.debug.ui.DebugUITools.lookupSource",
          "source": "DebugUITools.java:681"
        },
        {
          "method": "org.eclipse.debug.internal.ui.elements.adapters.StackFrameSourceDisplayAdapter$SourceLookupJob.run",
          "source": "StackFrameSourceDisplayAdapter.java:100"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 1,
      "commentIndex": 0,
      "bugId": "139839",
      "date": "2006-05-02T22:58:46+02:00",
      "product": "Platform",
      "component": "Debug",
      "severity": "critical"
    },
    {
      "exceptionType": "com.sun.jdi.VMDisconnectedException",
      "message": "Got IOException from Virtual Machine",
      "elements": [
        {
          "method": "org.eclipse.jdi.internal.connect.PacketSendManager.sendPacket",
          "source": "PacketSendManager.java:80"
        },
        {
          "method": "org.eclipse.jdi.internal.MirrorImpl.requestVM",
          "source": "MirrorImpl.java:170"
        },
        {
          "method": "org.eclipse.jdi.internal.MirrorImpl.requestVM",
          "source": "MirrorImpl.java:192"
        },
        {
          "method": "org.eclipse.jdi.internal.ObjectReferenceImpl.getValues",
          "source": "ObjectReferenceImpl.java:246"
        },
        {
          "method": "org.eclipse.jdi.internal.ObjectReferenceImpl.getValue",
          "source": "ObjectReferenceImpl.java:190"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIFieldVariable.retrieveValue",
          "source": "JDIFieldVariable.java:78"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue",
          "source": "JDIVariable.java:67"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue",
          "source": "JDIVariable.java:89"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.getObject",
          "source": "PDESourceLookupQuery.java:114"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.findSourceElement",
          "source": "PDESourceLookupQuery.java:99"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.run",
          "source": "PDESourceLookupQuery.java:77"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupDirector.getSourceElement",
          "source": "PDESourceLookupDirector.java:52"
        },
        {
          "method": "org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility.lookup",
          "source": "SourceLookupFacility.java:147"
        },
        {
          "method": "org.eclipse.debug.ui.DebugUITools.lookupSource",
          "source": "DebugUITools.java:681"
        },
        {
          "method": "org.eclipse.debug.internal.ui.elements.adapters.StackFrameSourceDisplayAdapter$SourceLookupJob.run",
          "source": "StackFrameSourceDisplayAdapter.java:100"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 2,
      "commentIndex": 0,
      "bugId": "139839",
      "date": "2006-05-02T22:58:46+02:00",
      "product": "Platform",
      "component": "Debug",
      "severity": "critical"
    },
    {
      "exceptionType": "com.sun.jdi.VMDisconnectedException",
      "message": "Got IOException from Virtual Machine",
      "elements": [
        {
          "method": "org.eclipse.jdi.internal.connect.PacketSendManager.sendPacket",
          "source": "PacketSendManager.java:80"
        },
        {
          "method": "org.eclipse.jdi.internal.MirrorImpl.requestVM",
          "source": "MirrorImpl.java:170"
        },
        {
          "method": "org.eclipse.jdi.internal.MirrorImpl.requestVM",
          "source": "MirrorImpl.java:192"
        },
        {
          "method": "org.eclipse.jdi.internal.ObjectReferenceImpl.getValues",
          "source": "ObjectReferenceImpl.java:246"
        },
        {
          "method": "org.eclipse.jdi.internal.ObjectReferenceImpl.getValue",
          "source": "ObjectReferenceImpl.java:190"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIFieldVariable.retrieveValue",
          "source": "JDIFieldVariable.java:78"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue",
          "source": "JDIVariable.java:67"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue",
          "source": "JDIVariable.java:89"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.getObject",
          "source": "PDESourceLookupQuery.java:114"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.findSourceElement",
          "source": "PDESourceLookupQuery.java:99"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupQuery.run",
          "source": "PDESourceLookupQuery.java:77"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.pde.internal.ui.launcher.PDESourceLookupDirector.getSourceElement",
          "source": "PDESourceLookupDirector.java:52"
        },
        {
          "method": "org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility.lookup",
          "source": "SourceLookupFacility.java:147"
        },
        {
          "method": "org.eclipse.debug.ui.DebugUITools.lookupSource",
          "source": "DebugUITools.java:681"
        },
        {
          "method": "org.eclipse.debug.internal.ui.elements.adapters.StackFrameSourceDisplayAdapter$SourceLookupJob.run",
          "source": "StackFrameSourceDisplayAdapter.java:100"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 3,
      "commentIndex": 0,
      "bugId": "139839",
      "date": "2006-05-02T22:58:46+02:00",
      "product": "Platform",
      "component": "Debug",
      "severity": "critical"
    }
  ],
  "groupId": "139839",
  "bugId": "139839",
  "date": "2006-05-02T22:58:46+02:00",
  "product": "Platform",
  "component": "Debug",
  "severity": "critical"
}