{
  "comments": [
    "When running JUnit, URL or HTTP Recording Tests with backward compatibility, the execution sometimes hangs at 93% (or 57%) and it never completes. Needs a restart of AC when this happens. Couldn\u0027t reproduce the pattern of this bug. When it hangs I don\u0027t see any java.exe processes still around though they start and go away. But if I cancel the test when it hangs, the final .execution result seems to be good. \nNOTE - Just for verification, I have used AC/BC for doing the New AC Test Pass1 results submissions and it worked well for 60% of the time and then started failing at 93% or 57% and I switched to IAC for submitting the rest of the results.",
    "Check if the fix for sending a termination notice to the client resolves this.  If not, investigate.",
    "I think this is related to bug 131236, and I expect the fix for that to resolve this as well.",
    "I\u0027m not clear whether this is still happening and if it is whether it is different from the same results appearing occasionally with the RAC.",
    "retargeting for consideration in 4.2.1.",
    "Kevin has been encountering this one - all artifacts are present and correct, yet the test doesn\u0027t complete.  Reassigning to him for 4.2.1 investigation.",
    "\nI have been looking into this bug and I had thought it was an error because I\nwas seeing the test execution hang at 93%.\n\nBut the problem I was seeing was due to the gui changing. It is now required to terminate the test execution inorder for the the execution to go to completion. By doing this I was unable to get a hang.",
    "I experience a hang at 93% for all but the most simple of JUnit tests.  \n\nThe following exception is generated if I try to stop the test via the Debug View:\n\norg.eclipse.hyades.execution.invocation.RemoteInvocationException\n\tat org.eclipse.hyades.execution.local.SessionImpl.invokeRemote(SessionImpl.java:107)\n\tat org.eclipse.hyades.execution.local.RemoteObjectStub.delegateRemoteCall(RemoteObjectStub.java:87)\n\tat org.eclipse.hyades.execution.local.ExecutorStub.kill(ExecutorStub.java:92)\n\tat org.eclipse.hyades.execution.local.ExecutorStub.kill(ExecutorStub.java:104)\n\tat org.eclipse.hyades.execution.harness.TestExecutionHarness.stopTest(TestExecutionHarness.java:2575)\n\tat org.eclipse.hyades.execution.harness.TestExecutionHarness.stopTest(TestExecutionHarness.java:2595)\n\tat org.eclipse.hyades.test.core.internal.launch.processes.TestExecutionProcess.terminate(TestExecutionProcess.java:138)\n\tat org.eclipse.debug.core.Launch.terminate(Launch.java:229)\n\tat org.eclipse.debug.internal.ui.actions.context.TerminateAdapter$3.run(TerminateAdapter.java:89)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)\nCaused by: org.eclipse.hyades.internal.execution.local.control.InactiveAgentException\n\tat org.eclipse.hyades.internal.execution.local.control.AgentImpl.invokeCustomCommand(AgentImpl.java:475)\n\tat org.eclipse.hyades.execution.local.SessionImpl.invokeRemote(SessionImpl.java:104)\n\t... 9 more\n\nIs there anything I can do or provide to help isolate and resolve this? ",
    "I\u0027ve re-opened the bug.\n\nJonathan - Are you using the 4.2 release build?  And can you provide a test case?",
    "On the newsgroup Jonathan said \"I\u0027m attempting to use TPTP 4.2 in conjunction with Eclipse 3.2\".\n\nFurther into the discussion on the 93% hang, Prince Singh said \"I solved the problem in linux by stopping the agent controller, the workbench also. Delete the file /tmp/IBMRAC/ramaster(for windows u\u0027ll need to check how it is done). TPTP\u0027s error reporting still needs some work, I guess.\"\n\nYet later in the discussion Bertrand Quenin said \"If you are working with processes and threads, make sure all of them are killed at the end of the test. I\u0027m experiencing TPTP testing for month now, and this kind of problem is almost always linked to \"survivor\" processes/threads.\"\n\nJust trying to bring the knowledge encapsulated there into the appropriate bugzilla.",
    "Karla,\n\nYes, I\u0027m using the 4.2 release build.  The installation was originally a beta, but I believe I\u0027ve been careful about ensuring all bits are updated appropriately and are in-sync with each other. \n\nBertrand made an interesting comment that I did some investigation into.  His observation is that lingering threads are problematic.  I know for a fact that my TestCase spawns multiple threads.  This has to do with the fact that I\u0027m attempting to write integration and acceptance tests for an engine that has a lot of framework (timers, worker threads, you name it).  I\u0027m in the process of trying to add hooks into all the various pieces that allow me to shut everything down.  I\u0027m just about there -- just one TimerService to go.  I\u0027ll post those results once I have them.\n\nOne thing I noticed when I remotely debug my test is that one of the blocked threads is named, \u0027DestroyJavaVM\u0027.  I did some looking into that and here\u0027s the description:\n\nUnloading the VM \n\nThe main thread cannot detach itself from the VM. Instead, it must call DestroyJavaVM() to unload the entire VM. \n\nThe VM waits until the main thread is the only user thread before it actually unloads. User threads include both Java threads and attached native threads. This restriction exists because a Java thread or attached native thread may be holding system resources, such as locks, windows, and so on. The VM cannot automatically free these resources. By restricting the main thread to be the only running thread when the VM is unloaded, the burden of releasing system resources held by arbitrary threads is on the programmer.\n\nHere\u0027s the link:\nhttp://java.sun.com/j2se/1.5.0/docs/guide/jni/spec/invocation.html\n\nThis is VERY preliminary and may not even be pertinent to how the AgentController works -- I haven\u0027t looked into how the JVM is launched.  I\u0027ll take a walk through the AgentController to verify the relevancy of this information.  Hopefully it\u0027s not a red herring.  \n\nCheers,\nJonathan\n\n",
    "Created an attachment (id\u003d47457)\nJUnit test case\n\n",
    "I attached a simple test case that can be used to reproduce the hang.  Nothing fancy; just create a thread and don\u0027t stop it.  The only thing noteworthy about it that may tie my investigation to the original bug report is that if the thread is set to be a daemon the remote JVM will exit.  The hang still occurs, but at least there is no longer has a stranded java executable that has to be killed.\n\nJonathan",
    "In my opinion, this behavior is correct and is absolutely not a bug from the TPTP framework.\n\nIndeed, if all processes/threads spawned by the JUnit test itself are cleaned at the end, the test ends gracefully. On the opposite, if there are remaining processes/threads spawned by the JUnit test at the end, the test hangs, waiting for these processes/threads to stop.\n\nFor me, it\u0027s absolutely correct, TPTP has NOT to clean remaining processes/threads spawned by the test, the tester HAS to. Moreover, TPTP must NOT garbage these remaining processes/threads, because the bug (remaining stuff is a bug) is on the tester side and this behavior has to be seen as a convenience feature that allows a tester to notice those \"zombies\".\n\n",
    "Bertrand,\n\n I\u0027m mostly in agreement with you.  Basically, it looks to me that everything is functioning as designed.  However, I think there are a couple of points to keep in mind that shouldn\u0027t be lost in the shuffle of \"works as advertised\":\n\n1.  The tester may have no knowledge of what is spawning the thread(s) and even if they did, they may not have the ability to shut them down.  The hang isn\u0027t limited to threads started directly by a unit test -- my sample works that way just to reproduce the problem in the most straightforward manner possible.  In reality, the component under test may reference [even indirectly] some third-party library that starts a thread for its own use. In the very best case scenario the tester would have to use a test decorator to implement a oneTimeTearDown method that can close shop once all tests are done.  The point I want to stress is that I think it\u0027s more likely there won\u0027t be a bug in the tester\u0027s code and in my experience it\u0027s the exception rather than the rule that an application provides an internal \u0027off-switch\u0027 to facilitate shutting down all but the primary thread.    \n\n2.  IMHO, one of the goals of TPTP should be to make the framework transparent.  In other words, the tests should execute the same regardless of if they\u0027re run directly in the IDE or via an ant task that\u0027s sending them to a server halfway across the world; if the test exits when executed locally, it should exit when executed remotely.  \n\nI think the last thing any sane developer would suggest is that forcefully shutting down threads at the conclusion of a suite is a viable alternative.  If there\u0027s a clean way for the framework to work around the issue that\u0027s great.  If not, at least we have an understanding of what one possible cause of a hang is.\n\nThanks for the suggestion on looking into the threads btw.\n\nJonathan",
    "(In reply to comment #14)\n\u003e Bertrand,\n\u003e  I\u0027m mostly in agreement with you.  Basically, it looks to me that everything\n\u003e is functioning as designed.  However, I think there are a couple of points to\n\u003e keep in mind that shouldn\u0027t be lost in the shuffle of \"works as advertised\":\n\u003e 1.  The tester may have no knowledge of what is spawning the thread(s) and even\n\u003e if they did, they may not have the ability to shut them down.  The hang isn\u0027t\n\u003e limited to threads started directly by a unit test -- my sample works that way\n\u003e just to reproduce the problem in the most straightforward manner possible.  In\n\u003e reality, the component under test may reference [even indirectly] some\n\u003e third-party library that starts a thread for its own use. In the very best case\n\u003e scenario the tester would have to use a test decorator to implement a\n\u003e oneTimeTearDown method that can close shop once all tests are done.  The point\n\u003e I want to stress is that I think it\u0027s more likely there won\u0027t be a bug in the\n\u003e tester\u0027s code and in my experience it\u0027s the exception rather than the rule that\n\u003e an application provides an internal \u0027off-switch\u0027 to facilitate shutting down\n\u003e all but the primary thread.    \n\u003e 2.  IMHO, one of the goals of TPTP should be to make the framework transparent.\n\u003e  In other words, the tests should execute the same regardless of if they\u0027re run\n\u003e directly in the IDE or via an ant task that\u0027s sending them to a server halfway\n\u003e across the world; if the test exits when executed locally, it should exit when\n\u003e executed remotely.  \n\u003e I think the last thing any sane developer would suggest is that forcefully\n\u003e shutting down threads at the conclusion of a suite is a viable alternative.  If\n\u003e there\u0027s a clean way for the framework to work around the issue that\u0027s great. \n\u003e If not, at least we have an understanding of what one possible cause of a hang\n\u003e is.\n\u003e Thanks for the suggestion on looking into the threads btw.\n\u003e Jonathan\n\nI think you make the exception the general rule. If you are working with threads and if those threads don\u0027t exit gracefuly, then implements your own \"kill them all\" procedure. (oneTimeTearDown is perfect for that thread\u0027o\u0027cide).\n\nPerhaps i\u0027ll surprise you, but i like to see when there are reaminings threads, and i appreciate this behavior for this. With remote debugging, it enables me to see which remaining threads i have, some are mines (testing engine) and some are SUT\u0027s ones (bugs).\n\nThe cleaner way to handle this is to check all remaining thread in your \"oneTimeTearDown\" and send an execution event (error, info, warning, choose the one you like) to the workbench, then, kill them all. It would be great to have this behavior optionnal.\n",
    "Lowering priority. Needs further investigation and we don\u0027t have the resource to put on it for 4.3.",
    "Retargeting to future as 4.3 is closing down to all non-essential bug fixing.",
    "Transferring ownership of new agemt controller issues with no specific target date to Mikhail for consideration in future releases."
  ],
  "commentCreationDates": [
    "2006-04-12T20:49:19+02:00",
    "2006-04-14T02:30:06+02:00",
    "2006-04-18T19:14:13+02:00",
    "2006-05-25T20:36:35+02:00",
    "2006-06-06T19:54:56+02:00",
    "2006-06-30T00:03:44+02:00",
    "2006-07-24T23:54:22+02:00",
    "2006-08-02T20:38:43+02:00",
    "2006-08-02T22:01:58+02:00",
    "2006-08-03T18:36:44+02:00",
    "2006-08-05T19:53:57+02:00",
    "2006-08-07T03:52:10+02:00",
    "2006-08-07T03:53:38+02:00",
    "2006-08-08T18:35:51+02:00",
    "2006-08-10T02:23:56+02:00",
    "2006-08-10T10:46:42+02:00",
    "2006-09-11T20:35:05+02:00",
    "2006-10-24T19:23:10+02:00",
    "2007-02-05T18:37:26+01:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.hyades.execution.invocation.RemoteInvocationException",
      "elements": [
        {
          "method": "org.eclipse.hyades.execution.local.SessionImpl.invokeRemote",
          "source": "SessionImpl.java:107"
        },
        {
          "method": "org.eclipse.hyades.execution.local.RemoteObjectStub.delegateRemoteCall",
          "source": "RemoteObjectStub.java:87"
        },
        {
          "method": "org.eclipse.hyades.execution.local.ExecutorStub.kill",
          "source": "ExecutorStub.java:92"
        },
        {
          "method": "org.eclipse.hyades.execution.local.ExecutorStub.kill",
          "source": "ExecutorStub.java:104"
        },
        {
          "method": "org.eclipse.hyades.execution.harness.TestExecutionHarness.stopTest",
          "source": "TestExecutionHarness.java:2575"
        },
        {
          "method": "org.eclipse.hyades.execution.harness.TestExecutionHarness.stopTest",
          "source": "TestExecutionHarness.java:2595"
        },
        {
          "method": "org.eclipse.hyades.test.core.internal.launch.processes.TestExecutionProcess.terminate",
          "source": "TestExecutionProcess.java:138"
        },
        {
          "method": "org.eclipse.debug.core.Launch.terminate",
          "source": "Launch.java:229"
        },
        {
          "method": "org.eclipse.debug.internal.ui.actions.context.TerminateAdapter$3.run",
          "source": "TerminateAdapter.java:89"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "causedBy": {
        "exceptionType": "org.eclipse.hyades.internal.execution.local.control.InactiveAgentException",
        "elements": [
          {
            "method": "org.eclipse.hyades.internal.execution.local.control.AgentImpl.invokeCustomCommand",
            "source": "AgentImpl.java:475"
          },
          {
            "method": "org.eclipse.hyades.execution.local.SessionImpl.invokeRemote",
            "source": "SessionImpl.java:104"
          }
        ],
        "number": 0,
        "commentIndex": 0
      },
      "number": 0,
      "commentIndex": 7,
      "bugId": "136419",
      "date": "2006-08-02T20:38:43+02:00",
      "product": "TPTP Agent Controller",
      "component": "Platform.Communication",
      "severity": "major"
    }
  ],
  "groupId": "136419",
  "bugId": "136419",
  "date": "2006-04-12T20:49:19+02:00",
  "product": "TPTP Agent Controller",
  "component": "Platform.Communication",
  "severity": "major"
}