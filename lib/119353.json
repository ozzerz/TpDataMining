{
  "comments": [
    "I am running into a problem in load-time weaving when I use reflection delegates because the weaver is generating an incorrect bridge method when I perform an inter-type declaration on Struts.ActionServlet for the init method. On investigation, the BCEL world is recognizing this as an overriding method, because its version of getDeclaredMethods is returning the declared methods for all ancestor superclasses. However, the reflection world is returning only the declared methods for this one class. It therefore appears that the weaver expects getDeclaredMethods to return all of them (making the name quite misleading). I think previously the method was being implemented inconsistently between 1.5 reflection and \u003c1.5 reflection delegates. But it looks like it needs to be handled consistently to include all superclass methods.\n\nHowever, I don?t know what other places (e.g., the MAP) are really expecting getDeclaredMethods and its siblings to behave like Java reflection\u0027s version?\n\nI started work on adding a getAllDeclaredMethods method to ReferenceType and delegates, as an alternative to provide the weaver the ability to check method overriding as in this case, but it\u0027s a little bit involved and I wanted to flag the issue first.\n\nHere\u0027s a test that fails and illustrates the issue:\nIndex: ReflectionBasedReferenceTypeDelegateTest.java\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nRCS file: /home/technology/org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java,v\nretrieving revision 1.5\ndiff -u -r1.5 ReflectionBasedReferenceTypeDelegateTest.java\n--- ReflectionBasedReferenceTypeDelegateTest.java\t28 Nov 2005 17:44:40 -0000\t1.5\n+++ ReflectionBasedReferenceTypeDelegateTest.java\t6 Dec 2005 04:11:41 -0000\n@@ -238,6 +238,18 @@\n         assertTrue(\"Superclass for Map generic type should be Object but was \"+rt2,rt2.equals(UnresolvedType.OBJECT));         \n     }\n     \n+    public void testCompareSubclassDelegates() {\n+        world.setBehaveInJava5Way(true);\n+        \n+        BcelWorld bcelWorld \u003d new BcelWorld();\n+        bcelWorld.setBehaveInJava5Way(true);\n+        UnresolvedType javaUtilHashMap \u003d UnresolvedType.forName(\"java.util.HashMap\");\n+        ReferenceType rawType \u003d (ReferenceType)bcelWorld.resolve(javaUtilHashMap );\n+        \n+        ReferenceType rawReflectType \u003d (ReferenceType)world.resolve(javaUtilHashMap );\n+        assertEquals(rawType.getDelegate().getDeclaredMethods().length, rawReflectType.getDelegate().getDeclaredMethods().length);\n+    }\n+    \n \t// todo: array of int\t\n \n \tprotected void setUp() throws Exception {\n\n\nThis results in:\njunit.framework.AssertionFailedError: expected:\u003c41\u003e but was:\u003c29\u003e\n\tat junit.framework.Assert.fail(Assert.java:47)\n\tat junit.framework.Assert.failNotEquals(Assert.java:282)\n\tat junit.framework.Assert.assertEquals(Assert.java:64)\n\tat junit.framework.Assert.assertEquals(Assert.java:201)\n\tat junit.framework.Assert.assertEquals(Assert.java:207)\n\tat org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:250)\n\tat java.lang.reflect.Method.invoke(Native Method)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)",
    "Two small clarifications: the incorrect bridge method results in a VerifyError. If I use only BCEL delegates then the system behaves properly.",
    "I modified the test program to output what the differences are between the two sets.  Interesting results:\n\nCouldn\u0027t find java.util.HashMap java.util.HashMap.init(int) in the bcel set\nCouldn\u0027t find java.util.HashMap java.util.HashMap.init() in the bcel set\nCouldn\u0027t find java.util.HashMap java.util.HashMap.init(java.util.Map) in the bcel set\nCouldn\u0027t find java.util.HashMap java.util.HashMap.init(int, float) in the bcel set\nCouldn\u0027t find void java.util.HashMap.\u003cinit\u003e(int, float) in the reflection set\nCouldn\u0027t find void java.util.HashMap.\u003cinit\u003e(int) in the reflection set\nCouldn\u0027t find void java.util.HashMap.\u003cinit\u003e() in the reflection set\nCouldn\u0027t find void java.util.HashMap.\u003cinit\u003e(java.util.Map) in the reflection set\nCouldn\u0027t find void java.util.HashMap.\u003cclinit\u003e() in the reflection set\n\nI don\u0027t like the disagreement between the \u0027init\u0027 and \u0027\u003cinit\u003e\u0027 strings.  I suspect that is the root of this problem.  I\u0027m not sure about the \u003cclinit\u003e - but at least we know that can\u0027t have an impact on bridge methods ;)\n\nI\u0027m not sure how this quite ties up with Rons description that getDeclaredMethods() is differing in each case as the initial fix here just seems to be transforming the reflection based entries for ctors to indicate \u003cinit\u003e...",
    "Created an attachment (id\u003d31379)\nPatch to the delegates (1.5 and \u003c 1.5)\n\nRon ... this zip contains two patches, one for the weaver project, one for weaver5 - can you try it out and see if it helps your situation with the rogue bridge method?  Basically I\u0027ve made the reflection world return the same thing as the bcel world.  The test I modified still fails because of the \u003cclinit\u003e method but that shouldnt impact bridge method creation.",
    "Hmmm .. I just re-read the original append by Ron.\n\nIn my case I wasn\u0027t getting 41 and 29, I was getting 41 and 40.\n\nperhaps I\u0027m not running it in quite the same way - i\u0027ll keep hacking away - but if you could try the patch it might help with the bridge problem.",
    "I will try the patches and report back...\n\nOn closer examination, the 29 vs 41 methods I was seeing was on a Java 1.3.1 VM but running in Eclipse where the Java 1.5 JRE was on the classpath and BCEL was using that to resolve types (!). When corrected to use a 1.3 JRE in Eclipse, I see 29 vs 30 methods on a Java 1.3 VM and I always saw 40 vs 41 on a Java 1.5 VM. Hopefully this test will show 29 vs 30 when run via ant (the docs on how to run ant tests for a module from the command line aren\u0027t working for me...)\n\nReflect:\nput, clone, get, access$000, access$100, values, size, access$200, clear, remove, access$300, loadFactor, keySet, entrySet, isEmpty, containsValue, containsKey, rehash, putAll, writeObject, readObject, capacity, getHashIterator, access$308, access$110, init, init, init, init\nBCEL:\n\u003cinit\u003e, \u003cinit\u003e, \u003cinit\u003e, \u003cinit\u003e, size, isEmpty, containsValue, containsKey, get, rehash, put, remove, putAll, clear, clone, keySet, values, entrySet, getHashIterator, writeObject, readObject, capacity, loadFactor, access$000, access$100, access$200, access$308, access$110, access$300, \u003cclinit\u003e\n",
    "It looks like those patches fix the problem (although I had to patch the patches to use an IReflectionWorld interface that my LTWWorld implementation also implements :-)). I am not seeing the same error messages and things appear to be working properly on a quick run. Thanks!",
    "fixes checked in - thanks for trying them out Ron. waiting on build.",
    "oops - closed prematurely.  i\u0027m really waiting on the build...",
    "fix available."
  ],
  "commentCreationDates": [
    "2005-12-06T04:11:15+01:00",
    "2005-12-06T04:12:13+01:00",
    "2005-12-08T15:45:12+01:00",
    "2005-12-08T15:53:18+01:00",
    "2005-12-08T15:57:49+01:00",
    "2005-12-09T04:18:53+01:00",
    "2005-12-09T04:51:02+01:00",
    "2005-12-09T08:39:40+01:00",
    "2005-12-09T08:41:26+01:00",
    "2005-12-09T14:02:37+01:00"
  ],
  "traces": [
    {
      "exceptionType": "junit.framework.AssertionFailedError",
      "message": "expected:\u003c41\u003e but was:\u003c29\u003e",
      "elements": [
        {
          "method": "junit.framework.Assert.fail",
          "source": "Assert.java:47"
        },
        {
          "method": "junit.framework.Assert.failNotEquals",
          "source": "Assert.java:282"
        },
        {
          "method": "junit.framework.Assert.assertEquals",
          "source": "Assert.java:64"
        },
        {
          "method": "junit.framework.Assert.assertEquals",
          "source": "Assert.java:201"
        },
        {
          "method": "junit.framework.Assert.assertEquals",
          "source": "Assert.java:207"
        },
        {
          "method": "org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates",
          "source": "ReflectionBasedReferenceTypeDelegateTest.java:250"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Native Method"
        },
        {
          "method": "junit.framework.TestCase.runTest",
          "source": "TestCase.java:154"
        },
        {
          "method": "junit.framework.TestCase.runBare",
          "source": "TestCase.java:127"
        },
        {
          "method": "junit.framework.TestResult$1.protect",
          "source": "TestResult.java:106"
        },
        {
          "method": "junit.framework.TestResult.runProtected",
          "source": "TestResult.java:124"
        },
        {
          "method": "junit.framework.TestResult.run",
          "source": "TestResult.java:109"
        },
        {
          "method": "junit.framework.TestCase.run",
          "source": "TestCase.java:118"
        },
        {
          "method": "junit.framework.TestSuite.runTest",
          "source": "TestSuite.java:208"
        },
        {
          "method": "junit.framework.TestSuite.run",
          "source": "TestSuite.java:203"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:478"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run",
          "source": "RemoteTestRunner.java:344"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main",
          "source": "RemoteTestRunner.java:196"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "119353",
      "date": "2005-12-06T04:11:15+01:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "119353",
  "bugId": "119353",
  "date": "2005-12-06T04:11:15+01:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}