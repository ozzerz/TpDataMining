{
  "comments": [
    "(The following was found in 2.0.1)\n\nI\u0027ve noticed Target.getCThreads throwing an exception when it posts the\ninfo-threads command in order to get information about the current threads:\n\norg.eclipse.cdt.debug.core.cdi.CDIException: Target is not suspended\n\tat org.eclipse.cdt.debug.mi.core.cdi.model.Target.getCThreads(Target.java:291)\n\tat org.eclipse.cdt.debug.mi.core.cdi.model.Target.getThreads(Target.java:315)\n\tat org.eclipse.cdt.debug.mi.core.cdi.model.Target.getCurrentThread(Target.java:300)\n\tat\norg.eclipse.cdt.debug.internal.core.model.CDebugTarget.setCurrentThread(CDebugTarget.java:1739)\n\tat\norg.eclipse.cdt.debug.internal.core.model.CDebugTarget.refreshThreads(CDebugTarget.java:749)\n\tat\norg.eclipse.cdt.debug.internal.core.model.CDebugTarget.handleSuspendedEvent(CDebugTarget.java:1334)\n\tat\norg.eclipse.cdt.debug.internal.core.model.CDebugTarget.handleDebugEvents(CDebugTarget.java:1049)\n\tat org.eclipse.cdt.debug.mi.core.cdi.EventManager.fireEvents(EventManager.java:245)\n\tat org.eclipse.cdt.debug.mi.core.cdi.EventManager.update(EventManager.java:216)\n\tat java.util.Observable.notifyObservers(Unknown Source)\n\tat org.eclipse.cdt.debug.mi.core.MISession.notifyObservers(MISession.java:492)\n\tat org.eclipse.cdt.debug.mi.core.EventThread.run(EventThread.java:46)\n\nWhile I can\u0027t be sure, I can guess at the cause.  That\u0027s because I just ran into\na similar situation in some of my own code that extends CDT.  The deal is this:\nshared library events are handled in RxThread by (a) creating some MIEvents that\ndescribe the event, (b) having MISession fire those events by posting them to a\nqueue, and then (c) resuming execution of the debugged process.  The events\nposted in step (b) are picked up by EventThread and routed to whomever wants\nthem.  However, when the objects receiving the event notification are called,\nthere\u0027s no guarantee as to where the RxThread has gotten to in its execution. \nThat is, the debugged process may or may not have been restarted by the time a\nparticular object received notification of the event.  Thus, attempts to post\nMICommands may or may not result in \"Target is not suspended\" exceptions.\n\nPerhaps the canonical way for handling event notification is with something like\nthe following:\n\n        target.incrementSuspendCount();\n        try {\n            handleEvent();\n        } finally {\n            target.decrementSuspendCount();\n        }\n\nWith suspend counts, you take care of any problems with multiple threads trying\nto suspend and resume the target.  Unfortunately, it doesn\u0027t take care of *how*\nthe target should be suspended (vis., the various ways that the target needs to\nbe resumed after handling a shared library event -- see latter half of\nEventManager.processSharedLibEvent).\n\nAnother possibility would be to force all of the events that are posted by\nEventManager.processSharedLibEvent to be completely routed by the time\nEventManager.processSharedLibEvent tries to restart the debugged process.  That\nmight clear up a lot of problems, but would seem to require the addition of some\nAPI to check the state of the queue holding the MIEvents or block until it\nsignals that it\u0027s empty.\n\nBut there might be problem with that approach, too.  If the event notification\nhandler needs to issue some MICommands, it will post them to the TxThread and\nthen wait for a reply to come through in RxThread.  But if RxThread is waiting\nfor all event notifications to be handled, you\u0027ll have a deadlock.\n\nUnless there\u0027s a simple solution I\u0027m overlooking (which is entirely possible), I\ndon\u0027t think I envy whoever is assigned this report... :-)",
    "Thinking about the problem some more, perhaps a solution occurs to me.\n\nThe issue is that event notification handlers may expect that the debug target \nis suspended, allowing them to make queries on that target.  However, at least \nin the case of handling events generated as part of a \"shared library event\", \nthe notification handlers can\u0027t know for sure if the debug target is \nsuspended.  That\u0027s because the event notification is handled in one thread \n(the EventThread) while the shared library event is handled in another thread \n(the RxThread), which will restart the debug target at some indeterminate time \nrelative to what\u0027s going on in EventThread.\n\nVarious possible approaches to a solution are presented in my original report, \nalong with their serious drawbacks.  However, I think that a workable solution \nhas occurred to me.\n\nThis approach is to move the restarting of the debug target from RxThread to \nEventThread in a way such that this restarting will occur after all event \nnotification is handled.  This can be achieved by creating a new subclass of \nMIEvent and -- instead of executing all of that code in the second half of \nEventManager.processSharedLibEvent -- create an instance of this MIEvent \nsubclass and post it to the MISession event queue after all the other MIEvents \nhave been posted.  This MIEvent subclass would take care of executing the code \nthat would otherwise be executed by EventManager.processSharedLibEvent.\n\nThis way, the RxThread is freed up to handle other incoming messages, and the \ndebug target is restarted after the other MIEvents have been handled, allowing \nthe handlers of those MIEvents to assume that the debug target is suspended \nand will stay suspended.",
    "Following up with more information:\n\nSome of my analysis was off the mark.  I had speculated that the cause was \nrelated to handling notifications in the context of a Shared Library Event, \nwhere the debug target was suspended and then resumed.  However, \nthis \"obviously\" is not the case.  The stack trace shows that a SuspendedEvent \nis being handled.  But this kind of event is not sent out in the case of a \nShared Library Event.  Rather, DestroyedEvents and CreatedEvents are sent \nout.  So that\u0027s not the cause of the problem.\n\nHowever, the change I suggest (moving the code that resumes the debug target \ninto an MIEvent) is probably still a good one to make.  I made the change \nmyself in order to (a) attempt to fix the problem reported here, and (b) to \nfix the \"similar situation\" I alluded to in my original post.  While (a) was, \nof course, not fixed, (b) was.  So I still think it\u0027s a good change to make in \nthe abstract.\n\nIn the meantime, I\u0027m still not sure of the catalyst for the bug leading to the \ncrash described in the original report.",
    "Keith,\n  you may or may not be aware of it but we are doing some\nreengeneering of the CDI code including MI in the head branch\n\nFeedback like this is very important to not do the same mistakes.\nWill take a second look when back. Meanwhile cc\u0027ing dave and mikhail\nif you need a fix for the 2.0.x branch",
    "Let see if we can reproduce this one.",
    "Original submitter no longer with PalmSource.  Please direct any questions about\norigin of bug to Brad.Jarvinen@palmsource.com (but Keith may still be in the\nknow if you want to try him too). ",
    "We will need to reevaluate this for CDT-3.1.  Does\nany folks from PalmSource can work with me to track this down.\n\nThanks",
    "Hi Alain,\n\nI\u0027m working on trying to reproduce this.  So far I haven\u0027t had any luck and \nunfortunately the original reporter of the bug is no longer with PalmSource.\n\nThanks,\nEwa.",
    "Returning to the pool.",
    "Future means you commit to fix it in the Future. Inboxes can\u0027t make committments. Moving to \u0027--\u0027."
  ],
  "commentCreationDates": [
    "2004-09-16T07:01:22+02:00",
    "2004-09-18T01:13:31+02:00",
    "2004-09-22T02:18:57+02:00",
    "2004-09-22T23:19:42+02:00",
    "2004-11-01T01:47:25+01:00",
    "2004-11-02T00:35:03+01:00",
    "2005-07-21T22:54:11+02:00",
    "2005-07-28T02:49:36+02:00",
    "2005-09-06T17:45:48+02:00",
    "2007-08-21T17:04:40+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.cdt.debug.core.cdi.CDIException",
      "message": "Target is not suspended",
      "elements": [
        {
          "method": "org.eclipse.cdt.debug.mi.core.cdi.model.Target.getCThreads",
          "source": "Target.java:291"
        },
        {
          "method": "org.eclipse.cdt.debug.mi.core.cdi.model.Target.getThreads",
          "source": "Target.java:315"
        },
        {
          "method": "org.eclipse.cdt.debug.mi.core.cdi.model.Target.getCurrentThread",
          "source": "Target.java:300"
        },
        {
          "method": "org.eclipse.cdt.debug.internal.core.model.CDebugTarget.setCurrentThread",
          "source": "CDebugTarget.java:1739"
        },
        {
          "method": "org.eclipse.cdt.debug.internal.core.model.CDebugTarget.refreshThreads",
          "source": "CDebugTarget.java:749"
        },
        {
          "method": "org.eclipse.cdt.debug.internal.core.model.CDebugTarget.handleSuspendedEvent",
          "source": "CDebugTarget.java:1334"
        },
        {
          "method": "org.eclipse.cdt.debug.internal.core.model.CDebugTarget.handleDebugEvents",
          "source": "CDebugTarget.java:1049"
        },
        {
          "method": "org.eclipse.cdt.debug.mi.core.cdi.EventManager.fireEvents",
          "source": "EventManager.java:245"
        },
        {
          "method": "org.eclipse.cdt.debug.mi.core.cdi.EventManager.update",
          "source": "EventManager.java:216"
        },
        {
          "method": "java.util.Observable.notifyObservers",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.cdt.debug.mi.core.MISession.notifyObservers",
          "source": "MISession.java:492"
        },
        {
          "method": "org.eclipse.cdt.debug.mi.core.EventThread.run",
          "source": "EventThread.java:46"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "74041",
      "date": "2004-09-16T07:01:22+02:00",
      "product": "CDT",
      "component": "cdt-debug",
      "severity": "normal"
    }
  ],
  "groupId": "74041",
  "bugId": "74041",
  "date": "2004-09-16T07:01:22+02:00",
  "product": "CDT",
  "component": "cdt-debug",
  "severity": "normal"
}