{
  "comments": [
    "Given:\n* Bundle A contains:\n    com.xyz.Service - the interface\n    com.xyz.ServiceImpl - the implementation of Service\n* Bundle B creates an instance of ServiceImpl and attempt to register it.\n\nBundle B\u0027s call to BundleContext.registerService() will fail if the \ncom.xyz.Service class hasn\u0027t already been explicitly loaded by B\u0027s classloader.\n\nThus, the following will fail:\n    context.registerService(\"com.xyz.Service\", svc, null);\n\nwhile this will work:\n    context.registerService(com.xyz.Service.class.getName(), svc, null);\n\nThis bug was introduced in M9.  I\u0027ll attach an example (as soon as I figure \nout how to attach it).  Meanwhile, here\u0027s the stack trace:\n\n\njava.lang.IllegalArgumentException: The service class com.xyz.Service could \nnot be loaded from an exported package\n\tat \norg.eclipse.osgi.framework.internal.core.BundleContextImpl.registerService\n(BundleContextImpl.java:598)\n\tat \norg.eclipse.osgi.framework.internal.core.BundleContextImpl.registerService\n(BundleContextImpl.java:641)\n\tat implementation.ServiceImplementationPlugin.start\n(ServiceImplementationPlugin.java:42)\n\tat org.eclipse.osgi.framework.internal.core.BundleContextImpl$1.run\n(BundleContextImpl.java:958)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat \norg.eclipse.osgi.framework.internal.core.BundleContextImpl.startActivator\n(BundleContextImpl.java:954)\n...",
    "Created an attachment (id\u003d11076)\nTwo bundles illustrating the bug.\n\nAdd the two Plugins and open the implementation.Perspective1 perspective.",
    "This is working as designed (almost).  Actually you should not be able to \nregister the service in both scenarios.  The service class names that a service \nobject is registered as must be accessable by the registering bundle from \neither the parent classloader, an imported package, or as a local class to the \nregistering bundle.  In your scenario you are registering a service using the \ncom.xyz.Service interface which is provided by the ServiceDefinition bundle but \nbut the package is not exported by ServiceDefinition.  To export a package your \nplugin must have a handcrafted manifest file with the following header:\n\nExport-Package: com.xyz\n\nI will attach a fixed up version of the sample plugins that show you what the \nmanifest file should look like for the ServiceDefinition plugin.  \n\nNow as to why the second way works.  This is a bug that needs to be fixed.  It \nlooks like if you access the Service interface directly from your plugin \n(ServiceImplementation) then that forces the ClassLoader of your plugin to try \nto load the Service interface class.  This ends up doing a look aside load of \nthe Service interface from the ClassLoader of the ServiceDefinition bundle.  \nThis is all working as expected.  But what is strange is that the ClassLoader \nof the ServiceImplementation plugin is getting marked by the VM as having \ninitiated the class even though it did not do any actuall defining of the \nclass.  It looks like an extra step is going to have to be done in PackageAdmin \nto see if the classloader of the class is actually the Bundle\u0027s classloader \nthat we are trying to load the class out of.",
    "Created an attachment (id\u003d11102)\nmodified sample plugins that work\n\nmodified ServiceDefinition to add an Export-Package statement to the manifest.",
    "Is using the MANIFEST.MF required now?  Having come from the OSGi side, I was \nso much happier letting plugin.xml decide which packages were exported \n(one \u0027*\u0027 goes a long way).  Having to explicitly export packages via the \nExport-Package header is tedious and error prone.  Import-Package is even \nworse!  Maybe it would be different if the PDE automatically populated those \ntwo headers (and kept the plugin.xml and MANIFEST.MF in sync).  Short of that, \nit would be great if you allowed us to bypass MANIFEST.MF the way you did in \nM8.",
    "I have fixed the bug that was giving you inconsistent behavior depending on if \nyou passed a constant String to registerService or String from Class.getName\n().  Both ways will now fail in your scenario.\n\nThere are reasons that we want to limit the source of the Classes that you \nregister a Service as.  When using bundle dependancies (instead of \nimport/export package) it is possible for two bundles to get different versions \nof package.  In fact that is one motivation behind using bundle dependancies.  \nBut this opens up the door for bundles to get ClassCastExceptions when getting \na Service from the Service Registry.  Since we introduced this behavior with \nbundle dependancies, the OSGi community saw fit to restrict the Service Classes \nto only come from Sources that were available in the OSGi R3 spec.  That is the \nParent ClassLoader, the Import/Export class space and the private classloader \nof the bundle.\n\nNote that it is only the responsibility of the provider to export the package \nthey are providing the service classes in.  A bundle is allowed to both export \nand provide a package.  So depending bundles are not forced to import the \npackage, they can continue to use bundle dependancies to access the package.  \nThis forces the Framework to choose a single source of the package instead of \nallowing multiple bundles to provide the package.\n\nThis is a sanity check the Framework does to prevent developers from shooting \nthemselves in the foot.  I think allowing one to override such a check is a \ngood idea.  I added a new java property that you can set to prevent the check.  \nThe property is:\n\nosgi.checkServiceClassSource\n\nBy default it is set to \"true\".  You can set it to \"false\" by setting the java \nproperty on the commandline when starting eclipse, or set the property in the \nconfig.ini file in the configuration directory of your install."
  ],
  "commentCreationDates": [
    "2004-05-25T20:24:08+02:00",
    "2004-05-25T20:26:57+02:00",
    "2004-05-25T23:39:59+02:00",
    "2004-05-25T23:43:08+02:00",
    "2004-05-25T23:54:15+02:00",
    "2004-05-26T16:15:44+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.IllegalArgumentException",
      "message": "The service class com.xyz.Service could  not be loaded from an exported package",
      "elements": [
        {
          "method": "org.eclipse.osgi.framework.internal.core.BundleContextImpl.registerService",
          "source": "BundleContextImpl.java:598"
        },
        {
          "method": "org.eclipse.osgi.framework.internal.core.BundleContextImpl.registerService",
          "source": "BundleContextImpl.java:641"
        },
        {
          "method": "implementation.ServiceImplementationPlugin.start",
          "source": "ServiceImplementationPlugin.java:42"
        },
        {
          "method": "org.eclipse.osgi.framework.internal.core.BundleContextImpl$1.run",
          "source": "BundleContextImpl.java:958"
        },
        {
          "method": "java.security.AccessController.doPrivileged",
          "source": "Native Method"
        },
        {
          "method": "org.eclipse.osgi.framework.internal.core.BundleContextImpl.startActivator",
          "source": "BundleContextImpl.java:954"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "63938",
      "date": "2004-05-25T20:24:08+02:00",
      "product": "Equinox",
      "component": "Incubator",
      "severity": "normal"
    }
  ],
  "groupId": "63938",
  "bugId": "63938",
  "date": "2004-05-25T20:24:08+02:00",
  "product": "Equinox",
  "component": "Incubator",
  "severity": "normal"
}