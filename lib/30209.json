{
  "comments": [
    "The following test class reproduces the problem with the serialization \ncompatibility between the JDT compiler and the JDK 1.4 and JDK 1.3 compilers.\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * This is a test class that illustrates a serialization incompatibility\n * between the eclipse and standard JDK compiler implementations.  The problem\n * manifests itself when trying to serialize bytecode compiled with one\n * compiler and then trying to deserialize it with bytecode compiled from\n * another compiler\n * \n * @author eldonm\n */\npublic class SerializationTest implements Serializable {\n\n    // (1) The SerializationTest.class reference is what is causing the problem\n    private static String className \u003d SerializationTest.class.getName();\n\n    /**\n     * Constructor for SerializationTest.\n     */\n    public SerializationTest() {\n        super();\n    }\n\n    public static void main(String[] args) throws Exception {\n        if (args.length !\u003d 2) {\n            printUsage();\n            System.exit(1);\n        }\n\n        if (\"write\".equals(args[0])) {\n            SerializationTest test \u003d new SerializationTest();\n            ObjectOutputStream out \u003d new ObjectOutputStream(\n                new FileOutputStream(args[1]));\n            out.writeObject(test);\n            out.close();\n        } else if (\"read\".equals(args[0])) {\n            ObjectInputStream in \u003d new ObjectInputStream(\n                new FileInputStream(args[1]));\n            SerializationTest test \u003d (SerializationTest) in.readObject();\n            in.close();\n        } else {\n            printUsage();\n        }\n    }\n\n    static void printUsage() {\n        System.out.println(\n            \"Usage: java SerializationTest write|read filename\");\n    }\n}\n\nTo reproduce the problem, add this class to a java natured Eclipse project and \nexecute it as a application after adding the parameters \"write\"  followed by \nthe desired serialized file name of the test serialized file \n(e.g. \"c:\\\\test.ser\")\n\nThen compile the same code with the JDK 1.3 or 1.4 compiler and execute the \napplication with the read argument on the same test filename (e.g. java read \nc:\\\\test.ser\").  \n\nYou will then see a stack trace similar to the following:\n\njava.io.InvalidClassException: SerializationTest; local class incomp\natible: stream classdesc serialVersionUID \u003d -6933307971724216872, local class \nse\nrialVersionUID \u003d -5182857768810774092\n  at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java\n:459)\n  at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.\njava:1521)\n  at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.jav\na:1435)\n  at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStrea\nm.java:1626)\n  at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:\n1274)\n  at java.io.ObjectInputStream.readObject(ObjectInputStream.java:3\n24)\n  at SerializationTest.main(Unknown Source)\n\nThe (1) comment in the code above is the cause of the problem.  The static \nstring is assigned a value from the class using the java.lang.Class.getName() \nmethod.  This triggers the eclipse compiler to synthesize additional class \nstructure as shown below (taken from the decompiled version of the bytecode \nfor the class listing shown above):\n\n// JDT\n\n  private static String className;\n  static Class class$0; /* synthetic field */\n\n  static\n  {\n    className \u003d SerializationTest.class.getName();\n  }\n\n// JDK 1.4\n\n    static Class class$(String s)\n    {\n        return Class.forName(s);\n        ClassNotFoundException classnotfoundexception;\n        classnotfoundexception;\n        throw new NoClassDefFoundError(classnotfoundexception.getMessage());\n    }\n\n    private static String className;\n    static Class class$SerializationTest; /* synthetic field */\n\n    static\n    {\n        className \u003d (class$SerializationTest !\u003d null ?\nclass$SerializationTest : (class$SerializationTest \u003d\nclass$(\"SerializationTest\"))).getName();\n    }\n\nThis difference between the two results in a different class signature, thus   \nresulting in the serialization incompatibility included at the beginning of \nthis report.",
    "Unfortunately, the Java language specs does specify one particular \nimplementation for the class literal. Our implementation is different from \nothers, causing the serialization issues you are seeing; but none is more right \nthan the other. Ours is generating more compact code (one method less).\n\nIf the specs were enforcing one particular implementation to be the proper one, \nthen we would follow it. On the other end, serialization should ignore \nsynthetics, and it doesn\u0027t thus this is a dead-end.\n\nYour best take is to use the same binaries on the way in and out. Either use \nbinaries from JDT or from a different compiler on both ends.\n\nSimilar issues arise with local innerclasses.\n\nAt last, you could resort to using the serialVersionUID trick to workaround \nthese issues.",
    "Oops, my previous post should read: \n\nUnfortunately, the Java language specs does NOT specify one particular \nimplementation for the class literal.",
    "Thanks for the detailed information and rapid response!  When we ran into this \na few weeks ago, we reverted to just using JDT compiled code everywhere.\n\nHas anyone pushed on Sun to improve serialization to ignore synthetics, or to \nat least remove this ambiguity in the specification?\n\nIt seems, from my perspective, that even though the JDT code is a bit more \ncompact, it would be great (for portability) to mimic what Sun has been doing \nuntil the specification or serialization issue can be worked out.\n\nOur primary concern was ensuring automated nightly builds using ant produced \nthe same bytecode the development machines produced so that a complex \ndeployment of a multi-tier system where serialization is used to move data \nbetween tiers would succeed.  We successfully worked around the issue by \nreplicating the eclipse build process using ant with the build.compiler \nproperty set to org.eclipse.jdt.core.JDTCompilerAdapter.  It would have been \nextremely beneficial if Eclipse included a Export to Ant build script feature \nor a way to execute Eclipse in headless mode from the command-line, as we had \nto replicate the eclipse setup manually in the ant build script.",
    "Eclipse can certainly be run in headless mode, and in particular the JDT/Core \ncomponent will run under these conditions (no dependency on UI code). You could \nsetup a workspace in headless mode (our test suites are precisely doing it, you \ncould check org.eclipse.jdt.core.tests.model project on dev.eclipse.org).\n\nAs for getting Sun to spec either serialization or compiler internals, I \nremember hearing one of the language guru clearly saying no. This is very \nunfortunate, and trying to mimic some unspecified behavior is hard (adjusting \non a moving target). \n\nI think using the same binaries on both ends is the only true answer. \nFYI, we recently made a couple fixes to our compiler which could result in some \nserialization issues with respect to serialized instances of local innerclasses \n(we posted it on jdt-core-dev mailing list). This to say that binaries have to \nbe produced with the exact same compiler to be trustable (same vendor, same \nversion) to be reliable.\n\nHope this helps, and anyway thanks for your original diagnosis of this issue.\n",
    "Won\u0027t change current implementation unless spec would.",
    "*** Bug 30357 has been marked as a duplicate of this bug. ***",
    "*** Bug 32227 has been marked as a duplicate of this bug. ***",
    "*** Bug 37328 has been marked as a duplicate of this bug. ***",
    "Should have been tagged as duplicate",
    "\n\n*** This bug has been marked as a duplicate of 10104 ***"
  ],
  "commentCreationDates": [
    "2003-01-24T21:04:28+01:00",
    "2003-01-24T23:09:15+01:00",
    "2003-01-24T23:10:57+01:00",
    "2003-01-24T23:28:44+01:00",
    "2003-01-25T12:23:17+01:00",
    "2003-01-27T14:42:03+01:00",
    "2003-01-28T11:21:50+01:00",
    "2003-02-19T13:27:08+01:00",
    "2003-05-07T17:54:53+02:00",
    "2003-09-05T13:54:13+02:00",
    "2003-09-05T13:54:44+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.io.InvalidClassException",
      "message": "SerializationTest; local class incomp atible: stream classdesc serialVersionUID \u003d -6933307971724216872, local class  se rialVersionUID \u003d -5182857768810774092",
      "elements": [
        {
          "method": "java.io.ObjectStreamClass.initNonProxy",
          "source": "ObjectStreamClass.java :459"
        },
        {
          "method": "java.io.ObjectInputStream.readNonProxyDesc",
          "source": "ObjectInputStream. java:1521"
        },
        {
          "method": "java.io.ObjectInputStream.readClassDesc",
          "source": "ObjectInputStream.jav a:1435"
        },
        {
          "method": "java.io.ObjectInputStream.readOrdinaryObject",
          "source": "ObjectInputStrea m.java:1626"
        },
        {
          "method": "java.io.ObjectInputStream.readObject0",
          "source": "ObjectInputStream.java: 1274"
        },
        {
          "method": "java.io.ObjectInputStream.readObject",
          "source": "ObjectInputStream.java:3 24"
        },
        {
          "method": "SerializationTest.main",
          "source": "Unknown Source"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "30209",
      "duplicateId": "10104",
      "date": "2003-01-24T21:04:28+01:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "10104",
  "bugId": "30209",
  "duplicateId": "10104",
  "date": "2003-01-24T21:04:28+01:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}