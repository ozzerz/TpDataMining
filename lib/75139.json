{
  "comments": [
    "Programmatically adding types to an xs:redefine content through the XSD API has \nno effect.  I will attach a test case to demonstrate what I\u0027m trying to do.  \nInformation about possible workarounds is greatly appreciated (as is a fix too, \nof course ;-)",
    "Created an attachment (id\u003d14817)\nStandalone test case for programmatic redefine\n",
    "Created an attachment (id\u003d14818)\nCompany.xsd\n",
    "Created an attachment (id\u003d14819)\nDepartment.xsd\n",
    "Created an attachment (id\u003d14820)\nEmployee.xsd\n",
    "Created an attachment (id\u003d14833)\nChanges to your testcase to make it work\n\nI\u0027ve made a number of changes to the test case make it do what I think it\u0027s\nsupposed to do.  Supporting model changes that require undoing previous\nincludes or redefines and then redoing them isn\u0027t something I can support\neasily/quickly. I think this would take a more brute force approach we don\u0027t\nsupport yet, e.g., something like XSDSchema.reset() to force everything to be\nrecomputed from scratch.  To work around this in your test case, I simply make\na copy of the changed schema and then use that intead.",
    "Thanks for the help and the quick response, Ed.\n\nCloning the schema will be problematic in our application because the schemas \nare being cached and potentially referenced from downstream dependent schemas.  \nWe would need to unload the schema and all its dependents and then load it \nagain, which is potentially a very expensive operation.  Would there be a quick \nand dirty way to accomplish the XSDSchema.reset() functionality where the \nschema could be updated in-place, perhaps with some limitations such as that it \nwould only work when types are added, but not removed from the XSDRedefine \ncontent?  I noticed that if I did an XSDSchema.update() on the \nXSDRedefine.incorporatedSchema, things started almost working.\n",
    "James, keeping this interrelated tangle of schemas consistent in the face of\narbitrary changes in any of the schemas is going to be extremely difficult, but\nI could take a stab at implementing reset() for you to try out. I guess I could\nreuse this test case and call reset() where it calls update() right now.\n\nOkay?",
    "Sounds great -- thanks, Ed!",
    "Created an attachment (id\u003d14933)\nPatches to implement XSDSchema.reset and XSDSchema.update(boolean force).\n\nJames, I\u0027ve attached source patches for the changes I\u0027ve made to XSD to get\nyour test case to work.  Can you confirm that this meets your needs?  I\u0027d\nrather not commit the changes without prior confirmation and additional testing\non your part...",
    "Ed,\n\nThank you very much for the quick and excellent work.  I found a couple of \nproblems, but I\u0027m able to work around them.  I get a NPE under the following \ncircumstances:\n\n1) NPE (stack trace is below) if I do a XSDSchema.reset() when adding an \nxs:redefine has no content yet or when adding an xs:include.\n2) Incorrect type resolution if I first do an XSDSchema.update() after adding \nan empty xs:redefine and secondly do an XSDSchema.reset() after adding content \nunder the xs:redefine.  In this case, the types seem to resolve still to the \nold un-redefined types.\n\nIf you want more information on these, just let me know.\n\nOne question to confirm that I\u0027m using the API correctly: I\u0027ve found that after \nprogramatically adding an xs:include, I need to do a XSDSchema.update() and now \nwith the changes you\u0027ve made I need to do a XSDSchema.reset() after adding \ncontent to an xs:redefine.\n\nThanks again for the fix.\n\n    James\n\n2004-09-30 20:12:36,438 ERROR [TestOverrideCreation] [Thread-46::] \njava.lang.NullPointerException during test: null\njava.lang.NullPointerException\n    at org.eclipse.emf.ecore.util.EcoreUtil.remove(EcoreUtil.java:1952)\n    at org.eclipse.xsd.impl.XSDSchemaCompositorImpl.reset\n(XSDSchemaCompositorImpl.java:75)\n    at org.eclipse.xsd.impl.XSDConcreteComponentImpl.reset\n(XSDConcreteComponentImpl.java:234)\n    at org.eclipse.xsd.impl.XSDSchemaImpl.reset(XSDSchemaImpl.java:2842)\n    at com.nextance.xsd.impl.component.XSDirectiveImpl.updateSchemaLocation\n(XSDirectiveImpl.java:75)\n",
    "Maybe this change in XSDSchemaCompositorImpl will fix the null pointer problem:\n\n    if (resolvedSchema !\u003d null \u0026\u0026 incorporatedSchema !\u003d resolvedSchema \u0026\u0026\nresolvedSchema !\u003d null)\n\nI.e., the additional null guard.\n\nI hope it\u0027s not asking for too much, but I\u0027d be able to solve each problem much\nfaster if you provided a way to reproduce each. I\u0027m under so much pressure to do\nso many other things, I probably shouldn\u0027t even be looking at this, and I can\nonly justify it if it goes quickly.",
    "\nEd,\n\nI changed the XSDSchemaCompositorImpl.reset() to check for a null \nresolvedSchema and a null incorporatedSchema and everything works fine now (see \nbelow).  Can you please make this change on your end and check in your \nchanges?  Would you like me to change this bug to FIXED?\n\nAlso, just to confirm that I\u0027m using the API correctly, here\u0027s the scenario of \nour usage:\n\nInitially, schemaA constains an include of schemaB.  Because a redefine is \ngoing to be done on a type from schemaB, the include directive is replaced with \na redefine directive.  When the include directive is removed and I do a \nschemaA.reset(), then after the redefine directive is added and the redefined \ntype is added within the redefine directive, I do a schemaA.update(true).  \nAfter this, the types are all correctly resolved.  Is this the correct way to \nuse the API?  Also, is there a performance/memory usage benefit to using an \ninclude instead of a redefine?\n\nThanks again for the fix!\n\n    James\n\n\n\n  public void reset()\n  {\n    super.reset();\n    if (resolvedSchema !\u003d null \u0026\u0026 incorporatedSchema !\u003d null \u0026\u0026 \nincorporatedSchema !\u003d resolvedSchema)\n    {\n      EcoreUtil.remove(incorporatedSchema);\n    }\n  }\n\n",
    "James, thanks for testing. Your usage scenario is correct.  I\u0027ve committed the\nchanges to the 2.1 CVS stream.  Redfine and namespace changing includes both\ncause cloning of the entire referenced schema, so they do cause bloating...",
    "Fixed in latest 2.1.0 build"
  ],
  "commentCreationDates": [
    "2004-09-28T05:55:58+02:00",
    "2004-09-28T05:58:19+02:00",
    "2004-09-28T05:59:32+02:00",
    "2004-09-28T05:59:59+02:00",
    "2004-09-28T06:00:20+02:00",
    "2004-09-28T15:15:44+02:00",
    "2004-09-28T21:19:13+02:00",
    "2004-09-28T21:33:17+02:00",
    "2004-09-28T21:50:53+02:00",
    "2004-09-30T19:39:26+02:00",
    "2004-10-01T06:13:10+02:00",
    "2004-10-01T17:11:49+02:00",
    "2004-10-07T02:36:09+02:00",
    "2004-10-07T14:32:09+02:00",
    "2004-10-14T21:02:34+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.emf.ecore.util.EcoreUtil.remove",
          "source": "EcoreUtil.java:1952"
        },
        {
          "method": "org.eclipse.xsd.impl.XSDSchemaCompositorImpl.reset",
          "source": "XSDSchemaCompositorImpl.java:75"
        },
        {
          "method": "org.eclipse.xsd.impl.XSDConcreteComponentImpl.reset",
          "source": "XSDConcreteComponentImpl.java:234"
        },
        {
          "method": "org.eclipse.xsd.impl.XSDSchemaImpl.reset",
          "source": "XSDSchemaImpl.java:2842"
        },
        {
          "method": "com.nextance.xsd.impl.component.XSDirectiveImpl.updateSchemaLocation",
          "source": "XSDirectiveImpl.java:75"
        }
      ],
      "number": 0,
      "commentIndex": 10,
      "bugId": "75139",
      "date": "2004-10-01T06:13:10+02:00",
      "product": "MDT",
      "component": "XSD",
      "severity": "normal"
    }
  ],
  "groupId": "75139",
  "bugId": "75139",
  "date": "2004-09-28T05:55:58+02:00",
  "product": "MDT",
  "component": "XSD",
  "severity": "normal"
}