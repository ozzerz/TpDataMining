{
  "comments": [
    "Repro\n\n1. Create a project and then enable project-level JDT preferences to cause the prefs file to be written.\n2. Close Eclipse and make the whole project directory read-only.\n3. Open Eclipse with a new workspace.\n4. Import the project.\n\nThe project imports and the build kicks off. Eventually, a dialog pops up:\n\n\"Problems occurred while refreshing local changes.\"\n\"Problems saving preferences.\"\n\"Exception occurred while saving project preferences: /myproj/.settings/org.eclipse.jdt.core.prefs\"",
    "Import as well as preferences loading/writing is platform",
    "Note that this has only been seen with org.eclipse.jdt.core.prefs file. Other prefs file work fine, so there is definitely a JDT aspect here.",
    "\nI\u0027m passing this on to the JDT group for the first cut based on the input that this seems localized to the JDT preference store...\n\nNOTE: I\u0027m just starting to take over the triage so don\u0027t be too harsh if you think I\u0027ve mis-directed this; just punt it back with appropriate comments...;-)\n",
    "As said, Import as well as preferences loading/writing is platform. We\u0027re just using their API.\n\nIt\u0027s probably just us in JDT which use project specific settings.\n\nBTW, Konstantin, what exactly should be the expected behaviour with the read-only preferences?",
    "I should be prompted to make the file writable. You can easily get this behavior by simply calling IWorkspace.validateEdit(IFile[] files, Object context) and passing in a valid SWT Shell object for the \"context\" parameter. Make sure to gracefully handle the case where the user selects \"No\" (check the returned IStatus).\n\nRead-only project files come up a lot when dealing with source control systems (like Perforce) that make the local files read-only until they are \"checked out\". \n",
    "Maybe core.runtime isn\u0027t following the \u0027validateEdit\u0027 protocol. But note that you can\u0027t test this by simply making something read-only. You\u0027ll get the prompt only if your project is connected to a pessimistic repository provider that defines the behaviour of \u0027validateEdit\u0027.",
    "Actually, this does work with files that are simply read-only. The Resource/SCM layer provides a default validateEdit handler if no SCM is configured for the project. You will get prompted to make the file writable if it\u0027s read-only and a Shell is passed in. If no Shell is passed it, it simply fails.\n",
    "The Project preferences mechanism does call validateEditor (ProjectPreferences#save). The problem is that we don\u0027t have access to a Shell at this level.  When validateEdit is called with no shell, it doesn\u0027t prompt the user.  Michael, perhaps DefaultUIFileModificationValidator could search for a shell via IWorkbench.getActiveWorkbenchWindow() if the provided context is null?",
    "The problem is that the spec for validateEdit states that the lack of a shell means that no prompt will occur. If we look for a shell and prompt, we would break the spec. \n\nThere are two things happening here that are questionable. Firstly, the JDT preferences are being written on a build. Generally, preferences should only be saved as a reult of a user initiated actions (which would have access to a Shell). It would be useful to know why the JDT builder is modifying the preferences.\n\nSecondly, the validateEdit mechanism is really used for shared projects. I would be curious to know why you are making a non-shared project read-only? Are you just testing out of curiousity or do you have a scenario that requires this to work? In comment 5, the Peforce repository provider is mentioned. It should be possible for a repository provider to perform the checkout in the absence of a shell (i.e. it shouldn\u0027t need to prompt the user). CVS should work in this scenario. Are you seeing failures with Perforce?",
    "I agree that preferences should not be written on build. Based on what I am seeing with writable projects, the contents of the file do not actually change, so there just might be an optimization check missing.\n\nAs far as the scenario questions regarding Perforce usage.\n\n1. The particular error happens too fast after the import (assuming auto-build is enabled) to allow the user the chance to configure the SCM options for the project.\n\n2. The Perforce SCM plugins are very poor in quality, so what a lot of people who work with Perforce in Eclipse end up doing is letting Eclipse treat the project is as simply read-only. After the necessary changes, you run an external tool that checks for changes and builds the delta to send to the repository. This works flawlessly with the editors. Support of this in project metadata / project properties is spotty. Some code calls validateEdit correctly. Some does not. ",
    "The error is not happening during or as a side-effect of a build.  When a project is first created we start a background refresh job to discover the project contents.  It\u0027s this job that is causing the file to be written.  However, it looks like the file is being written in error. \n\nDJ, it looks like reading the project preference file causes the file to be rewritten.  Here is the stack trace:\n\norg.osgi.service.prefs.BackingStoreException: Exception occurred while saving project preferences: /jtest2/.settings/org.eclipse.jdt.core.prefs.\nat org.eclipse.core.internal.resources.ProjectPreferences.save(ProjectPreferences.java:327)\nat org.eclipse.core.internal.preferences.EclipsePreferences.flush(EclipsePreferences.java:352)\nat org.eclipse.core.internal.resources.ProjectPreferences.flush(ProjectPreferences.java:566)\nat org.eclipse.core.internal.preferences.PreferencesService.applyPreferences(PreferencesService.java:172)\nat org.eclipse.core.internal.resources.ProjectPreferences.read(ProjectPreferences.java:394)\nat org.eclipse.core.internal.resources.ProjectPreferences.updatePreferences(ProjectPreferences.java:416)\nat org.eclipse.core.internal.resources.File.updateMetadataFiles(File.java:408)\nat org.eclipse.core.internal.localstore.RefreshLocalVisitor.visit(RefreshLocalVisitor.java:294)\nat org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:93)\nat org.eclipse.core.internal.localstore.FileSystemResourceManager.refreshResource(FileSystemResourceManager.java:697)\nat org.eclipse.core.internal.localstore.FileSystemResourceManager.refresh(FileSystemResourceManager.java:681)\nat org.eclipse.core.internal.resources.Resource.refreshLocal(Resource.java:1400)\nat org.eclipse.core.internal.refresh.RefreshJob.runInWorkspace(RefreshJob.java:141)\nat org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:38)\nat org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)",
    "To clarify some ambiguities in the steps to reproduce:\n\n1) \"Enable project-level JDT preferences\" - This step doesn\u0027t say which preferences.  I couldn\u0027t reproduce by just setting Java compiler preferences, but when I set all preferences under \"Java Code Style\" and \"Java Compiler\" as project-specific, I got the error.\n\n4) Import using \"Import existing project\"",
    "I get the same error with these steps:\n\n1) Enable project-specific JDT preferences\n2) Make the preference file read-only\n3) try to change a project-specific preference in that project.\n\nSo the same error occurs even when the preferences are explicitly changed from the project properties page.  Even though it starts in the UI, it calls a runtime-level API to save the preferences.  So, there is no way to pass in a context shell.  Michael is correct that the validateEdit spec quite clearly states prompting should NOT occur if no context shell is provided.",
    "Right. That\u0027s a fundamental problem with the validateEdit api. Project metadata files tend to be modified deep inside the guts of \"core\" (non-api) code. This means that access to the Shell is unlikely.\n\nThere are basically two solutions for this:\n\n1. Follow the pattern established by validateEdit and punch a whole through the api layer into which the Shell can be dropped as an Object. This can be done in a pure additive fashion to not break existing api.\n\n2. Pre-emptively call validateEdit from the ui code with Shell prior to calling into the api that you know will modify the file. The disadvantage is that the ui code will now have to have the knowledge of which files the api is writing. The advantage is that you don\u0027t have to change any api.",
    "My preference would be point 2. This could be made easier for clients by adding API that would return a change description that contained the set of files that would be modified as the result of a set of preference changes. Clients could then run validateEdit on the files that would be affected.",
    "Point 2 is unrealistic. That requires the UI code to have knowledge about the implementation of the core code. Mostly it\u0027s an implementation detail how and where (and if) things are stored.",
    "The problem is that, as unrealistic as point 2 seems, point 1 is probably more unrealistic since the preference mechanism does not depend on Resources and hence has no knowledge of validateEdit. Regardless of the approach taken, the UI client will need to know that there is a possibility that workspace resources may be affected. It is really only a matter of deciding what they need to do to ensure that validateEdit gets called with a shell.\n\nAnother approach we could take is to add a preference that would make the default validator for unshared projects automatically make a file writtable if no Shell is provided. It would be off by default but users could enable it to avoid this type of failure. If we wanted to be fancy, we could even specify a list of file types for which the prefernece applies. Of course, we couldn\u0027t make it a project preference since the user wouldn\u0027t be able to set it if the file was read-only;-)",
    "I would try to fix validateEdit to change the behaviour when no context has been passed in (deprecate it, create a new one).\nThere are quite a few usages of validateEdit of null these calles are made in core, and hasn\u0027t been thought of passing a context in.\nMaybe UI can set a shell provider for a particular thread (e.g. by using a special Runnable)\n",
    "There isn\u0027t time in 3.2 to redesign validateEdit, but here are two thoughts for what we can do in the short term:\n\n - This particular use case is that the project has just been created and the user hasn\u0027t had a chance to associate it with a team provider yet.  In this case, it should not be attempted to rewrite the preference file it has just finished reading. This should be fixed, if only for the performance win of avoiding writing files unnecessarily.  If it is fixed, I think it will allow the user to associate the project with a repository without getting errors.\n\n - Another short term solution is for the project preference mechanism to just make the file writable rather than failing when there is no team provider.  Ostensibly these files are metadata that is \"owned\" by the preference mechanism, so it\u0027s not unreasonable for it to just clear the read-only bit and write the file.",
    "Fix released.  We no longer attempt to write the preference file when we have just finished reading it.  This fixes the case of importing read-only projects, and provides a performance enhancement for every time project preferences are loaded from disk.",
    "No longer seeing this particular problem. Closing. "
  ],
  "commentCreationDates": [
    "2006-03-03T04:35:15+01:00",
    "2006-03-03T18:33:37+01:00",
    "2006-03-03T18:36:48+01:00",
    "2006-03-06T16:09:20+01:00",
    "2006-03-07T10:32:45+01:00",
    "2006-03-07T14:33:14+01:00",
    "2006-03-07T14:42:32+01:00",
    "2006-03-07T14:46:58+01:00",
    "2006-03-07T16:58:43+01:00",
    "2006-03-07T17:27:22+01:00",
    "2006-03-07T17:50:04+01:00",
    "2006-03-07T21:54:43+01:00",
    "2006-03-07T21:57:07+01:00",
    "2006-03-07T22:08:36+01:00",
    "2006-03-07T22:18:35+01:00",
    "2006-03-08T13:32:43+01:00",
    "2006-03-08T13:48:46+01:00",
    "2006-03-08T14:31:53+01:00",
    "2006-03-08T15:01:10+01:00",
    "2006-03-09T15:05:06+01:00",
    "2006-04-21T22:30:34+02:00",
    "2006-10-13T18:52:44+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.osgi.service.prefs.BackingStoreException",
      "message": "Exception occurred while saving project preferences: /jtest2/.settings/org.eclipse.jdt.core.prefs.",
      "elements": [
        {
          "method": "org.eclipse.core.internal.resources.ProjectPreferences.save",
          "source": "ProjectPreferences.java:327"
        },
        {
          "method": "org.eclipse.core.internal.preferences.EclipsePreferences.flush",
          "source": "EclipsePreferences.java:352"
        },
        {
          "method": "org.eclipse.core.internal.resources.ProjectPreferences.flush",
          "source": "ProjectPreferences.java:566"
        },
        {
          "method": "org.eclipse.core.internal.preferences.PreferencesService.applyPreferences",
          "source": "PreferencesService.java:172"
        },
        {
          "method": "org.eclipse.core.internal.resources.ProjectPreferences.read",
          "source": "ProjectPreferences.java:394"
        },
        {
          "method": "org.eclipse.core.internal.resources.ProjectPreferences.updatePreferences",
          "source": "ProjectPreferences.java:416"
        },
        {
          "method": "org.eclipse.core.internal.resources.File.updateMetadataFiles",
          "source": "File.java:408"
        },
        {
          "method": "org.eclipse.core.internal.localstore.RefreshLocalVisitor.visit",
          "source": "RefreshLocalVisitor.java:294"
        },
        {
          "method": "org.eclipse.core.internal.localstore.UnifiedTree.accept",
          "source": "UnifiedTree.java:93"
        },
        {
          "method": "org.eclipse.core.internal.localstore.FileSystemResourceManager.refreshResource",
          "source": "FileSystemResourceManager.java:697"
        },
        {
          "method": "org.eclipse.core.internal.localstore.FileSystemResourceManager.refresh",
          "source": "FileSystemResourceManager.java:681"
        },
        {
          "method": "org.eclipse.core.internal.resources.Resource.refreshLocal",
          "source": "Resource.java:1400"
        },
        {
          "method": "org.eclipse.core.internal.refresh.RefreshJob.runInWorkspace",
          "source": "RefreshJob.java:141"
        },
        {
          "method": "org.eclipse.core.internal.resources.InternalWorkspaceJob.run",
          "source": "InternalWorkspaceJob.java:38"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 0,
      "commentIndex": 11,
      "bugId": "130266",
      "date": "2006-03-07T21:54:43+01:00",
      "product": "Platform",
      "component": "Resources",
      "severity": "normal"
    }
  ],
  "groupId": "130266",
  "bugId": "130266",
  "date": "2006-03-03T04:35:15+01:00",
  "product": "Platform",
  "component": "Resources",
  "severity": "normal"
}