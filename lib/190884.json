{
  "comments": [
    "when indexing the gcc source code the indexer stumbles on some files:\nError while parsing /tumples/gcc/genpreds.c.\n\njava.lang.ArrayIndexOutOfBoundsException\n\tat java.lang.System.arraycopy(Native Method)\n\tat org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.replaceArgumentMacros(BaseScanner.java:3519)\n\tat org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.expandFunctionStyleMacro(BaseScanner.java:3650)\n\tat org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.handleFunctionStyleMacro(BaseScanner.java:3429)\n\tat org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.scanIdentifier(BaseScanner.java:1123)\n\tat org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.fetchToken(BaseScanner.java:763)\n\tat org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.doFetchToken(BaseScanner.java:602)\n\tat org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.nextToken(BaseScanner.java:557)\n\tat org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser.fetchToken(AbstractGNUSourceCodeParser.java:257)\n\tat org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser.LA(AbstractGNUSourceCodeParser.java:184)\n\tat org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser.LT(AbstractGNUSourceCodeParser.java:204)\n\tat org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser.errorHandling(AbstractGNUSourceCodeParser.java:502)\n\tat org.eclipse.cdt.internal.core.dom.parser.c.GNUCSourceParser.translationUnit(GNUCSourceParser.java:649)\n\tat org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser.parse(AbstractGNUSourceCodeParser.java:445)\n\tat org.eclipse.cdt.core.dom.parser.c.AbstractCLanguage.getASTTranslationUnit(AbstractCLanguage.java:105)\n\tat org.eclipse.cdt.internal.core.pdom.indexer.fast.PDOMFastIndexerTask.createAST(PDOMFastIndexerTask.java:159)\n\tat org.eclipse.cdt.internal.core.pdom.indexer.PDOMIndexerTask.createAST(PDOMIndexerTask.java:166)\n\tat org.eclipse.cdt.internal.core.pdom.indexer.PDOMIndexerTask.parseTU(PDOMIndexerTask.java:291)\n\tat org.eclipse.cdt.internal.core.pdom.indexer.PDOMIndexerTask.internalParseTUs(PDOMIndexerTask.java:213)\n\tat org.eclipse.cdt.internal.core.pdom.indexer.PDOMIndexerTask.parseTUs(PDOMIndexerTask.java:189)\n\tat org.eclipse.cdt.internal.core.pdom.indexer.fast.PDOMFastIndexerTask.run(PDOMFastIndexerTask.java:102)\n\tat org.eclipse.cdt.internal.core.pdom.indexer.PDOMRebuildTask.run(PDOMRebuildTask.java:75)\n\tat org.eclipse.cdt.internal.core.pdom.PDOMIndexerJob.run(PDOMIndexerJob.java:89)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)\n\neclipse.buildId\u003dI20070517-1700\njava.version\u003d1.5.0_06\njava.vendor\u003dSun Microsystems Inc.\nBootLoader constants: OS\u003dlinux, ARCH\u003dx86, WS\u003dgtk, NL\u003den_US\nFramework arguments:  -startup /home/chrismatthews/Desktop/eclipse/plugins/org.eclipse.equinox.launcher_1.0.0.v20070516.jar\nCommand-line arguments:  -os linux -ws gtk -arch x86 -startup /home/chrismatthews/Desktop/eclipse/plugins/org.eclipse.equinox.launcher_1.0.0.v20070516.jar\n\nThe contents of the file:\n\n/* Generate from machine description:\n   - prototype declarations for operand predicates (tm-preds.h)\n   - function definitions of operand predicates, if defined new-style\n     (insn-preds.c)\n   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 51 Franklin Street, Fifth Floor,\nBoston, MA 02110-1301, USA.  */\n\n#include \"bconfig.h\"\n#include \"system.h\"\n#include \"coretypes.h\"\n#include \"tm.h\"\n#include \"rtl.h\"\n#include \"errors.h\"\n#include \"obstack.h\"\n#include \"gensupport.h\"\n\n/* Given a predicate expression EXP, from form NAME at line LINENO,\n   verify that it does not contain any RTL constructs which are not\n   valid in predicate definitions.  Returns true if EXP is\n   INvalid; issues error messages, caller need not.  */\nstatic bool\nvalidate_exp (rtx exp, const char *name, int lineno)\n{\n  if (exp \u003d\u003d 0)\n    {\n      message_with_line (lineno, \"%s: must give a predicate expression\", name);\n      return true;\n    }\n\n  switch (GET_CODE (exp))\n    {\n      /* Ternary, binary, unary expressions: recurse into subexpressions.  */\n    case IF_THEN_ELSE:\n      if (validate_exp (XEXP (exp, 2), name, lineno))\n\treturn true;\n      /* else fall through */\n    case AND:\n    case IOR:\n      if (validate_exp (XEXP (exp, 1), name, lineno))\n\treturn true;\n      /* else fall through */\n    case NOT:\n      return validate_exp (XEXP (exp, 0), name, lineno);\n\n      /* MATCH_CODE might have a syntax error in its path expression.  */\n    case MATCH_CODE:\n      {\n\tconst char *p;\n\tfor (p \u003d XSTR (exp, 1); *p; p++)\n\t  {\n\t    if (!ISDIGIT (*p) \u0026\u0026 !ISLOWER (*p))\n\t      {\n\t\tmessage_with_line (lineno, \"%s: invalid character in path \"\n\t\t\t\t   \"string \u0027%s\u0027\", name, XSTR (exp, 1));\n\t\thave_error \u003d 1;\n\t\treturn true;\n\t      }\n\t  }\n      }\n      /* fall through */\n\n      /* These need no special checking.  */\n    case MATCH_OPERAND:\n    case MATCH_TEST:\n      return false;\n\n    default:\n      message_with_line (lineno,\n\t\t\t \"%s: cannot use \u0027%s\u0027 in a predicate expression\",\n\t\t\t name, GET_RTX_NAME (GET_CODE (exp)));\n      have_error \u003d 1;\n      return true;\n    }\n}\n\n/* Predicates are defined with (define_predicate) or\n   (define_special_predicate) expressions in the machine description.  */\nstatic void\nprocess_define_predicate (rtx defn, int lineno)\n{\n  struct pred_data *pred;\n  const char *p;\n\n  if (!ISALPHA (XSTR (defn, 0)[0]) \u0026\u0026 XSTR (defn, 0)[0] !\u003d \u0027_\u0027)\n    goto bad_name;\n  for (p \u003d XSTR (defn, 0) + 1; *p; p++)\n    if (!ISALNUM (*p) \u0026\u0026 *p !\u003d \u0027_\u0027)\n      goto bad_name;\n  \n  if (validate_exp (XEXP (defn, 1), XSTR (defn, 0), lineno))\n    return;\n\n  pred \u003d XCNEW (struct pred_data);\n  pred-\u003ename \u003d XSTR (defn, 0);\n  pred-\u003eexp \u003d XEXP (defn, 1);\n  pred-\u003ec_block \u003d XSTR (defn, 2);\n\n  if (GET_CODE (defn) \u003d\u003d DEFINE_SPECIAL_PREDICATE)\n    pred-\u003especial \u003d true;\n\n  add_predicate (pred);\n  return;\n\n bad_name:\n  message_with_line (lineno,\n\t\t     \"%s: predicate name must be a valid C function name\",\n\t\t     XSTR (defn, 0));\n  have_error \u003d 1;\n  return;\n}\n\n/* Given a predicate, if it has an embedded C block, write the block\n   out as a static inline subroutine, and augment the RTL test with a\n   match_test that calls that subroutine.  For instance,\n\n       (define_predicate \"basereg_operand\"\n         (match_operand 0 \"register_operand\")\n       {\n         if (GET_CODE (op) \u003d\u003d SUBREG)\n           op \u003d SUBREG_REG (op);\n         return REG_POINTER (op);\n       })\n\n   becomes\n\n       static inline int basereg_operand_1(rtx op, enum machine_mode mode)\n       {\n         if (GET_CODE (op) \u003d\u003d SUBREG)\n           op \u003d SUBREG_REG (op);\n         return REG_POINTER (op);\n       }\n\n       (define_predicate \"basereg_operand\"\n         (and (match_operand 0 \"register_operand\")\n\t      (match_test \"basereg_operand_1 (op, mode)\")))\n\n   The only wart is that there\u0027s no way to insist on a { } string in\n   an RTL template, so we have to handle \"\" strings.  */\n\n   \nstatic void\nwrite_predicate_subfunction (struct pred_data *p)\n{\n  const char *match_test_str;\n  rtx match_test_exp, and_exp;\n\n  if (p-\u003ec_block[0] \u003d\u003d \u0027\\0\u0027)\n    return;\n\n  /* Construct the function-call expression.  */\n  obstack_grow (rtl_obstack, p-\u003ename, strlen (p-\u003ename));\n  obstack_grow (rtl_obstack, \"_1 (op, mode)\",\n\t\tsizeof \"_1 (op, mode)\");\n  match_test_str \u003d XOBFINISH (rtl_obstack, const char *);\n\n  /* Add the function-call expression to the complete expression to be\n     evaluated.  */\n  match_test_exp \u003d rtx_alloc (MATCH_TEST);\n  XSTR (match_test_exp, 0) \u003d match_test_str;\n\n  and_exp \u003d rtx_alloc (AND);\n  XEXP (and_exp, 0) \u003d p-\u003eexp;\n  XEXP (and_exp, 1) \u003d match_test_exp;\n\n  p-\u003eexp \u003d and_exp;\n\n  printf (\"static inline int\\n\"\n\t  \"%s_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\\n\",\n\t  p-\u003ename);\n  print_rtx_ptr_loc (p-\u003ec_block);\n  if (p-\u003ec_block[0] \u003d\u003d \u0027{\u0027)\n    fputs (p-\u003ec_block, stdout);\n  else\n    printf (\"{\\n  %s\\n}\", p-\u003ec_block);\n  fputs (\"\\n\\n\", stdout);\n}\n\n/* Given a predicate expression EXP, from form NAME, determine whether\n   it refers to the variable given as VAR.  */\nstatic bool\nneeds_variable (rtx exp, const char *var)\n{\n  switch (GET_CODE (exp))\n    {\n      /* Ternary, binary, unary expressions need a variable if\n\t any of their subexpressions do.  */\n    case IF_THEN_ELSE:\n      if (needs_variable (XEXP (exp, 2), var))\n\treturn true;\n      /* else fall through */\n    case AND:\n    case IOR:\n      if (needs_variable (XEXP (exp, 1), var))\n\treturn true;\n      /* else fall through */\n    case NOT:\n      return needs_variable (XEXP (exp, 0), var);\n\n      /* MATCH_CODE uses \"op\", but nothing else.  */\n    case MATCH_CODE:\n      return !strcmp (var, \"op\");\n\n      /* MATCH_OPERAND uses \"op\" and may use \"mode\".  */\n    case MATCH_OPERAND:\n      if (!strcmp (var, \"op\"))\n\treturn true;\n      if (!strcmp (var, \"mode\") \u0026\u0026 GET_MODE (exp) \u003d\u003d VOIDmode)\n\treturn true;\n      return false;\n\n      /* MATCH_TEST uses var if XSTR (exp, 0) \u003d~ /\\b${var}\\b/o; */\n    case MATCH_TEST:\n      {\n\tconst char *p \u003d XSTR (exp, 0);\n\tconst char *q \u003d strstr (p, var);\n\tif (!q)\n\t  return false;\n\tif (q !\u003d p \u0026\u0026 (ISALNUM (q[-1]) || q[-1] \u003d\u003d \u0027_\u0027))\n\t  return false;\n\tq +\u003d strlen (var);\n\tif (ISALNUM (q[0] || q[0] \u003d\u003d \u0027_\u0027))\n\t  return false;\n      }\n      return true;\n\n    default:\n      gcc_unreachable ();\n    }\n}\n\n/* Given an RTL expression EXP, find all subexpressions which we may\n   assume to perform mode tests.  Normal MATCH_OPERAND does;\n   MATCH_CODE does if it applies to the whole expression and accepts\n   CONST_INT or CONST_DOUBLE; and we have to assume that MATCH_TEST\n   does not.  These combine in almost-boolean fashion - the only\n   exception is that (not X) must be assumed not to perform a mode\n   test, whether or not X does.\n\n   The mark is the RTL /v flag, which is true for subexpressions which\n   do *not* perform mode tests.\n*/\n#define NO_MODE_TEST(EXP) RTX_FLAG (EXP, volatil)\nstatic void\nmark_mode_tests (rtx exp)\n{\n  switch (GET_CODE (exp))\n    {\n    case MATCH_OPERAND:\n      {\n\tstruct pred_data *p \u003d lookup_predicate (XSTR (exp, 1));\n\tif (!p)\n\t  error (\"reference to undefined predicate \u0027%s\u0027\", XSTR (exp, 1));\n\telse if (p-\u003especial || GET_MODE (exp) !\u003d VOIDmode)\n\t  NO_MODE_TEST (exp) \u003d 1;\n      }\n      break;\n\n    case MATCH_CODE:\n      if (XSTR (exp, 1)[0] !\u003d \u0027\\0\u0027\n\t  || (!strstr (XSTR (exp, 0), \"const_int\")\n\t      \u0026\u0026 !strstr (XSTR (exp, 0), \"const_double\")))\n\tNO_MODE_TEST (exp) \u003d 1;\n      break;\n\n    case MATCH_TEST:\n    case NOT:\n      NO_MODE_TEST (exp) \u003d 1;\n      break;\n\n    case AND:\n      mark_mode_tests (XEXP (exp, 0));\n      mark_mode_tests (XEXP (exp, 1));\n\n      NO_MODE_TEST (exp) \u003d (NO_MODE_TEST (XEXP (exp, 0))\n\t\t\t    \u0026\u0026 NO_MODE_TEST (XEXP (exp, 1)));\n      break;\n      \n    case IOR:\n      mark_mode_tests (XEXP (exp, 0));\n      mark_mode_tests (XEXP (exp, 1));\n\n      NO_MODE_TEST (exp) \u003d (NO_MODE_TEST (XEXP (exp, 0))\n\t\t\t    || NO_MODE_TEST (XEXP (exp, 1)));\n      break;\n\n    case IF_THEN_ELSE:\n      /* A ? B : C does a mode test if (one of A and B) does a mode\n\t test, and C does too.  */\n      mark_mode_tests (XEXP (exp, 0));\n      mark_mode_tests (XEXP (exp, 1));\n      mark_mode_tests (XEXP (exp, 2));\n\n      NO_MODE_TEST (exp) \u003d ((NO_MODE_TEST (XEXP (exp, 0))\n\t\t\t     \u0026\u0026 NO_MODE_TEST (XEXP (exp, 1)))\n\t\t\t    || NO_MODE_TEST (XEXP (exp, 2)));\n      break;\n\n    default:\n      gcc_unreachable ();\n    }\n}\n\n/* Determine whether the expression EXP is a MATCH_CODE that should\n   be written as a switch statement.  */\nstatic bool\ngenerate_switch_p (rtx exp)\n{\n  return GET_CODE (exp) \u003d\u003d MATCH_CODE\n\t \u0026\u0026 strchr (XSTR (exp, 0), \u0027,\u0027);\n}\n\n/* Given a predicate, work out where in its RTL expression to add\n   tests for proper modes.  Special predicates do not get any such\n   tests.  We try to avoid adding tests when we don\u0027t have to; in\n   particular, other normal predicates can be counted on to do it for\n   us.  */\n\nstatic void\nadd_mode_tests (struct pred_data *p)\n{\n  rtx match_test_exp, and_exp;\n  rtx *pos;\n\n  /* Don\u0027t touch special predicates.  */\n  if (p-\u003especial)\n    return;\n\n  mark_mode_tests (p-\u003eexp);\n\n  /* If the whole expression already tests the mode, we\u0027re done.  */\n  if (!NO_MODE_TEST (p-\u003eexp))\n    return;\n\n  match_test_exp \u003d rtx_alloc (MATCH_TEST);\n  XSTR (match_test_exp, 0) \u003d \"mode \u003d\u003d VOIDmode || GET_MODE (op) \u003d\u003d mode\";\n  and_exp \u003d rtx_alloc (AND);\n  XEXP (and_exp, 1) \u003d match_test_exp;\n\n  /* It is always correct to rewrite p-\u003eexp as\n\n        (and (...) (match_test \"mode \u003d\u003d VOIDmode || GET_MODE (op) \u003d\u003d mode\"))\n\n     but there are a couple forms where we can do better.  If the\n     top-level pattern is an IOR, and one of the two branches does test\n     the mode, we can wrap just the branch that doesn\u0027t.  Likewise, if\n     we have an IF_THEN_ELSE, and one side of it tests the mode, we can\n     wrap just the side that doesn\u0027t.  And, of course, we can repeat this\n     descent as many times as it works.  */\n\n  pos \u003d \u0026p-\u003eexp;\n  for (;;)\n    {\n      rtx subexp \u003d *pos;\n\n      switch (GET_CODE (subexp))\n\t{\n\tcase AND:\n\t  /* The switch code generation in write_predicate_stmts prefers\n\t     rtx code tests to be at the top of the expression tree.  So\n\t     push this AND down into the second operand of an existing\n\t     AND expression.  */\n\t  if (generate_switch_p (XEXP (subexp, 0)))\n\t    pos \u003d \u0026XEXP (subexp, 1);\n\t  goto break_loop;\n\n\tcase IOR:\n\t  {\n\t    int test0 \u003d NO_MODE_TEST (XEXP (subexp, 0));\n\t    int test1 \u003d NO_MODE_TEST (XEXP (subexp, 1));\n\t    \n\t    gcc_assert (test0 || test1);\n\t    \n\t    if (test0 \u0026\u0026 test1)\n\t      goto break_loop;\n\t    pos \u003d test0 ? \u0026XEXP (subexp, 0) : \u0026XEXP (subexp, 1);\n\t  }\n\t  break;\n\t  \n\tcase IF_THEN_ELSE:\n\t  {\n\t    int test0 \u003d NO_MODE_TEST (XEXP (subexp, 0));\n\t    int test1 \u003d NO_MODE_TEST (XEXP (subexp, 1));\n\t    int test2 \u003d NO_MODE_TEST (XEXP (subexp, 2));\n\t    \n\t    gcc_assert ((test0 \u0026\u0026 test1) || test2);\n\t    \n\t    if (test0 \u0026\u0026 test1 \u0026\u0026 test2)\n\t      goto break_loop;\n\t    if (test0 \u0026\u0026 test1)\n\t      /* Must put it on the dependent clause, not the\n\t      \t controlling expression, or we change the meaning of\n\t      \t the test.  */\n\t      pos \u003d \u0026XEXP (subexp, 1);\n\t    else\n\t      pos \u003d \u0026XEXP (subexp, 2);\n\t  }\n\t  break;\n\t  \n\tdefault:\n\t  goto break_loop;\n\t}\n    }\n break_loop:\n  XEXP (and_exp, 0) \u003d *pos;\n  *pos \u003d and_exp;\n}\n\n/* PATH is a string describing a path from the root of an RTL\n   expression to an inner subexpression to be tested.  Output\n   code which computes the subexpression from the variable\n   holding the root of the expression.  */\nstatic void\nwrite_extract_subexp (const char *path)\n{\n  int len \u003d strlen (path);\n  int i;\n\n  /* We first write out the operations (XEXP or XVECEXP) in reverse\n     order, then write \"op\", then the indices in forward order.  */\n  for (i \u003d len - 1; i \u003e\u003d 0; i--)\n    {\n      if (ISLOWER (path[i]))\n\tfputs (\"XVECEXP (\", stdout);\n      else if (ISDIGIT (path[i]))\n\tfputs (\"XEXP (\", stdout);\n      else\n\tgcc_unreachable ();\n    }\n\n  fputs (\"op\", stdout);\n\n  for (i \u003d 0; i \u003c len; i++)\n    {\n      if (ISLOWER (path[i]))\n\tprintf (\", 0, %d)\", path[i] - \u0027a\u0027);\n      else if (ISDIGIT (path[i]))\n\tprintf (\", %d)\", path[i] - \u00270\u0027);\n      else\n\tgcc_unreachable ();\n    }\n}\n\n/* CODES is a list of RTX codes.  Write out an expression which\n   determines whether the operand has one of those codes.  */\nstatic void\nwrite_match_code (const char *path, const char *codes)\n{\n  const char *code;\n\n  while ((code \u003d scan_comma_elt (\u0026codes)) !\u003d 0)\n    {\n      fputs (\"GET_CODE (\", stdout);\n      write_extract_subexp (path);\n      fputs (\") \u003d\u003d \", stdout);\n      while (code \u003c codes)\n\t{\n\t  putchar (TOUPPER (*code));\n\t  code++;\n\t}\n      \n      if (*codes \u003d\u003d \u0027,\u0027)\n\tfputs (\" || \", stdout);\n    }\n}\n\n/* EXP is an RTL (sub)expression for a predicate.  Recursively\n   descend the expression and write out an equivalent C expression.  */\nstatic void\nwrite_predicate_expr (rtx exp)\n{\n  switch (GET_CODE (exp))\n    {\n    case AND:\n      putchar (\u0027(\u0027);\n      write_predicate_expr (XEXP (exp, 0));\n      fputs (\") \u0026\u0026 (\", stdout);\n      write_predicate_expr (XEXP (exp, 1));\n      putchar (\u0027)\u0027);\n      break;\n  \n    case IOR:\n      putchar (\u0027(\u0027);\n      write_predicate_expr (XEXP (exp, 0));\n      fputs (\") || (\", stdout);\n      write_predicate_expr (XEXP (exp, 1));\n      putchar (\u0027)\u0027);\n      break;\n\n    case NOT:\n      fputs (\"!(\", stdout);\n      write_predicate_expr (XEXP (exp, 0));\n      putchar (\u0027)\u0027);\n      break;\n\n    case IF_THEN_ELSE:\n      putchar (\u0027(\u0027);\n      write_predicate_expr (XEXP (exp, 0));\n      fputs (\") ? (\", stdout);\n      write_predicate_expr (XEXP (exp, 1));\n      fputs (\") : (\", stdout);\n      write_predicate_expr (XEXP (exp, 2));\n      putchar (\u0027)\u0027);\n      break;\n\n    case MATCH_OPERAND:\n      if (GET_MODE (exp) \u003d\u003d VOIDmode)\n        printf (\"%s (op, mode)\", XSTR (exp, 1));\n      else\n        printf (\"%s (op, %smode)\", XSTR (exp, 1), mode_name[GET_MODE (exp)]);\n      break;\n\n    case MATCH_CODE:\n      write_match_code (XSTR (exp, 1), XSTR (exp, 0));\n      break;\n\n    case MATCH_TEST:\n      print_c_condition (XSTR (exp, 0));\n      break;\n\n    default:\n      gcc_unreachable ();\n    }\n}\n\n/* Write the MATCH_CODE expression EXP as a switch statement.  */\n\nstatic void\nwrite_match_code_switch (rtx exp)\n{\n  const char *codes \u003d XSTR (exp, 0);\n  const char *path \u003d XSTR (exp, 1);\n  const char *code;\n\n  fputs (\"  switch (GET_CODE (\", stdout);\n  write_extract_subexp (path);\n  fputs (\"))\\n    {\\n\", stdout);\n\n  while ((code \u003d scan_comma_elt (\u0026codes)) !\u003d 0)\n    {\n      fputs (\"    case \", stdout);\n      while (code \u003c codes)\n\t{\n\t  putchar (TOUPPER (*code));\n\t  code++;\n\t}\n      fputs(\":\\n\", stdout);\n    }\n}\n\n/* Given a predicate expression EXP, write out a sequence of stmts\n   to evaluate it.  This is similar to write_predicate_expr but can\n   generate efficient switch statements.  */\n\nstatic void\nwrite_predicate_stmts (rtx exp)\n{\n  switch (GET_CODE (exp))\n    {\n    case MATCH_CODE:\n      if (generate_switch_p (exp))\n\t{\n\t  write_match_code_switch (exp);\n\t  puts (\"      return true;\\n\"\n\t\t\"    default:\\n\"\n\t\t\"      break;\\n\"\n\t\t\"    }\\n\"\n\t\t\"  return false;\");\n\t  return;\n\t}\n      break;\n\n    case AND:\n      if (generate_switch_p (XEXP (exp, 0)))\n\t{\n\t  write_match_code_switch (XEXP (exp, 0));\n\t  puts (\"      break;\\n\"\n\t\t\"    default:\\n\"\n\t\t\"      return false;\\n\"\n\t\t\"    }\");\n\t  exp \u003d XEXP (exp, 1);\n\t}\n      break;\n\n    case IOR:\n      if (generate_switch_p (XEXP (exp, 0)))\n\t{\n\t  write_match_code_switch (XEXP (exp, 0));\n\t  puts (\"      return true;\\n\"\n\t\t\"    default:\\n\"\n\t\t\"      break;\\n\"\n\t\t\"    }\");\n\t  exp \u003d XEXP (exp, 1);\n\t}\n      break;\n\n    case NOT:\n      if (generate_switch_p (XEXP (exp, 0)))\n\t{\n\t  write_match_code_switch (XEXP (exp, 0));\n\t  puts (\"      return false;\\n\"\n\t\t\"    default:\\n\"\n\t\t\"      break;\\n\"\n\t\t\"    }\\n\"\n\t\t\"  return true;\");\n\t  return;\n\t}\n      break;\n\n    default:\n      break;\n    }\n\n  fputs(\"  return \",stdout);\n  write_predicate_expr (exp);\n  fputs(\";\\n\", stdout);\n}\n\n/* Given a predicate, write out a complete C function to compute it.  */\nstatic void\nwrite_one_predicate_function (struct pred_data *p)\n{\n  if (!p-\u003eexp)\n    return;\n\n  write_predicate_subfunction (p);\n  add_mode_tests (p);\n\n  /* A normal predicate can legitimately not look at enum machine_mode\n     if it accepts only CONST_INTs and/or CONST_DOUBLEs.  */\n  printf (\"int\\n%s (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\\n{\\n\",\n\t  p-\u003ename);\n  write_predicate_stmts (p-\u003eexp);\n  fputs (\"}\\n\\n\", stdout);\n}\n\n/* Constraints fall into two categories: register constraints\n   (define_register_constraint), and others (define_constraint,\n   define_memory_constraint, define_address_constraint).  We\n   work out automatically which of the various old-style macros\n   they correspond to, and produce appropriate code.  They all\n   go in the same hash table so we can verify that there are no\n   duplicate names.  */\n\n/* All data from one constraint definition.  */\nstruct constraint_data\n{\n  struct constraint_data *next_this_letter;\n  struct constraint_data *next_textual;\n  const char *name;\n  const char *c_name;    /* same as .name unless mangling is necessary */\n  size_t namelen;\n  const char *regclass;  /* for register constraints */\n  rtx exp;               /* for other constraints */\n  unsigned int lineno;   /* line of definition */\n  unsigned int is_register  : 1;\n  unsigned int is_const_int : 1;\n  unsigned int is_const_dbl : 1;\n  unsigned int is_extra     : 1;\n  unsigned int is_memory    : 1;\n  unsigned int is_address   : 1;\n};\n\n/* Overview of all constraints beginning with a given letter.  */\n\nstatic struct constraint_data *\nconstraints_by_letter_table[1\u003c\u003cCHAR_BIT];\n\n/* For looking up all the constraints in the order that they appeared\n   in the machine description.  */\nstatic struct constraint_data *first_constraint;\nstatic struct constraint_data **last_constraint_ptr \u003d \u0026first_constraint;\n\n#define FOR_ALL_CONSTRAINTS(iter_) \\\n  for (iter_ \u003d first_constraint; iter_; iter_ \u003d iter_-\u003enext_textual)\n\n/* These letters, and all names beginning with them, are reserved for\n   generic constraints.  */\nstatic const char generic_constraint_letters[] \u003d \"EFVXgimnoprs\";\n\n/* Machine-independent code expects that constraints with these\n   (initial) letters will allow only (a subset of all) CONST_INTs.  */\n\nstatic const char const_int_constraints[] \u003d \"IJKLMNOP\";\n\n/* Machine-independent code expects that constraints with these\n   (initial) letters will allow only (a subset of all) CONST_DOUBLEs.  */\n\nstatic const char const_dbl_constraints[] \u003d \"GH\";\n\n/* Summary data used to decide whether to output various functions and\n   macro definitions.  */\nstatic unsigned int constraint_max_namelen;\nstatic bool have_register_constraints;\nstatic bool have_memory_constraints;\nstatic bool have_address_constraints;\nstatic bool have_extra_constraints;\nstatic bool have_const_int_constraints;\nstatic bool have_const_dbl_constraints;\n\n/* Convert NAME, which contains angle brackets and/or underscores, to\n   a string that can be used as part of a C identifier.  The string\n   comes from the rtl_obstack.  */\nstatic const char *\nmangle (const char *name)\n{\n  for (; *name; name++)\n    switch (*name)\n      {\n      case \u0027_\u0027: obstack_grow (rtl_obstack, \"__\", 2); break;\n      case \u0027\u003c\u0027:\tobstack_grow (rtl_obstack, \"_l\", 2); break;\n      case \u0027\u003e\u0027:\tobstack_grow (rtl_obstack, \"_g\", 2); break;\n      default: obstack_1grow (rtl_obstack, *name); break;\n      }\n\n  obstack_1grow (rtl_obstack, \u0027\\0\u0027);\n  return obstack_finish (rtl_obstack);\n}\n\n/* Add one constraint, of any sort, to the tables.  NAME is its name;\n   REGCLASS is the register class, if any; EXP is the expression to\n   test, if any;  IS_MEMORY and IS_ADDRESS indicate memory and address\n   constraints, respectively; LINENO is the line number from the MD reader.\n   Not all combinations of arguments are valid; most importantly, REGCLASS\n   is mutually exclusive with EXP, and IS_MEMORY/IS_ADDRESS are only\n   meaningful for constraints with EXP.\n\n   This function enforces all syntactic and semantic rules about what\n   constraints can be defined.  */\n\nstatic void\nadd_constraint (const char *name, const char *regclass,\n\t\trtx exp, bool is_memory, bool is_address,\n\t\tint lineno)\n{\n  struct constraint_data *c, **iter, **slot;\n  const char *p;\n  bool need_mangled_name \u003d false;\n  bool is_const_int;\n  bool is_const_dbl;\n  size_t namelen;\n\n  if (exp \u0026\u0026 validate_exp (exp, name, lineno))\n    return;\n\n  if (!ISALPHA (name[0]) \u0026\u0026 name[0] !\u003d \u0027_\u0027)\n    {\n      if (name[1] \u003d\u003d \u0027\\0\u0027)\n\tmessage_with_line (lineno, \"constraint name \u0027%s\u0027 is not \"\n\t\t\t   \"a letter or underscore\", name);\n      else\n\tmessage_with_line (lineno, \"constraint name \u0027%s\u0027 does not begin \"\n\t\t\t   \"with a letter or underscore\", name);\n      have_error \u003d 1;\n      return;\n    }\n  for (p \u003d name; *p; p++)\n    if (!ISALNUM (*p))\n      {\n\tif (*p \u003d\u003d \u0027\u003c\u0027 || *p \u003d\u003d \u0027\u003e\u0027 || *p \u003d\u003d \u0027_\u0027)\n\t  need_mangled_name \u003d true;\n\telse\n\t  {\n\t    message_with_line (lineno,\n\t\t\t       \"constraint name \u0027%s\u0027 must be composed of \"\n\t\t\t       \"letters, digits, underscores, and \"\n\t\t\t       \"angle brackets\", name);\n\t    have_error \u003d 1;\n\t    return;\n\t  }\n      }\n\n  if (strchr (generic_constraint_letters, name[0]))\n    {\n      if (name[1] \u003d\u003d \u0027\\0\u0027)\n\tmessage_with_line (lineno, \"constraint letter \u0027%s\u0027 cannot be \"\n\t\t\t   \"redefined by the machine description\", name);\n      else\n\tmessage_with_line (lineno, \"constraint name \u0027%s\u0027 cannot be defined by \"\n\t\t\t   \"the machine description, as it begins with \u0027%c\u0027\",\n\t\t\t   name, name[0]);\n      have_error \u003d 1;\n      return;\n    }\n\n  \n  namelen \u003d strlen (name);\n  slot \u003d \u0026constraints_by_letter_table[(unsigned int)name[0]];\n  for (iter \u003d slot; *iter; iter \u003d \u0026(*iter)-\u003enext_this_letter)\n    {\n      /* This causes slot to end up pointing to the\n\t next_this_letter field of the last constraint with a name\n\t of equal or greater length than the new constraint; hence\n\t the new constraint will be inserted after all previous\n\t constraints with names of the same length.  */\n      if ((*iter)-\u003enamelen \u003e\u003d namelen)\n\tslot \u003d iter;\n\n      if (!strcmp ((*iter)-\u003ename, name))\n\t{\n\t  message_with_line (lineno, \"redefinition of constraint \u0027%s\u0027\", name);\n\t  message_with_line ((*iter)-\u003elineno, \"previous definition is here\");\n\t  have_error \u003d 1;\n\t  return;\n\t}\n      else if (!strncmp ((*iter)-\u003ename, name, (*iter)-\u003enamelen))\n\t{\n\t  message_with_line (lineno, \"defining constraint \u0027%s\u0027 here\", name);\n\t  message_with_line ((*iter)-\u003elineno, \"renders constraint \u0027%s\u0027 \"\n\t\t\t     \"(defined here) a prefix\", (*iter)-\u003ename);\n\t  have_error \u003d 1;\n\t  return;\n\t}\n      else if (!strncmp ((*iter)-\u003ename, name, namelen))\n\t{\n\t  message_with_line (lineno, \"constraint \u0027%s\u0027 is a prefix\", name);\n\t  message_with_line ((*iter)-\u003elineno, \"of constraint \u0027%s\u0027 \"\n\t\t\t     \"(defined here)\", (*iter)-\u003ename);\n\t  have_error \u003d 1;\n\t  return;\n\t}\n    }\n\n  is_const_int \u003d strchr (const_int_constraints, name[0]) !\u003d 0;\n  is_const_dbl \u003d strchr (const_dbl_constraints, name[0]) !\u003d 0;\n\n  if (is_const_int || is_const_dbl)\n    {\n      enum rtx_code appropriate_code\n\t\u003d is_const_int ? CONST_INT : CONST_DOUBLE;\n\n      /* Consider relaxing this requirement in the future.  */\n      if (regclass\n\t  || GET_CODE (exp) !\u003d AND\n\t  || GET_CODE (XEXP (exp, 0)) !\u003d MATCH_CODE\n\t  || strcmp (XSTR (XEXP (exp, 0), 0),\n\t\t     GET_RTX_NAME (appropriate_code)))\n\t{\n\t  if (name[1] \u003d\u003d \u0027\\0\u0027)\n\t    message_with_line (lineno, \"constraint letter \u0027%c\u0027 is reserved \"\n\t\t\t       \"for %s constraints\",\n\t\t\t       name[0], GET_RTX_NAME (appropriate_code));\n\t  else\n\t    message_with_line (lineno, \"constraint names beginning with \u0027%c\u0027 \"\n\t\t\t       \"(%s) are reserved for %s constraints\",\n\t\t\t       name[0], name, \n\t\t\t       GET_RTX_NAME (appropriate_code));\n\n\t  have_error \u003d 1;\n\t  return;\n\t}\n\n      if (is_memory)\n\t{\n\t  if (name[1] \u003d\u003d \u0027\\0\u0027)\n\t    message_with_line (lineno, \"constraint letter \u0027%c\u0027 cannot be a \"\n\t\t\t       \"memory constraint\", name[0]);\n\t  else\n\t    message_with_line (lineno, \"constraint name \u0027%s\u0027 begins with \u0027%c\u0027, \"\n\t\t\t       \"and therefore cannot be a memory constraint\",\n\t\t\t       name, name[0]);\n\n\t  have_error \u003d 1;\n\t  return;\n\t}\n      else if (is_address)\n\t{\n\t  if (name[1] \u003d\u003d \u0027\\0\u0027)\n\t    message_with_line (lineno, \"constraint letter \u0027%c\u0027 cannot be a \"\n\t\t\t       \"memory constraint\", name[0]);\n\t  else\n\t    message_with_line (lineno, \"constraint name \u0027%s\u0027 begins with \u0027%c\u0027, \"\n\t\t\t       \"and therefore cannot be a memory constraint\",\n\t\t\t       name, name[0]);\n\n\t  have_error \u003d 1;\n\t  return;\n\t}\n    }\n\n  \n  c \u003d obstack_alloc (rtl_obstack, sizeof (struct constraint_data));\n  c-\u003ename \u003d name;\n  c-\u003ec_name \u003d need_mangled_name ? mangle (name) : name;\n  c-\u003elineno \u003d lineno;\n  c-\u003enamelen \u003d namelen;\n  c-\u003eregclass \u003d regclass;\n  c-\u003eexp \u003d exp;\n  c-\u003eis_register \u003d regclass !\u003d 0;\n  c-\u003eis_const_int \u003d is_const_int;\n  c-\u003eis_const_dbl \u003d is_const_dbl;\n  c-\u003eis_extra \u003d !(regclass || is_const_int || is_const_dbl);\n  c-\u003eis_memory \u003d is_memory;\n  c-\u003eis_address \u003d is_address;\n\n  c-\u003enext_this_letter \u003d *slot;\n  *slot \u003d c;\n\n  /* Insert this constraint in the list of all constraints in textual\n     order.  */\n  c-\u003enext_textual \u003d 0;\n  *last_constraint_ptr \u003d c;\n  last_constraint_ptr \u003d \u0026c-\u003enext_textual;\n\n  constraint_max_namelen \u003d MAX (constraint_max_namelen, strlen (name));\n  have_register_constraints |\u003d c-\u003eis_register;\n  have_const_int_constraints |\u003d c-\u003eis_const_int;\n  have_const_dbl_constraints |\u003d c-\u003eis_const_dbl;\n  have_extra_constraints |\u003d c-\u003eis_extra;\n  have_memory_constraints |\u003d c-\u003eis_memory;\n  have_address_constraints |\u003d c-\u003eis_address;\n}\n\n/* Process a DEFINE_CONSTRAINT, DEFINE_MEMORY_CONSTRAINT, or\n   DEFINE_ADDRESS_CONSTRAINT expression, C.  */\nstatic void\nprocess_define_constraint (rtx c, int lineno)\n{\n  add_constraint (XSTR (c, 0), 0, XEXP (c, 2),\n\t\t  GET_CODE (c) \u003d\u003d DEFINE_MEMORY_CONSTRAINT,\n\t\t  GET_CODE (c) \u003d\u003d DEFINE_ADDRESS_CONSTRAINT,\n\t\t  lineno);\n}\n\n/* Process a DEFINE_REGISTER_CONSTRAINT expression, C.  */\nstatic void\nprocess_define_register_constraint (rtx c, int lineno)\n{\n  add_constraint (XSTR (c, 0), XSTR (c, 1), 0, false, false, lineno);\n}\n\n/* Write out an enumeration with one entry per machine-specific\n   constraint.  */\nstatic void\nwrite_enum_constraint_num (void)\n{\n  struct constraint_data *c;\n\n  fputs (\"enum constraint_num\\n\"\n\t \"{\\n\"\n\t \"  CONSTRAINT__UNKNOWN \u003d 0\", stdout);\n  FOR_ALL_CONSTRAINTS (c)\n    printf (\",\\n  CONSTRAINT_%s\", c-\u003ec_name);\n  puts (\"\\n};\\n\");\n}\n\n/* Write out a function which looks at a string and determines what\n   constraint name, if any, it begins with.  */\nstatic void\nwrite_lookup_constraint (void)\n{\n  unsigned int i;\n  puts (\"enum constraint_num\\n\"\n\t\"lookup_constraint (const char *str)\\n\"\n\t\"{\\n\"\n\t\"  switch (str[0])\\n\"\n\t\"    {\");\n\n  for (i \u003d 0; i \u003c ARRAY_SIZE(constraints_by_letter_table); i++)\n    {\n      struct constraint_data *c \u003d constraints_by_letter_table[i];\n      if (!c)\n\tcontinue;\n\n      printf (\"    case \u0027%c\u0027:\\n\", i);\n      if (c-\u003enamelen \u003d\u003d 1)\n\tprintf (\"      return CONSTRAINT_%s;\\n\", c-\u003ec_name);\n      else\n\t{\n\t  do\n\t    {\n\t      printf (\"      if (!strncmp (str, \\\"%s\\\", %lu))\\n\"\n\t\t      \"        return CONSTRAINT_%s;\\n\",\n\t\t      c-\u003ename, (unsigned long int) c-\u003enamelen, c-\u003ec_name);\n\t      c \u003d c-\u003enext_this_letter;\n\t    }\n\t  while (c);\n\t  puts (\"      break;\");\n\t}\n    }\n\n  puts (\"    default: break;\\n\"\n\t\"    }\\n\"\n\t\"  return CONSTRAINT__UNKNOWN;\\n\"\n\t\"}\\n\");\n}\n\n/* Write out a function which looks at a string and determines what\n   the constraint name length is.  */\nstatic void\nwrite_insn_constraint_len (void)\n{\n  unsigned int i;\n\n  puts (\"static inline size_t\\n\"\n\t\"insn_constraint_len (char fc, const char *str ATTRIBUTE_UNUSED)\\n\"\n\t\"{\\n\"\n\t\"  switch (fc)\\n\"\n\t\"    {\");\n\n  for (i \u003d 0; i \u003c ARRAY_SIZE(constraints_by_letter_table); i++)\n    {\n      struct constraint_data *c \u003d constraints_by_letter_table[i];\n\n      if (!c\n      \t  || c-\u003enamelen \u003d\u003d 1)\n\tcontinue;\n\n      /* Constraints with multiple characters should have the same\n\t length.  */\n      {\n\tstruct constraint_data *c2 \u003d c-\u003enext_this_letter;\n\tsize_t len \u003d c-\u003enamelen;\n\twhile (c2)\n\t  {\n\t    if (c2-\u003enamelen !\u003d len)\n\t      error (\"Multi-letter constraints with first letter \u0027%c\u0027 \"\n\t\t     \"should have same length\", i);\n\t    c2 \u003d c2-\u003enext_this_letter;\n\t  }\n      }\n\n      printf (\"    case \u0027%c\u0027: return %lu;\\n\",\n\t      i, (unsigned long int) c-\u003enamelen);\n    }\n\n  puts (\"    default: break;\\n\"\n\t\"    }\\n\"\n\t\"  return 1;\\n\"\n\t\"}\\n\");\n}\n  \n/* Write out the function which computes the register class corresponding\n   to a register constraint.  */\nstatic void\nwrite_regclass_for_constraint (void)\n{\n  struct constraint_data *c;\n\n  puts (\"enum reg_class\\n\"\n\t\"regclass_for_constraint (enum constraint_num c)\\n\"\n\t\"{\\n\"\n\t\"  switch (c)\\n\"\n\t\"    {\");\n\n  FOR_ALL_CONSTRAINTS (c)\n    if (c-\u003eis_register)\n      printf (\"    case CONSTRAINT_%s: return %s;\\n\", c-\u003ec_name, c-\u003eregclass);\n\n  puts (\"    default: break;\\n\"\n\t\"    }\\n\"\n\t\"  return NO_REGS;\\n\"\n\t\"}\\n\");\n}\n\n/* Write out the functions which compute whether a given value matches\n   a given non-register constraint.  */\nstatic void\nwrite_tm_constrs_h (void)\n{\n  struct constraint_data *c;\n\n  printf (\"\\\n/* Generated automatically by the program \u0027%s\u0027\\n\\\n   from the machine description file \u0027%s\u0027.  */\\n\\n\", progname, in_fname);\n\n  puts (\"\\\n#ifndef GCC_TM_CONSTRS_H\\n\\\n#define GCC_TM_CONSTRS_H\\n\");\n\n  FOR_ALL_CONSTRAINTS (c)\n    if (!c-\u003eis_register)\n      {\n\tbool needs_ival \u003d needs_variable (c-\u003eexp, \"ival\");\n\tbool needs_hval \u003d needs_variable (c-\u003eexp, \"hval\");\n\tbool needs_lval \u003d needs_variable (c-\u003eexp, \"lval\");\n\tbool needs_rval \u003d needs_variable (c-\u003eexp, \"rval\");\n\tbool needs_mode \u003d (needs_variable (c-\u003eexp, \"mode\")\n\t\t\t   || needs_hval || needs_lval || needs_rval);\n\tbool needs_op \u003d (needs_variable (c-\u003eexp, \"op\")\n\t\t\t || needs_ival || needs_mode);\n\n\tprintf (\"static inline bool\\n\"\n\t\t\"satisfies_constraint_%s (rtx %s)\\n\"\n\t\t\"{\\n\", c-\u003ec_name,\n\t\tneeds_op ? \"op\" : \"ARG_UNUSED (op)\");\n\tif (needs_mode)\n\t  puts (\"enum machine_mode mode \u003d GET_MODE (op);\");\n\tif (needs_ival)\n\t  puts (\"  HOST_WIDE_INT ival \u003d 0;\");\n\tif (needs_hval)\n\t  puts (\"  HOST_WIDE_INT hval \u003d 0;\");\n\tif (needs_lval)\n\t  puts (\"  unsigned HOST_WIDE_INT lval \u003d 0;\");\n\tif (needs_rval)\n\t  puts (\"  const REAL_VALUE_TYPE *rval \u003d 0;\");\n\n\tif (needs_ival)\n\t  puts (\"  if (GET_CODE (op) \u003d\u003d CONST_INT)\\n\"\n\t\t\"    ival \u003d INTVAL (op);\");\n\tif (needs_hval)\n\t  puts (\"  if (GET_CODE (op) \u003d\u003d CONST_DOUBLE \u0026\u0026 mode \u003d\u003d VOIDmode)\"\n\t\t\"    hval \u003d CONST_DOUBLE_HIGH (op);\");\n\tif (needs_lval)\n\t  puts (\"  if (GET_CODE (op) \u003d\u003d CONST_DOUBLE \u0026\u0026 mode \u003d\u003d VOIDmode)\"\n\t\t\"    lval \u003d CONST_DOUBLE_LOW (op);\");\n\tif (needs_rval)\n\t  puts (\"  if (GET_CODE (op) \u003d\u003d CONST_DOUBLE \u0026\u0026 mode !\u003d VOIDmode)\"\n\t\t\"    rval \u003d CONST_DOUBLE_REAL_VALUE (op);\");\n\n\twrite_predicate_stmts (c-\u003eexp);\n\tfputs (\"}\\n\", stdout);\n      }\n  puts (\"#endif /* tm-constrs.h */\");\n}\n\n/* Write out the wrapper function, constraint_satisfied_p, that maps\n   a CONSTRAINT_xxx constant to one of the predicate functions generated\n   above.  */\nstatic void\nwrite_constraint_satisfied_p (void)\n{\n  struct constraint_data *c;\n\n  puts (\"bool\\n\"\n\t\"constraint_satisfied_p (rtx op, enum constraint_num c)\\n\"\n\t\"{\\n\"\n\t\"  switch (c)\\n\"\n\t\"    {\");\n\n  FOR_ALL_CONSTRAINTS (c)\n    if (!c-\u003eis_register)\n      printf (\"    case CONSTRAINT_%s: \"\n\t      \"return satisfies_constraint_%s (op);\\n\",\n\t      c-\u003ec_name, c-\u003ec_name);\n\n  puts (\"    default: break;\\n\"\n\t\"    }\\n\"\n\t\"  return false;\\n\"\n\t\"}\\n\");\n}\n\n/* Write out the function which computes whether a given value matches\n   a given CONST_INT constraint.  This doesn\u0027t just forward to\n   constraint_satisfied_p because caller passes the INTVAL, not the RTX.  */\nstatic void\nwrite_insn_const_int_ok_for_constraint (void)\n{\n  struct constraint_data *c;\n\n  puts (\"bool\\n\"\n\t\"insn_const_int_ok_for_constraint (HOST_WIDE_INT ival, \"\n\t                                  \"enum constraint_num c)\\n\"\n\t\"{\\n\"\n\t\"  switch (c)\\n\"\n\t\"    {\");\n\n  FOR_ALL_CONSTRAINTS (c)\n    if (c-\u003eis_const_int)\n      {\n\tprintf (\"    case CONSTRAINT_%s:\\n      return \", c-\u003ec_name);\n\t/* c-\u003eexp is guaranteed to be (and (match_code \"const_int\") (...));\n\t   we know at this point that we have a const_int, so we need not\n\t   bother with that part of the test.  */\n\twrite_predicate_expr (XEXP (c-\u003eexp, 1));\n\tfputs (\";\\n\\n\", stdout);\n      }\n\n  puts (\"    default: break;\\n\"\n\t\"    }\\n\"\n\t\"  return false;\\n\"\n\t\"}\\n\");\n}\n\n\n/* Write out the function which computes whether a given constraint is\n   a memory constraint.  */\nstatic void\nwrite_insn_extra_memory_constraint (void)\n{\n  struct constraint_data *c;\n\n  puts (\"bool\\n\"\n\t\"insn_extra_memory_constraint (enum constraint_num c)\\n\"\n\t\"{\\n\"\n\t\"  switch (c)\\n\"\n\t\"    {\");\n\n  FOR_ALL_CONSTRAINTS (c)\n    if (c-\u003eis_memory)\n      printf (\"    case CONSTRAINT_%s:\\n      return true;\\n\\n\", c-\u003ec_name);\n\n  puts (\"    default: break;\\n\"\n\t\"    }\\n\"\n\t\"  return false;\\n\"\n\t\"}\\n\");\n}\n\n/* Write out the function which computes whether a given constraint is\n   an address constraint.  */\nstatic void\nwrite_insn_extra_address_constraint (void)\n{\n  struct constraint_data *c;\n\n  puts (\"bool\\n\"\n\t\"insn_extra_address_constraint (enum constraint_num c)\\n\"\n\t\"{\\n\"\n\t\"  switch (c)\\n\"\n\t\"    {\");\n\n  FOR_ALL_CONSTRAINTS (c)\n    if (c-\u003eis_address)\n      printf (\"    case CONSTRAINT_%s:\\n      return true;\\n\\n\", c-\u003ec_name);\n\n  puts (\"    default: break;\\n\"\n\t\"    }\\n\"\n\t\"  return false;\\n\"\n\t\"}\\n\");\n}\n\n\n/* Write tm-preds.h.  Unfortunately, it is impossible to forward-declare\n   an enumeration in portable C, so we have to condition all these\n   prototypes on HAVE_MACHINE_MODES.  */\nstatic void\nwrite_tm_preds_h (void)\n{\n  struct pred_data *p;\n\n  printf (\"\\\n/* Generated automatically by the program \u0027%s\u0027\\n\\\n   from the machine description file \u0027%s\u0027.  */\\n\\n\", progname, in_fname);\n\n  puts (\"\\\n#ifndef GCC_TM_PREDS_H\\n\\\n#define GCC_TM_PREDS_H\\n\\\n\\n\\\n#ifdef HAVE_MACHINE_MODES\");\n\n  FOR_ALL_PREDICATES (p)\n    printf (\"extern int %s (rtx, enum machine_mode);\\n\", p-\u003ename);\n\n  puts (\"#endif /* HAVE_MACHINE_MODES */\\n\");\n\n  if (constraint_max_namelen \u003e 0)\n    {\n      write_enum_constraint_num ();\n      puts (\"extern enum constraint_num lookup_constraint (const char *);\\n\"\n\t    \"extern bool constraint_satisfied_p (rtx, enum constraint_num);\\n\");\n\n      if (constraint_max_namelen \u003e 1)\n        {\n\t  write_insn_constraint_len ();\n\t  puts (\"#define CONSTRAINT_LEN(c_,s_) \"\n\t\t\"insn_constraint_len (c_,s_)\\n\");\n\t}\n      else\n\tputs (\"#define CONSTRAINT_LEN(c_,s_) 1\\n\");\n      if (have_register_constraints)\n\tputs (\"extern enum reg_class regclass_for_constraint \"\n\t      \"(enum constraint_num);\\n\"\n\t      \"#define REG_CLASS_FROM_CONSTRAINT(c_,s_) \\\\\\n\"\n\t      \"    regclass_for_constraint (lookup_constraint (s_))\\n\");\n      else\n\tputs (\"#define REG_CLASS_FROM_CONSTRAINT(c_,s_) NO_REGS\");\n      if (have_const_int_constraints)\n\tputs (\"extern bool insn_const_int_ok_for_constraint \"\n\t      \"(HOST_WIDE_INT, enum constraint_num);\\n\"\n\t      \"#define CONST_OK_FOR_CONSTRAINT_P(v_,c_,s_) \\\\\\n\"\n\t      \"    insn_const_int_ok_for_constraint (v_, \"\n\t      \"lookup_constraint (s_))\\n\");\n      if (have_const_dbl_constraints)\n\tputs (\"#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(v_,c_,s_) \\\\\\n\"\n\t      \"    constraint_satisfied_p (v_, lookup_constraint (s_))\\n\");\n      else\n\tputs (\"#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(v_,c_,s_) 0\\n\");\n      if (have_extra_constraints)\n\tputs (\"#define EXTRA_CONSTRAINT_STR(v_,c_,s_) \\\\\\n\"\n\t      \"    constraint_satisfied_p (v_, lookup_constraint (s_))\\n\");\n      if (have_memory_constraints)\n\tputs (\"extern bool \"\n\t      \"insn_extra_memory_constraint (enum constraint_num);\\n\"\n\t      \"#define EXTRA_MEMORY_CONSTRAINT(c_,s_) \"\n\t      \"insn_extra_memory_constraint (lookup_constraint (s_))\\n\");\n      else\n\tputs (\"#define EXTRA_MEMORY_CONSTRAINT(c_,s_) false\\n\");\n      if (have_address_constraints)\n\tputs (\"extern bool \"\n\t      \"insn_extra_address_constraint (enum constraint_num);\\n\"\n\t      \"#define EXTRA_ADDRESS_CONSTRAINT(c_,s_) \"\n\t      \"insn_extra_address_constraint (lookup_constraint (s_))\\n\");\n      else\n\tputs (\"#define EXTRA_ADDRESS_CONSTRAINT(c_,s_) false\\n\");\n    }\n\n  puts (\"#endif /* tm-preds.h */\");\n}\n\n/* Write insn-preds.c.  \n   N.B. the list of headers to include was copied from genrecog; it\n   may not be ideal.\n\n   FUTURE: Write #line markers referring back to the machine\n   description.  (Can\u0027t practically do this now since we don\u0027t know\n   the line number of the C block - just the line number of the enclosing\n   expression.)  */\nstatic void\nwrite_insn_preds_c (void)\n{\n  struct pred_data *p;\n\n  printf (\"\\\n/* Generated automatically by the program \u0027%s\u0027\\n\\\n   from the machine description file \u0027%s\u0027.  */\\n\\n\", progname, in_fname);\n\n  puts (\"\\\n#include \\\"config.h\\\"\\n\\\n#include \\\"system.h\\\"\\n\\\n#include \\\"coretypes.h\\\"\\n\\\n#include \\\"tm.h\\\"\\n\\\n#include \\\"rtl.h\\\"\\n\\\n#include \\\"tree.h\\\"\\n\\\n#include \\\"tm_p.h\\\"\\n\\\n#include \\\"function.h\\\"\\n\\\n#include \\\"insn-config.h\\\"\\n\\\n#include \\\"recog.h\\\"\\n\\\n#include \\\"real.h\\\"\\n\\\n#include \\\"output.h\\\"\\n\\\n#include \\\"flags.h\\\"\\n\\\n#include \\\"hard-reg-set.h\\\"\\n\\\n#include \\\"resource.h\\\"\\n\\\n#include \\\"toplev.h\\\"\\n\\\n#include \\\"reload.h\\\"\\n\\\n#include \\\"regs.h\\\"\\n\\\n#include \\\"tm-constrs.h\\\"\\n\");\n\n  FOR_ALL_PREDICATES (p)\n    write_one_predicate_function (p);\n\n  if (constraint_max_namelen \u003e 0)\n    {\n      write_lookup_constraint ();\n      if (have_register_constraints)\n\twrite_regclass_for_constraint ();\n      write_constraint_satisfied_p ();\n      \n      if (have_const_int_constraints)\n\twrite_insn_const_int_ok_for_constraint ();\n\n      if (have_memory_constraints)\n\twrite_insn_extra_memory_constraint ();\n      if (have_address_constraints)\n\twrite_insn_extra_address_constraint ();\n    }\n}\n\n/* Argument parsing.  */\nstatic bool gen_header;\nstatic bool gen_constrs;\n\nstatic bool\nparse_option (const char *opt)\n{\n  if (!strcmp (opt, \"-h\"))\n    {\n      gen_header \u003d true;\n      return 1;\n    }\n  else if (!strcmp (opt, \"-c\"))\n    {\n      gen_constrs \u003d true;\n      return 1;\n    }\n  else\n    return 0;\n}\n\n/* Master control.  */\nint\nmain (int argc, char **argv)\n{\n  rtx defn;\n  int pattern_lineno, next_insn_code \u003d 0;\n\n  progname \u003d argv[0];\n  if (argc \u003c\u003d 1)\n    fatal (\"no input file name\");\n  if (init_md_reader_args_cb (argc, argv, parse_option) !\u003d SUCCESS_EXIT_CODE)\n    return FATAL_EXIT_CODE;\n\n  while ((defn \u003d read_md_rtx (\u0026pattern_lineno, \u0026next_insn_code)) !\u003d 0)\n    switch (GET_CODE (defn))\n      {\n      case DEFINE_PREDICATE:\n      case DEFINE_SPECIAL_PREDICATE:\n\tprocess_define_predicate (defn, pattern_lineno);\n\tbreak;\n\n      case DEFINE_CONSTRAINT:\n      case DEFINE_MEMORY_CONSTRAINT:\n      case DEFINE_ADDRESS_CONSTRAINT:\n\tprocess_define_constraint (defn, pattern_lineno);\n\tbreak;\n\n      case DEFINE_REGISTER_CONSTRAINT:\n\tprocess_define_register_constraint (defn, pattern_lineno);\n\tbreak;\n\n      default:\n\tbreak;\n      }\n\n  if (gen_header)\n    write_tm_preds_h ();\n  else if (gen_constrs)\n    write_tm_constrs_h ();\n  else\n    write_insn_preds_c ();\n\n  if (have_error || ferror (stdout) || fflush (stdout) || fclose (stdout))\n    return FATAL_EXIT_CODE;\n\n  return SUCCESS_EXIT_CODE;\n}",
    "The problem seems to buried in one of the headers included. I\u0027ll try to reproduce the problem with the gcc-sources. What version of gcc are you building?",
    "(In reply to comment #1)\n\u003e The problem seems to buried in one of the headers included. I\u0027ll try to\n\u003e reproduce the problem with the gcc-sources. What version of gcc are you\n\u003e building?\n\u003e \n\nI\u0027m working on the Tuples branch of gcc. It is almost exactly the same as the project head right now - so you could probably use that with the same effect.  There were actually lots of places in the src that exploded the indexer - most were in the test suites. ",
    "\u003e I\u0027m working on the Tuples branch of gcc. It is almost exactly the same as the\n\u003e project head right now - so you could probably use that with the same effect. \nok, I prefer using a released version, I\u0027ll go with gcc-4.2.0, then.\n\n\u003e There were actually lots of places in the src that exploded the indexer - most\n\u003e were in the test suites. \nThe test-suites contain lots of invalid code, so parsing those is not too interesting. However if they trigger exceptions in the indexer it is worth looking at them. I see what I can do, thanks.\n\n",
    "Unfortunately I was not able to reproduce the problem. I.e. I can index the sources in gcc-4.2.0/gcc without exceptions.",
    "(In reply to comment #4)\n\u003e Unfortunately I was not able to reproduce the problem. I.e. I can index the\n\u003e sources in gcc-4.2.0/gcc without exceptions.\n\u003e \n\nI checked out the 4-2 head and I can index /gcc (although the test suite threw lots of exceptions) as well. I guess this might only be in the newer code.  The specific branch that I am working on is called \"gimple-tuples-branch\". I verified that the two files that cause this exception have not been changed since checkout - so what is in the svn should be exactly the same.",
    "The scanner has been replaced, so the particular exception can no longer be thrown.\nFixed in 5.0 \u003e 20071114."
  ],
  "commentCreationDates": [
    "2007-06-04T21:43:11+02:00",
    "2007-06-05T16:25:39+02:00",
    "2007-06-05T17:20:11+02:00",
    "2007-06-05T17:32:45+02:00",
    "2007-06-06T10:08:28+02:00",
    "2007-06-06T22:47:49+02:00",
    "2007-11-14T12:39:46+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ArrayIndexOutOfBoundsException",
      "elements": [
        {
          "method": "java.lang.System.arraycopy",
          "source": "Native Method"
        },
        {
          "method": "org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.replaceArgumentMacros",
          "source": "BaseScanner.java:3519"
        },
        {
          "method": "org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.expandFunctionStyleMacro",
          "source": "BaseScanner.java:3650"
        },
        {
          "method": "org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.handleFunctionStyleMacro",
          "source": "BaseScanner.java:3429"
        },
        {
          "method": "org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.scanIdentifier",
          "source": "BaseScanner.java:1123"
        },
        {
          "method": "org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.fetchToken",
          "source": "BaseScanner.java:763"
        },
        {
          "method": "org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.doFetchToken",
          "source": "BaseScanner.java:602"
        },
        {
          "method": "org.eclipse.cdt.internal.core.parser.scanner2.BaseScanner.nextToken",
          "source": "BaseScanner.java:557"
        },
        {
          "method": "org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser.fetchToken",
          "source": "AbstractGNUSourceCodeParser.java:257"
        },
        {
          "method": "org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser.LA",
          "source": "AbstractGNUSourceCodeParser.java:184"
        },
        {
          "method": "org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser.LT",
          "source": "AbstractGNUSourceCodeParser.java:204"
        },
        {
          "method": "org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser.errorHandling",
          "source": "AbstractGNUSourceCodeParser.java:502"
        },
        {
          "method": "org.eclipse.cdt.internal.core.dom.parser.c.GNUCSourceParser.translationUnit",
          "source": "GNUCSourceParser.java:649"
        },
        {
          "method": "org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser.parse",
          "source": "AbstractGNUSourceCodeParser.java:445"
        },
        {
          "method": "org.eclipse.cdt.core.dom.parser.c.AbstractCLanguage.getASTTranslationUnit",
          "source": "AbstractCLanguage.java:105"
        },
        {
          "method": "org.eclipse.cdt.internal.core.pdom.indexer.fast.PDOMFastIndexerTask.createAST",
          "source": "PDOMFastIndexerTask.java:159"
        },
        {
          "method": "org.eclipse.cdt.internal.core.pdom.indexer.PDOMIndexerTask.createAST",
          "source": "PDOMIndexerTask.java:166"
        },
        {
          "method": "org.eclipse.cdt.internal.core.pdom.indexer.PDOMIndexerTask.parseTU",
          "source": "PDOMIndexerTask.java:291"
        },
        {
          "method": "org.eclipse.cdt.internal.core.pdom.indexer.PDOMIndexerTask.internalParseTUs",
          "source": "PDOMIndexerTask.java:213"
        },
        {
          "method": "org.eclipse.cdt.internal.core.pdom.indexer.PDOMIndexerTask.parseTUs",
          "source": "PDOMIndexerTask.java:189"
        },
        {
          "method": "org.eclipse.cdt.internal.core.pdom.indexer.fast.PDOMFastIndexerTask.run",
          "source": "PDOMFastIndexerTask.java:102"
        },
        {
          "method": "org.eclipse.cdt.internal.core.pdom.indexer.PDOMRebuildTask.run",
          "source": "PDOMRebuildTask.java:75"
        },
        {
          "method": "org.eclipse.cdt.internal.core.pdom.PDOMIndexerJob.run",
          "source": "PDOMIndexerJob.java:89"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:55"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "190884",
      "date": "2007-06-04T21:43:11+02:00",
      "product": "CDT",
      "component": "CDT-parser",
      "severity": "normal"
    }
  ],
  "groupId": "190884",
  "bugId": "190884",
  "date": "2007-06-04T21:43:11+02:00",
  "product": "CDT",
  "component": "CDT-parser",
  "severity": "normal"
}