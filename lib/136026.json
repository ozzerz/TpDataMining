{
  "comments": [
    "While following up a mailing list question, I blundered into a bug I don\u0027t understand.  Same result in 1.5.1 (command-line) and 1.5.1a (via AJDT 1.3.1).  \n\n---------------- output\nStarting CflowOrder.main(..)\nException in thread \"main\" java.lang.VerifyError: (class: bugs/CflowOrder$A, method: foo signature: ()V) Incompatible object argument for function call\n\tat bugs.CflowOrder.main(CflowOrder.java:20)\n\n---------------- bugs/CflowOrder.java\n\npackage bugs;\n\nimport java.io.PrintStream;\nimport java.lang.annotation.*;\n\nimport org.aspectj.lang.JoinPoint;\n\npublic class CflowOrder {\n\n    public static void main(String[] args) {\n        Log.print(\"Starting CflowOrder.main(..)\");\n        A.main(null);\n        Log.print(\"Ending CflowOrder.main(..)\");\n    }\n\n    @Retention(value \u003d RetentionPolicy.RUNTIME)\n    @interface Annotation {\n        String value();\n    }\n\n    static class A {\n        @Annotation(\"A.foo\")\n        void foo() {\n            new B().foo();\n            Log.print(\"A.foo()\");\n        }\n\n        public static void main(String[] args) {\n            new A().foo();\n            Log.print(\"A.main(..)\");\n        }\n    }\n\n    static class B {\n        @Annotation(\"B.foo\")\n        void foo() {\n            Log.print(\"B.foo()\");\n        }\n    }\n\n    static class Log implements IAspect {\n        static final PrintStream out \u003d System.err;\n\n        static void print(String label) {\n            out.println(label);\n        }\n\n        static void print(String label, JoinPoint tjp, JoinPoint.StaticPart sp,\n                Object a) {\n            out.println(label);\n            out.println(\"\\tJoin point: \" + tjp);\n            out.println(\"\\tEnclosing join point: \" + sp);\n            out.println(\"\\tAnnotation: \" + a);\n        }\n    }\n    static aspect Logger implements IAspect {\n\n        //declare error: execution(* *(..)) \u0026\u0026 !within(Log) : \"er\";\n\n//        before() : cflow(execution(void CflowOrder.main(String[]))) \n//            \u0026\u0026 !call(* IAspect+.*(..)) \u0026\u0026 ! within(IAspect+) {\n//            Log.print(\"cflow(..main(..))\", thisJoinPoint,\n//                    thisEnclosingJoinPointStaticPart, null);\n//        }\n    }\n\n    interface IAspect {}\n    static aspect MyAspect  implements IAspect {\n\n        pointcut annotated(Annotation a) :\n            call(@Annotation * *(..)) \u0026\u0026 @annotation(a);\n\n        pointcut belowAnnotated() :\n            cflowbelow(annotated(Annotation));\n      pointcut topAnnotated(Annotation a) : annotated(a) \n            \u0026\u0026 !belowAnnotated();\n\n      pointcut notTopAnnotated(Annotation a, Annotation aTop) : annotated(a) \n      \u0026\u0026 cflowbelow(annotated(aTop));\n//        pointcut topAnnotated(Annotation a) : annotated(a) \n//            \u0026\u0026 !cflowbelow(annotated(Annotation));\n//\n//        pointcut notTopAnnotated(Annotation a, Annotation aTop) : annotated(a) \n//            \u0026\u0026  cflowbelow(topAnnotated(aTop));\n\n        // if this first, then no nonTopAnnotated advice\n        before(Annotation a) : topAnnotated(a) {\n            Log.print(\"topAnnotated\", thisJoinPoint,\n                    thisEnclosingJoinPointStaticPart, a);\n        }\n        // if topAnnotated is first, this does not run\n        before(Annotation a, Annotation aTop) : notTopAnnotated(a, aTop) {\n            Log.print(\"nonTopAnnotated\", thisJoinPoint,\n                    thisEnclosingJoinPointStaticPart, a);\n        }\n    }\n}",
    "Created an attachment (id\u003d38239)\n.class files produced by ajc 1.5.1\n\n",
    "Yikes, that was hard to diagnose.  Offending code looks like:\n\n46:  getstatic       #36; //Field CflowOrder$MyAspect.ajc$cflowCounter$0:Lorg/aspectj/runtime/internal/CFlowCounter;\n49:  bipush  0\n51:  invokevirtual   #42; //Method org/aspectj/runtime/internal/CFlowStack.get:(I)Ljava/lang/Object;\n\nYou can\u0027t call CflowStack.get() on a CflowCounter instance!\n\nThis is occurring because of the logic that shares cflow fields when working with the same pointcut.  Unfortunately in the situation in this program the pointcut behaves like a counter in one place and a stack in the other (ie. the consumer of the pointcut is using the context it exposes in one case but not the other).  Our cache that is indexed by \"pointcutString:declaringAspect\" to find a cflow field doesn\u0027t take into account the kind of context in which it is being used.  if we extend the cache key to include this information (by appending \u0027stack\u0027 or \u0027counter\u0027 to the key) then it works.\n\nfix committed - there are possibly other bugzilla cases that are this same problem, but Wes\u0027 testcase was the best ;)"
  ],
  "commentCreationDates": [
    "2006-04-11T03:41:44+02:00",
    "2006-04-11T03:42:47+02:00",
    "2006-05-12T14:36:35+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.VerifyError",
      "message": "(class: bugs/CflowOrder$A, method: foo signature: ()V) Incompatible object argument for function call",
      "elements": [
        {
          "method": "bugs.CflowOrder.main",
          "source": "CflowOrder.java:20"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "136026",
      "date": "2006-04-11T03:41:44+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "major"
    }
  ],
  "groupId": "136026",
  "bugId": "136026",
  "date": "2006-04-11T03:41:44+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "major"
}