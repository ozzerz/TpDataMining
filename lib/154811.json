{
  "comments": [
    "Simple mistake at 604:55 in the code listed at the bottom causes the following error:\n\nInternal compiler error java.lang.ClassCastException: \n org.eclipse.jdt.internal.compiler.parser.RecoveredBlock at \n org.eclipse.jdt.internal.compiler.parser.Parser.consumeType\n HeaderNameWithTypeParameters(Parser.java:2109) at \n org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule\n (Parser.java:4961) at \n org.eclipse.jdt.internal.compiler.parser.Parser.parse\n (Parser.java:8839) at \n org.eclipse.jdt.internal.compiler.parser.Parser.parse\n (Parser.java:9160) at \n org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parse\n Statements(MethodDeclaration.java:117) at \n org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseM\n ethod(TypeDeclaration.java:805) at \n org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBod\n ies(Parser.java:8111) at \n org.eclipse.jdt.internal.compiler.Compiler.process\n (Compiler.java:583) at \n org.eclipse.jdt.internal.compiler.Compiler.compile\n (Compiler.java:411) at \n org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.co\n mpile(AbstractImageBuilder.java:300) at \n org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.co\n mpile(AbstractImageBuilder.java:237) at \n org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.\n build(IncrementalImageBuilder.java:120) at \n org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas\n (JavaBuilder.java:260) at \n org.eclipse.jdt.internal.core.builder.JavaBuilder.build\n (JavaBuilder.java:185) at \n org.eclipse.core.internal.events.BuildManager$2.run\n (BuildManager.java:603) at \n org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:\n 37) at \n org.eclipse.core.internal.events.BuildManager.basicBuild\n (BuildManager.java:167) at \n org.eclipse.core.internal.events.BuildManager.basicBuild\n (BuildManager.java:201) at \n org.eclipse.core.internal.events.BuildManager$1.run\n (BuildManager.java:230) at \n org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:\n 37) at \n org.eclipse.core.internal.events.BuildManager.basicBuild\n (BuildManager.java:233) at \n org.eclipse.core.internal.events.BuildManager.basicBuildLo\n op(BuildManager.java:252) at \n org.eclipse.core.internal.events.BuildManager.build\n (BuildManager.java:285) at \n org.eclipse.core.internal.events.AutoBuildJob.doBuild\n (AutoBuildJob.java:145) at \n org.eclipse.core.internal.events.AutoBuildJob.run\n (AutoBuildJob.java:208) at \n org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)\n\n\n-------------------- FactorStoreIndexed.java --------------------------\nimport java.util.Iterator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\n\n/**\n * A place to store factors during computation. This indexes to find the the variable proposed by a heuristic efficiently.\n * \n * @param \u003cT\u003e type of the heuristic object.\n * \n * \u003cp\u003e\n * This file is part of CIspace.ve package. \u003cbr\u003e\n * CIspace.ve package is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your option) any later version. \u003cbr\u003e\n * CIspace.ve package is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. \u003cbr\u003e\n * You should have received a copy of the GNU General Public License along with CIspace.ve package; if not, write to the Free Software Foundation,\n * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n * \u003c/p\u003e\n * \n * @author David Poole\n * \n * @version 1.1 22-August-2006\n * \n * \u003cp\u003e\n * TODO Remove bug in min-fill(?) - there are variables with no factors associated with\u003cbr\u003e\n * *************************************\n * \u003cul\u003e\n * Changes by Jacek Kisy\u0026#324;ski:\n * \u003cli\u003echanged to abstract, heuristic value stored in parameterized type object - it allows to implement constraints on heuristic.\n * \u003cli\u003eremove(Variable) and willBeNext() methods added - used by {@link CIspace.ve.QueryStepByStep}.\n * \u003cli\u003euse of generics (update to J2SE 5.0)\n * \u003cli\u003euse of automatic boxing and unboxing (update to J2SE 5.0)\n * \u003cli\u003euse of generics (update to J2SE 5.0)\n * \u003cli\u003euses Variable.compareTo(Object) instead of Variable.getId()\n * \u003cli\u003euses Variable.equals(Object) instead of \"\u003d\u003d\"\n * \u003cli\u003euses Variable.getDomainSize() instead of Variable.getDomain().length\n * \u003cli\u003eimplements (not extends) CIspace.ve.FactorStore\n * \u003cli\u003emany identifiers renamed\n * \u003cli\u003eunnecessary recomputing of neighbours removed (methods: clean_up() and compute_neighbours() removed)\n * \u003cli\u003eunnecessary recomputing of heuristics removed\n * \u003cli\u003e\u003cb\u003eInterface change \u003c/b\u003e heuristics added/renamed: \"min-factor\" (\u003d\"min-weight\") || \"min-degree\" (\u003d\"min-size\") || \"min-fill\"\n * (\u003d\"min-deficiency\", \"min-discrepancy\") || \"max-cardinality\" (constructor takes one more parameter)\n * \u003cli\u003ethrows java.lang.IllegalArgumentException() if provided ordering heuristic is not one of listed above\n * \u003cli\u003eiterators are now ItrSafe not CIspace.ve.FactorIterators\n * \u003cli\u003emember VariableToEliminate.positionInPQ removed (never used)\n * \u003cli\u003eheap rebuilding debugged (it wasn\u0027t being rebuild after heuristics were updated)\n * \u003cli\u003emaxNumNeighs debugged (it was equal to numbers of variables to sum out)\n * \u003cli\u003eparameter Variables added in constructor\n * \u003cli\u003eprivate class FactorLink removed and Factor index created (so it can be used for min-fill heuristic)\n * \u003cli\u003eenumFacsRemaining class removed\n * \u003c/ul\u003e\n */\npublic abstract class FactorStoreIndexed\u003cT extends Comparable\u003cT\u003e\u003e implements FactorStore {\n\n\t/** Priority queue of Variables to be eliminated stored as VariableToEliminate. */\n\tprotected VariableToEliminate\u003cT\u003e[] varsPQ;\n\n\t/** Number of Variables to be eliminated. */\n\tprotected int numVariablesToEliminate;\n\n\t/**\n\t * Elimination heuristic: \u003cbr\u003e\n\t * \"min-factor\" (\u003d\"min-weight\") || \"min-degree\" (\u003d\"min-size\") || \"min-fill\" (\u003d\"min-deficiency\", \"min-discrepancy\") || \"max-cardinality\".\n\t */\n\tString how;\n\n\t/** The last Variable returned. */\n\tprivate VariableToEliminate\u003cT\u003e last \u003d null;\n\n\t/** Maps Variable to VariableToEliminate */\n\tprivate HashMap\u003cVariable, VariableToEliminate\u003cT\u003e\u003e varToVarInQuery;\n\n\t/** Final factors. */\n\tprivate Factor[] finalFacs;\n\n\t/** Number of final Factors. */\n\tprivate int numFinalFacs;\n\n\t/** Index of factors. */\n\tprivate HashMap\u003cVariable, HashSet\u003cFactor\u003e\u003e factorIndex;\n\n\t/**\n\t * Constructor.\n\t * \n\t * @param toSumOut - Variables to be summed out.\n\t * @param initFactorsIterator - initial Factors.\n\t * @param nrInitFactors - number of initial Factors.\n\t * @param variablesIterator - Variables in the network.\n\t * @param numVariables - number of Variables in the network.\n\t * @param how an ordering heuristic: min-factor (\u003dmin-weight), min-degree (\u003dmin-size), min-fill (\u003dmin-deficiency, min-discrepancy),\n\t * max-cardinality.\n\t * \n\t * @throws java.lang.IllegalArgumentException() if provided ordering heuristic is not one of listed above.\n\t */\n\tpublic FactorStoreIndexed(Variable[] toSumOut, Iterator\u003cFactor\u003e initFactorsIterator, int nrInitFactors, Iterator\u003cVariable\u003e variablesIterator,\n\t\t\tint numVariables, String how) {\n\t\tthis.numVariablesToEliminate \u003d toSumOut.length;\n\t\tthis.varToVarInQuery \u003d new HashMap\u003cVariable, VariableToEliminate\u003cT\u003e\u003e(this.numVariablesToEliminate * 3 / 2);\n\t\tthis.finalFacs \u003d new Factor[nrInitFactors + 1];\n\t\tthis.numFinalFacs \u003d 0;\n\n\t\t// Determine heuristic\n\t\tif ((how.equals(\"min-degree\")) || ((how.equals(\"min-size\"))))\n\t\t\tthis.how \u003d \"min-degree\";\n\t\telse if ((how.equals(\"min-fill\")) || (how.equals(\"min-deficiency\")) || (how.equals(\"min-discrepancy\")))\n\t\t\tthis.how \u003d \"min-fill\";\n\t\telse if ((how.equals(\"min-factor\")) || (how.equals(\"min-weight\")))\n\t\t\tthis.how \u003d \"min-factor\";\n\t\telse if (how.equals(\"max-cardinality\"))\n\t\t\tthis.how \u003d \"max-cardinality\";\n\t\telse\n\t\t\tthrow new IllegalArgumentException(\"Wrong ordering heuristic!\");\n\n\t\t// Create VariablesToEliminate\n\t\tthis.createHeapSpace(toSumOut, numVariables);\n\n\t\t// Create FactorIndex\n\t\tthis.factorIndex \u003d new HashMap\u003cVariable, HashSet\u003cFactor\u003e\u003e((int) Math.round(1.4 * numVariables));\n\t\twhile (variablesIterator.hasNext())\n\t\t\tthis.factorIndex.put(variablesIterator.next(), new HashSet\u003cFactor\u003e());\n\t\twhile (initFactorsIterator.hasNext())\n\t\t\tthis.add(initFactorsIterator.next());\n\n\t\t// Update heuristic\n\t\tif (this.how.equals(\"min-degree\"))\n\t\t\tfor (int i \u003d 0; i \u003c this.numVariablesToEliminate; i++)\n\t\t\t\tthis.varsPQ[i].setMinDegree();\n\t\telse if (this.how.equals(\"min-fill\"))\n\t\t\tfor (int i \u003d 0; i \u003c this.numVariablesToEliminate; i++)\n\t\t\t\tthis.varsPQ[i].setMinFill();\n\t\telse if (this.how.equals(\"min-factor\"))\n\t\t\tfor (int i \u003d 0; i \u003c this.numVariablesToEliminate; i++)\n\t\t\t\tthis.varsPQ[i].setMinFactor();\n\t\t// else this.how.equals(\"max-cardinality\")) - do nothing, all heuristics for max-cardinality are zero right now\n\n\t\t// Make into a heap\n\t\tfor (int i \u003d 1; i \u003c this.numVariablesToEliminate; i++)\n\t\t\tshuffleUp(i);\n\t}\n\n\t/**\n\t * @param toSumOut\n\t * @param numVariables\n\t */\n\tabstract protected void createHeapSpace(Variable[] toSumOut, int numVariables);\n\n\t/**\n\t * @see CIspace.ve.FactorStore#hasNext()\n\t */\n\tpublic boolean hasNext() {\n\t\treturn this.numVariablesToEliminate \u003e 0;\n\t}\n\n\t/**\n\t * Used by {@link CIspace.ve.QueryStepByStep}.\n\t * \n\t * @return variable, which will be eliminated next.\n\t */\n\tprotected Variable nextToEliminate() {\n\t\treturn this.varsPQ[0].var;\n\t}\n\n\t/**\n\t * @see CIspace.ve.FactorStore#next()\n\t */\n\tpublic Variable next() {\n\t\t// System.out.println(\"\\n\" + varsPQ[0].var.getName() + \" is at the top of the heap\");\n\t\t// System.out.println(\" num factors:\" + varsPQ[0].numFactors + \". numNeighbours:\" + varsPQ[0].numNeighbours);\n\t\tthis.last \u003d this.varsPQ[0];\n\t\tthis.varsPQ[0] \u003d this.varsPQ[--this.numVariablesToEliminate];\n\t\t// Update heuristic (if \"max-cardinality\" is a current heuristic)\n\t\tif (this.how.equals(\"max-cardinality\")) {\n\t\t\tfor (int i \u003d 0; i \u003c this.last.numNeighbours; i++) {\n\t\t\t\tVariableToEliminate vte \u003d this.varToVarInQuery.get(this.last.neighbours[i]);\n\t\t\t\tif (vte !\u003d null)\n\t\t\t\t\tvte.setHeuristicValue(vte.recomputeMaxCardinality());\n\t\t\t}\n\t\t\t// Rebuild the heap\n\t\t\tfor (int i \u003d ((this.numVariablesToEliminate / 2) - 1); i \u003e\u003d 0; i--)\n\t\t\t\tshuffleDown(i);\n\t\t} else\n\t\t\t// Rebuild the heap\n\t\t\tshuffleDown(0);\n\t\t// Remove Factors on last from last\u0027s index (we remove those Factors from indexes of other Variables in\n\t\t// FactorStoreIndexed.EnumFacsRemoved.next()\n\t\tthis.factorIndex.remove(this.last.var);\n\t\treturn this.last.var;\n\t}\n\n\t/**\n\t * Removes variable from the FactorStore. Used by {@link CIspace.ve.QueryStepByStep}. Shouldn\u0027t be used during inference with this heuristic!\n\t * \n\t * @param variable to be removed from the FactorStore.\n\t */\n\tprotected void remove(Variable variable) {\n\t\tint i \u003d 0;\n\t\twhile (!variable.equals(this.varsPQ[i].var))\n\t\t\ti++;\n\t\tthis.last \u003d this.varsPQ[i];\n\t\tthis.varsPQ[i] \u003d this.varsPQ[--this.numVariablesToEliminate];\n\t\t// Update heuristic (if \"max-cardinality\" is a current heuristic)\n\t\tif (this.how.equals(\"max-cardinality\")) {\n\t\t\tfor (int j \u003d 0; j \u003c this.last.numNeighbours; j++) {\n\t\t\t\tVariableToEliminate vte \u003d this.varToVarInQuery.get(this.last.neighbours[j]);\n\t\t\t\tif (vte !\u003d null)\n\t\t\t\t\tvte.setHeuristicValue(vte.recomputeMaxCardinality());\n\t\t\t}\n\t\t\t// Rebuild the heap\n\t\t\tfor (int j \u003d ((this.numVariablesToEliminate / 2) - 1); j \u003e\u003d 0; j--)\n\t\t\t\tshuffleDown(j);\n\t\t} else\n\t\t\t// Rebuild the heap\n\t\t\tshuffleDown(0);\n\t\t// Remove Factors on last from last\u0027s index\n\t\tthis.factorIndex.remove(this.last.var);\n\t\t// Remove factors on last from other indexes\n\t\tIterator\u003cFactor\u003e factorsIterator \u003d this.last.factors.iterator();\n\t\twhile (factorsIterator.hasNext()) {\n\t\t\tFactor factor \u003d factorsIterator.next();\n\t\t\tItrSafe\u003cVariable\u003e variablesIterator \u003d factor.getVariables();\n\t\t\twhile (variablesIterator.hasNext()) {\n\t\t\t\tVariable var \u003d variablesIterator.next();\n\t\t\t\tVariableToEliminate vte \u003d FactorStoreIndexed.this.varToVarInQuery.get(var);\n\t\t\t\tif (vte !\u003d null) {\n\t\t\t\t\tif (vte !\u003d FactorStoreIndexed.this.last)\n\t\t\t\t\t\t// Remove from index\n\t\t\t\t\t\tFactorStoreIndexed.this.factorIndex.get(var).remove(factor);\n\t\t\t\t\t// Update neighbours count (and neighbours list)\n\t\t\t\t\tvte.removeNeighbours(factor.variables);\n\t\t\t\t} else\n\t\t\t\t\t// Remove from index\n\t\t\t\t\tFactorStoreIndexed.this.factorIndex.get(var).remove(factor);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Make into a heap by shuffling down the value at position pos. This assumes that varsPQ is a heap except maybe that the value at position pos is\n\t * larger than it\u0027s children.\n\t * \n\t * @param pos position of the value to be shuffled down.\n\t */\n\tprivate void shuffleDown(int pos) {\n\t\tint smallest;\n\t\tif (2 * pos + 1 \u003c this.numVariablesToEliminate \u0026\u0026 (this.varsPQ[2 * pos + 1].heuristicValue.compareTo(this.varsPQ[pos].heuristicValue) \u003c 0))\n\t\t\tsmallest \u003d 2 * pos + 1;\n\t\telse\n\t\t\tsmallest \u003d pos;\n\t\tif (2 * pos + 2 \u003c this.numVariablesToEliminate\n\t\t\t\t\u0026\u0026 (this.varsPQ[2 * pos + 2].heuristicValue.compareTo(this.varsPQ[smallest].heuristicValue) \u003c 0))\n\t\t\tsmallest \u003d 2 * pos + 2;\n\t\tif (smallest !\u003d pos) {\n\t\t\t// swap varsPQ[pos] \u0026 varsPQ[smallest]\n\t\t\tVariableToEliminate\u003cT\u003e tmp \u003d this.varsPQ[pos];\n\t\t\tthis.varsPQ[pos] \u003d this.varsPQ[smallest];\n\t\t\tthis.varsPQ[smallest] \u003d tmp;\n\t\t\tshuffleDown(smallest);\n\t\t}\n\t}\n\n\t/**\n\t * Make into a heap by shuffling up the value at position pos. This assumes that varsPQ is a heap except maybe that the value at position pos is\n\t * smaller than it\u0027s parent.\n\t * \n\t * @param pos position of the value to be shuffled up.\n\t */\n\tprivate void shuffleUp(int pos) {\n\t\tVariableToEliminate\u003cT\u003e tmp \u003d this.varsPQ[pos];\n\t\twhile (pos \u003e 0 \u0026 (tmp.heuristicValue.compareTo(this.varsPQ[(pos - 1) / 2].heuristicValue) \u003c 0)) {\n\t\t\tthis.varsPQ[pos] \u003d this.varsPQ[(pos - 1) / 2];\n\t\t\tpos \u003d (pos - 1) / 2;\n\t\t}\n\t\tthis.varsPQ[pos] \u003d tmp;\n\t}\n\n\t/**\n\t * @see CIspace.ve.FactorStore#addFactorComputed(CIspace.ve.Factor)\n\t */\n\tpublic void addFactorComputed(Factor factor) {\n\t\tthis.add(factor);\n\t\tif (!this.how.equals(\"max-cardinality\")) {\n\t\t\t// ---------------------- MIN-DEGREE --------------------------\n\t\t\tif (this.how.equals(\"min-degree\")) {\n\t\t\t\tfor (int i \u003d 0; i \u003c factor.variables.length; i++) {\n\t\t\t\t\tVariableToEliminate vte \u003d this.varToVarInQuery.get(factor.variables[i]);\n\t\t\t\t\tif (vte !\u003d null)\n\t\t\t\t\t\tvte.setHeuristicValue(vte.recomputeMinDegree());\n\t\t\t\t}\n\t\t\t// ---------------------- MIN-FILL --------------------------------\n\t\t\telse if (this.how.equals(\"min-fill\")) {\n\t\t\t\t// Find neigbours of eliminated node and their neighbours.\n\t\t\t\tHashSet\u003cVariableToEliminate\u003e toUpdate \u003d new HashSet\u003cVariableToEliminate\u003e();\n\t\t\t\tfor (int i \u003d 0; i \u003c factor.variables.length; i++) {\n\t\t\t\t\tVariableToEliminate vte \u003d this.varToVarInQuery.get(factor.variables[i]);\n\t\t\t\t\tif (vte !\u003d null) {\n\t\t\t\t\t\ttoUpdate.add(vte);\n\t\t\t\t\t\tfor (int j \u003d 0; j \u003c vte.numNeighbours; j++) {\n\t\t\t\t\t\t\tVariableToEliminate vte2 \u003d this.varToVarInQuery.get(vte.neighbours[i]);\n\t\t\t\t\t\t\tif (vte2 !\u003d null)\n\t\t\t\t\t\t\t\ttoUpdate.add(vte2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Recompute min-fill heuristic for neigbours of eliminated node and their neighbours.\n\t\t\t\tIterator\u003cVariableToEliminate\u003e toUpdateIterator \u003d toUpdate.iterator();\n\t\t\t\twhile (toUpdateIterator.hasNext())\n\t\t\t\t\ttoUpdateIterator.next().setHeuristicValue(recomputeMinFill());\n\t\t\t}\n\t\t\t// ---------------------- MIN-FACTOR --------------------------\n\t\t\telse\n\t\t\t\t// (this.how.equals(\"min-factor\"))\n\t\t\t\tfor (int i \u003d 0; i \u003c factor.variables.length; i++) {\n\t\t\t\t\tVariableToEliminate vte \u003d this.varToVarInQuery.get(factor.variables[i]);\n\t\t\t\t\tif (vte !\u003d null)\n\t\t\t\t\t\tvte.setHeuristicValue(vte.recomputeMinFactor());\n\t\t\t\t}\n\t\t\t// ----------------------- REBUILD THE HEAP ------------------\n\t\t\tfor (int i \u003d ((this.numVariablesToEliminate / 2) - 1); i \u003e\u003d 0; i--)\n\t\t\t\tshuffleDown(i);\n\t\t}\n\t\t// else - do nothing, heuristics for max-cardinality couldn\u0027t change.\n\t}\n\n\t/**\n\t * @see CIspace.ve.FactorStore#enumFactorsRemoved()\n\t */\n\tpublic ItrSafe\u003cFactor\u003e enumFactorsRemoved() {\n\t\treturn new EnumFacsRemoved();\n\t}\n\n\t/**\n\t * Simple Iterator class. Does not provide opportunity to remove elements from the container.\n\t * \u003cp\u003e\n\t * This code is based on the Iterator code in {@link java.util.AbstractList}.\n\t * \n\t * @author David Poole (original code) \u0026 Jacek Kisynski (adaptation for #CSP, update to Java2)\n\t * \n\t * @version 1.0 23-June-2004\n\t */\n\tprivate class EnumFacsRemoved extends ItrSafe\u003cFactor\u003e {\n\n\t\t/** Factors for the last Variable returned. */\n\t\tIterator\u003cFactor\u003e factorsIterator \u003d FactorStoreIndexed.this.last.factors.iterator();\n\n\t\t/**\n\t\t * @return true if the iterator has more elements.\n\t\t */\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.factorsIterator.hasNext();\n\t\t}\n\n\t\t/**\n\t\t * @throws NoSuchElementException\n\t\t * \n\t\t * @return the next element in the iteration.\n\t\t */\n\t\tpublic Factor next() {\n\t\t\tFactor res \u003d this.factorsIterator.next();\n\t\t\tfor (int i \u003d 0; i \u003c res.variables.length; i++) {\n\t\t\t\tVariableToEliminate vte \u003d FactorStoreIndexed.this.varToVarInQuery.get(res.variables[i]);\n\t\t\t\tif (vte !\u003d null) {\n\t\t\t\t\tif (vte !\u003d FactorStoreIndexed.this.last)\n\t\t\t\t\t\t// Remove from index\n\t\t\t\t\t\tFactorStoreIndexed.this.factorIndex.get(res.variables[i]).remove(res);\n\t\t\t\t\t// else - we don\u0027t remove from current HashSet as it would cause ConcurrentModification Exception, we simply remove the whole\n\t\t\t\t\t// HashSet in FactorStoreIndexed.next() method and keep it only as a member of FactorStoreIndexed.last.\n\t\t\t\t\t// Update neighbours count (and neighbours list)\n\t\t\t\t\tvte.removeNeighbours(res.variables);\n\t\t\t\t} else\n\t\t\t\t\t// Remove from index\n\t\t\t\t\tFactorStoreIndexed.this.factorIndex.get(res.variables[i]).remove(res);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/**\n\t * @see CIspace.ve.FactorStore#enumFactorsFinal()\n\t */\n\tpublic ItrSafe\u003cFactor\u003e enumFactorsFinal() {\n\t\treturn new ItrArray\u003cFactor\u003e(this.finalFacs, this.numFinalFacs);\n\t}\n\n\t/**\n\t * This class provides the infrastructure for the Variable in the priority queue.\n\t * \n\t * @param \u003cT1\u003e type of the heuristic object.\n\t * \n\t * @author David Poole (original code) \u0026 Jacek Kisynski (adaptation for #CSP, update to Java2)\n\t * \n\t * @version 1.0 26-January-2005\n\t */\n\tprotected abstract class VariableToEliminate\u003cT1 extends T\u003e {\n\n\t\t/** The Variable */\n\t\tprivate Variable var;\n\n\t\t/**\n\t\t * The Variables that are neighbours. In order. Note that this does not only include VariablesToEliminate but also all other Variables (but\n\t\t * does not include this.VariableToEliminate itself.\n\t\t */\n\t\tprivate Variable[] neighbours;\n\n\t\t/** Number of factors which makes particular Variable to be a neighbour. In order. */\n\t\tprivate int[] neighboursCount;\n\n\t\t/** The number of neighbours. */\n\t\tprotected int numNeighbours;\n\n\t\t/** The index of the Factors that involve this Variable. In no particular order. */\n\t\tprivate HashSet\u003cFactor\u003e factors;\n\n\t\t/** The number of factors */\n\t\tprivate int numFactors;\n\n\t\t/** If heuristic is \"max-cardinality\" then it is equal to (0 - number of eliminated neighbours). */\n\t\tprotected long maxCardinality;\n\n\t\t/** Value of the current heuristic. */\n\t\tprivate T1 heuristicValue;\n\n\t\t/**\n\t\t * Constructor.\n\t\t * \n\t\t * @param variable\n\t\t * @param maxNumNeighs\n\t\t */\n\t\tprotected VariableToEliminate(Variable variable, int maxNumNeighs) {\n\t\t\tthis.var \u003d variable;\n\t\t\tFactorStoreIndexed.this.varToVarInQuery.put(variable, (VariableToEliminate\u003cT\u003e) this);\n\t\t\tthis.neighbours \u003d new VariableNature[maxNumNeighs];\n\t\t\tthis.numNeighbours \u003d 0;\n\t\t}\n\n\t\t/**\n\t\t * Adds neighbours to VariableToEliminate.\n\t\t * \n\t\t * @param variables to be added.\n\t\t */\n\t\tvoid addNeighbours(Variable[] variables) {\n\t\t\tVariable[] newNeighbours \u003d new Variable[this.numNeighbours + variables.length];\n\t\t\tint[] newNeighboursCount \u003d new int[this.numNeighbours + variables.length];\n\t\t\t// Merging algorithm\n\t\t\tint vPos \u003d 0;\n\t\t\tint nbsPos \u003d 0;\n\t\t\tint newPos \u003d 0;\n\t\t\twhile (vPos \u003c variables.length \u0026\u0026 nbsPos \u003c this.numNeighbours) {\n\t\t\t\tif (variables[vPos].equals(this.var))\n\t\t\t\t\tvPos++;\n\t\t\t\telse if (variables[vPos].equals(this.neighbours[nbsPos])) {\n\t\t\t\t\tnewNeighbours[newPos] \u003d variables[vPos++];\n\t\t\t\t\tnewNeighboursCount[newPos++] \u003d this.neighboursCount[nbsPos++] + 1;\n\t\t\t\t} else if (variables[vPos].compareTo(this.neighbours[nbsPos]) \u003c 0) {\n\t\t\t\t\tnewNeighbours[newPos] \u003d variables[vPos++];\n\t\t\t\t\tnewNeighboursCount[newPos++] \u003d 1;\n\t\t\t\t} else {\n\t\t\t\t\tnewNeighbours[newPos] \u003d this.neighbours[nbsPos];\n\t\t\t\t\tnewNeighboursCount[newPos++] \u003d this.neighboursCount[nbsPos++];\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (vPos \u003c variables.length)\n\t\t\t\tif (variables[vPos].equals(this.var))\n\t\t\t\t\tvPos++;\n\t\t\t\telse {\n\t\t\t\t\tnewNeighbours[newPos] \u003d variables[vPos++];\n\t\t\t\t\tnewNeighboursCount[newPos++] \u003d 1;\n\t\t\t\t}\n\t\t\twhile (nbsPos \u003c this.numNeighbours) {\n\t\t\t\tnewNeighbours[newPos] \u003d this.neighbours[nbsPos];\n\t\t\t\tnewNeighboursCount[newPos++] \u003d this.neighboursCount[nbsPos++];\n\t\t\t}\n\t\t\tthis.neighbours \u003d newNeighbours;\n\t\t\tthis.neighboursCount \u003d newNeighboursCount;\n\t\t\tthis.numNeighbours \u003d newPos;\n\t\t}\n\n\t\t/**\n\t\t * Removes neighbours from VariableToEliminate (adjusts neighbourCount, neighbours and neigbourNum).\n\t\t * \n\t\t * @param variables to be removed.\n\t\t */\n\t\tvoid removeNeighbours(Variable[] variables) {\n\t\t\tint vPos \u003d 0;\n\t\t\tint nbsPos \u003d 0;\n\t\t\tint newPos \u003d 0;\n\t\t\twhile (vPos \u003c variables.length) {\n\t\t\t\tif (variables[vPos].equals(this.var)) // Skip Variable itself\n\t\t\t\t\tvPos++;\n\t\t\t\telse if (variables[vPos].equals(this.neighbours[nbsPos])) { // Neighbour\n\t\t\t\t\tif (this.neighboursCount[nbsPos] \u003d\u003d 1) { // Variable is no longer a neighbour\n\t\t\t\t\t\tvPos++;\n\t\t\t\t\t\tnbsPos++;\n\t\t\t\t\t} else { // Variable is still a neighbour\n\t\t\t\t\t\tthis.neighboursCount[newPos] \u003d this.neighboursCount[nbsPos++] - 1;\n\t\t\t\t\t\tthis.neighbours[newPos++] \u003d variables[vPos++];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// (variables[vPos].compareTo(this.neighbours[nbsPos]) \u003e 0)\n\t\t\t\t\tthis.neighboursCount[newPos] \u003d this.neighboursCount[nbsPos];\n\t\t\t\t\tthis.neighbours[newPos++] \u003d this.neighbours[nbsPos++];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Copy remaining neighbours\n\t\t\twhile (nbsPos \u003c this.numNeighbours) {\n\t\t\t\tthis.neighboursCount[newPos] \u003d this.neighboursCount[nbsPos];\n\t\t\t\tthis.neighbours[newPos++] \u003d this.neighbours[nbsPos++];\n\t\t\t}\n\t\t\tthis.numNeighbours \u003d newPos;\n\t\t}\n\n\t\t/**\n\t\t * Computes \"min-factor\" (\u003d\"min-weight\") heuristic.\n\t\t * \n\t\t * @return the size of the resulting factor after this Variable has been eliminated.\n\t\t */\n\t\tprotected long recomputeMinFactor() {\n\t\t\tlong heuristicValue \u003d 1;\n\t\t\tfor (int i \u003d 0; i \u003c this.numNeighbours; i++)\n\t\t\t\theuristicValue *\u003d this.neighbours[i].getDomainSize();\n\t\t\treturn heuristicValue;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t */\n\t\tabstract protected void setMinFactor();\n\n\t\t/**\n\t\t * Recomputing min-degree (\u003dmin-size) heuristic is unnecessary, it is equal to:\n\t\t * \u003cp\u003e\n\t\t * this.numNeighbours - number of Variables in the resulting factor after this Variable has been eliminated.\n\t\t */\n\n\t\t/**\n\t\t * \n\t\t */\n\t\tabstract protected void setMinDegree();\n\n\t\t/**\n\t\t * Recomputes min-fill\" (\u003d\"min-deficiency\", \"min-discrepancy\") heuristic.\n\t\t * \n\t\t * @return number of edges to be added after this Variable has been eliminated.\n\t\t */\n\t\tprotected long recomputeMinFill() {\n\t\t\tlong heuristicValue \u003d 0;\n\t\t\t// Process each neighbour\n\t\t\tfor (int i \u003d 0; i \u003c (this.numNeighbours - 1); i++) {\n\t\t\t\tboolean[] neighboursAdj \u003d new boolean[this.numNeighbours - (i + 1)]; // Adjacency vector\n\t\t\t\t// Process all Factors on current neighbour\n\t\t\t\tIterator\u003cFactor\u003e factorsIterator \u003d FactorStoreIndexed.this.factorIndex.get(this.neighbours[i]).iterator();\n\t\t\t\twhile (factorsIterator.hasNext()) {\n\t\t\t\t\tFactor factor \u003d factorsIterator.next();\n\t\t\t\t\t// Set indexes\n\t\t\t\t\tint nbsAdjPos \u003d 0;\n\t\t\t\t\tint nbsPos \u003d i + 1;\n\t\t\t\t\tint fctPos \u003d 0;\n\t\t\t\t\t// Find the current neighbour\n\t\t\t\t\twhile (factor.variables[fctPos].compareTo(this.neighbours[i]) \u003c 0)\n\t\t\t\t\t\tfctPos++;\n\t\t\t\t\tfctPos++;\n\t\t\t\t\t// if ((fctPos \u003c factor.variables().length) \u0026\u0026 (factor.variables()[fctPos].equals(this.neighbours[i]))) {\n\t\t\t\t\t// fctPos++;\n\t\t\t\t\t// Find connections to other neigbours using merging-like scheme\n\t\t\t\t\twhile ((fctPos \u003c factor.variables.length) \u0026\u0026 (nbsPos \u003c this.numNeighbours)) {\n\t\t\t\t\t\tif (factor.variables[fctPos].equals(this.neighbours[nbsPos])) {\n\t\t\t\t\t\t\tneighboursAdj[nbsAdjPos++] \u003d true;\n\t\t\t\t\t\t\tfctPos++;\n\t\t\t\t\t\t\tnbsPos++;\n\t\t\t\t\t\t} else if (factor.variables[fctPos].compareTo(this.neighbours[nbsPos]) \u003c 0)\n\t\t\t\t\t\t\tfctPos++;\n\t\t\t\t\t\telse { // (fl.factor.variables()[fctPos].compareTo(this.neighbours[nbsPos]) \u003e 0)\n\t\t\t\t\t\t\tnbsPos++;\n\t\t\t\t\t\t\tnbsAdjPos++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t\t// Update heuristic\n\t\t\t\tfor (int j \u003d 0; j \u003c neighboursAdj.length; j++)\n\t\t\t\t\tif (!(neighboursAdj[j]))\n\t\t\t\t\t\theuristicValue++;\n\t\t\t}\n\t\t\treturn heuristicValue;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t */\n\t\tabstract protected void setMinFill();\n\n\t\t/**\n\t\t * Recomputes \"max-cardinality\" heuristic.\n\t\t * \n\t\t * @return (0 - number of eliminated neighbours).\n\t\t */\n\t\tprotected long recomputeMaxCardinality() {\n\t\t\treturn this.maxCardinality--;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t */\n\t\t abstract protected void setMaxCardinality();}\n\t\t\n\t\t/**\n\t\t * @see java.lang.Object#toString()\n\t\t */\n\t\tpublic String toString() {\n\t\t\tStringBuffer buffer \u003d new StringBuffer(this.var + \" N[\");\n\t\t\tfor (int i \u003d 0; i \u003c this.numNeighbours; i++)\n\t\t\t\tbuffer.append(this.neighbours[i] + \"-\" + this.neighboursCount[i] + \" \");\n\t\t\tbuffer.append(\"] F(\" + this.numFactors + \") H(\" + this.heuristicValue + \")\");\n\t\t\treturn buffer.toString();\n\t\t}\n\t}\n\n\t/**\n\t * Adds Factor to the index.\n\t * \n\t * @param factor to be added to the index.\n\t */\n\tprivate void add(Factor factor) {\n\t\tboolean noVariablesToEliminate \u003d true;\n\t\tfor (int i \u003d 0; i \u003c factor.variables.length; i++) {\n\t\t\tHashSet\u003cFactor\u003e variableFactorsIndex \u003d this.factorIndex.get(factor.variables[i]);\n\t\t\tvariableFactorsIndex.add(factor);\n\t\t\tVariableToEliminate\u003cT\u003e vte \u003d FactorStoreIndexed.this.varToVarInQuery.get(factor.variables[i]);\n\t\t\tif (vte !\u003d null) {\n\t\t\t\tnoVariablesToEliminate \u003d false;\n\t\t\t\tvte.factors \u003d variableFactorsIndex;\n\t\t\t\t// Update neighbours count (and neighbours list)\n\t\t\t\tvte.addNeighbours(factor.variables);\n\t\t\t}\n\t\t}\n\t\tif (noVariablesToEliminate)\n\t\t\t// Add to final Factors\n\t\t\tFactorStoreIndexed.this.finalFacs[FactorStoreIndexed.this.numFinalFacs++] \u003d factor;\n\t}\n}",
    "David,\n\nSeems to be a bug from the recovery.",
    "Smaller test case:\n\n//-----------------------------------------//\npublic class X {\n\tvoid foo1() {\n\t\t{\n\t\t}\n\t\tclass Y  {\n\t\t}\n\tvoid foo2() {\n\t}\n\tclass Z\u003cT\u003e {\n\t\t\n\t}\n}\n}\n//-----------------------------------------//",
    "Created an attachment (id\u003d52647)\nProposed fix\n\n",
    "Released for 3.3 M3.\n\nTests added\n  ComplianceDiagnoseTest#test0052()\n  DietRecoveryTest#test117()",
    "Formatting the code doesn\u0027t work, but it doesn\u0027t crash.\nBut editing is doesn\u0027t fail anymore.\n\nVerified for 3.3 M3 using warm-up build I20061030-0800"
  ],
  "commentCreationDates": [
    "2006-08-23T07:38:35+02:00",
    "2006-08-23T15:25:41+02:00",
    "2006-10-24T11:02:11+02:00",
    "2006-10-25T09:36:13+02:00",
    "2006-10-25T09:40:55+02:00",
    "2006-10-30T20:00:30+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ClassCastException",
      "message": "org.eclipse.jdt.internal.compiler.parser.RecoveredBlock",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.compiler.parser.Parser.consumeTypeHeaderNameWithTypeParameters",
          "source": "Parser.java:2109"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule",
          "source": "Parser.java:4961"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.parser.Parser.parse",
          "source": "Parser.java:8839"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.parser.Parser.parse",
          "source": "Parser.java:9160"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements",
          "source": "MethodDeclaration.java:117"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethod",
          "source": "TypeDeclaration.java:805"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies",
          "source": "Parser.java:8111"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.process",
          "source": "Compiler.java:583"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:411"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:300"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:237"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.build",
          "source": "IncrementalImageBuilder.java:120"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas",
          "source": "JavaBuilder.java:260"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.JavaBuilder.build",
          "source": "JavaBuilder.java:185"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$2.run",
          "source": "BuildManager.java:603"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:  37"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:167"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:201"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$1.run",
          "source": "BuildManager.java:230"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:  37"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:233"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuildLoop",
          "source": "BuildManager.java:252"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.build",
          "source": "BuildManager.java:285"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.doBuild",
          "source": "AutoBuildJob.java:145"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.run",
          "source": "AutoBuildJob.java:208"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "154811",
      "date": "2006-08-23T07:38:35+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "154811",
  "bugId": "154811",
  "date": "2006-08-23T07:38:35+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}