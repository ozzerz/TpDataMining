{
  "comments": [
    "Build ID:  I20070323-1616\n\nSteps To Reproduce:\nI am unsure how to reproduce this bug. I had been running eclipse 3.2 with this workspace with no issues. I ran Eclipse 3.3 m6 against the same workspace and upon launch I noticed I had this strange error in my task list. Doing a clean all did not help.\n\nNote my target compiler is Java 1.5.11.\n\nMore information:\nSeverity and Description\tPath\tResource\tLocation\tCreation Time\tId\nInternal compiler error\njava.lang.NullPointerException\n\tat org.eclipse.jdt.internal.compiler.flow.ConditionalFlowInfo.unconditionalInits(ConditionalFlowInfo.java:207)\n\tat org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo.addInitializationsFrom(UnconditionalFlowInfo.java:93)\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:655)\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:253)\n\tat org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:107)\n\tat org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:621)\n\tat org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:391)\n\tat org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:356)\n\tat org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:173)\n\tat org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:293)\n\tat org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:59)\n\tat org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)\n\tat org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:172)\n\tat org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:629)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:163)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)\n\tat org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:248)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:251)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:307)\n\tat org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:339)\n\tat org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:137)\n\tat org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:235)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)\n\tcore/src/com/bsideinc/utils\tDateUtils.java\tline 0\t1174925086542\t65610\n\n\n\n\n******************\n\nfrom .metadata/.log:\n\n!MESSAGE Problems occurred when invoking code from plug-in: \"org.eclipse.jdt.ui\".\n!STACK 0\njava.lang.NullPointerException\n\tat org.eclipse.jdt.internal.compiler.flow.ConditionalFlowInfo.unconditionalInits(ConditionalFlowInfo.java:207)\n\tat org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo.addInitializationsFrom(UnconditionalFlowInfo.java:93)\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:655)\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:253)\n\tat org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:107)\n\tat org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:852)\n\tat org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:517)\n\tat org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:867)\n\tat org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:651)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:606)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:601)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:514)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:502)\n\tat org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:155)\n\tat org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$3.run(SelectionListenerWithASTManager.java:140)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)",
    "Could you please try to simplify core/src/com/bsideinc/utils/DateUtils.java and see whether this gets rid of the error or else share its contents with us?",
    "Strange... I was not able to work using 3.3m6 so I switched to 3.2.. worked until now.. quit... then started with 33m6 and now it is compiling just fine. I will continue to use 33m6 and see if it comes back up. Here is the source for the file just in case it may be useful:\n\npublic class DateUtils {\n    private static Map\u003cString, String\u003e s_timezoneMappings \u003d new HashMap\u003cString, String\u003e();\n\n    static {\n        s_timezoneMappings.put(\"ET\", \"America/New_York\");\n        s_timezoneMappings.put(\"EST\", \"America/New_York\");\n        s_timezoneMappings.put(\"EDT\", \"America/New_York\");\n        s_timezoneMappings.put(\"America/New_York\", \"America/New_York\");\n\n        s_timezoneMappings.put(\"CT\", \"America/Chicago\");\n        s_timezoneMappings.put(\"CST\", \"America/Chicago\");\n        s_timezoneMappings.put(\"CDT\", \"America/Chicago\");\n        s_timezoneMappings.put(\"America/Chicago\", \"America/Chicago\");\n\n        s_timezoneMappings.put(\"MT\", \"America/Denver\");\n        s_timezoneMappings.put(\"MST\", \"America/Denver\");\n        s_timezoneMappings.put(\"MDT\", \"America/Denver\");\n        s_timezoneMappings.put(\"America/Denver\", \"America/Denver\");\n\n        s_timezoneMappings.put(\"PT\", \"America/Los_Angeles\");\n        s_timezoneMappings.put(\"PST\", \"America/Los_Angeles\");\n        s_timezoneMappings.put(\"PDT\", \"America/Los_Angeles\");\n        s_timezoneMappings.put(\"America/Los_Angeles\", \"America/Los_Angeles\");\n\n        s_timezoneMappings.put(\"AT\", \"America/Anchorage\");\n        s_timezoneMappings.put(\"AST\", \"America/Anchorage\");\n        s_timezoneMappings.put(\"ADT\", \"America/Anchorage\");\n        s_timezoneMappings.put(\"America/Anchorage\", \"America/Anchorage\");\n\n        s_timezoneMappings.put(\"HT\", \"Pacific/Honolulu\");\n        s_timezoneMappings.put(\"HST\", \"Pacific/Honolulu\");\n        s_timezoneMappings.put(\"HDT\", \"Pacific/Honolulu\");\n        s_timezoneMappings.put(\"Pacific/Honolulu\", \"Pacific/Honolulu\");\n    }\n\n    /**\n     * Converts various old timezone name formats into the new format (ie, ET -\u003e America/New_York).\n     * @param timezone\n     * @return\n     * @throws NullPointerException if timezone is null\n     */\n    public static TimeZone getCanonicalTimezone(String timezone) {\n        return TimeZone.getTimeZone(s_timezoneMappings.get(timezone));\n    }\n\n    /**\n     * Returns a new {@link Calendar} instance as a copy of the the given {@link Calendar} in the provided\n     * {@link TimeZone}\n     * @throws NullPointerException if any of the parameters are null\n     */\n    public static Calendar toTimeZone(Calendar c, TimeZone tz) {\n        Calendar cnew \u003d Calendar.getInstance(tz);\n        cnew.setTimeInMillis(c.getTimeInMillis());\n        return cnew;\n    }\n\n    /**\n     * Calculates the number of days that the two dates differ by (c2 - c1).  For example:\n     * \u003ctable\u003e\n     *   \u003ctr\u003e\u003cth\u003ec1\u003c/th\u003e\u003cth\u003ec2\u003c/th\u003e\u003cth\u003eday diff\u003c/th\u003e\u003c/tr\u003e\n     *   \u003ctr\u003e\u003ctd\u003e2006-12-20 08:00\u003c/td\u003e\u003ctd\u003e2006-12-20 23:00\u003c/td\u003e\u003ctd\u003e0\u003c/td\u003e\u003c/tr\u003e\n     *   \u003ctr\u003e\u003ctd\u003e2006-12-20 08:00\u003c/td\u003e\u003ctd\u003e2006-12-21 07:00\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003c/tr\u003e\n     *   \u003ctr\u003e\u003ctd\u003e2006-12-20 08:00\u003c/td\u003e\u003ctd\u003e2006-12-21 17:00\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003c/tr\u003e\n     *   \u003ctr\u003e\u003ctd\u003e2006-04-01 08:00\u003c/td\u003e\u003ctd\u003e2006-04-02 08:00 (after DST change)\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/table\u003e\n     * @param c1\n     * @param c2\n     * @return\n     * @throws IllegalArgumentException if the Calendars are in different timezones\n     * @throws NullPointerException if any of the parameters are null\n     */\n    public static int dayDiff(Calendar c1, Calendar c2) {\n        // if the two dates are in different timezones, we don\u0027t know which one to do the comparison in\n        if (!c1.getTimeZone().equals(c2.getTimeZone()))\n            throw new IllegalArgumentException(\"Can\u0027t compute day diff when calendars have different timezones\");\n\n        // normalize both dates to 8am on their respective days.\n        Calendar work1 \u003d (Calendar) c1.clone();\n        work1.set(Calendar.HOUR_OF_DAY, 8);\n        work1.set(Calendar.MINUTE, 0);\n        work1.set(Calendar.SECOND, 0);\n        work1.set(Calendar.MILLISECOND, 0);\n\n        Calendar work2 \u003d (Calendar) c2.clone();\n        work2.set(Calendar.HOUR_OF_DAY, 8);\n        work2.set(Calendar.MINUTE, 0);\n        work2.set(Calendar.SECOND, 0);\n        work2.set(Calendar.MILLISECOND, 0);\n\n        // compute the diff in days via milliseconds.  then round to the nearest integer as that will take care of\n        // the 23 hr (spring) and 25 hr (fall) days attributed to daylight savings time\n        double rawDiff \u003d (work2.getTimeInMillis() - work1.getTimeInMillis()) / (24.0 * 60 * 60 * 1000);\n        return (int) Math.round(rawDiff);\n    }\n}",
    "Thanks for the elements.\n\nHaving a closer look at the stack trace and at the code, I\u0027m a bit puzzled. From TypeDeclaration#654 I take that outerInfo is an UnconditionalFlowInfo or else we should get a CCE (a careful look at the code leaves little doubt if any, but the explicit use of an UnconditionalFlowInfo type clears it anyway). Hence the call to unconditionalInits at UnconditionalFlowInfo#93 should select UnconditionalFlowInfo#unconditionalInits at runtime, instead of the ConditionalFlowInfo#unconditionalInits which raises the NPE.\n\nKent, could you please have a look and let me know what you think? \n(Most probable is that I miss something. Or else one of the generated code or the jvm would be wrong - but I can\u0027t quite see how that could be without causing many more errors.)",
    "The only way to initialize either field (initsWhenTrue or initsWhenFalse) to null is thru the default constructor for ConditionalFlowInfo, but no sender appears to pass null.\n\nOnly 2 implementations of unconditionalInits() exist, this one with the NPE on the first line (207) :\n\npublic UnconditionalFlowInfo unconditionalInits() {\n  return initsWhenTrue.unconditionalInits().\n    mergedWith(initsWhenFalse.unconditionalInits());\n}\n\nand this one in UnconditionalFlowInfo :\n\npublic UnconditionalFlowInfo unconditionalInits() {\n  return this;\n}\n\nSo if unconditionalInits() doesn\u0027t answer null, it would have to be one of the calls to constructor for ConditionalFlowInfo, but there are only 2.\n\nThe first is in ConditionalFlowInfo :\n\npublic FlowInfo copy() {\n  // no implementation of copy answers null\n  return new ConditionalFlowInfo(initsWhenTrue.copy(), initsWhenFalse.copy());\n}\n\nand the second is in FlowInfo :\n\npublic static FlowInfo conditional(FlowInfo initsWhenTrue, FlowInfo initsWhenFalse) {\n  return new ConditionalFlowInfo(initsWhenTrue, initsWhenFalse);\n}\n\nThis one is called from 5 analyseCode() methods but none of those methods pass null as an argument.\n\nI do not see how a NPE could occur at line 207",
    "So we both agree, thanks for investigating.\nRyan, I will close this bug as WORKSFORME, since we have no reproduceable test case (so far) and neither Kent nor I see how the stack trace you attached could happen without something going really weird underneath. \nPlease reopen if you get those errors again, especially if you can nail down a test case.",
    "Verified for 3.3M7 using I20070427-0010"
  ],
  "commentCreationDates": [
    "2007-03-26T18:13:00+02:00",
    "2007-03-26T19:06:50+02:00",
    "2007-03-26T19:23:06+02:00",
    "2007-03-27T12:03:42+02:00",
    "2007-03-27T18:26:58+02:00",
    "2007-03-28T06:45:38+02:00",
    "2007-04-27T17:18:19+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.compiler.flow.ConditionalFlowInfo.unconditionalInits",
          "source": "ConditionalFlowInfo.java:207"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo.addInitializationsFrom",
          "source": "UnconditionalFlowInfo.java:93"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode",
          "source": "TypeDeclaration.java:655"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode",
          "source": "TypeDeclaration.java:253"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode",
          "source": "CompilationUnitDeclaration.java:107"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.process",
          "source": "Compiler.java:621"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:391"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:356"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile",
          "source": "BatchImageBuilder.java:173"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:293"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build",
          "source": "BatchImageBuilder.java:59"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll",
          "source": "JavaBuilder.java:254"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.JavaBuilder.build",
          "source": "JavaBuilder.java:172"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$2.run",
          "source": "BuildManager.java:629"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:163"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:199"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$1.run",
          "source": "BuildManager.java:248"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:251"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuildLoop",
          "source": "BuildManager.java:307"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.build",
          "source": "BuildManager.java:339"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.doBuild",
          "source": "AutoBuildJob.java:137"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.run",
          "source": "AutoBuildJob.java:235"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "179334",
      "date": "2007-03-26T18:13:00+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.compiler.flow.ConditionalFlowInfo.unconditionalInits",
          "source": "ConditionalFlowInfo.java:207"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo.addInitializationsFrom",
          "source": "UnconditionalFlowInfo.java:93"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode",
          "source": "TypeDeclaration.java:655"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode",
          "source": "TypeDeclaration.java:253"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode",
          "source": "CompilationUnitDeclaration.java:107"
        },
        {
          "method": "org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve",
          "source": "CompilationUnitResolver.java:852"
        },
        {
          "method": "org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve",
          "source": "CompilationUnitResolver.java:517"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTParser.internalCreateAST",
          "source": "ASTParser.java:867"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTParser.createAST",
          "source": "ASTParser.java:651"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run",
          "source": "ASTProvider.java:606"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST",
          "source": "ASTProvider.java:601"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST",
          "source": "ASTProvider.java:514"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST",
          "source": "ASTProvider.java:502"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform",
          "source": "SelectionListenerWithASTManager.java:155"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$3.run",
          "source": "SelectionListenerWithASTManager.java:140"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 1,
      "commentIndex": 0,
      "bugId": "179334",
      "date": "2007-03-26T18:13:00+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "179334",
  "bugId": "179334",
  "date": "2007-03-26T18:13:00+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}