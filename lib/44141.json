{
  "comments": [
    "20030930+JDT patches\n\nAttempting to format SearchEngine unit, I got out of memory errors, and \nfollowing entries into the log:\n\n!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:18:57.646\n!MESSAGE formatter returned null-edit. \nstring: /***********************************************************************\n******\n * Copyright (c) 2000, 2003 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Common Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n\npackage org.eclipse.formatter.example\n\n/**\n * Example class showing the format of the new comment formatter\n * @version 1.0\n */\nclass File {\n\n        /**\n         * Returns the number of bytes that can be read from this file input \nstream without blocking.\n         * \u003cp\u003eHere is an example on how to use \u003ccode\u003eavailableSize\u003c/code\u003e.\u003c/p\u003e\n         *\n         * The Loop to compute the number of bytes works as follows:\n         * \u003cpre\u003e\n         * while ((size \u003d availableSize(stream, size)) \u003e 0) { System.out.println\n(\"available\"); }\n         * \u003c/pre\u003e\n         * For further reference consult {@link org.eclipse.formatter}.\n         * @param stream The file input stream to return the number of \navailable bytes for.\n         * @param size The current number of available bytes.\n         * @return the number of bytes that can be read from this file input \nstream without blocking.\n         * @exception IOException if an I/O error occurs.\n         */\n        public static int availableSize(FileInputStream stream, int size) {\n\n                if (size \u003c currentSize) {\n                try {\n                size\u003d(long)stream.available();\n                } catch (IOException e) {\n\n                }\n                } else if (size \u003d\u003d currentSize) {\n                ++size;\n                } else {\n                --size;\n                }\n                return size;\n        }\n}\n!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:18:57.677\n!MESSAGE formatter returned null-edit. \nstring: /***********************************************************************\n******\n * Copyright (c) 2000, 2003 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Common Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n\npackage org.eclipse.formatter.example\n\n/**\n * Example class showing the format of the new comment formatter\n * @version 1.0\n */\nclass File {\n\n        /**\n         * Returns the number of bytes that can be read from this file input \nstream\n         * without blocking.\n         * \u003cp\u003e\n         * Here is an example on how to use \u003ccode\u003eavailableSize\u003c/code\u003e.\n         * \u003c/p\u003e\n         *\n         * The Loop to compute the number of bytes works as follows:\n         *\n         * \u003cpre\u003e\nwhile ((size \u003d availableSize(stream, size)) \u003e 0) { System.out.println\n(\"available\"); }\n         * \u003c/pre\u003e\n         *\n         * For further reference consult {@link org.eclipse.formatter}.\n         *\n         * @param stream\n         *                     The file input stream to return the number of \navailable bytes\n         *                     for.\n         * @param size\n         *                     The current number of available bytes.\n         * @return the number of bytes that can be read from this file input \nstream\n         *                without blocking.\n         * @exception IOException\n         *                          if an I/O error occurs.\n         */\n        public static int availableSize(FileInputStream stream, int size) {\n\n                if (size \u003c currentSize) {\n                try {\n                size\u003d(long)stream.available();\n                } catch (IOException e) {\n\n                }\n                } else if (size \u003d\u003d currentSize) {\n                ++size;\n                } else {\n                --size;\n                }\n                return size;\n        }\n}\n!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:19:22.318\n!MESSAGE formatter returned null-edit. \nstring: /***********************************************************************\n******\n * Copyright (c) 2000, 2003 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Common Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n\npackage org.eclipse.formatter.example\n\n/**\n * Example class showing the format of the new comment formatter\n * @version 1.0\n */\nclass File {\n\n        /**\n         * Returns the number of bytes that can be read from this file input \nstream without blocking.\n         * \u003cp\u003eHere is an example on how to use \u003ccode\u003eavailableSize\u003c/code\u003e.\u003c/p\u003e\n         *\n         * The Loop to compute the number of bytes works as follows:\n         * \u003cpre\u003e\n         * while ((size \u003d availableSize(stream, size)) \u003e 0) { System.out.println\n(\"available\"); }\n         * \u003c/pre\u003e\n         * For further reference consult {@link org.eclipse.formatter}.\n         * @param stream The file input stream to return the number of \navailable bytes for.\n         * @param size The current number of available bytes.\n         * @return the number of bytes that can be read from this file input \nstream without blocking.\n         * @exception IOException if an I/O error occurs.\n         */\n        public static int availableSize(FileInputStream stream, int size) {\n\n                if (size \u003c currentSize) {\n                try {\n                size\u003d(long)stream.available();\n                } catch (IOException e) {\n\n                }\n                } else if (size \u003d\u003d currentSize) {\n                ++size;\n                } else {\n                --size;\n                }\n                return size;\n        }\n}\n!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:19:22.349\n!MESSAGE formatter returned null-edit. \nstring: /***********************************************************************\n******\n * Copyright (c) 2000, 2003 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Common Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n\npackage org.eclipse.formatter.example\n\n/**\n * Example class showing the format of the new comment formatter\n * @version 1.0\n */\nclass File {\n\n        /**\n         * Returns the number of bytes that can be read from this file input \nstream\n         * without blocking.\n         * \u003cp\u003e\n         * Here is an example on how to use \u003ccode\u003eavailableSize\u003c/code\u003e.\n         * \u003c/p\u003e\n         *\n         * The Loop to compute the number of bytes works as follows:\n         *\n         * \u003cpre\u003e\nwhile ((size \u003d availableSize(stream, size)) \u003e 0) { System.out.println\n(\"available\"); }\n         * \u003c/pre\u003e\n         *\n         * For further reference consult {@link org.eclipse.formatter}.\n         *\n         * @param stream\n         *                     The file input stream to return the number of \navailable bytes\n         *                     for.\n         * @param size\n         *                     The current number of available bytes.\n         * @return the number of bytes that can be read from this file input \nstream\n         *                without blocking.\n         * @exception IOException\n         *                          if an I/O error occurs.\n         */\n        public static int availableSize(FileInputStream stream, int size) {\n\n                if (size \u003c currentSize) {\n                try {\n                size\u003d(long)stream.available();\n                } catch (IOException e) {\n\n                }\n                } else if (size \u003d\u003d currentSize) {\n                ++size;\n                } else {\n                --size;\n                }\n                return size;\n        }\n}\n!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:19:22.974\n!MESSAGE formatter returned null-edit. \nstring: /***********************************************************************\n******\n * Copyright (c) 2000, 2003 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Common Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n\npackage org.eclipse.formatter.example\n\n/**\n * Example class showing the format of the new comment formatter\n * @version 1.0\n */\nclass File {\n\n        /**\n         * Returns the number of bytes that can be read from this file input \nstream without blocking.\n         * \u003cp\u003eHere is an example on how to use \u003ccode\u003eavailableSize\u003c/code\u003e.\u003c/p\u003e\n         *\n         * The Loop to compute the number of bytes works as follows:\n         * \u003cpre\u003e\n         * while ((size \u003d availableSize(stream, size)) \u003e 0) { System.out.println\n(\"available\"); }\n         * \u003c/pre\u003e\n         * For further reference consult {@link org.eclipse.formatter}.\n         * @param stream The file input stream to return the number of \navailable bytes for.\n         * @param size The current number of available bytes.\n         * @return the number of bytes that can be read from this file input \nstream without blocking.\n         * @exception IOException if an I/O error occurs.\n         */\n        public static int availableSize(FileInputStream stream, int size) {\n\n                if (size \u003c currentSize) {\n                try {\n                size\u003d(long)stream.available();\n                } catch (IOException e) {\n\n                }\n                } else if (size \u003d\u003d currentSize) {\n                ++size;\n                } else {\n                --size;\n                }\n                return size;\n        }\n}\n!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:19:22.990\n!MESSAGE formatter returned null-edit. \nstring: /***********************************************************************\n******\n * Copyright (c) 2000, 2003 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Common Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n\npackage org.eclipse.formatter.example\n\n/**\n * Example class showing the format of the new comment formatter\n * @version 1.0\n */\nclass File {\n\n        /**\n         * Returns the number of bytes that can be read from this file input \nstream\n         * without blocking.\n         * \u003cp\u003e\n         * Here is an example on how to use \u003ccode\u003eavailableSize\u003c/code\u003e.\n         * \u003c/p\u003e\n         *\n         * The Loop to compute the number of bytes works as follows:\n         *\n         * \u003cpre\u003e\nwhile ((size \u003d availableSize(stream, size)) \u003e 0) { System.out.println\n(\"available\"); }\n         * \u003c/pre\u003e\n         *\n         * For further reference consult {@link org.eclipse.formatter}.\n         *\n         * @param stream\n         *                     The file input stream to return the number of \navailable bytes\n         *                     for.\n         * @param size\n         *                     The current number of available bytes.\n         * @return the number of bytes that can be read from this file input \nstream\n         *                without blocking.\n         * @exception IOException\n         *                          if an I/O error occurs.\n         */\n        public static int availableSize(FileInputStream stream, int size) {\n\n                if (size \u003c currentSize) {\n                try {\n                size\u003d(long)stream.available();\n                } catch (IOException e) {\n\n                }\n                } else if (size \u003d\u003d currentSize) {\n                ++size;\n                } else {\n                --size;\n                }\n                return size;\n        }\n}\n!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:19:24.599\n!MESSAGE formatter returned null-edit. \nstring: /***********************************************************************\n******\n * Copyright (c) 2000, 2003 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Common Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n\npackage org.eclipse.formatter.example\n\n/**\n * Example class showing the format of the new comment formatter\n * @version 1.0\n */\nclass File {\n\n        /**\n         * Returns the number of bytes that can be read from this file input \nstream without blocking.\n         * \u003cp\u003eHere is an example on how to use \u003ccode\u003eavailableSize\u003c/code\u003e.\u003c/p\u003e\n         *\n         * The Loop to compute the number of bytes works as follows:\n         * \u003cpre\u003e\n         * while ((size \u003d availableSize(stream, size)) \u003e 0) { System.out.println\n(\"available\"); }\n         * \u003c/pre\u003e\n         * For further reference consult {@link org.eclipse.formatter}.\n         * @param stream The file input stream to return the number of \navailable bytes for.\n         * @param size The current number of available bytes.\n         * @return the number of bytes that can be read from this file input \nstream without blocking.\n         * @exception IOException if an I/O error occurs.\n         */\n        public static int availableSize(FileInputStream stream, int size) {\n\n                if (size \u003c currentSize) {\n                try {\n                size\u003d(long)stream.available();\n                } catch (IOException e) {\n\n                }\n                } else if (size \u003d\u003d currentSize) {\n                ++size;\n                } else {\n                --size;\n                }\n                return size;\n        }\n}\n!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:19:24.646\n!MESSAGE formatter returned null-edit. \nstring: /***********************************************************************\n******\n * Copyright (c) 2000, 2003 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Common Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n\npackage org.eclipse.formatter.example\n\n/**\n * Example class showing the format of the new comment formatter\n * @version 1.0\n */\nclass File {\n\n        /**\n         * Returns\n         * the\n         * number\n         * of\n         * bytes\n         * that\n         * can\n         * be\n         * read\n         * from\n         * this\n         * file\n         * input\n         * stream\n         * without\n         * blocking.\n         * \u003cp\u003e\n         * Here\n         * is\n         * an\n         * example\n         * on\n         * how\n         * to\n         * use\n         * \u003ccode\u003eavailableSize\u003c/code\u003e.\n         * \u003c/p\u003e\n         *\n         * The\n         * Loop\n         * to\n         * compute\n         * the\n         * number\n         * of\n         * bytes\n         * works\n         * as\n         * follows:\n         *\n         * \u003cpre\u003e\nwhile ((size \u003d availableSize(stream, size)) \u003e 0) { System.out.println\n(\"available\"); }\n         * \u003c/pre\u003e\n         *\n         * For\n         * further\n         * reference\n         * consult\n         * {@link org.eclipse.formatter}.\n         *\n         * @param\n         * stream\n         * The\n         * file\n         * input\n         * stream\n         * to\n         * return\n         * the\n         * number\n         * of\n         * available\n         * bytes\n         * for.\n         * @param\n         * size\n         * The\n         * current\n         * number\n         * of\n         * available\n         * bytes.\n         * @return\n         * the\n         * number\n         * of\n         * bytes\n         * that\n         * can\n         * be\n         * read\n         * from\n         * this\n         * file\n         * input\n         * stream\n         * without\n         * blocking.\n         * @exception\n         * IOException\n         * if\n         * an\n         * I/O\n         * error\n         * occurs.\n         */\n        public static int availableSize(FileInputStream stream, int size) {\n\n                if (size \u003c currentSize) {\n                try {\n                size\u003d(long)stream.available();\n                } catch (IOException e) {\n\n                }\n                } else if (size \u003d\u003d currentSize) {\n                ++size;\n                } else {\n                --size;\n                }\n                return size;\n        }\n}\n!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:19:25.177\n!MESSAGE formatter returned null-edit. \nstring: /***********************************************************************\n******\n * Copyright (c) 2000, 2003 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Common Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n\npackage org.eclipse.formatter.example\n\n/**\n * Example class showing the format of the new comment formatter\n * @version 1.0\n */\nclass File {\n\n        /**\n         * Returns the number of bytes that can be read from this file input \nstream without blocking.\n         * \u003cp\u003eHere is an example on how to use \u003ccode\u003eavailableSize\u003c/code\u003e.\u003c/p\u003e\n         *\n         * The Loop to compute the number of bytes works as follows:\n         * \u003cpre\u003e\n         * while ((size \u003d availableSize(stream, size)) \u003e 0) { System.out.println\n(\"available\"); }\n         * \u003c/pre\u003e\n         * For further reference consult {@link org.eclipse.formatter}.\n         * @param stream The file input stream to return the number of \navailable bytes for.\n         * @param size The current number of available bytes.\n         * @return the number of bytes that can be read from this file input \nstream without blocking.\n         * @exception IOException if an I/O error occurs.\n         */\n        public static int availableSize(FileInputStream stream, int size) {\n\n                if (size \u003c currentSize) {\n                try {\n                size\u003d(long)stream.available();\n                } catch (IOException e) {\n\n                }\n                } else if (size \u003d\u003d currentSize) {\n                ++size;\n                } else {\n                --size;\n                }\n                return size;\n        }\n}\n!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:19:25.193\n!MESSAGE formatter returned null-edit. \nstring: /***********************************************************************\n******\n * Copyright (c) 2000, 2003 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Common Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n\npackage org.eclipse.formatter.example\n\n/**\n * Example class showing the format of the new comment formatter\n * @version 1.0\n */\nclass File {\n\n        /**\n         * Returns the number of bytes that can be read from this file input \nstream without blocking.\n         * \u003cp\u003e\n         * Here is an example on how to use \u003ccode\u003eavailableSize\u003c/code\u003e.\n         * \u003c/p\u003e\n         *\n         * The Loop to compute the number of bytes works as follows:\n         *\n         * \u003cpre\u003e\nwhile ((size \u003d availableSize(stream, size)) \u003e 0) { System.out.println\n(\"available\"); }\n         * \u003c/pre\u003e\n         *\n         * For further reference consult {@link org.eclipse.formatter}.\n         *\n         * @param stream\n         *                     The file input stream to return the number of \navailable bytes for.\n         * @param size\n         *                     The current number of available bytes.\n         * @return the number of bytes that can be read from this file input \nstream without blocking.\n         * @exception IOException\n         *                          if an I/O error occurs.\n         */\n        public static int availableSize(FileInputStream stream, int size) {\n\n                if (size \u003c currentSize) {\n                try {\n                size\u003d(long)stream.available();\n                } catch (IOException e) {\n\n                }\n                } else if (size \u003d\u003d currentSize) {\n                ++size;\n                } else {\n                --size;\n                }\n                return size;\n        }\n}\n!ENTRY org.eclipse.ui 4 4 Oct 03, 2003 18:19:57.333\n!MESSAGE Unhandled exception caught in event loop.\nUnhandled exception caught in event loop.\nReason:\n!ENTRY org.eclipse.ui 4 0 Oct 03, 2003 18:19:57.349\n!MESSAGE java.lang.OutOfMemoryError\n!STACK 0\njava.lang.OutOfMemoryError\njava.lang.OutOfMemoryError\njava.lang.OutOfMemoryError",
    "After I fixed the source for the formatter page, I get these errors:\norg.eclipse.jface.util.Assert$AssertionFailedException: Assertion failed: \n\tat java.lang.Throwable.\u003cinit\u003e(Throwable.java)\n\tat java.lang.Throwable.\u003cinit\u003e(Throwable.java)\n\tat org.eclipse.jface.util.Assert$AssertionFailedException.\u003cinit\u003e(Assert.java:54)\n\tat org.eclipse.jface.util.Assert.isTrue(Assert.java:168)\n\tat org.eclipse.jface.util.Assert.isTrue(Assert.java)\n\tat\norg.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findDifferences(RangeDifferencer.java)\n\tat\norg.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findRanges(RangeDifferencer.java:291)\n\tat\norg.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findRanges(RangeDifferencer.java:276)\n\tat\norg.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer.handleChange(DocumentLineDiffer.java:773)\n\tat\norg.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer$1.run(DocumentLineDiffer.java:575)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:61)\n\n\nand:\norg.eclipse.jface.util.Assert$AssertionFailedException: Assertion failed: \n\tat java.lang.Throwable.\u003cinit\u003e(Throwable.java)\n\tat java.lang.Throwable.\u003cinit\u003e(Throwable.java)\n\tat org.eclipse.jface.util.Assert$AssertionFailedException.\u003cinit\u003e(Assert.java:54)\n\tat org.eclipse.jface.util.Assert.isTrue(Assert.java:168)\n\tat org.eclipse.jface.util.Assert.isTrue(Assert.java)\n\tat\norg.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findDifferences(RangeDifferencer.java)\n\tat\norg.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findRanges(RangeDifferencer.java:291)\n\tat\norg.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findRanges(RangeDifferencer.java:276)\n\tat\norg.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer.handleChange(DocumentLineDiffer.java:773)\n\tat\norg.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer.documentChanged(DocumentLineDiffer.java:655)\n\tat\norg.eclipse.jface.text.AbstractDocument.doFireDocumentChanged2(AbstractDocument.java)\n\tat\norg.eclipse.jface.text.AbstractDocument.doFireDocumentChanged(AbstractDocument.java)\n\tat\norg.eclipse.jface.text.AbstractDocument.doFireDocumentChanged(AbstractDocument.java)\n\tat\norg.eclipse.jface.text.AbstractDocument.fireDocumentChanged(AbstractDocument.java)\n\tat org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java)\n\tat\norg.eclipse.jdt.internal.ui.javaeditor.PartiallySynchronizedDocument.replace(PartiallySynchronizedDocument.java:61)\n\tat\norg.eclipse.jdt.internal.ui.text.comment.CommentRegion.applyText(CommentRegion.java)\n\tat\norg.eclipse.jdt.internal.ui.text.comment.CommentLine.applyLine(CommentLine.java:125)\n\tat\norg.eclipse.jdt.internal.ui.text.comment.CommentRegion.applyRegion(CommentRegion.java:167)\n\tat\norg.eclipse.jdt.internal.ui.text.comment.CommentRegion.format(CommentRegion.java:256)\n\tat\norg.eclipse.jdt.internal.ui.text.comment.CommentFormattingStrategy.format(CommentFormattingStrategy.java:131)\n\tat\norg.eclipse.jface.text.formatter.ContentFormatter.format(ContentFormatter.java:782)\n\tat\norg.eclipse.jface.text.formatter.ContentFormatter.formatPartitions(ContentFormatter.java:602)\n\tat\norg.eclipse.jface.text.formatter.ContentFormatter.format(ContentFormatter.java:491)\n\tat org.eclipse.jface.text.source.SourceViewer.doOperation(SourceViewer.java:664)\n\tat\norg.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.doOperation(JavaSourceViewer.java:98)\n\tat\norg.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:169)\n\tat\norg.eclipse.ui.texteditor.TextOperationAction$1.run(TextOperationAction.java:122)\n\tat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java)\n\tat org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:120)\n\tat org.eclipse.jface.action.Action.runWithEvent(Action.java:842)\n\tat\norg.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:543)\n\tat\norg.eclipse.jface.action.ActionContributionItem.access$4(ActionContributionItem.java:496)\n\tat\norg.eclipse.jface.action.ActionContributionItem$6.handleEvent(ActionContributionItem.java:468)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java)\n\tat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2106)\n\tat org.eclipse.ui.internal.Workbench.run(Workbench.java:2089)\n\tat\norg.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:858)\n\tat org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:79)\n\tat\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:41)\n\tat java.lang.reflect.Method.invoke(Method.java:386)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:298)\n\tat org.eclipse.core.launcher.Main.run(Main.java:764)\n\tat org.eclipse.core.launcher.Main.main(Main.java:598)\n",
    "Formatted ouput is with line split \u003d 120. I don\u0027t see what I could do to fix it.\n\n/*******************************************************************************\n * Copyright (c) 2000, 2003 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials \n * are made available under the terms of the Common Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n * \n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.jdt.core.search;\nimport org.eclipse.core.resources.*;\nimport org.eclipse.core.runtime.*;\nimport org.eclipse.jdt.core.*;\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter;\nimport org.eclipse.jdt.internal.compiler.CompilationResult;\nimport org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\nimport org.eclipse.jdt.internal.compiler.ast.*;\nimport org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.LocalTypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\nimport org.eclipse.jdt.internal.compiler.lookup.ClassScope;\nimport org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;\nimport org.eclipse.jdt.internal.compiler.parser.Parser;\nimport org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\nimport org.eclipse.jdt.internal.compiler.problem.ProblemReporter;\nimport org.eclipse.jdt.internal.core.*;\nimport org.eclipse.jdt.internal.core.search.*;\nimport org.eclipse.jdt.internal.core.search.HierarchyScope;\nimport org.eclipse.jdt.internal.core.search.IndexSearchAdapter;\nimport org.eclipse.jdt.internal.core.search.IIndexSearchRequestor;\nimport org.eclipse.jdt.internal.core.search.IInfoConstants;\nimport org.eclipse.jdt.internal.core.search.JavaSearchScope;\nimport org.eclipse.jdt.internal.core.search.JavaWorkspaceScope;\nimport org.eclipse.jdt.internal.core.search.PatternSearchJob;\nimport org.eclipse.jdt.internal.core.search.PathCollector;\nimport org.eclipse.jdt.internal.core.search.Util;\nimport org.eclipse.jdt.internal.core.search.indexing.*;\nimport org.eclipse.jdt.internal.core.search.matching.*;\nimport java.util.*;\n/**\n * A \u003ccode\u003eSearchEngine\u003c/code\u003e searches for java elements following a search\npattern.\n * The search can be limited to a search scope.\n * \u003cp\u003e\n * Various search patterns can be created using the factory methods \n * \u003ccode\u003ecreateSearchPattern(String, int, int, boolean)\u003c/code\u003e,\n\u003ccode\u003ecreateSearchPattern(IJavaElement, int)\u003c/code\u003e,\n * \u003ccode\u003ecreateOrSearchPattern(ISearchPattern, ISearchPattern)\u003c/code\u003e.\n * \u003c/p\u003e\n * \u003cp\u003eFor example, one can search for references to a method in the hierarchy of\na type, \n * or one can search for the declarations of types starting with \"Abstract\" in a\nproject.\n * \u003c/p\u003e\n * \u003cp\u003e\n * This class may be instantiated; it is not intended to be subclassed.\n * \u003c/p\u003e\n * TODO: remove IWorkspace argument on the search methods before 3.0\n */\npublic class SearchEngine {\n    /*\n     * A default parser to parse non-reconciled working copies\n     */\n    private Parser parser;\n    private CompilerOptions compilerOptions;\n    /*\n     * A list of working copies that take precedence over their original \n     * compilation units.\n     */\n    private ICompilationUnit[] workingCopies;\n    /*\n     * A working copy owner whose working copies will take precedent over \n     * their original compilation units.\n     */\n    private WorkingCopyOwner workingCopyOwner;\n    /**\n     * For tracing purpose.\n     */\n    public static boolean VERBOSE \u003d false;\n    /**\n     * Creates a new search engine.\n     */\n    public SearchEngine() {\n        // will use working copies of PRIMARY owner\n    }\n    /**\n     * Creates a new search engine with a list of working copies that will take\nprecedence over \n     * their original compilation units in the subsequent search operations.\n     * \u003cp\u003e\n     * Note that passing an empty working copy will be as if the original\ncompilation\n     * unit had been deleted.\u003c/p\u003e\n     * \u003cp\u003e\n     * Since 3.0 the given working copies take precedence over primary working\ncopies (if any).\n     * \n     * @param workingCopies the working copies that take precedence over their\noriginal compilation units\n     * @since 2.0\n     */\n    public SearchEngine(IWorkingCopy[] workingCopies) {\n        int length \u003d workingCopies.length;\n        System.arraycopy(workingCopies, 0, this.workingCopies \u003d new\nICompilationUnit[length], 0, length);\n    }\n    /**\n     * Creates a new search engine with the given working copy owner.\n     * The working copies owned by this owner will take precedence over \n     * the primary compilation units in the subsequent search operations.\n     * \n     * @param workingCopyOwner the owner of the working copies that take\nprecedence over their original compilation units\n     * @since 3.0\n     */\n    public SearchEngine(WorkingCopyOwner workingCopyOwner) {\n        this.workingCopyOwner \u003d workingCopyOwner;\n    }\n    /**\n     * Returns a java search scope limited to the hierarchy of the given type.\n     * The java elements resulting from a search with this scope will\n     * be types in this hierarchy, or members of the types in this hierarchy.\n     *\n     * @param type the focus of the hierarchy scope\n     * @return a new hierarchy scope\n     * @exception JavaModelException if the hierarchy could not be computed on\nthe given type\n     */\n    public static IJavaSearchScope createHierarchyScope(IType type) throws\nJavaModelException {\n        return createHierarchyScope(type, DefaultWorkingCopyOwner.PRIMARY);\n    }\n    /**\n     * Returns a java search scope limited to the hierarchy of the given type.\n     * When the hierarchy is computed, the types defined in the working copies owned\n     * by the given owner take precedence over the original compilation units.\n     * The java elements resulting from a search with this scope will\n     * be types in this hierarchy, or members of the types in this hierarchy.\n     *\n     * @param type the focus of the hierarchy scope\n     * @param the owner of working copies that take precedence over original\ncompilation units\n     * @return a new hierarchy scope\n     * @exception JavaModelException if the hierarchy could not be computed on\nthe given type\n     * @since 3.0\n     */\n    public static IJavaSearchScope createHierarchyScope(IType type,\nWorkingCopyOwner owner) throws JavaModelException {\n        return new HierarchyScope(type, owner);\n    }\n    /**\n     * Returns a java search scope limited to the given resources.\n     * The java elements resulting from a search with this scope will\n     * have their underlying resource included in or equals to one of the given\n     * resources.\n     * \u003cp\u003e\n     * Resources must not overlap, for example, one cannot include a folder and\nits children.\n     * \u003c/p\u003e\n     *\n     * @param resources the resources the scope is limited to\n     * @return a new java search scope\n     * @deprecated Use createJavaSearchScope(IJavaElement[]) instead\n     */\n    public static IJavaSearchScope createJavaSearchScope(IResource[] resources) {\n        int length \u003d resources.length;\n        IJavaElement[] elements \u003d new IJavaElement[length];\n        for (int i \u003d 0; i \u003c length; i++) {\n            elements[i] \u003d JavaCore.create(resources[i]);\n        }\n        return createJavaSearchScope(elements);\n    }\n    /**\n     * Returns a java search scope limited to the given java elements.\n     * The java elements resulting from a search with this scope will\n     * be children of the given elements.\n     * \u003cp\u003e\n     * If an element is an IJavaProject, then the project\u0027s source folders, \n     * its jars (external and internal) and its referenced projects (with their\nsource \n     * folders and jars, recursively) will be included.\n     * If an element is an IPackageFragmentRoot, then only the package fragments of \n     * this package fragment root will be included.\n     * If an element is an IPackageFragment, then only the compilation unit and\nclass \n     * files of this package fragment will be included. Subpackages will NOT be \n     * included.\u003c/p\u003e\n     * \u003cp\u003e\n     * In other words, this is equivalent to using\nSearchEngine.createJavaSearchScope(elements, true).\u003c/p\u003e\n     *\n     * @param elements the java elements the scope is limited to\n     * @return a new java search scope\n     * @since 2.0\n     */\n    public static IJavaSearchScope createJavaSearchScope(IJavaElement[] elements) {\n        return createJavaSearchScope(elements, true);\n    }\n    /**\n     * Returns a java search scope limited to the given java elements.\n     * The java elements resulting from a search with this scope will\n     * be children of the given elements.\n     * \n     * If an element is an IJavaProject, then the project\u0027s source folders, \n     * its jars (external and internal) and - if specified - its referenced\nprojects \n     * (with their source folders and jars, recursively) will be included.\n     * If an element is an IPackageFragmentRoot, then only the package fragments of \n     * this package fragment root will be included.\n     * If an element is an IPackageFragment, then only the compilation unit and\nclass \n     * files of this package fragment will be included. Subpackages will NOT be \n     * included.\n     *\n     * @param elements the java elements the scope is limited to\n     * @param includeReferencedProjects a flag indicating if referenced projects\nmust be \n     * \t\t\t\t\t\t\t\t\t recursively included\n     * @return a new java search scope\n     * @since 2.0\n     */\n    public static IJavaSearchScope createJavaSearchScope(IJavaElement[]\nelements, boolean includeReferencedProjects) {\n        JavaSearchScope scope \u003d new JavaSearchScope();\n        HashSet visitedProjects \u003d new HashSet(2);\n        for (int i \u003d 0, length \u003d elements.length; i \u003c length; i++) {\n            IJavaElement element \u003d elements[i];\n            if (element !\u003d null) {\n                try {\n                    if (element instanceof IJavaProject) {\n                        scope.add((IJavaProject) element,\nincludeReferencedProjects, visitedProjects);\n                    } else {\n                        scope.add(element);\n                    }\n                } catch (JavaModelException e) {\n                    // ignore\n                }\n            }\n        }\n        return scope;\n    }\n    /**\n     * Returns a search pattern that combines the given two patterns into a \"or\"\npattern.\n     * The search result will match either the left pattern or the right pattern.\n     *\n     * @param leftPattern the left pattern\n     * @param rightPattern the right pattern\n     * @return a \"or\" pattern\n     */\n    public static ISearchPattern createOrSearchPattern(ISearchPattern\nleftPattern, ISearchPattern rightPattern) {\n        return new OrPattern((SearchPattern) leftPattern, (SearchPattern)\nrightPattern);\n    }\n    /**\n     * Returns a search pattern based on a given string pattern. The string\npatterns support \u0027*\u0027 wild-cards.\n     * The remaining parameters are used to narrow down the type of expected\nresults.\n     *\n     * \u003cbr\u003e\n     *\tExamples:\n     *\t\u003cul\u003e\n     * \t\t\u003cli\u003esearch for case insensitive references to \u003ccode\u003eObject\u003c/code\u003e:\n     *\t\t\t\u003ccode\u003ecreateSearchPattern(\"Object\", TYPE, REFERENCES, false);\u003c/code\u003e\u003c/li\u003e\n     *  \t\u003cli\u003esearch for case sensitive references to exact \u003ccode\u003eObject()\u003c/code\u003e\nconstructor:\n     *\t\t\t\u003ccode\u003ecreateSearchPattern(\"java.lang.Object()\", CONSTRUCTOR,\nREFERENCES, true);\u003c/code\u003e\u003c/li\u003e\n     *  \t\u003cli\u003esearch for implementers of \u003ccode\u003ejava.lang.Runnable\u003c/code\u003e:\n     *\t\t\t\u003ccode\u003ecreateSearchPattern(\"java.lang.Runnable\", TYPE, IMPLEMENTORS,\ntrue);\u003c/code\u003e\u003c/li\u003e\n     *  \u003c/ul\u003e\n     * @param stringPattern the given pattern\n     * @param searchFor determines the nature of the searched elements\n     *\t\u003cul\u003e\n     * \t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.CLASS\u003c/code\u003e: only look for classes\u003c/li\u003e\n     *\t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.INTERFACE\u003c/code\u003e: only look for\ninterfaces\u003c/li\u003e\n     * \t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.TYPE\u003c/code\u003e: look for both classes and\ninterfaces\u003c/li\u003e\n     *\t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.FIELD\u003c/code\u003e: look for fields\u003c/li\u003e\n     *\t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.METHOD\u003c/code\u003e: look for methods\u003c/li\u003e\n     *\t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.CONSTRUCTOR\u003c/code\u003e: look for\nconstructors\u003c/li\u003e\n     *\t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.PACKAGE\u003c/code\u003e: look for packages\u003c/li\u003e\n     *\t\u003c/ul\u003e\n     * @param limitTo determines the nature of the expected matches\n     *\t\u003cul\u003e\n     * \t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.DECLARATIONS\u003c/code\u003e: will search\ndeclarations matching with the corresponding\n     * \t\t\telement. In case the element is a method, declarations of matching\nmethods in subtypes will also\n     *  \t\tbe found, allowing to find declarations of abstract methods, etc.\u003c/li\u003e\n     *\n     *\t\t \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.REFERENCES\u003c/code\u003e: will search\nreferences to the given element.\u003c/li\u003e\n     *\n     *\t\t \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.ALL_OCCURRENCES\u003c/code\u003e: will search for\neither declarations or references as specified\n     *  \t\tabove.\u003c/li\u003e\n     *\n     *\t\t \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.IMPLEMENTORS\u003c/code\u003e: for interface, will\nfind all types which implements a given interface.\u003c/li\u003e\n     *\t\u003c/ul\u003e\n     *\n     * @param isCaseSensitive indicates whether the search is case sensitive or not.\n     * @return a search pattern on the given string pattern, or\n\u003ccode\u003enull\u003c/code\u003e if the string pattern is ill-formed.\n     */\n    public static ISearchPattern createSearchPattern(String stringPattern, int\nsearchFor, int limitTo,\n            boolean isCaseSensitive) {\n        int matchMode;\n        if (stringPattern.indexOf(\u0027*\u0027) !\u003d -1 || stringPattern.indexOf(\u0027?\u0027) !\u003d -1) {\n            matchMode \u003d IJavaSearchConstants.PATTERN_MATCH;\n        } else {\n            matchMode \u003d IJavaSearchConstants.EXACT_MATCH;\n        }\n        return SearchPattern.createPattern(stringPattern, searchFor, limitTo,\nmatchMode, isCaseSensitive);\n    }\n    /**\n     * Returns a search pattern based on a given Java element. \n     * The pattern is used to trigger the appropriate search, and can be\nparameterized as follows:\n     *\n     * @param element the java element the search pattern is based on\n     * @param limitTo determines the nature of the expected matches\n     * \t\u003cul\u003e\n     * \t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.DECLARATIONS\u003c/code\u003e: will search\ndeclarations matching with the corresponding\n     * \t\t\telement. In case the element is a method, declarations of matching\nmethods in subtypes will also\n     *  \t\tbe found, allowing to find declarations of abstract methods, etc.\u003c/li\u003e\n     *\n     *\t\t \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.REFERENCES\u003c/code\u003e: will search\nreferences to the given element.\u003c/li\u003e\n     *\n     *\t\t \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.ALL_OCCURRENCES\u003c/code\u003e: will search for\neither declarations or references as specified\n     *  \t\tabove.\u003c/li\u003e\n     *\n     *\t\t \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.IMPLEMENTORS\u003c/code\u003e: for interface, will\nfind all types which implements a given interface.\u003c/li\u003e\n     *\t\u003c/ul\u003e\n     * @return a search pattern for a java element or \u003ccode\u003enull\u003c/code\u003e if the\ngiven element is ill-formed\n     */\n    public static ISearchPattern createSearchPattern(IJavaElement element, int\nlimitTo) {\n        return SearchPattern.createPattern(element, limitTo);\n    }\n    /**\n     * Returns a java search scope with the workspace as the only limit.\n     *\n     * @return a new workspace scope\n     */\n    public static IJavaSearchScope createWorkspaceScope() {\n        return new JavaWorkspaceScope();\n    }\n    private Parser getParser() {\n        if (this.parser \u003d\u003d null) {\n            this.compilerOptions \u003d new CompilerOptions(JavaCore.getOptions());\n            ProblemReporter problemReporter \u003d new ProblemReporter(\n                    DefaultErrorHandlingPolicies.proceedWithAllProblems(),\nthis.compilerOptions,\n                    new DefaultProblemFactory());\n            this.parser \u003d new Parser(problemReporter, true);\n        }\n        return this.parser;\n    }\n    /**\n     * Returns the underlying resource of the given element.\n     */\n    private IResource getResource(IJavaElement element) {\n        if (element instanceof IMember) {\n            ICompilationUnit cu \u003d ((IMember) element).getCompilationUnit();\n            if (cu !\u003d null) {\n                return cu.getResource();\n            }\n        }\n        return element.getResource();\n    }\n    /*\n     * Returns the list of working copies used by this search engine.\n     * Returns null if none.\n     */\n    private ICompilationUnit[] getWorkingCopies() {\n        ICompilationUnit[] copies;\n        if (this.workingCopies !\u003d null) {\n            if (this.workingCopyOwner \u003d\u003d null) {\n                copies \u003d JavaModelManager.getJavaModelManager()\n                        .getWorkingCopies(DefaultWorkingCopyOwner.PRIMARY,\nfalse/*don\u0027t add primary WCs a second time*/);\n                if (copies \u003d\u003d null) {\n                    copies \u003d this.workingCopies;\n                } else {\n                    HashMap pathToCUs \u003d new HashMap();\n                    for (int i \u003d 0, length \u003d copies.length; i \u003c length; i++) {\n                        ICompilationUnit unit \u003d copies[i];\n                        pathToCUs.put(unit.getPath(), unit);\n                    }\n                    for (int i \u003d 0, length \u003d this.workingCopies.length; i \u003c\nlength; i++) {\n                        ICompilationUnit unit \u003d this.workingCopies[i];\n                        pathToCUs.put(unit.getPath(), unit);\n                    }\n                    int length \u003d pathToCUs.size();\n                    copies \u003d new ICompilationUnit[length];\n                    pathToCUs.values().toArray(copies);\n                }\n            } else {\n                copies \u003d this.workingCopies;\n            }\n        } else if (this.workingCopyOwner !\u003d null) {\n            copies \u003d JavaModelManager.getJavaModelManager()\n                    .getWorkingCopies(this.workingCopyOwner, true/*add primary\nWCs*/);\n        } else {\n            copies \u003d JavaModelManager.getJavaModelManager()\n                    .getWorkingCopies(DefaultWorkingCopyOwner.PRIMARY,\nfalse/*don\u0027t add primary WCs a second time*/);\n        }\n        if (copies \u003d\u003d null)\n            return null;\n        // filter out primary working copies that are saved\n        ICompilationUnit[] result \u003d null;\n        int length \u003d copies.length;\n        int index \u003d 0;\n        for (int i \u003d 0; i \u003c length; i++) {\n            CompilationUnit copy \u003d (CompilationUnit) copies[i];\n            try {\n                if (!copy.isPrimary() || copy.hasUnsavedChanges() ||\n!copy.isBasedOn(copy.getResource())) {\n                    if (result \u003d\u003d null) {\n                        result \u003d new ICompilationUnit[length];\n                    }\n                    result[index++] \u003d copy;\n                }\n            } catch (JavaModelException e) {\n                // copy doesn\u0027t exist: ignore\n            }\n        }\n        if (index !\u003d length \u0026\u0026 result !\u003d null) {\n            System.arraycopy(result, 0, result \u003d new ICompilationUnit[index], 0,\nindex);\n        }\n        return result;\n    }\n    /**\n     * Returns the list of working copies used to do the search on the given\njava element.\n     */\n    private ICompilationUnit[] getWorkingCopies(IJavaElement element) {\n        if (element instanceof IMember) {\n            ICompilationUnit cu \u003d ((IMember) element).getCompilationUnit();\n            if (cu !\u003d null \u0026\u0026 cu.isWorkingCopy()) {\n                ICompilationUnit[] copies \u003d getWorkingCopies();\n                int length \u003d copies \u003d\u003d null ? 0 : copies.length;\n                if (length \u003e 0) {\n                    ICompilationUnit[] newWorkingCopies \u003d new\nICompilationUnit[length + 1];\n                    System.arraycopy(copies, 0, newWorkingCopies, 0, length);\n                    newWorkingCopies[length] \u003d cu;\n                    return newWorkingCopies;\n                } else {\n                    return new ICompilationUnit[]{cu};\n                }\n            }\n        }\n        return getWorkingCopies();\n    }\n    /**\n     * Searches for the Java element determined by the given signature. The\nsignature\n     * can be incomplete. For example, a call like \n     * \u003ccode\u003esearch(ws, \"run()\", METHOD,REFERENCES, col)\u003c/code\u003e\n     * searches for all references to the method \u003ccode\u003erun\u003c/code\u003e.\n     *\n     * Note that by default the pattern will be case insensitive. For specifying\ncase s\n     * sensitive search, use \u003ccode\u003esearch(workspace,\ncreateSearchPattern(patternString, searchFor, limitTo, true), scope,\nresultCollector);\u003c/code\u003e\n     * \n     * @param workspace the workspace\n     * @param pattern the pattern to be searched for\n     * @param searchFor a hint what kind of Java element the string pattern\nrepresents.\n     *  Look into \u003ccode\u003eIJavaSearchConstants\u003c/code\u003e for valid values\n     * @param limitTo one of the following values:\n     *\t\u003cul\u003e\n     *\t  \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.DECLARATIONS\u003c/code\u003e: search \n     *\t\t  for declarations only \u003c/li\u003e\n     *\t  \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.REFERENCES\u003c/code\u003e: search \n     *\t\t  for all references \u003c/li\u003e\n     *\t  \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.ALL_OCCURENCES\u003c/code\u003e: search \n     *\t\t  for both declarations and all references \u003c/li\u003e\n     *\t  \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.IMPLEMENTORS\u003c/code\u003e: search for\n     *\t\t  all implementors of an interface; the value is only valid if\n     *\t\t  the Java element represents an interface\u003c/li\u003e\n     * \t\u003c/ul\u003e\n     * @param scope the search result has to be limited to the given scope\n     * @param resultCollector a callback object to which each match is reported\t \n     * @exception JavaModelException if the search failed. Reasons include:\n     *\t\u003cul\u003e\n     *\t\t\u003cli\u003ethe classpath is incorrectly set\u003c/li\u003e\n     *\t\u003c/ul\u003e\n     */\n    public void search(IWorkspace workspace, String patternString, int\nsearchFor, int limitTo, IJavaSearchScope scope,\n            IJavaSearchResultCollector resultCollector) throws JavaModelException {\n        search(workspace, createSearchPattern(patternString, searchFor, limitTo,\ntrue), scope, resultCollector);\n    }\n    /**\n     * Searches for the given Java element.\n     *\n     * @param workspace the workspace\n     * @param element the Java element to be searched for\n     * @param limitTo one of the following values:\n     *\t\u003cul\u003e\n     *\t  \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.DECLARATIONS\u003c/code\u003e: search \n     *\t\t  for declarations only \u003c/li\u003e\n     *\t  \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.REFERENCES\u003c/code\u003e: search \n     *\t\t  for all references \u003c/li\u003e\n     *\t  \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.ALL_OCCURENCES\u003c/code\u003e: search \n     *\t\t  for both declarations and all references \u003c/li\u003e\n     *\t  \u003cli\u003e\u003ccode\u003eIJavaSearchConstants.IMPLEMENTORS\u003c/code\u003e: search for\n     *\t\t  all implementors of an interface; the value is only valid if\n     *\t\t  the Java element represents an interface\u003c/li\u003e\n     * \t\u003c/ul\u003e\n     * @param scope the search result has to be limited to the given scope\n     * @param resultCollector a callback object to which each match is reported\n     * @exception JavaModelException if the search failed. Reasons include:\n     *\t\u003cul\u003e\n     *\t\t\u003cli\u003ethe element doesn\u0027t exist\u003c/li\u003e\n     *\t\t\u003cli\u003ethe classpath is incorrectly set\u003c/li\u003e\n     *\t\u003c/ul\u003e\n     */\n    public void search(IWorkspace workspace, IJavaElement element, int limitTo,\nIJavaSearchScope scope,\n            IJavaSearchResultCollector resultCollector) throws JavaModelException {\n        search(workspace, createSearchPattern(element, limitTo), scope,\nresultCollector);\n    }\n    /**\n     * Searches for matches of a given search pattern. Search patterns can be\ncreated using helper\n     * methods (from a String pattern or a Java element) and encapsulate the\ndescription of what is\n     * being searched (for example, search method declarations in a case\nsensitive way).\n     *\n     * @param workspace the workspace\n     * @param searchPattern the pattern to be searched for\n     * @param scope the search result has to be limited to the given scope\n     * @param resultCollector a callback object to which each match is reported\n     * @exception JavaModelException if the search failed. Reasons include:\n     *\t\u003cul\u003e\n     *\t\t\u003cli\u003ethe classpath is incorrectly set\u003c/li\u003e\n     *\t\u003c/ul\u003e\n     */\n    public void search(IWorkspace workspace, ISearchPattern searchPattern,\nIJavaSearchScope scope,\n            IJavaSearchResultCollector resultCollector) throws JavaModelException {\n        long start \u003d -1;\n        if (VERBOSE) {\n            start \u003d System.currentTimeMillis();\n            System.out.println(\"Searching for \" + searchPattern + \" in \" +\nscope); //$NON-NLS-1$//$NON-NLS-2$\n        }\n        /* search is starting */\n        resultCollector.aboutToStart();\n        MatchLocator matchLocator \u003d null;\n        try {\n            if (searchPattern \u003d\u003d null)\n                return;\n            /* initialize progress monitor */\n            IProgressMonitor progressMonitor \u003d resultCollector.getProgressMonitor();\n            if (progressMonitor !\u003d null) {\n                progressMonitor.beginTask(Util.bind(\"engine.searching\"), 100);\n//$NON-NLS-1$\n            }\n            /* index search */\n            PathCollector pathCollector \u003d new PathCollector();\n            // In the case of a hierarchy scope make sure that the hierarchy is\nnot computed.\n            // MatchLocator will filter out elements not in the hierarchy\n            SearchPattern pattern \u003d (SearchPattern) searchPattern;\n            if (scope instanceof HierarchyScope) {\n                ((HierarchyScope) scope).needsRefresh \u003d false;\n                pattern.mustResolve \u003d true; // force resolve to compute type\nbindings\n            }\n            IndexManager indexManager \u003d\nJavaModelManager.getJavaModelManager().getIndexManager();\n            int detailLevel \u003d IInfoConstants.PathInfo | IInfoConstants.PositionInfo;\n            matchLocator \u003d new MatchLocator(pattern, detailLevel,\nresultCollector, scope, progressMonitor \u003d\u003d null\n                    ? null\n                    : new SubProgressMonitor(progressMonitor, 95));\n            indexManager.performConcurrentJob(new PatternSearchJob(pattern,\nscope, pattern.focus, pattern\n                    .isPolymorphicSearch(), detailLevel,\n                    pathCollector, indexManager),\nIJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,\n                    progressMonitor \u003d\u003d null ? null : new\nSubProgressMonitor(progressMonitor, 5));\n            /* eliminating false matches and locating them */\n            if (progressMonitor !\u003d null \u0026\u0026 progressMonitor.isCanceled())\n                throw new OperationCanceledException();\n            matchLocator.locateMatches(pathCollector.getPaths(), workspace,\nworkingCopiesThatCanSeeFocus(pattern.focus,\n                    pattern.isPolymorphicSearch()));\n            if (progressMonitor !\u003d null \u0026\u0026 progressMonitor.isCanceled())\n                throw new OperationCanceledException();\n            if (progressMonitor !\u003d null) {\n                progressMonitor.done();\n            }\n            matchLocator.locatePackageDeclarations(workspace);\n        } finally {\n            /* search has ended */\n            resultCollector.done();\n            if (VERBOSE) {\n                System.out.println(\"Total time: \" + (System.currentTimeMillis()\n- start) + \"ms\"); //$NON-NLS-1$ //$NON-NLS-2$\n                if (matchLocator !\u003d null)\n                    System.out.println(\"Time in result collector: \" +\nmatchLocator.resultCollectorTime + \"ms\"); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n        }\n    }\n    /**\n     * Searches for all top-level types and member types in the given scope.\n     * The search can be selecting specific types (given a package or a type name\n     * prefix and match modes). \n     * \n     * @param workspace the workspace to search in\n     * @param packageName the full name of the package of the searched types, or\na prefix for this\n     *\t\t\t\t\t\tpackage, or a wild-carded string for this package.\n     * @param typeName the dot-separated qualified name of the searched type\n(the qualification include\n     *\t\t\t\t\tthe enclosing types if the searched type is a member type), or a prefix\n     *\t\t\t\t\tfor this type, or a wild-carded string for this type.\n     * @param matchMode one of\n     * \u003cul\u003e\n     *\t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.EXACT_MATCH\u003c/code\u003e if the package name\nand type name are the full names\n     *\t\t\tof the searched types.\u003c/li\u003e\n     *\t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.PREFIX_MATCH\u003c/code\u003e if the package name\nand type name are prefixes of the names\n     *\t\t\tof the searched types.\u003c/li\u003e\n     *\t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.PATTERN_MATCH\u003c/code\u003e if the package name\nand type name contain wild-cards.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @param isCaseSensitive whether the search should be case sensitive\n     * @param searchFor one of\n     * \u003cul\u003e\n     * \t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.CLASS\u003c/code\u003e if searching for classes\nonly\u003c/li\u003e\n     * \t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.INTERFACE\u003c/code\u003e if searching for\ninterfaces only\u003c/li\u003e\n     * \t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.TYPE\u003c/code\u003e if searching for both\nclasses and interfaces\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @param scope the scope to search in\n     * @param nameRequestor the requestor that collects the results of the search\n     * @param waitingPolicy one of\n     * \u003cul\u003e\n     *\t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.FORCE_IMMEDIATE_SEARCH\u003c/code\u003e if the\nsearch should start immediately\u003c/li\u003e\n     *\t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH\u003c/code\u003e if\nthe search should be cancelled if the\n     *\t\t\tunderlying indexer has not finished indexing the workspace\u003c/li\u003e\n     *\t\t\u003cli\u003e\u003ccode\u003eIJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH\u003c/code\u003e if the\nsearch should wait for the\n     *\t\t\tunderlying indexer to finish indexing the workspace\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @param progressMonitor the progress monitor to report progress to, or\n\u003ccode\u003enull\u003c/code\u003e if no progress\n     *\t\t\t\t\t\t\tmonitor is provided\n     * @exception JavaModelException if the search failed. Reasons include:\n     *\t\u003cul\u003e\n     *\t\t\u003cli\u003ethe classpath is incorrectly set\u003c/li\u003e\n     *\t\u003c/ul\u003e\n     */\n    public void searchAllTypeNames(IWorkspace workspace, char[] packageName,\nchar[] typeName, int matchMode,\n            boolean isCaseSensitive, int searchFor, IJavaSearchScope scope,\nfinal ITypeNameRequestor nameRequestor,\n            int waitingPolicy, IProgressMonitor progressMonitor) throws\nJavaModelException {\n        IndexManager indexManager \u003d\nJavaModelManager.getJavaModelManager().getIndexManager();\n        char classOrInterface;\n        switch (searchFor) {\n            case IJavaSearchConstants.CLASS :\n                classOrInterface \u003d IIndexConstants.CLASS_SUFFIX;\n                break;\n            case IJavaSearchConstants.INTERFACE :\n                classOrInterface \u003d IIndexConstants.INTERFACE_SUFFIX;\n                break;\n            default :\n                classOrInterface \u003d IIndexConstants.TYPE_SUFFIX;\n                break;\n        }\n        SearchPattern pattern \u003d new TypeDeclarationPattern(packageName, null, //\ndo find member types\n                typeName, classOrInterface, matchMode, isCaseSensitive);\n        final HashSet workingCopyPaths \u003d new HashSet();\n        ICompilationUnit[] copies \u003d getWorkingCopies();\n        if (copies !\u003d null) {\n            for (int i \u003d 0, length \u003d copies.length; i \u003c length; i++) {\n                ICompilationUnit workingCopy \u003d copies[i];\n                workingCopyPaths.add(workingCopy.getPath().toString());\n            }\n        }\n        IIndexSearchRequestor searchRequestor \u003d new IndexSearchAdapter() {\n            public void acceptClassDeclaration(String resourcePath, char[]\nsimpleTypeName, char[][] enclosingTypeNames,\n                    char[] pkgName) {\n                if (enclosingTypeNames !\u003d IIndexConstants.ONE_ZERO_CHAR //\nfilter out local and anonymous classes\n                        \u0026\u0026 !workingCopyPaths.contains(resourcePath)) { // filter\nout working copies\n                    nameRequestor.acceptClass(pkgName, simpleTypeName,\nenclosingTypeNames, resourcePath);\n                }\n            }\n            public void acceptInterfaceDeclaration(String resourcePath, char[]\nsimpleTypeName,\n                    char[][] enclosingTypeNames, char[] pkgName) {\n                if (enclosingTypeNames !\u003d IIndexConstants.ONE_ZERO_CHAR //\nfilter out local and anonymous classes\n                        \u0026\u0026 !workingCopyPaths.contains(resourcePath)) { // filter\nout working copies\n                    nameRequestor.acceptInterface(pkgName, simpleTypeName,\nenclosingTypeNames, resourcePath);\n                }\n            }\n        };\n        try {\n            if (progressMonitor !\u003d null) {\n                progressMonitor.beginTask(Util.bind(\"engine.searching\"), 100);\n//$NON-NLS-1$\n            }\n            // add type names from indexes\n            indexManager.performConcurrentJob(\n\t\t\tnew PatternSearchJob(pattern, scope, IInfoConstants.NameInfo\n                    | IInfoConstants.PathInfo, searchRequestor, indexManager),\n                    waitingPolicy, progressMonitor \u003d\u003d null ? null : new\nSubProgressMonitor(progressMonitor, 100));\n            // add type names from working copies\n            if (copies !\u003d null) {\n                for (int i \u003d 0, length \u003d copies.length; i \u003c length; i++) {\n                    ICompilationUnit workingCopy \u003d copies[i];\n                    IPackageDeclaration[] packageDeclarations \u003d\nworkingCopy.getPackageDeclarations();\n                    final String path \u003d workingCopy.getPath().toString();\n                    final char[] packageDeclaration \u003d packageDeclarations.length\n\u003d\u003d 0\n                            ? CharOperation.NO_CHAR\n                            : packageDeclarations[0].getElementName().toCharArray();\n                    if (workingCopy.isConsistent()) {\n                        IType[] allTypes \u003d workingCopy.getAllTypes();\n                        for (int j \u003d 0, allTypesLength \u003d allTypes.length; j \u003c\nallTypesLength; j++) {\n                            IType type \u003d allTypes[j];\n                            IJavaElement parent \u003d type.getParent();\n                            char[][] enclosingTypeNames;\n                            if (parent instanceof IType) {\n                                char[] parentQualifiedName \u003d ((IType)\nparent).getTypeQualifiedName(\u0027.\u0027).toCharArray();\n                                enclosingTypeNames \u003d CharOperation.splitOn(\u0027.\u0027,\nparentQualifiedName);\n                            } else {\n                                enclosingTypeNames \u003d CharOperation.NO_CHAR_CHAR;\n                            }\n                            if (type.isClass()) {\n                                nameRequestor.acceptClass(packageDeclaration,\ntype.getElementName().toCharArray(),\n                                        enclosingTypeNames, path);\n                            } else {\n                               \nnameRequestor.acceptInterface(packageDeclaration,\ntype.getElementName().toCharArray(),\n                                        enclosingTypeNames, path);\n                            }\n                        }\n                    } else {\n                        Parser basicParser \u003d getParser();\n                        final char[] contents \u003d\nworkingCopy.getBuffer().getCharacters();\n                        org.eclipse.jdt.internal.compiler.env.ICompilationUnit\nunit \u003d new org.eclipse.jdt.internal.compiler.env.ICompilationUnit() {\n                            public char[] getContents() {\n                                return contents;\n                            }\n                            public char[] getMainTypeName() {\n                                return null;\n                            }\n                            public char[][] getPackageName() {\n                                return null;\n                            }\n                            public char[] getFileName() {\n                                return null;\n                            }\n                        };\n                        CompilationResult compilationUnitResult \u003d new\nCompilationResult(unit, 0, 0,\n                                this.compilerOptions.maxProblemsPerUnit);\n                        CompilationUnitDeclaration parsedUnit \u003d\nbasicParser.dietParse(unit, compilationUnitResult);\n                        if (parsedUnit !\u003d null) {\n                            class AllTypeDeclarationsVisitor extends\nAbstractSyntaxTreeVisitorAdapter {\n                                public boolean visit(LocalTypeDeclaration\ntypeDeclaration, BlockScope blockScope) {\n                                    return false; // no local type\n                                }\n                                public boolean\nvisit(AnonymousLocalTypeDeclaration typeDeclaration,\n                                        BlockScope blockScope) {\n                                    return false; // no anonymous type\n                                }\n                                public boolean visit(TypeDeclaration\ntypeDeclaration,\n                                        CompilationUnitScope compilationUnitScope) {\n                                    if (!typeDeclaration.isInterface()) {\n                                       \nnameRequestor.acceptClass(packageDeclaration, typeDeclaration.name,\n                                                CharOperation.NO_CHAR_CHAR, path);\n                                    } else {\n                                       \nnameRequestor.acceptInterface(packageDeclaration, typeDeclaration.name,\n                                                CharOperation.NO_CHAR_CHAR, path);\n                                    }\n                                    return true;\n                                }\n                                public boolean visit(MemberTypeDeclaration\nmemberTypeDeclaration, ClassScope classScope) {\n                                    // compute encloising type names\n                                    TypeDeclaration enclosing \u003d\nmemberTypeDeclaration.enclosingType;\n                                    char[][] enclosingTypeNames \u003d\nCharOperation.NO_CHAR_CHAR;\n                                    while (enclosing !\u003d null) {\n                                        enclosingTypeNames \u003d\nCharOperation.arrayConcat(new char[][]{enclosing.name},\n                                                enclosingTypeNames);\n                                        if (enclosing instanceof\nMemberTypeDeclaration) {\n                                            enclosing \u003d ((MemberTypeDeclaration)\nenclosing).enclosingType;\n                                        } else {\n                                            enclosing \u003d null;\n                                        }\n                                    }\n                                    // report\n                                    if (!memberTypeDeclaration.isInterface()) {\n                                       \nnameRequestor.acceptClass(packageDeclaration, memberTypeDeclaration.name,\n                                                enclosingTypeNames, path);\n                                    } else {\n                                       \nnameRequestor.acceptInterface(packageDeclaration, memberTypeDeclaration.name,\n                                                enclosingTypeNames, path);\n                                    }\n                                    return true;\n                                }\n                            }\n                            parsedUnit.traverse(new\nAllTypeDeclarationsVisitor(), parsedUnit.scope);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (progressMonitor !\u003d null) {\n                progressMonitor.done();\n            }\n        }\n    }\n    /**\n     * Searches for all declarations of the fields accessed in the given element.\n     * The element can be a compilation unit, a source type, or a source method.\n     * Reports the field declarations using the given collector.\n     * \u003cp\u003e\n     * Consider the following code:\n     * \u003ccode\u003e\n     * \u003cpre\u003e\n     *\t\tclass A {\n     *\t\t\tint field1;\n     *\t\t}\n     *\t\tclass B extends A {\n     *\t\t\tString value;\n     *\t\t}\n     *\t\tclass X {\n     *\t\t\tvoid test() {\n     *\t\t\t\tB b \u003d new B();\n     *\t\t\t\tSystem.out.println(b.value + b.field1);\n     *\t\t\t};\n     *\t\t}\n     * \u003c/pre\u003e\n     * \u003c/code\u003e\n     * then searching for declarations of accessed fields in method \n     * \u003ccode\u003eX.test()\u003c/code\u003e would collect the fields\n     * \u003ccode\u003eB.value\u003c/code\u003e and \u003ccode\u003eA.field1\u003c/code\u003e.\n     * \u003c/p\u003e\n     *\n     * @param workspace the workspace\n     * @param enclosingElement the method, type, or compilation unit to be\nsearched in\n     * @param resultCollector a callback object to which each match is reported\n     * @exception JavaModelException if the search failed. Reasons include:\n     *\t\u003cul\u003e\n     *\t\t\u003cli\u003ethe element doesn\u0027t exist\u003c/li\u003e\n     *\t\t\u003cli\u003ethe classpath is incorrectly set\u003c/li\u003e\n     *\t\u003c/ul\u003e\n     */\n    public void searchDeclarationsOfAccessedFields(IWorkspace workspace,\nIJavaElement enclosingElement,\n            IJavaSearchResultCollector resultCollector) throws JavaModelException {\n        SearchPattern pattern \u003d new\nDeclarationOfAccessedFieldsPattern(enclosingElement);\n        IJavaSearchScope scope \u003d createJavaSearchScope(new\nIJavaElement[]{enclosingElement});\n        IResource resource \u003d this.getResource(enclosingElement);\n        if (resource instanceof IFile) {\n            if (VERBOSE) {\n                System.out.println(\"Searching for \" + pattern + \" in \" +\nresource.getFullPath()); //$NON-NLS-1$//$NON-NLS-2$\n            }\n            MatchLocator locator \u003d new MatchLocator(pattern,\nIInfoConstants.DeclarationInfo, resultCollector, scope,\n                    resultCollector.getProgressMonitor());\n            locator.locateMatches(new\nString[]{resource.getFullPath().toString()}, workspace, this.getWorkingCopies(\n                    enclosingElement));\n        } else {\n            search(workspace, pattern, scope, resultCollector);\n        }\n    }\n    /**\n     * Searches for all declarations of the types referenced in the given element.\n     * The element can be a compilation unit, a source type, or a source method.\n     * Reports the type declarations using the given collector.\n     * \u003cp\u003e\n     * Consider the following code:\n     * \u003ccode\u003e\n     * \u003cpre\u003e\n     *\t\tclass A {\n     *\t\t}\n     *\t\tclass B extends A {\n     *\t\t}\n     *\t\tinterface I {\n     *\t\t  int VALUE \u003d 0;\n     *\t\t}\n     *\t\tclass X {\n     *\t\t\tvoid test() {\n     *\t\t\t\tB b \u003d new B();\n     *\t\t\t\tthis.foo(b, I.VALUE);\n     *\t\t\t};\n     *\t\t}\n     * \u003c/pre\u003e\n     * \u003c/code\u003e\n     * then searching for declarations of referenced types in method\n\u003ccode\u003eX.test()\u003c/code\u003e\n     * would collect the class \u003ccode\u003eB\u003c/code\u003e and the interface \u003ccode\u003eI\u003c/code\u003e.\n     * \u003c/p\u003e\n     *\n     * @param workspace the workspace\n     * @param enclosingElement the method, type, or compilation unit to be\nsearched in\n     * @param resultCollector a callback object to which each match is reported\n     * @exception JavaModelException if the search failed. Reasons include:\n     *\t\u003cul\u003e\n     *\t\t\u003cli\u003ethe element doesn\u0027t exist\u003c/li\u003e\n     *\t\t\u003cli\u003ethe classpath is incorrectly set\u003c/li\u003e\n     *\t\u003c/ul\u003e\n     */\n    public void searchDeclarationsOfReferencedTypes(IWorkspace workspace,\nIJavaElement enclosingElement,\n            IJavaSearchResultCollector resultCollector) throws JavaModelException {\n        SearchPattern pattern \u003d new\nDeclarationOfReferencedTypesPattern(enclosingElement);\n        IJavaSearchScope scope \u003d createJavaSearchScope(new\nIJavaElement[]{enclosingElement});\n        IResource resource \u003d this.getResource(enclosingElement);\n        if (resource instanceof IFile) {\n            if (VERBOSE) {\n                System.out.println(\"Searching for \" + pattern + \" in \" +\nresource.getFullPath()); //$NON-NLS-1$//$NON-NLS-2$\n            }\n            MatchLocator locator \u003d new MatchLocator(pattern,\nIInfoConstants.DeclarationInfo, resultCollector, scope,\n                    resultCollector.getProgressMonitor());\n            locator.locateMatches(new\nString[]{resource.getFullPath().toString()}, workspace, this.getWorkingCopies(\n                    enclosingElement));\n        } else {\n            search(workspace, pattern, scope, resultCollector);\n        }\n    }\n    /**\n     * Searches for all declarations of the methods invoked in the given element.\n     * The element can be a compilation unit, a source type, or a source method.\n     * Reports the method declarations using the given collector.\n     * \u003cp\u003e\n     * Consider the following code:\n     * \u003ccode\u003e\n     * \u003cpre\u003e\n     *\t\tclass A {\n     *\t\t\tvoid foo() {};\n     *\t\t\tvoid bar() {};\n     *\t\t}\n     *\t\tclass B extends A {\n     *\t\t\tvoid foo() {};\n     *\t\t}\n     *\t\tclass X {\n     *\t\t\tvoid test() {\n     *\t\t\t\tA a \u003d new B();\n     *\t\t\t\ta.foo();\n     *\t\t\t\tB b \u003d (B)a;\n     *\t\t\t\tb.bar();\n     *\t\t\t};\n     *\t\t}\n     * \u003c/pre\u003e\n     * \u003c/code\u003e\n     * then searching for declarations of sent messages in method \n     * \u003ccode\u003eX.test()\u003c/code\u003e would collect the methods\n     * \u003ccode\u003eA.foo()\u003c/code\u003e, \u003ccode\u003eB.foo()\u003c/code\u003e, and \u003ccode\u003eA.bar()\u003c/code\u003e.\n     * \u003c/p\u003e\n     *\n     * @param workspace the workspace\n     * @param enclosingElement the method, type, or compilation unit to be\nsearched in\n     * @param resultCollector a callback object to which each match is reported\n     * @exception JavaModelException if the search failed. Reasons include:\n     *\t\u003cul\u003e\n     *\t\t\u003cli\u003ethe element doesn\u0027t exist\u003c/li\u003e\n     *\t\t\u003cli\u003ethe classpath is incorrectly set\u003c/li\u003e\n     *\t\u003c/ul\u003e\n     */\n    public void searchDeclarationsOfSentMessages(IWorkspace workspace,\nIJavaElement enclosingElement,\n            IJavaSearchResultCollector resultCollector) throws JavaModelException {\n        SearchPattern pattern \u003d new\nDeclarationOfReferencedMethodsPattern(enclosingElement);\n        IJavaSearchScope scope \u003d createJavaSearchScope(new\nIJavaElement[]{enclosingElement});\n        IResource resource \u003d this.getResource(enclosingElement);\n        if (resource instanceof IFile) {\n            if (VERBOSE) {\n                System.out.println(\"Searching for \" + pattern + \" in \" +\nresource.getFullPath()); //$NON-NLS-1$//$NON-NLS-2$\n            }\n            MatchLocator locator \u003d new MatchLocator(pattern,\nIInfoConstants.DeclarationInfo, resultCollector, scope,\n                    resultCollector.getProgressMonitor());\n            locator.locateMatches(new\nString[]{resource.getFullPath().toString()}, workspace, this.getWorkingCopies(\n                    enclosingElement));\n        } else {\n            search(workspace, pattern, scope, resultCollector);\n        }\n    }\n    /*\n     * Returns the working copies that cannot see the given focus.\n     */\n    private ICompilationUnit[] workingCopiesThatCanSeeFocus(IJavaElement focus,\nboolean isPolymorphicSearch) {\n        ICompilationUnit[] copies \u003d getWorkingCopies();\n        if (focus \u003d\u003d null || copies \u003d\u003d null)\n            return copies;\n        while (!(focus instanceof IJavaProject) \u0026\u0026 !(focus instanceof\nJarPackageFragmentRoot)) {\n            focus \u003d focus.getParent();\n        }\n        int length \u003d copies.length;\n        ICompilationUnit[] result \u003d null;\n        int index \u003d -1;\n        for (int i \u003d 0; i \u003c length; i++) {\n            ICompilationUnit workingCopy \u003d copies[i];\n            IPath projectOrJar \u003d\nIndexSelector.getProjectOrJar(workingCopy).getPath();\n            if (!IndexSelector.canSeeFocus(focus, isPolymorphicSearch,\nprojectOrJar)) {\n                if (result \u003d\u003d null) {\n                    result \u003d new ICompilationUnit[length - 1];\n                    System.arraycopy(copies, 0, result, 0, i);\n                    index \u003d i;\n                }\n            } else if (result !\u003d null) {\n                result[index++] \u003d workingCopy;\n            }\n        }\n        if (result !\u003d null) {\n            if (result.length !\u003d index) {\n                System.arraycopy(result, 0, result \u003d new\nICompilationUnit[index], 0, index);\n            }\n            return result;\n        } else {\n            return copies;\n        }\n    }\n}",
    "I had enabled the new formatter (which generate edits)\n",
    "I could not reproduce the problem. I never get an OutOfMemory error.",
    "Java code formatter is Jdt Core. Comment formatting does not use edits and the\nerror message says:\n\n!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:18:57.646\n!MESSAGE formatter returned null-edit. \n\n",
    "The null edits where a separate issue related to a bug in the formatter page. \nThe suspicion is that the edit application is causing grief here. \n\n",
    "As discussed with Olivier the problem doesn\u0027t occur if the quick differences \nis disabled (see exception in comment #1). Moving to text for comments.",
    "To reproduce you have to enable the new formatter.\n",
    "The entry\n\u0027!ENTRY org.eclipse.jdt.ui 4 10001 Oct 03, 2003 18:18:57.646\n!MESSAGE formatter returned null-edit.\u0027\nseen by Philippe came drom a bug in the codeformatter-example source.\nThis is fixed (different bug report)\n\nBTW, Note that this is only a message in the log, not a stacktrace. It should\nhelp us to find incompatibilities. If the new formatter returns a null edit\n(source has syntax error or something else) I use the unformatted text.\nI improve this warning message so it does not cause more confusion (will remove\nthe logging later when we\u0027re done with the conversion).\n\"formatter failed to format (no edit returned). Will use unformatted text\ninstead. kind: \" + kind + \", string: \" + string\"\n\n\n\n\n\n\n\n\n\n",
    "There are at least two separate issues remaining: \n\n- The failed assertion in RangeDifferencer - the code is the same as everywhere\nin compare and I cannot reproduce this - I assume it has to do with a concurrent\nmodification. \n-\u003e I have a fix for this, although not a very satisfying one, which I will\ncommit shortly.\n\n- The OutOfMemory error *can* and will happen when diffing large documents with\nmany changes. This is a shortcoming of the diff / alignment algorithm used,\nwhich is O(number of changes^2) for space. The same will happen when\nreformatting, say, StyledText and doing a compare with HEAD.\n\n-\u003e Workaround is to not use compare and disable quick diff (Ctrl+Shift+Q) in\nsuch situations.\n-\u003e A long term solution would be to back off to a different diffing algo (Dan\nHirschberg\u0027s linear space algorithm for computing maximal common subsequences)\non large files.\n\n",
    "fixed the concurrency issue \u003e 20031006\n\nworkaround for OutOfMemoryError described in comment 10.\n\nClosing.",
    "*** Bug 61599 has been marked as a duplicate of this bug. ***"
  ],
  "commentCreationDates": [
    "2003-10-03T18:28:55+02:00",
    "2003-10-03T18:34:39+02:00",
    "2003-10-03T18:49:27+02:00",
    "2003-10-03T18:53:09+02:00",
    "2003-10-03T18:57:21+02:00",
    "2003-10-06T10:33:47+02:00",
    "2003-10-06T10:40:13+02:00",
    "2003-10-06T12:31:59+02:00",
    "2003-10-06T12:49:04+02:00",
    "2003-10-06T13:03:34+02:00",
    "2003-10-06T15:45:29+02:00",
    "2003-10-06T18:25:54+02:00",
    "2004-05-12T20:58:49+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.jface.util.Assert$AssertionFailedException",
      "message": "Assertion failed:",
      "elements": [
        {
          "method": "java.lang.Throwable.\u003cinit\u003e",
          "source": "Throwable.java"
        },
        {
          "method": "java.lang.Throwable.\u003cinit\u003e",
          "source": "Throwable.java"
        },
        {
          "method": "org.eclipse.jface.util.Assert$AssertionFailedException.\u003cinit\u003e",
          "source": "Assert.java:54"
        },
        {
          "method": "org.eclipse.jface.util.Assert.isTrue",
          "source": "Assert.java:168"
        },
        {
          "method": "org.eclipse.jface.util.Assert.isTrue",
          "source": "Assert.java"
        },
        {
          "method": "org.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findDifferences",
          "source": "RangeDifferencer.java"
        },
        {
          "method": "org.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findRanges",
          "source": "RangeDifferencer.java:291"
        },
        {
          "method": "org.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findRanges",
          "source": "RangeDifferencer.java:276"
        },
        {
          "method": "org.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer.handleChange",
          "source": "DocumentLineDiffer.java:773"
        },
        {
          "method": "org.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer$1.run",
          "source": "DocumentLineDiffer.java:575"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:61"
        }
      ],
      "number": 0,
      "commentIndex": 1,
      "bugId": "44141",
      "date": "2003-10-03T18:34:39+02:00",
      "product": "JDT",
      "component": "Text",
      "severity": "normal"
    },
    {
      "exceptionType": "org.eclipse.jface.util.Assert$AssertionFailedException",
      "message": "Assertion failed:",
      "elements": [
        {
          "method": "java.lang.Throwable.\u003cinit\u003e",
          "source": "Throwable.java"
        },
        {
          "method": "java.lang.Throwable.\u003cinit\u003e",
          "source": "Throwable.java"
        },
        {
          "method": "org.eclipse.jface.util.Assert$AssertionFailedException.\u003cinit\u003e",
          "source": "Assert.java:54"
        },
        {
          "method": "org.eclipse.jface.util.Assert.isTrue",
          "source": "Assert.java:168"
        },
        {
          "method": "org.eclipse.jface.util.Assert.isTrue",
          "source": "Assert.java"
        },
        {
          "method": "org.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findDifferences",
          "source": "RangeDifferencer.java"
        },
        {
          "method": "org.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findRanges",
          "source": "RangeDifferencer.java:291"
        },
        {
          "method": "org.eclipse.ui.internal.texteditor.quickdiff.compare.rangedifferencer.RangeDifferencer.findRanges",
          "source": "RangeDifferencer.java:276"
        },
        {
          "method": "org.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer.handleChange",
          "source": "DocumentLineDiffer.java:773"
        },
        {
          "method": "org.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer.documentChanged",
          "source": "DocumentLineDiffer.java:655"
        },
        {
          "method": "org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged2",
          "source": "AbstractDocument.java"
        },
        {
          "method": "org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged",
          "source": "AbstractDocument.java"
        },
        {
          "method": "org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged",
          "source": "AbstractDocument.java"
        },
        {
          "method": "org.eclipse.jface.text.AbstractDocument.fireDocumentChanged",
          "source": "AbstractDocument.java"
        },
        {
          "method": "org.eclipse.jface.text.AbstractDocument.replace",
          "source": "AbstractDocument.java"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.PartiallySynchronizedDocument.replace",
          "source": "PartiallySynchronizedDocument.java:61"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.comment.CommentRegion.applyText",
          "source": "CommentRegion.java"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.comment.CommentLine.applyLine",
          "source": "CommentLine.java:125"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.comment.CommentRegion.applyRegion",
          "source": "CommentRegion.java:167"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.comment.CommentRegion.format",
          "source": "CommentRegion.java:256"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.comment.CommentFormattingStrategy.format",
          "source": "CommentFormattingStrategy.java:131"
        },
        {
          "method": "org.eclipse.jface.text.formatter.ContentFormatter.format",
          "source": "ContentFormatter.java:782"
        },
        {
          "method": "org.eclipse.jface.text.formatter.ContentFormatter.formatPartitions",
          "source": "ContentFormatter.java:602"
        },
        {
          "method": "org.eclipse.jface.text.formatter.ContentFormatter.format",
          "source": "ContentFormatter.java:491"
        },
        {
          "method": "org.eclipse.jface.text.source.SourceViewer.doOperation",
          "source": "SourceViewer.java:664"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.doOperation",
          "source": "JavaSourceViewer.java:98"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation",
          "source": "CompilationUnitEditor.java:169"
        },
        {
          "method": "org.eclipse.ui.texteditor.TextOperationAction$1.run",
          "source": "TextOperationAction.java:122"
        },
        {
          "method": "org.eclipse.swt.custom.BusyIndicator.showWhile",
          "source": "BusyIndicator.java"
        },
        {
          "method": "org.eclipse.ui.texteditor.TextOperationAction.run",
          "source": "TextOperationAction.java:120"
        },
        {
          "method": "org.eclipse.jface.action.Action.runWithEvent",
          "source": "Action.java:842"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection",
          "source": "ActionContributionItem.java:543"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.access$4",
          "source": "ActionContributionItem.java:496"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem$6.handleEvent",
          "source": "ActionContributionItem.java:468"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:2106"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.run",
          "source": "Workbench.java:2089"
        },
        {
          "method": "org.eclipse.core.internal.boot.InternalBootLoader.run",
          "source": "InternalBootLoader.java:858"
        },
        {
          "method": "org.eclipse.core.boot.BootLoader.run",
          "source": "BootLoader.java:461"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:79"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:41"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:386"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:298"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:764"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:598"
        }
      ],
      "number": 1,
      "commentIndex": 1,
      "bugId": "44141",
      "date": "2003-10-03T18:34:39+02:00",
      "product": "JDT",
      "component": "Text",
      "severity": "normal"
    }
  ],
  "groupId": "44141",
  "bugId": "44141",
  "date": "2003-10-03T18:28:55+02:00",
  "product": "JDT",
  "component": "Text",
  "severity": "normal"
}