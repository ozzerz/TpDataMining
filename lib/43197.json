{
  "comments": [
    "I have both a console line tracker and a debug event listener registered for \nthe same process. When the process terminates, I want to do different things \nin the plugin based on the messages that were written out by the process. \nHowever, sometimes I\u0027m getting the process terminated event *before* the last \ncall to the line tracker is made. It looks like the process termination event \nis handled by a Job worker thread, while the console line comes in on the main \nthread. They appear to happen at about the same time so it\u0027s a race to see \nwhich is actually called first.\n\nI tried to use the IConsoleLineTracker.dispose() method to perform the action \nbut that is not called until the launch is removed. There doesn\u0027t appear to be \na way for the console line tracker to know if it has the last line or not.\n\nIf the code that fires the termination event were changed to wait until the \nlast IConsoleLineTracker.lineAppended() method was called and returns first, \nthat would take care of it. Another way would be to have a new method, say \nIConsoleLineTracker.term(), to mirror the init() method. It would be called \nafter the last lines had been appended and the process was terminated, and I \ncould put my what-to-do-after-termination logic there.",
    "This is basically a dup of bug 31734 - for which there may be no solution. \nThere does not seem to be a way to determine when the last line has been \nwritten to the console. The process termination is asyncronous with console \noutput (which is bufferred). ",
    "Don\u0027t the stream monitors know when the stream is closed?\n\nAlso, is there a way to turn off buffering? Perhaps that would help. I don\u0027t \nlike the way the output from the command is visually clumped anyway.\n",
    "We have to buffer output - otherwise the UI gets blocked when processes are \nproducing large quantities of output.",
    "I have a workaround for this bug entry; I added a Thread.sleep(100) in the \nevent handler for the Terminate event, which (so far) has given the last line \nof output time to come in. This seems pretty fragile though, but it\u0027s the best \nI could come up with given the current design.\n\nI\u0027ll make another bugzilla entry about buffering if there isn\u0027t one already \nbecause I have an application where it needs to be unbuffered.\n",
    "Yes - the process reading from the stream does know when the stream is closed. \nOur IStreamListener interface is insufficient - it only notifies of text being \nappended, but not of closing. We either need an API change or an extension to \nthe interface to allow for this.",
    "Jared, I would think the fix would be something like this:\n\n* Add a new method to IStreamListener - something like #streamClosed\n(IStreamMonitor)\n* Specify that an IStreamMonitor notifies the listener when the stream closes\n* When all streams associated with a console close, the line notifier should \nnotify listeners of the last line (in case that it was written without a line \nterminator)\n\n(Darin S also knows about console stuff if you have questions). ",
    "NOTE: this is a breaking API change that will need an entry in the porting \nguide.",
    "Released the change. Have we gone through the PMC API-change approval process? Also... \nWhat porting guide? :)",
    "Did you release the required changes to the ConsoleDocumentParitioner - I get \ncompile errors when I catch up.",
    "For now, the porting guide is the r3_0_changes.html file in the core debug plug-\nin. You need to add a section in the API Changes section describing the change \nan impact (i.e. listeners must implement the new method, and stream monitor \nimplementations must notify listeners).",
    "No, the change hadn\u0027t been released despite the fact that I told it to. I had to fight the synchronize \nview to make it go.",
    "Porting guide updated. Please verify, DarinW.",
    "The ConsoleDocumentPartitioner has to use the notification to properly send \nline notifications via its ConsoleLineNotifier. The idea is that when all \nstreams that are connected to the document are closed, the line notifier should \nsee if it still needs to notify of the last line (which it currnetly does not \nnotify of - since a line delimiter may not be in the last line).",
    "As well, I get ClassCastExceptions when I run the code:\n\njava.lang.ClassCastException\n\tat org.eclipse.debug.internal.core.OutputStreamMonitor.fireStreamClosed\n(OutputStreamMonitor.java:114)\n\tat org.eclipse.debug.internal.core.OutputStreamMonitor.read\n(OutputStreamMonitor.java:175)\n\tat org.eclipse.debug.internal.core.OutputStreamMonitor.access$1\n(OutputStreamMonitor.java:142)\n\tat org.eclipse.debug.internal.core.OutputStreamMonitor$2.run\n(OutputStreamMonitor.java:196)\n\tat java.lang.Thread.run(Thread.java:534)\njava.lang.ClassCastException\n\tat org.eclipse.debug.internal.core.OutputStreamMonitor.fireStreamClosed\n(OutputStreamMonitor.java:114)\n\tat org.eclipse.debug.internal.core.OutputStreamMonitor.read\n(OutputStreamMonitor.java:175)\n\tat org.eclipse.debug.internal.core.OutputStreamMonitor.access$1\n(OutputStreamMonitor.java:142)\n\tat org.eclipse.debug.internal.core.OutputStreamMonitor$2.run\n(OutputStreamMonitor.java:196)\n\tat java.lang.Thread.run(Thread.java:534)",
    "Jared, I fixed up the OutputStreamNotifier to get rid of the class casts - \nplease verify my changes.",
    "(That would be OutputStreamMonitor)",
    "Looks good.",
    "Verified.",
    "re-opening. Jared, please look at comment #13 - the bug still exists. Console \nline trackers are not notified of the last line of output in the console.",
    "See bug 31734 for more history on this issue.",
    "This feature allows us to fix Bug 31734. Closing this report and using 31734 to track the old defect.",
    "Hold on, I see the changes in ConsoleLineNotifier but I don\u0027t see any exposure \nof this stream closed event higher than there. In particular there is no \nterminate or last-line function in IConsoleLineTracker. How is a console line \ntracker supposed to know there will be no more lines? The original bugzilla \nentry is that there wasn\u0027t a reliable way for a plugin to know that both a) a \nprocess it started has terminated, and b) all the output from that process has \nbeen examined with the console line tracker. Is that addressed?\n\nAlso, shouldn\u0027t ConsoleLineNotifier.streamClosed() be synchronized like \nConsoleLineNotifier.processNewLines()? I don\u0027t have a case where it\u0027s failing; \nit just looked like it should probably be synchronized.\n",
    "The fix is in progress via bug 31734.",
    "Reopening. I think Ed\u0027s right. We added a legitimate API \n(IStreamListener#streamClosed()) and solved a legitimate problem (not correctly \nnotifying IConsoleLineTrackers of the last line of output), but we haven\u0027t \nsolved the API issue requested in this report.",
    "This will also be a breaking API change.",
    "Doesn\u0027t have to be a breaking API change. If you could hold off on the debug \nterminate event until after all the line trackers were called for the last \nline then you could keep the same API. However, I can see how that would be \ndifficult given the output queueing and polling going on.",
    "Ed, trying to delay the terminate event like that isn\u0027t feasible.\n\nDarinW, can I just check in the change or do we need PMC approval first?",
    "Hold off on this change until after tomorrow\u0027s integration build. We need to \nfix up all the line trackers. As well, we could consider a \"LineTracker2\" \napproach that extends the line tracker with a new method. The method is only \ncalled if the client implements the new interface.",
    "With this new code I\u0027m now getting a crash when I run a simple external \ncommand that just runs \"c:\\winnt\\system32\\cmd.exe /c echo Hi there\" twice in a \nrow.\n\nThread [main] (Suspended (exception NullPointerException))\n\tConsoleDocumentPartitioner$2.run() line: 618\n\tRunnableLock.run() line: 35\n\tUISynchronizer(Synchronizer).runAsyncMessages() line: 102\n\tDisplay.runAsyncMessages() line: 2164\n\tDisplay.readAndDispatch() line: 1881\n\tWorkbench.runEventLoop(Window$IExceptionHandler) line: 2041\n\tWorkbench.run(Object) line: 2024\n\tInternalBootLoader.run(String, URL, String, String[], Runnable) line: \n858\n\tBootLoader.run(String, URL, String, String[], Runnable) line: 461\n\tNativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not \navailable [native method]\n\tNativeMethodAccessorImpl.invoke(Object, Object[]) line: 39\n\tDelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 25\n\tMethod.invoke(Object, Object[]) line: 324\n\tMain.basicRun(String[]) line: 295\n\tMain.run(String[]) line: 751\n\tMain.main(String[]) line: 587\n",
    "Ed, can you be more specific about your test case? Are you doing one launch that \nruns that command twice or are you launching the same configuration two times?\n\nA simple test case that executes a bash script doesn\u0027t cause this problem for \nme.",
    "Launching this configuration twice:\n\n\u003c?xml version\u003d\"1.0\" encoding\u003d\"UTF-8\"?\u003e\n\u003claunchConfiguration \ntype\u003d\"org.eclipse.ui.externaltools.ProgramLaunchConfigurationType\"\u003e\n    \u003cstringAttribute\n        key\u003d\"org.eclipse.ui.externaltools.ATTR_TOOL_ARGUMENTS\" value\u003d\"/c echo \nHi there\"/\u003e\n    \u003cstringAttribute key\u003d\"org.eclipse.ui.externaltools.ATTR_LOCATION\" \nvalue\u003d\"c:\\winnt\\system32\\cmd.exe\"/\u003e\n    \u003cbooleanAttribute\n        key\u003d\"org.eclipse.debug.core.appendEnvironmentVariables\" value\u003d\"true\"/\u003e\n\u003c/launchConfiguration\u003e\n",
    "BTW, I noticed RuntimeProcess.terminated() closes the streams proxy first and \nthen fires the debug terminated event:\n\n\t/**\n\t * Notification that the system process associated with this process\n\t * has terminated.\n\t */\n\tprotected void terminated() {\n\t\tif (fStreamsProxy instanceof StreamsProxy) {\n\t\t\t((StreamsProxy)fStreamsProxy).close();\n\t\t}\n\t\tfTerminated\u003d true;\n\t\ttry {\n\t\t\tfExitValue \u003d fProcess.exitValue();\n\t\t} catch (IllegalThreadStateException ie) {\n\t\t}\n\t\tfProcess\u003d null;\n\t\tfireTerminateEvent();\n\t}\n\nAs an experiment I commented out the event queue and the polling thread and \nStreamEntrys in ConsoleDocumentPartitioner and did a display.syncExec() (not \nasyncExec) to append text to the console document, and that made things come \nout in the right order (all stream lines processed and then the terminate \nevent). If you think this might be a good way to handle it I can whip up a \npatch.\n\n(this is not the version that crashed in the last comment; the version that \ncrashed came straight from HEAD).",
    "Released the new IConsoleLineTracker API and fixed the NPE. I updated the \nr3_0_changes file in debug core too.\n\nPlease verify, DarinW.",
    "(you too, Ed)",
    "Man, it takes a long time to refetch and rebuild from Head! Anyway I got the \ncode and unfortunately it doesn\u0027t work. The problem with it is that there are \n(at least) two stream closed notifications sent to the IStreamListener, one \nfor stderr and one for stdout. Depending on thread timing, the \nIConsoleLineTracker.streamClosed() method can be called twice. In my testing, \nit\u0027s called once, then the process terminated event comes in, and then it\u0027s \ncalled again. Rather than putting more flags in there to prevent the extra \ncalls, I recommend you back out that change and restore IConsoleLineTracker to \nits original state.",
    "If you only want to do your processing when the first (or last) stream is \nclosed, the worst you should have to do is create a flag.",
    "A flag won\u0027t work. In my testing, the new IConsoleLineTracker.streamClosed() \ncan be called zero, one, or two times depending on the racing of the various \nthreads. So the plugin can\u0027t depend on it. Since adding it was a breaking \nchange to a somewhat commonly used interface (IConsoleLineTracker), I think \nit\u0027s better to take it out until a proven solution is available, perhaps based \non comment#32.",
    "Jared - the problem is with our implementation. We should only call the closed \nmethod when all streams on a given console close - not when each stream closes. \nAnd thus, the method should likey be named #consoleClosed()",
    "The current implementation does not account for the fact that more than the \nstandard streams can be connected to a console (for example, Ant connects 5 \ndifferent streams to the console). As well, a stream may be closed before a \nlistener can be notified (i.e. a listener may register after a stream has been \nclosed). We may need to add extra API to the stream monitor - #isClosed().",
    "Created an attachment (id\u003d6208)\nProposed patch for ordering terminate event after output without an api change\n\nI\u0027ve simplified the ConsoleDocumentPartitioner (removed the polling and event\nqueue stuff) so that output can predictably be handled before the process\nterminate event fires. This version works in all my tests but it does leave out\nline wrapping support due to lack of time (and because I think line wrapping\nshould be a function of the view not the document model). I left the API change\nto IConsoleLineTracker and ConsoleLineNotifier in simply because I didn\u0027t want\nto change the JDT and Ant consumers back. However the new stream/console closed\nstuff will not be called since it\u0027s not needed anymore.",
    "Ed - I need a clarification... do you want notifiation when the console is \nclosed (and no more output will be appended), or do you just want to ensure you \nare notified of the last line of output?\n\n(NOTE: Removing the buffering will not be acceptable to many Eclipse clients \nsince it is critical when handling large amounts of output). ",
    "Previously there were three levels of buffering and queueing going on, and \nmultiple copies of the console text:\n\n1. OutputStreamMonitor, running its own thread, has an 8192 byte buffer that \nit tries to read before calling IStreamListener.streamAppended(). This happens \neven if setBuffered(false) is called. setBuffered(true) simply creates another \ncopy of the data that can grow without bound until the caller requests the \ncontents and flushes it, but streamAppended() is still called regardless.\n\n2. ConsoleDocumentPartitioner was saving IStreamListener.streamAppended calls \non a queue. This was done without a copy of the text.\n\n3. ConsoleDocumentPartitioner.poll() was run in its own thread every 100ms to \npull \"some\" but not all of the events off that queue. At most it would only \npull off 8096 characters per call, which could result in an odd resonance with \nthe 8192 number in (1). This wasn\u0027t true buffering because if there were only \none request of one character in the queue, that character would be appended to \nthe document right away. All the text was copied once however, and also the \nuse of StringBuffer.setLength(0) would cause an extra copy I beleive (see \nrecent JDC articles on StringBuffer).\n\nThe patch eliminates (2) and (3), but the buffering in (1) is intact. Also an \nextra thread and up to two copies of the text are eliminated. I still see \nbuffering in my tests and I\u0027d like to get rid of that too but that\u0027s a \nseparate issue. So I would not expect any problems with the new code handling \nlarge amounts of data (one of my tests has large amounts of data); if you see \nany let me know.",
    "(OK, thanks for the explanation - I have not looked at the code yet).",
    "*** Bug 43577 has been marked as a duplicate of this bug. ***",
    "The patch recreates the problem in bug 31734. The last line of output doesn\u0027t \nget hyperlinks.",
    "From Darin\u0027s comments in comment #39, the idea of an accurate consoleClosed() \nnotification seems impossible. I\u0027m inclined to rip it out completely.\n\nEd, can you solve your problem using an IStreamListener? In your console line \ntracker, try adding something like this:\npublic class MyLineTracker implements IConsoleLineTracker {\n  // Stream listener\n  private IStreamListener systemOutListener;\n\n  public void init(IConsole console) {\n    // Whatever you do now\n    systemOutListener\u003d new IStreamListener() {\n      public void streamAppended(String text, IStreamMonitor monitor) {\n      }\n      public void streamClosed(IStreamMonitor monitor) {\n        // Your post-closed processing here\n        System.out.println(\"System out closed\");\n      }\n    };\n    console.getProcess().getStreamsProxy().getOutputStreamMonitor().\naddListener(systemOutListener);\n  }\n}",
    "No, the IStreamListener.streamClosed() method would be called before some \nindeterminate number of the IConsoleLineTracker.lineAppended() methods.\n\nI\u0027ve duplicated the hyperlink problem you found and I\u0027ll have a new patch for \nyou soon.",
    "Created an attachment (id\u003d6214)\nNew proposed patch also fixes the hyperlink on last line problem\n\nThis reverses the recent changes to IConsoleLineTracker and IStreamListener\nwhile at the same time fixing the race condition in this bug and the last line\nproblem in bug 31734. Changes made to Ant and JDT were backed out too.",
    "The problem with removing the polling queue is that you can flood the UI thread \nsuch that it does not provide relevant cycles to the UI for interaction. (That \nis why we added the polling thread and delay to process 8K of output per poll).",
    "That might have been the case with asyncExec but I\u0027m not seeing that problem \nwith the syncExec used in my patch. I ran this program which writes output as \nhard as it can and the user interface is still very responsive:\n\n  public static void main(String[] args) {\n  \tfor (int i \u003d 1; i \u003c 100000; i++) {\n  \t\tSystem.out.println(i \n+ \"AbcdefghijklmnopqrstuvwxyzAbcdefghijklmnopqrstuvwxyzAbcdefghijklmnopqrstuvwx\nyzAbcdefghijklmnopqrstuvwxyzAbcdefghijklmnopqrstuvwxyzAbcdefghijklmnopqrstuvwxy\nzAbcdefghijklmnopqrstuvwxyz\");\n  \t}\n    System.out.print(\"at Grah.main(Grah.java:13)\");\n  }\n\nIt\u0027s really cool the way it\u0027s working now, give it a try and see if you can \nbreak it :).",
    "Here\u0027s my fix (it avoids the sync exec, there are no breaking changes, and the \nbuffering is still intact).\n\n* I removed the changes to IStreamListener and the requriement on Stream \nmonitors to notify of the stream closing\n* The console document partitioner listens for a terminate event from its \nprocess, and puts the event in the buffered queue. This acts like an \"all \nstreams are closed\" event\n* The console line notifier notifies of the last line when the \"termainte\" is \nprocessed from the buffer, and notifies line trackers that the console is closed\n* A new interface is added - IConsoleLineTrackerExtension - with the new method \n#consoleClosed(). Only those who implement the new interface are notified of \nthe console closing\n\nAdded tests to LineTrackerTests.\n\nDarin (S) - the Ant UI tests are broken, but I did not have update writes to \nrelease my fix. The tests that count lines are now off by once, since there is \nactually an empty line of output at the end. So, where you expect 5 lines, \nthere are now 6, etc.",
    "Please verify Darin (S), and adjust ant UI tests.",
    "Updated the tests (again :-) ) ...do not think I made it for the build tonight \nthough...",
    "I tried this version and I\u0027m getting an out of memory exception on a test that \ngenerates a very large amount of output, even when I set the option to limit \nsaved console output:\n\nThread [Output Stream Monitor] (Suspended (exception OutOfMemoryError))\n\tOutputStreamMonitor.access$1(OutputStreamMonitor) line: 124\n\tOutputStreamMonitor$1.run() line: 177\n\tThread.run() line: 534\n\nThis crash does not occur in the non-polling version. Another artifact of the \npolling method is that the process runs, all its output is saved away in \nmemory, and (if there was space in memory) it terminates. Meanwhile output \nkeeps going and going to the console and there is no way to stop it short of \nremoving the terminated console.\n\nAnother problem is that the 8k per 100ms limit means you can display a max of \n80k per second. I have a real world application (not a test case) that wants \nto output 20M to stdout, which would take over 4 minutes just to spool through \nthe console (the program itself runs in 9 seconds, it\u0027s a metadata query \nthing, don\u0027t ask). Also I haven\u0027t profiled it but with larger outputs, the \nextra memory copying that the polling method uses may start to hurt too.\n",
    "Another crash in your new code, sorry:\n\nThread [main] (Suspended (exception NullPointerException))\n\tConsoleDocumentPartitioner$2.run() line: 632\n\tRunnableLock.run() line: 35\n\tUISynchronizer(Synchronizer).runAsyncMessages() line: 102\n\tDisplay.runAsyncMessages() line: 2149\n\tDisplay.readAndDispatch() line: 1866\n\tWorkbench.runEventLoop(Window$IExceptionHandler) line: 2064\n\tWorkbench.run(Object) line: 2047\n\tInternalBootLoader.run(String, URL, String, String[], Runnable) line: \n858\n\tBootLoader.run(String, URL, String, String[], Runnable) line: 461\n\tNativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not \navailable [native method]\n\tNativeMethodAccessorImpl.invoke(Object, Object[]) line: 39\n\tDelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 25\n\tMethod.invoke(Object, Object[]) line: 324\n\tMain.basicRun(String[]) line: 295\n\tMain.run(String[]) line: 751\n\tMain.main(String[]) line: 587\n\nI ran a batch file as an external program and pressed the stop button about \nmidway before it finished. Any program that takes its time generating output \nwould probably show the problem but here\u0027s the test I used:\n\nEcho one\nsleep 1\nEcho two\nsleep 2\nEcho thee\nsleep 3\nEcho four\nsleep 4\nEcho five\nsleep 5\n",
    "I\u0027m tempted to open new bug reports. I believe the \"race\" condition is \nnow \"fixed\". The problems (new or not) are:\n\n(1) Large amounts of output can cause out of memory.\n(2) NPE somewhere in the code.\n\nAny objections?",
    "The memory one, ok. The NPE, no because it was the new code that created the \nnew NPE. Here\u0027s a quickie patch that fixes the NPE:\n\nIndex: ConsoleDocumentPartitioner.java\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nRCS \nfile: /home/eclipse/org.eclipse.debug.ui/ui/org/eclipse/debug/internal/ui/views\n/console/ConsoleDocumentPartitioner.java,v\nretrieving revision 1.35\ndiff -u -r1.35 ConsoleDocumentPartitioner.java\n--- ConsoleDocumentPartitioner.java\t25 Sep 2003 03:43:46 -0000\t1.35\n+++ ConsoleDocumentPartitioner.java\t25 Sep 2003 14:05:59 -0000\n@@ -629,7 +629,9 @@\n \t\t\t\tif (display !\u003d null) {\n \t\t\t\t\tdisplay.asyncExec(new Runnable() {\n \t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\n\tfLineNotifier.streamsClosed();\n+\t\t\t\t\t\t\tif (fLineNotifier !\u003d \nnull) {\n+\t\t\t\t\t\t\t\n\tfLineNotifier.streamsClosed();\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t});\n \t\t\t\t}\n\n\n\nI discovered another problem last night, not a crash but a usability problem. \nIf you are running a shell in the console and you\u0027re using the polling \nversion, then if you type in a command that generates a moderate amount of \noutput you cannot stop the output by sending a signal to the shell because \nmost likely the command has already run and the console is just showing you \nspooled output. You can\u0027t stop it by closing terminated consoles because the \nconsole is not terminated - the shell is still running. This is going to put a \ncrimp in any work for bug 36669.",
    "You can stop the output by pressing the \"clear\" button. It clears the console \nas well as the queue of buffered output.",
    "I\u0027ve added Ed\u0027s fix for the NPE.",
    "Well clearing is one way :-). Seriously though, a user will want to stop the \noutput because they think they\u0027re something wrong with it and they often need \nto look at what has been output so far, maybe cut-n-paste some of the bad \noutput into a mail message or something.\n\nThe patch from 9/24 does not have the runaway console problem because the \ntarget process is throttled to the speed of the console output, just as if you \nhad run it outside Eclipse with output going to a command line shell. It still \nhas the same low level buffering (I haven\u0027t figured out how to disable that \nyet). It does not have the NPE, does not require an interface extension for \nclients that need to process all output, handles infinitely long console \noutput without running out of memory, and provides a responsive UI. It holds \nthe terminate event until after all the lines are processed which makes the \nwhole thing much more predictable. Line trackers can affect process control, \nfor example a line tracker can see something alarming in the output stream and \nkill the process before it gets much further - not possible with the polling \nscheme. If you\u0027re concerned about throttling, that can be added to the patch \nversion by just doing sleeps in the stream listener - they run on the output \nmonitor thread anyway.\n\nI really think a non-polling version such as the 8/24 patch is a better design \nfor the kinds of things we need the console to do in our internal and external \nproducts based on Eclipse.",
    "With the new buffering I just added (bug 43654), the console keeps up with the \nprogram. When I press terminate there is minimal-to-no lag.\n\nThe Eclipse 3.0 model is \"concurrency\". Everything is asyncronous (especially \nrunning/debugging programs), so you cannot (generally) count on the order of \nevents in a multi-threaded, concurrent environment. There is nothing (and never \nwas) in our spec that gurentees output is complete when a terminate is \nreceived. We would be limiting ourself if we had to hold to that (in terms of \nconcurrency). (You can be building a project, running a program, checking out \nfiles from CVS, processing output... all at the same time).\n\nIn general, we can\u0027t do sync exec\u0027s. Every sync exec we ever put in, we have \ntaken out because at some point it has caused a deadlock. With the new \nbuffering, I don\u0027t see a need for it.",
    "Verified but we have bug 44012 and bug 44040.\n",
    "I don\u0027t want to re-open this bug (if I even can...) without running this by you\nguys first.  I think I have found an issue with the implemented fix in release\n3.0 (Final).\n\nI have not attempted to get this into a repeatable isolated test case because it\nis fairly tightly integrated into a whole pile of other stuff.  Basically, I\nwill explain the situation however, and what I did to work around it.\n\nI have an Ant-based builder which calls some command line tools to compile and\nlink assembly code.  Anyway - I have basically created a dummy AntProcess very\nsimilar to the the way Ant UI does it (but without all the launch\nconfigurations, etc. as I do not need them).  This gives me a ProcessConsole to\ndump my streams to.  I have implemented console line trackers to parse the\noutput of my build.  I re-used the BuildFailedTracker, and the TaskLineTracker\nprovided with Ant UI, and I created my own line tracker which parses error\nstrings and line numbers from my command line tools.  No problem - works great.\n\nI next added code in *my* line tracker to create overlays on my resources based\non the build output.  This is accomplished by creating markers in the resources\nat the line number found by the line tracker, as it happens.  This marker is\ncreated in a separate IWorkspaceRunnable(), and a decorator is created at the\nsame time (I am implementing the ILightweightLabelDecorator interface and the\norg.eclipse.ui.decorators extension point).\n\nWhen this was all implemented, I ran into issues where the console would\n*sometimes* disappear before the line trackers were finished with it - which led\nme to Bugzilla and this bug.  Great!  I saw the new IConsoleLineTrackerExtension\ninterface, and assumed implementing this would solve my issues.  I changed my\nline trackers to implement this new interface and... no dice.  It still\nperiodically missed error markers and overlays, and seemed better, but still\nfailed randomly.\n\nInserting Thread.sleep()\u0027s in my consoleClosed() method seemed to do the trick\nbut the value needed was not consistent and this was a hack.  I inserted\nnumerous logging calls in my plugins - and I actually saw cases where the\nconsoleClosed() method was never called!  This seems like a persistent bug in\nthe code that was put in the 3.0 stream to address this bug.\n\nAnyway, after fighting with this for a couple days, I figured out that the\nTERMINATE event that is generated by the Process is what tells the\nConsoleDocumentPartitioner to close all the console streams by placing an event\nin a Queue.  There is a polling Queue that reads this event, and shuts down the\nconsoles.  However - what I am seeing is that the Process is sometimes still\nterminated before the Queue can process this request to close the console.  This\ncould be because of my \"stripped down\" implementation of a Process, or even have\nsomething to do with the decorator stuff.  At any rate - the consoleClosed()\nmethod was sometimes never called.  I also noticed that the code which inserted\nhyperlinks back to the Ant tasks in the TaskLinkManager class would throw an NPE\nas the console.getDocument() would return null - another sign the console\ndocument was disappearing too soon.  Here is a traceback of one of these instances:\n\n!ENTRY org.eclipse.ui 4 4 Nov 11, 2004 18:46:46.558\n!MESSAGE Unhandled event loop exception\n\n!ENTRY org.eclipse.ui 4 0 Nov 11, 2004 18:46:46.558\n!MESSAGE Failed to execute runnable (java.lang.NullPointerException)\n!STACK 0\norg.eclipse.swt.SWTException: Failed to execute runnable\n(java.lang.NullPointerException)\n\tat org.eclipse.swt.SWT.error(SWT.java:2691)\n\tat org.eclipse.swt.SWT.error(SWT.java:2616)\n\tat org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:109)\n\tat org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:2749)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2434)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1377)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1348)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:254)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:141)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:96)\n\tat\norg.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:335)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:273)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:129)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:183)\n\tat org.eclipse.core.launcher.Main.run(Main.java:644)\n\tat org.eclipse.core.launcher.Main.main(Main.java:628)\n\n!ENTRY org.eclipse.ui 4 4 Nov 11, 2004 18:46:46.574\n!MESSAGE *** SWT nested exception\n\n!ENTRY org.eclipse.ui 4 0 Nov 11, 2004 18:46:46.574\n!MESSAGE java.lang.NullPointerException\n!STACK 0\njava.lang.NullPointerException\n\tat\norg.eclipse.debug.internal.ui.views.console.ConsoleLineNotifier.processNewLines(ConsoleLineNotifier.java:108)\n\tat\norg.eclipse.debug.internal.ui.views.console.ConsoleLineNotifier.consoleChanged(ConsoleLineNotifier.java:80)\n\tat\norg.eclipse.debug.internal.ui.views.console.ConsoleDocumentPartitioner.documentChanged2(ConsoleDocumentPartitioner.java:368)\n\tat\norg.eclipse.jface.text.AbstractDocument.updateDocumentStructures(AbstractDocument.java:605)\n\tat\norg.eclipse.jface.text.AbstractDocument.fireDocumentChanged(AbstractDocument.java:704)\n\tat org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:998)\n\tat\norg.eclipse.debug.internal.ui.views.console.ConsoleDocumentPartitioner$3.run(ConsoleDocumentPartitioner.java:699)\n\tat org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)\n\tat org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:106)\n\tat org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:2749)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2434)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1377)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1348)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:254)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:141)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:96)\n\tat\norg.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:335)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:273)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:129)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:183)\n\tat org.eclipse.core.launcher.Main.run(Main.java:644)\n\tat org.eclipse.core.launcher.Main.main(Main.java:628)\n\nSo - what I ended up doing was the following:\n\nI added a listener-type attribute to my Process and provided methods which\nallowed the console line trackers to register and unregister themselves with the\nProcess.  In the init() method of the console line trackers, I registered with\nthe Process.  Then - when the Process is terminated, it does not set it\u0027s\nfTerminated flag - it just fires a TERMINATE debug event (if there are\nregistered line trackers present) which tells the ConsoleDocumentPartitioner to\nclose all the line trackers.  Then, in the consoleClosed() method of the console\nline trackers (which now extend the IConsoleLineTrackerExtension interface), the\nline tracker unregisters itself with the Process.  When the last line tracker\nunregisters itself - the Process sets its fTerminated flag to true, and fires\nanother TERMINATE event for good measure.\n\nThis all seems to work fine now.  I\u0027m not sure how to reproduce this - or if you\nare even interested....but perhaps someone surfing bugs like I was will find\nthis info useful.  I\u0027m wondering if the Ant UI team ever implements decorators\nbased on the build failed line tracker, if the same issue will arise.",
    "The console implementation has changed completely in 3.1. It would be \nworthwhile to see if the problem occurrs there.",
    "I believe everything is working fine in 3.1. Our line tracker tests are passing (so we\u0027re getting notified of \nthe expected number of lines) and I haven\u0027t seen any cases of missing hyperlinks in day to day use.",
    "Yeah - we\u0027re still back on 3.0.  I\u0027ll try it on 3.1 if I get some time and see\nif there is still an issue.  I\u0027ll also try and track down a solid root cause for\nthis if I can (on 3.0) as that will be more useful than a long drawn out story\nof my part... ;o)"
  ],
  "commentCreationDates": [
    "2003-09-17T06:54:49+02:00",
    "2003-09-17T15:29:02+02:00",
    "2003-09-18T03:12:56+02:00",
    "2003-09-18T03:27:38+02:00",
    "2003-09-18T06:42:43+02:00",
    "2003-09-18T15:54:22+02:00",
    "2003-09-18T20:12:47+02:00",
    "2003-09-18T20:14:41+02:00",
    "2003-09-19T01:27:12+02:00",
    "2003-09-19T01:49:08+02:00",
    "2003-09-19T01:53:34+02:00",
    "2003-09-19T01:57:05+02:00",
    "2003-09-19T02:04:45+02:00",
    "2003-09-19T02:21:29+02:00",
    "2003-09-19T02:41:46+02:00",
    "2003-09-19T02:50:34+02:00",
    "2003-09-19T02:51:00+02:00",
    "2003-09-19T05:31:55+02:00",
    "2003-09-19T05:33:02+02:00",
    "2003-09-19T15:39:18+02:00",
    "2003-09-19T22:20:25+02:00",
    "2003-09-19T22:28:02+02:00",
    "2003-09-22T21:08:55+02:00",
    "2003-09-22T21:11:57+02:00",
    "2003-09-22T23:16:48+02:00",
    "2003-09-22T23:18:59+02:00",
    "2003-09-22T23:37:25+02:00",
    "2003-09-22T23:45:08+02:00",
    "2003-09-22T23:51:42+02:00",
    "2003-09-23T05:06:49+02:00",
    "2003-09-23T06:35:50+02:00",
    "2003-09-23T07:08:26+02:00",
    "2003-09-23T07:35:03+02:00",
    "2003-09-23T18:06:45+02:00",
    "2003-09-23T18:08:06+02:00",
    "2003-09-23T20:41:26+02:00",
    "2003-09-23T20:54:25+02:00",
    "2003-09-23T21:33:59+02:00",
    "2003-09-23T21:51:08+02:00",
    "2003-09-24T04:41:17+02:00",
    "2003-09-24T07:03:47+02:00",
    "2003-09-24T15:11:51+02:00",
    "2003-09-24T16:28:23+02:00",
    "2003-09-24T16:32:54+02:00",
    "2003-09-24T16:51:54+02:00",
    "2003-09-24T18:19:32+02:00",
    "2003-09-24T18:41:46+02:00",
    "2003-09-24T19:12:37+02:00",
    "2003-09-24T20:42:30+02:00",
    "2003-09-24T21:30:25+02:00",
    "2003-09-24T22:29:59+02:00",
    "2003-09-25T05:51:05+02:00",
    "2003-09-25T05:51:41+02:00",
    "2003-09-25T06:10:05+02:00",
    "2003-09-25T06:38:53+02:00",
    "2003-09-25T06:43:25+02:00",
    "2003-09-25T15:30:55+02:00",
    "2003-09-25T16:20:31+02:00",
    "2003-09-25T16:27:01+02:00",
    "2003-09-25T16:39:10+02:00",
    "2003-09-25T16:50:38+02:00",
    "2003-09-25T16:58:36+02:00",
    "2003-10-01T22:49:35+02:00",
    "2004-11-15T22:35:46+01:00",
    "2004-11-16T03:49:03+01:00",
    "2004-11-16T06:16:17+01:00",
    "2004-11-16T20:57:14+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ClassCastException",
      "elements": [
        {
          "method": "org.eclipse.debug.internal.core.OutputStreamMonitor.fireStreamClosed",
          "source": "OutputStreamMonitor.java:114"
        },
        {
          "method": "org.eclipse.debug.internal.core.OutputStreamMonitor.read",
          "source": "OutputStreamMonitor.java:175"
        },
        {
          "method": "org.eclipse.debug.internal.core.OutputStreamMonitor.access$1",
          "source": "OutputStreamMonitor.java:142"
        },
        {
          "method": "org.eclipse.debug.internal.core.OutputStreamMonitor$2.run",
          "source": "OutputStreamMonitor.java:196"
        },
        {
          "method": "java.lang.Thread.run",
          "source": "Thread.java:534"
        }
      ],
      "number": 0,
      "commentIndex": 14,
      "bugId": "43197",
      "date": "2003-09-19T02:41:46+02:00",
      "product": "Platform",
      "component": "Debug",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.ClassCastException",
      "elements": [
        {
          "method": "org.eclipse.debug.internal.core.OutputStreamMonitor.fireStreamClosed",
          "source": "OutputStreamMonitor.java:114"
        },
        {
          "method": "org.eclipse.debug.internal.core.OutputStreamMonitor.read",
          "source": "OutputStreamMonitor.java:175"
        },
        {
          "method": "org.eclipse.debug.internal.core.OutputStreamMonitor.access$1",
          "source": "OutputStreamMonitor.java:142"
        },
        {
          "method": "org.eclipse.debug.internal.core.OutputStreamMonitor$2.run",
          "source": "OutputStreamMonitor.java:196"
        },
        {
          "method": "java.lang.Thread.run",
          "source": "Thread.java:534"
        }
      ],
      "number": 1,
      "commentIndex": 14,
      "bugId": "43197",
      "date": "2003-09-19T02:41:46+02:00",
      "product": "Platform",
      "component": "Debug",
      "severity": "normal"
    },
    {
      "exceptionType": "org.eclipse.swt.SWTException",
      "message": "Failed to execute runnable (java.lang.NullPointerException)",
      "elements": [
        {
          "method": "org.eclipse.swt.SWT.error",
          "source": "SWT.java:2691"
        },
        {
          "method": "org.eclipse.swt.SWT.error",
          "source": "SWT.java:2616"
        },
        {
          "method": "org.eclipse.swt.widgets.Synchronizer.runAsyncMessages",
          "source": "Synchronizer.java:109"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runAsyncMessages",
          "source": "Display.java:2749"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:2434"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1377"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1348"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:254"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:141"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:96"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:335"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:273"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:129"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:324"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:183"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:644"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:628"
        }
      ],
      "number": 2,
      "commentIndex": 63,
      "bugId": "43197",
      "date": "2004-11-15T22:35:46+01:00",
      "product": "Platform",
      "component": "Debug",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.debug.internal.ui.views.console.ConsoleLineNotifier.processNewLines",
          "source": "ConsoleLineNotifier.java:108"
        },
        {
          "method": "org.eclipse.debug.internal.ui.views.console.ConsoleLineNotifier.consoleChanged",
          "source": "ConsoleLineNotifier.java:80"
        },
        {
          "method": "org.eclipse.debug.internal.ui.views.console.ConsoleDocumentPartitioner.documentChanged2",
          "source": "ConsoleDocumentPartitioner.java:368"
        },
        {
          "method": "org.eclipse.jface.text.AbstractDocument.updateDocumentStructures",
          "source": "AbstractDocument.java:605"
        },
        {
          "method": "org.eclipse.jface.text.AbstractDocument.fireDocumentChanged",
          "source": "AbstractDocument.java:704"
        },
        {
          "method": "org.eclipse.jface.text.AbstractDocument.replace",
          "source": "AbstractDocument.java:998"
        },
        {
          "method": "org.eclipse.debug.internal.ui.views.console.ConsoleDocumentPartitioner$3.run",
          "source": "ConsoleDocumentPartitioner.java:699"
        },
        {
          "method": "org.eclipse.swt.widgets.RunnableLock.run",
          "source": "RunnableLock.java:35"
        },
        {
          "method": "org.eclipse.swt.widgets.Synchronizer.runAsyncMessages",
          "source": "Synchronizer.java:106"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runAsyncMessages",
          "source": "Display.java:2749"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:2434"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1377"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1348"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:254"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:141"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:96"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:335"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:273"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:129"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:324"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:183"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:644"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:628"
        }
      ],
      "number": 3,
      "commentIndex": 63,
      "bugId": "43197",
      "date": "2004-11-15T22:35:46+01:00",
      "product": "Platform",
      "component": "Debug",
      "severity": "normal"
    }
  ],
  "groupId": "43197",
  "bugId": "43197",
  "date": "2003-09-17T06:54:49+02:00",
  "product": "Platform",
  "component": "Debug",
  "severity": "normal"
}