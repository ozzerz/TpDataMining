{
  "comments": [
    "I ran out of disk space while editing files in Eclipse.  I saved all the files I\nwas working on, and no error was reported.  However I started getting errors\nthat Eclipse couldn\u0027t save project metadata.  The error kept popping up, and\n(because I still didn\u0027t know I was out of disk space) I just assumed Eclipse was\nin a weird state.  I closed Eclipse and re-opened it.  Some of my files were\nempty or truncated, and I was still getting the problems with metadata save\nerrors.  I checked the logs and found the \"No space left on device\" errors. \nUnfortunately, by this time I had lost a large amount of work, because the files\nI had saved were either empty or truncated.\n\nSo the problems are:\n- Saving reported no warning or error when there was no space left, but simply\ntruncated the file (sometimes at byte 0).\n- The errors in saving metadata gave no information about the underlying\nexception (No space left on device).\n\nHere are a couple of applicable stack traces:\n\n!ENTRY org.eclipse.core.resources 4 568 2005-05-20 14:28:30.91\n!MESSAGE Could not write metadata for:\n/home/lhutchis/workspace/.metadata/.plugins/org.eclipse.core.resources/.projects/CORE/.indexes/b9/7e/17/history.index.\n!STACK 0\njava.io.IOException: No space left on device\n        at java.io.FileOutputStream.close0(Native Method)\n        at java.io.FileOutputStream.close(FileOutputStream.java:279)\n        at java.io.FilterOutputStream.close(FilterOutputStream.java:143)\n        at java.io.FilterOutputStream.close(FilterOutputStream.java:143)\n        at org.eclipse.core.internal.localstore.Bucket.save(Bucket.java:335)\n        at\norg.eclipse.core.internal.localstore.HistoryStore2.addState(HistoryStore2.java:90)\n        at\norg.eclipse.core.internal.localstore.FileSystemResourceManager.write(FileSystemResourceManager.java:783)\n        at\norg.eclipse.core.internal.resources.File.internalSetContents(File.java:326)\n        at org.eclipse.core.internal.resources.File.setContents(File.java:370)\n        at org.eclipse.core.internal.resources.File.setContents(File.java:470)\n        at\norg.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.commitFileBufferContent(ResourceTextFileBuffer.java:315)\n        at\norg.eclipse.core.internal.filebuffers.ResourceFileBuffer.commit(ResourceFileBuffer.java:317)\n        at\norg.eclipse.jdt.internal.ui.javaeditor.DocumentAdapter.save(DocumentAdapter.java:356)\n        at\norg.eclipse.jdt.internal.core.CommitWorkingCopyOperation.executeOperation(CommitWorkingCopyOperation.java:113)\n        at\norg.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:710)\n        at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)\n        at\norg.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:771)\n        at\norg.eclipse.jdt.internal.core.CompilationUnit.commitWorkingCopy(CompilationUnit.java:327)\n        at\norg.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:953)\n        at\norg.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$2.execute(CompilationUnitDocumentProvider.java:1012)\n        at\norg.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:126)\n        at\norg.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:68)\n        at\norg.eclipse.ui.actions.WorkspaceModifyOperation$1.run(WorkspaceModifyOperation.java:98)\n        at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)\n        at\norg.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:110)\n        at\norg.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:73)\n        at\norg.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:63)\n        at\norg.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:441)\n        at\norg.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:700)\n        at\norg.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:3675)\n        at\norg.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1361)\n        at\norg.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(Compilation\n!ENTRY org.eclipse.ui.ide 4 4 2005-05-20 14:48:22.305\n!MESSAGE Problems saving workspace\n\n!ENTRY org.eclipse.ui.ide 4 1 2005-05-20 14:48:22.346\n!MESSAGE Problems occurred while trying to save the state of the workbench.\n!SUBENTRY 1 org.eclipse.core.resources 4 568 2005-05-20 14:48:22.346\n!MESSAGE Could not write workspace metadata:\n/home/lhutchis/workspace/.metadata/.plugins/org.eclipse.core.resources/.root/52.tree.\n!STACK 0\njava.io.IOException: No space left on device\n        at java.io.FileOutputStream.close0(Native Method)\n        at java.io.FileOutputStream.close(FileOutputStream.java:279)\n        at java.io.FilterOutputStream.close(FilterOutputStream.java:143)\n        at\norg.eclipse.core.internal.localstore.SafeFileOutputStream.close(SafeFileOutputStream.java:58)\n        at java.io.FilterOutputStream.close(FilterOutputStream.java:143)\n        at\norg.eclipse.core.internal.resources.SaveManager.saveTree(SaveManager.java:1104)\n        at\norg.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:944)\n        at org.eclipse.core.internal.resources.Workspace.save(Workspace.java:1748)\n        at\norg.eclipse.ui.internal.ide.IDEWorkbenchAdvisor$2.run(IDEWorkbenchAdvisor.java:280)\n        at\norg.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)",
    "That\u0027s in deed a bad one.\n\nThe stack trace we see comes from HistoryStore2.addState(...) which catches the\nResourceException which contains the IOException, logs it and then \"normally\"\nreturns from the method.\n\nJohn, is this intentional?\n\nHowever, this is not the main cause for the failure. Something seems to go wrong\nin Platform Text since the Core methods that write the file correctly propagate\nthe error in a ResourceException. Will investigate what\u0027s going wrong here.\n\n",
    "Is there enough to go by in these stack traces?  I think there were a couple of\nother exceptions in the logs after this point, but on quick examination these\ntwo seemed to be representative.\n\nThe first exception I noticed was something about not being able to write\n\"/CORE\", which is the name of the project I was working in.  I don\u0027t remember\nexactly what the exception was.\n\nYou may want to test this by creating a small partition, creating a few Java\nfiles in Eclipse, opening them for editing, making modifications without saving,\nthen going \"cat /dev/zero \u003e /mnt/partition/temp\" to fill up the partition.  Then\ntry saving your changes and watch what happens.\n",
    "\u003e- Saving reported no warning or error when there was no space left, but simply\n\u003etruncated the file (sometimes at byte 0).\nI assume you did get a dialog but it did not report an error. Instead it said\nthat the file is out of sync (see attached picture of that dialog), below\nreferred to as OOSD.\n\nThere are two problems here:\n\n1. AbstractTextEditor.handleExceptionOnSave thinks the file is not in sync and\n   hence it does not report the error but shows the OOSD. To me this looks like \n   a Platform Core bug: since the saving of the file failed I would expect to \n   still be in sync.\n   If I would workaround this in handleExceptionOnSave by not checking the\n   sync state it but showing the error dialog instead it would still be \n   very confusing for the user because the next save would tell him that the \n   file is not in sync (OOSD). This will happen because the save operations \n   check the sync state before trying to write to disk.\n   Note: In addition, the history which seems partially changes should also be\n         reset.\n\n2. Assuming 1 is fixed the next problem is that the ErrorDialog class does not \n   show/display all the info that\u0027s in the status i.e. the \"Disk Full\" message\n   from the original low-level exception isn\u0027t shown.\n   \u003d\u003d\u003e filed bug 96227 and attached a patch to fix this\n   \u003d\u003d\u003e added workaround which appends low-level message until bug 96227 is fixed\n\nMoving to Platform Resources for comments.",
    "Created an attachment (id\u003d21551)\nPatch for FileSystemResourceManager.java\n\nNote: This patch is not sufficient. It only ensures that the file is in sync\nagain and makes the editor show an error dialog. The history might still be\nleft partially modified (see HistoryStore2).\n",
    "Created an attachment (id\u003d21552)\nPicture of the OOSD\n",
    "Actually I never saw a dialog with that exact message on (specifically, I was\nnever asked whether to overwrite the modified changes; however I do vaguely\nremember messages about things being out of sync, but there was always a\npathname reported in the dialog IIRC, and I was never given a choice as to what\nto do).  I\u0027m guessing you\u0027re saying OOSD is shown because the save was not\nsuccessful?  Then maybe I would get it if I save twice after running out of space?\n\nI\u0027m running Eclipse on Linux, although I suspect it shouldn\u0027t make a difference.\n\nI also suspect that this is not straightforward to fix, because depending on the\nexact order of failures that occur when running out of space, you could probably\ntrigger a variety of codepaths.  I recommend testing this many times, forcing a\npartition to run out of space at some random point.\n\n\"No space left on device\" situations are always really tricky to do anything\nabout, and most app authors just throw up their hands and say the behaviour is\nundefined in this case.  However I\u0027m convinced this can be handled in a sane way.\n\nPerhaps every save should be verified immediately after the save (i.e. in-memory\ncopy compared with what\u0027s on disk).  This would also copy other rare glitches,\ne.g. corrupt disk sectors.  Is this what the OOS test is about?\n\nOne other important point: When the files I was working on were shown to have\nsaved \"successfully\", they were marked as clean (no changes).  So when I thought\nthis was an Eclipse bug, I just closed Eclipse and restarted it, because I\nthought it was in a weird state.  How about:\n  (1) if there\u0027s a failure, the user be told that the changes have not saved\nsuccessfully, and suggest that the text be copied into a text editor before\nclosing Eclipse if repeated saves also fail.\n  (2) the document still be marked as \"dirty\" so that if the user does try to\nclose Eclipse, they get the \"unsaved changes\" dialog.\n",
    "The OOSD should only appear in cases where someone/thing outside Eclipse\nmodified the file. It warns you that the real file content (or precise:\nmodification stamp) is not the same as the one you\u0027re currently modifying. This\ndialog should not appear in cases where a failure happend during save.\n\n\u003e(1) if there\u0027s a failure, the user be told that the changes have not saved\nYes, that\u0027s what should happen and actually happens if you apply my attached patch.",
    "I understand.  So you\u0027re saying the stacktrace indicates I probably saw an OOSD,\neven though it really is not a situation where an OOSD was even the correct\nthing to show?\n\n(Nonetheless, I still don\u0027t remember actually being presented with an OOSD-like\nchoice at any point...)\n\n",
    "Resetting priority and target milestone since this is up to current component owner.",
    "Re: comment 1\n\nYes, the history store is considered a safety net mechanism so in order to not\ninterfere with the operation being performed (a file being saved) any errors\nwhile adding a new state are just logged.",
    "Re: comment 3 item 1:\n\nThis is the same issue (bug 33876) reported against Platform/Text. Even if we\napplied your patch, any errors preventing the sync info from being properly\nsaved would always be reported as a an out-of-sync message. Wouldn\u0027t a fix to\nbug 33876 address it more appropriately?",
    "Actually no. As already outlined in comment 3, item 1 we can do this but later,\ne.g. when the editor looses focus and gets re-activated we do a sync check (this\nis needed to detect outside changes). We then report the out-of sync which is\nnot understandable for the user. Same if he tries to save later.\n\nUp to know I thought that if my IResource is synchronized and I use only Eclipse\nAPI I can expect that the IResource stays synchronized (assuming that no one\ntouched it from outside). Shouldn\u0027t IFile.setContents() at least try to fulfill\nthat contract?\n\nHaving said that, I just added code to the editor as a safety net which will\nensure that the user gets the correct message. However, the OOSD will kick-in\nlater as soon as the user tries to save again or the editor gets a partActivated\nevent. There\u0027s no way that the editor fixes up the out-of-sync situation\nautomatically.",
    "*** Bug 33876 has been marked as a duplicate of this bug. ***",
    "There are two problems here, so I am going to create separate bug reports to\navoid confusion.\n\n1) If IFile.setContents fails part way through writing the file, then the file\ntimestamp will be changed on disk, but the sync info will not be updated.  The\nresult is that the file is out of sync after the exception is thrown.  This is a\ncore resources bug, and I have entered bug 96508 for this.  Since this behaviour\nhas been around forever, I consider it not critical and it won\u0027t be addressed\nfor 3.1.\n\n2) If IFile.setContents throws an exception AND the file is out of sync, then\nAbstractTextEditor discards the core exception and prompts for the out of sync\ncondition instead. I think this is the \"dangerous\" behaviour being reported by\nthe user where the real problem (out of disk space) was not being reported. Dani\nchanged AbstractTextEditor.handleExceptionOnSave today to report the \"real\"\nexception if the returned IStatus object contains a nested exception.  I think\nthis code is still dangerous because it will still discard legitimate exceptions\nif the status object doesn\u0027t contain a nested exception.  Instead it should\ncheck if the status has constant IResourceStatus.OUT_OF_SYNC_LOCAL, indicating\nthat setContents failed due to being out of sync. Any other exception should be\nreported to the user with its message intact.  I\u0027ll move this bug report back to\ntext so they can decide what to do with it (mark it fixed if the new behaviour\nis acceptable, or possibly defer).",
    "The problem is:\n- it is not spec\u0027ed in Platform Text that IResourceStatus.OUT_OF_SYNC_LOCAL \n is/must be used. Instead there\u0027s API to get the modification stamp (old) or ask\n  whether the input is synchronized\n- a core exception might be thrown that\u0027s not having the status\n  IResourceStatus.OUT_OF_SYNC_LOCAL\n\nI think the best solution here is:\n- show the OOSD only iff CoreEx with status IResourceStatus.OUT_OF_SYNC_LOCAL\n- show the error dialog iff not out of sync according to Platform Text API\n- in all other cases show a new OOSD dialog which also shows the exception\n\n\u003e I think this code is still dangerous because it will still discard legitimate \n\u003e exceptions if the status object doesn\u0027t contain a nested exception.\nJohn, just curious: can you give an example of such a case?\n\nEven though this behavior has been around forever, Platform Text will address\nthis for 3.1 ;-)",
    "Unfortunately IResourceStatus.OUT_OF_SYNC_LOCAL is not available in the layer\nwhere AbstractTextEditor is defined: it does not depend on core.resources.",
    "Possible solution is to add handleExceptionOnSave to AbstractDecoratedTextEditor\nwhere we can do this checking. In AbstractTextEditor we will do the following:\n- show the error dialog iff not out of sync according to Platform Text API\n- in all other cases show a new OOSD dialog which also shows the exception\n",
    "We don\u0027t want to duplicate the handleExceptionOnSave(...) code.\n\nFor 3.2 we will add a method to the document provider:\nIDocumentProviderExtension5.isNotSynchronizedException(CoreException) which will\ndecided whether the given throwable is the out of sync exception and nothing but\nthe out-of-sync exception (e.g. not nested, not a MultiStatus, etc.). I will\nfile a separate bug for this to be done in 3.2.\n\nFor 3.1 we will not change/add API, instead we implement this into a private\nAbstractTextEditor.isNotSynchronizedException(...) method which will uses the\nvalue of IResourceStatus.OUT_OF_SYNC_LOCAL since we cannot access this constant.\n\nFixed in HEAD.",
    "Filed bug 97829.",
    "Dani,\n\nVerifying against N20050607-0010 (using Windows, a floppy disk, and a lot of\npatience.)  The current behavior is:\n\n1) User sees \"Save problems.  Save could not be completed. Reason: Could not\nwrite file: a:\\a\\MyFile.java\".\n2) On this dialog, \"Details \u003e\u003e\" shows \"There is not enough space on the disk.\"\n3) User clicks OK, immediately sees \"The file has been changed on the file\nsystem.  Do you want to load the changes?\"  Clicking Yes will truncate the file.\n\nI could not completely decide from the discussion above whether this was the new\ndesired behavior for 3.1.  Leaving it up to you to decide whether to mark as\nVERIFIED.",
    "We now show the out of disk condition. That you get the refresh dialog is caused\nby bug 97829.\n\nSince the file could not be fully saved (the error you got) it\u0027s expected that\nthe result is truncated when you say \"yes\" to reload.",
    "Is there no way to portably check free space on the device before the file is\nsaved?  It would be even better if the save were aborted if there were\ninsufficient space on the device.\n\nAlso, even though it\u0027s the \"expected\" behavior for the file to be truncated if\nreloaded from disk, it\u0027s not exactly desirable behavior in this situation.  Is\nit possible to disable the \"out of sync\" check if saving failed due to an\nexception being caught?\n\nAlso, is it possible to make it so that the file reload step is written to the\nundo buffer, so that it can be undone in situations like this?  (I\u0027m not sure if\nEclipse\u0027s undo history has to be empty if a file is marked as unchanged.)\n",
    "\u003eIs there no way to portably check free space on the device before the file is\n\u003esaved?  It would be even better if the save were aborted if there were\n\u003einsufficient space on the device.\nI let Platform Core answer that question.\n\nThe \u0027reload\u0027 behavior is the same for the normal scenario as well where you\nchange (or a tool changed) the file directly on disk: if you click \u0027yes all\u0027\nyour changes are discarded and nothing is in the undo history. If you said \u0027no\u0027\nyou still have your file and can try to save it on another drive or free some\nspace. Even in your scenario there should still be the local history for your\nfile. Wasn\u0027t that the case?\n",
    "\u003eIs there no way to portably check free space on the device before the file is\n\u003esaved? It would be even better if the save were aborted if there were\n\u003einsufficient space on the device.\n\nNot with java.io.  FileOutputStream throws IOException in this case, but there\nis no way that I know of to check available space in advance. The only way I\nknow is to attempt to write the file to another name (original name + some\nsuffix), and then delete the old file and rename the new file after the write is\nsuccessful.  We do this in core for certain critical metadata files, but I think\nit would be too much of a performance hit to always do this.  \n\nI think the current behaviour is not bad considering it is a rare case.  The\nuser can clean up their disk, and they still have the file contents in the edit\nbuffer so no data is lost (unless they chose to override the editor buffer with\nthe truncated contents on disk). In that case there is always local history to\nfall back on.\n",
    "How does local history work?  I found a bunch of history files in the workspace\nmetadata, but I didn\u0027t know it was even there until it was first mentioned in\nthis bug.  Is this more than an undo history?\n\nThis is a rare case, so it may not be worth it to expend a lot more energy, but\nI\u0027m not sure that the performance hit to saving an additional copy with another\nextension (and then renaming it) would be all that great.  You already have to\nsave the file, and a delete + rename is trivially fast.  You get two additional\nwins from doing this: (1) If there\u0027s ever any other as-yet-unforeseen exception\nin the middle of saving the file to disk, it will be gracefully handled by this\ntoo; and (2) this completely eliminates the \"out of sync\" problem, since if the\ntemp file is only partially saved, it will not be detected as an out-of-sync\nsituation.  So no premature truncation occurs.\n\nIf the temp-file-save solution is not implemented, then if an exception is\nthrown, perhaps the user could just be warned in the exception dialog that if an\n\"out of sync\" dialog is shown next, it indicates the file may be truncated on\ndisk, and choosing \"Yes\" will also truncate the in-memory copy?  Otherwise the\ntruncation could be completely unexpected.",
    "\u003e How does local history work?\n\nSelect a file in either Navigator or Package Explorer, right click, and select\neither Compare With \u003e Local History or Replace With \u003e Local History. You can\nconfigure the size of the history from the General \u003e Workspace \u003e Local History\npreference page.",
    "One last note on comment 23: In my testing, the file was not in the local\nhistory, because the local history is stored on disk, and there was no room on\ndisk.  So that version of the file was truly gone."
  ],
  "commentCreationDates": [
    "2005-05-21T00:27:22+02:00",
    "2005-05-21T14:30:07+02:00",
    "2005-05-21T18:02:19+02:00",
    "2005-05-21T18:12:03+02:00",
    "2005-05-21T18:22:26+02:00",
    "2005-05-21T18:25:16+02:00",
    "2005-05-21T18:39:16+02:00",
    "2005-05-21T18:57:04+02:00",
    "2005-05-21T19:56:04+02:00",
    "2005-05-22T00:32:01+02:00",
    "2005-05-24T17:52:13+02:00",
    "2005-05-24T18:02:59+02:00",
    "2005-05-24T18:56:20+02:00",
    "2005-05-24T18:56:40+02:00",
    "2005-05-24T21:59:26+02:00",
    "2005-05-24T22:39:28+02:00",
    "2005-05-24T22:51:00+02:00",
    "2005-05-24T22:55:54+02:00",
    "2005-06-01T15:21:38+02:00",
    "2005-06-01T15:30:56+02:00",
    "2005-06-07T18:05:59+02:00",
    "2005-06-07T18:11:09+02:00",
    "2005-06-07T19:31:41+02:00",
    "2005-06-07T19:41:04+02:00",
    "2005-06-07T19:56:56+02:00",
    "2005-06-07T20:05:56+02:00",
    "2005-06-07T20:55:03+02:00",
    "2005-06-17T10:28:53+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.io.IOException",
      "message": "No space left on device",
      "elements": [
        {
          "method": "java.io.FileOutputStream.close0",
          "source": "Native Method"
        },
        {
          "method": "java.io.FileOutputStream.close",
          "source": "FileOutputStream.java:279"
        },
        {
          "method": "java.io.FilterOutputStream.close",
          "source": "FilterOutputStream.java:143"
        },
        {
          "method": "java.io.FilterOutputStream.close",
          "source": "FilterOutputStream.java:143"
        },
        {
          "method": "org.eclipse.core.internal.localstore.Bucket.save",
          "source": "Bucket.java:335"
        },
        {
          "method": "org.eclipse.core.internal.localstore.HistoryStore2.addState",
          "source": "HistoryStore2.java:90"
        },
        {
          "method": "org.eclipse.core.internal.localstore.FileSystemResourceManager.write",
          "source": "FileSystemResourceManager.java:783"
        },
        {
          "method": "org.eclipse.core.internal.resources.File.internalSetContents",
          "source": "File.java:326"
        },
        {
          "method": "org.eclipse.core.internal.resources.File.setContents",
          "source": "File.java:370"
        },
        {
          "method": "org.eclipse.core.internal.resources.File.setContents",
          "source": "File.java:470"
        },
        {
          "method": "org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.commitFileBufferContent",
          "source": "ResourceTextFileBuffer.java:315"
        },
        {
          "method": "org.eclipse.core.internal.filebuffers.ResourceFileBuffer.commit",
          "source": "ResourceFileBuffer.java:317"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.DocumentAdapter.save",
          "source": "DocumentAdapter.java:356"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CommitWorkingCopyOperation.executeOperation",
          "source": "CommitWorkingCopyOperation.java:113"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.run",
          "source": "JavaModelOperation.java:710"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.run",
          "source": "Workspace.java:1714"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.runOperation",
          "source": "JavaModelOperation.java:771"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.commitWorkingCopy",
          "source": "CompilationUnit.java:327"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy",
          "source": "CompilationUnitDocumentProvider.java:953"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$2.execute",
          "source": "CompilationUnitDocumentProvider.java:1012"
        },
        {
          "method": "org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run",
          "source": "TextFileDocumentProvider.java:126"
        },
        {
          "method": "org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute",
          "source": "WorkspaceModifyDelegatingOperation.java:68"
        },
        {
          "method": "org.eclipse.ui.actions.WorkspaceModifyOperation$1.run",
          "source": "WorkspaceModifyOperation.java:98"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.run",
          "source": "Workspace.java:1714"
        },
        {
          "method": "org.eclipse.ui.actions.WorkspaceModifyOperation.run",
          "source": "WorkspaceModifyOperation.java:110"
        },
        {
          "method": "org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run",
          "source": "WorkspaceOperationRunner.java:73"
        },
        {
          "method": "org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run",
          "source": "WorkspaceOperationRunner.java:63"
        },
        {
          "method": "org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation",
          "source": "TextFileDocumentProvider.java:441"
        },
        {
          "method": "org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument",
          "source": "TextFileDocumentProvider.java:700"
        },
        {
          "method": "org.eclipse.ui.texteditor.AbstractTextEditor.performSave",
          "source": "AbstractTextEditor.java:3675"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave",
          "source": "CompilationUnitEditor.java:1361"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "96185",
      "date": "2005-05-21T00:27:22+02:00",
      "product": "Platform",
      "component": "Text",
      "severity": "critical"
    },
    {
      "exceptionType": "java.io.IOException",
      "message": "No space left on device",
      "elements": [
        {
          "method": "java.io.FileOutputStream.close0",
          "source": "Native Method"
        },
        {
          "method": "java.io.FileOutputStream.close",
          "source": "FileOutputStream.java:279"
        },
        {
          "method": "java.io.FilterOutputStream.close",
          "source": "FilterOutputStream.java:143"
        },
        {
          "method": "org.eclipse.core.internal.localstore.SafeFileOutputStream.close",
          "source": "SafeFileOutputStream.java:58"
        },
        {
          "method": "java.io.FilterOutputStream.close",
          "source": "FilterOutputStream.java:143"
        },
        {
          "method": "org.eclipse.core.internal.resources.SaveManager.saveTree",
          "source": "SaveManager.java:1104"
        },
        {
          "method": "org.eclipse.core.internal.resources.SaveManager.save",
          "source": "SaveManager.java:944"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.save",
          "source": "Workspace.java:1748"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEWorkbenchAdvisor$2.run",
          "source": "IDEWorkbenchAdvisor.java:280"
        },
        {
          "method": "org.eclipse.jface.operation.ModalContext$ModalContextThread.run",
          "source": "ModalContext.java:113"
        }
      ],
      "number": 1,
      "commentIndex": 0,
      "bugId": "96185",
      "date": "2005-05-21T00:27:22+02:00",
      "product": "Platform",
      "component": "Text",
      "severity": "critical"
    }
  ],
  "groupId": "96185",
  "bugId": "96185",
  "date": "2005-05-21T00:27:22+02:00",
  "product": "Platform",
  "component": "Text",
  "severity": "critical"
}