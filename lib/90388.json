{
  "comments": [
    "Find stack trace and code below.\n\nRunning AJDT in incremental mode, I had a compile error, edited to change from a\ngeneric type to List, saved, and got the exception.\n\n(Sorry it\u0027s not written as a test case; I\u0027m booked now.)\n\nfrom: declare parents : Result implements Iterable\u003cResult\u003e;\n (was compile error (incorrectly - emailed Andy))\n\n  to: declare parents : Result implements List;\n\nGot BCException:\n\n------------------------------------------------------------\nInternal compiler error\norg.aspectj.weaver.BCException: Bad type name: \n\tat org.aspectj.weaver.TypeX.nameToSignature(TypeX.java:635)\n\tat org.aspectj.weaver.TypeX.forName(TypeX.java:88)\n\tat\norg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:155)\n\tat\norg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:163)\n\tat\norg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:229)\n\tat\norg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224)\n\tat\norg.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.abstractMethodMustBeImplemented(AjProblemReporter.java:203)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkAbstractMethod(MethodVerifier.java:96)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkMethods(MethodVerifier.java:305)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:575)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods(SourceTypeBinding.java:1376)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods(SourceTypeBinding.java:1379)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.verifyMethods(CompilationUnitScope.java:672)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:543)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:365)\n\tat\norg.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682)\n\tat\norg.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)\n\tat\norg.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)\n\tat org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)\n\tat\norg.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165)\n\n------------------------------------------------------------------------------\n/*\n */\npackage testing;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\n\npublic class TestContext {\n    private static final ThreadLocal\u003cTestContext\u003e TEST_CONTEXT \n        \u003d new ThreadLocal\u003cTestContext\u003e();\n\n    /**\n     * Harness calls this to start tests, get a handle to tests.\n     * \n     * @return new TestContext or current one, if already started\n     */\n    public static TestContext startTests() {\n        return getTestContext(true);\n    }\n\n    private static final void removeTestContext() {\n        TEST_CONTEXT.set(null);\n    }\n\n    private static final TestContext getTestContext(boolean create) {\n        TestContext result \u003d (TestContext) TEST_CONTEXT.get();\n        if ((null \u003d\u003d result) \u0026\u0026 create) {\n            result \u003d new TestContext();\n            TEST_CONTEXT.set(result);\n        }\n        return result;\n    }\n\n    final Stack\u003cResult\u003e results;\n    final Result root;\n    private TestContext() {\n        results \u003d new Stack\u003cResult\u003e();\n        root \u003d new Result(new Root());\n        results.push(root);\n    }\n\n    public void startTest(ITest test) {\n        assertHaveResult();\n        Result parent \u003d results.peek();\n        Result child \u003d new Result(test);\n        parent.addChild(child);\n        results.push(child);\n        child.start();\n    }\n\n    public void endTest(ITest test) {\n        doEndTest(test).pass();\n        // TODO error to call directly per Invariant, but not raised?\n        //doEndTest(test).setResult(null, null, null);\n    }\n\n    public void testFailure(ITest test, String message, Throwable thrown) {\n        doEndTest(test).fail(message, thrown);\n    }\n\n    public void testError(ITest test, String message, Throwable thrown) {\n        doEndTest(test).error(message, thrown);\n    }\n\n    private Result doEndTest(ITest test) {\n        assertHaveResult();\n        Result child \u003d results.pop();\n        checkSame(test, child);\n        return child;\n    }\n\n    /**\n     * Return the root Result, which has a pseudo-test Root.\n     * The children are the tests.\n     * Non-root Result returned if calls not balanced.\n     * @return root Result \n     */\n    public Result endTests() {\n        assertHaveResult();\n        Result result \u003d results.pop();\n        removeTestContext();\n        return result;\n    }\n\n    protected void checkSame(ITest test, Result result) {\n        if (null \u003d\u003d test) {\n            throw new IllegalArgumentException(\"null test\");\n        }\n        if (null \u003d\u003d result) {\n            throw new IllegalArgumentException(\"null result\");\n        }\n        if (result.test !\u003d test) {\n            throw new Error(\"expected \" + result.test + \" got \" + test);\n        }\n\n    }\n    /** @throws IllegalStateException if no Result on stack */\n    protected void assertHaveResult() {\n        if (results.isEmpty()) {\n            throw new IllegalStateException(\"empty results\");\n        }\n    }\n\n\n    static class Root implements ITest {\n        private Root() {\n        }\n\n        public String toString() {\n            return \"Root\";\n        }\n    }\n\n    static aspect A {\n        declare parents : Result implements List;\n        //declare parents : Result implements Iterable\u003cResult\u003e;\n    \n        private final ArrayList\u003cResult\u003e Result.children \n            \u003d new ArrayList\u003cResult\u003e();\n\n        /** @parm child the non-null Result to add as a child */\n        public void Result.addChild(Result child) {\n            children.add(child);\n        }\n\n        /** @return the non-null add-able List\u003cResult\u003e */\n        public Iterator\u003cResult\u003e Result.iterator() {\n            return children.iterator();\n        }\n    }\n    /**\n     * A test Result with a Test, Kind, and optional message and thrown. Since\n     * this is a List, results form a tree corresponding to the ITest tree.\n     * A Result is world-readable, but only TestContext-writable.\n     * dwNote requires DeclaringIListImplementation\n     */\n    public static class Result  {\n        public enum Kind {\n            UNSTARTED, INCOMPLETE, PASS, FAIL, ERROR\n        };\n\n        public final ITest test;\n\n\n        Kind kind;\n\n        String message;\n\n        Throwable thrown;\n\n        private Result(ITest test) {\n            this.test \u003d test;\n            kind \u003d Kind.UNSTARTED;\n        }\n\n        /** @return the Kind not null except during initialization */\n        public Kind getKind() {\n            return kind;\n        }\n\n        /** @return String message, may be null */\n        public String getMessage() {\n            return message;\n        }\n\n        /** @return Throwable thrown, may be null */\n        public Throwable getThrown() {\n            return thrown;\n        }\n        \n        public String toString() {\n            StringBuffer sb \u003d new StringBuffer();\n            TestingUtils.renderResultTree(this, sb);\n            return sb.toString();\n        }\n\n        private void start() {\n            setResult(Kind.INCOMPLETE, null, null);\n        }\n\n        private void pass() {\n            setResult(Kind.PASS, null, null);\n        }\n\n        private void pass(String message, Throwable thrown) {\n            setResult(Kind.PASS, message, thrown);\n        }\n\n        private void fail(String message, Throwable thrown) {\n            setResult(Kind.FAIL, message, thrown);\n        }\n\n        private void error(String message, Throwable thrown) {\n            setResult(Kind.ERROR, message, thrown);\n        }\n\n        private void setResult(Kind kind, String message, Throwable thrown) {\n            this.kind \u003d kind;\n            this.message \u003d message;\n            this.thrown \u003d thrown;\n        }\n    }\n}",
    "generics generics generics ... 1.5.0M3.",
    "I believe this is fixed by the changes for bug 97763...",
    "Fixed in latest dev build from http://eclipse.org/aspectj/downloads.php"
  ],
  "commentCreationDates": [
    "2005-04-05T23:40:04+02:00",
    "2005-04-06T09:12:16+02:00",
    "2005-06-01T18:32:15+02:00",
    "2005-06-03T17:34:46+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.aspectj.weaver.BCException",
      "message": "Bad type name:",
      "elements": [
        {
          "method": "org.aspectj.weaver.TypeX.nameToSignature",
          "source": "TypeX.java:635"
        },
        {
          "method": "org.aspectj.weaver.TypeX.forName",
          "source": "TypeX.java:88"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding",
          "source": "EclipseFactory.java:155"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings",
          "source": "EclipseFactory.java:163"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember",
          "source": "EclipseFactory.java:229"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember",
          "source": "EclipseFactory.java:224"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.abstractMethodMustBeImplemented",
          "source": "AjProblemReporter.java:203"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkAbstractMethod",
          "source": "MethodVerifier.java:96"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkMethods",
          "source": "MethodVerifier.java:305"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify",
          "source": "MethodVerifier.java:575"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods",
          "source": "SourceTypeBinding.java:1376"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods",
          "source": "SourceTypeBinding.java:1379"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.verifyMethods",
          "source": "CompilationUnitScope.java:672"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process",
          "source": "Compiler.java:543"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:365"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation",
          "source": "AjBuildManager.java:682"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild",
          "source": "AjBuildManager.java:168"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild",
          "source": "AjBuildManager.java:102"
        },
        {
          "method": "org.aspectj.ajde.internal.CompilerAdapter.compile",
          "source": "CompilerAdapter.java:122"
        },
        {
          "method": "org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run",
          "source": "AspectJBuildManager.java:165"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "90388",
      "date": "2005-04-05T23:40:04+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "90388",
  "bugId": "90388",
  "date": "2005-04-05T23:40:04+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}