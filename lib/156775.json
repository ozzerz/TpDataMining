{
  "comments": [
    "Eclipse 3.x added a lot of features for manipulating ImageDescriptors and managing them through ResourceManager. Currently, it is cumbersome to do the same thing with Fonts, so most people are still using global Font registry.\n\nThis enhancement requests that we add features to make Fonts as easy to manage as Images are.\n- FontDescriptors are provided globally\n- FontDescriptors are easy to manipulate\n- Concrete fonts are obtained from the FontDescriptors via a ResourceManager as needed\n- Fonts benefit from reference-counted shared allocations just like Images do.\n\n\nThe attached patch adds the following enhancements for Font management.\n\nNew Features:\n\n1. (feature) Add helper methods to FontDescriptor to allow font size and style to be set without packing and unpacking the FontData.\n\n2. (performance) Add a getFontData() method to FontDescriptor, to make it possible to manipulate font descriptors without creating a concrete Fonts.\n\n3. (cleanup) Remove NamedFontDescriptor, and replace it with (the more general) ArrayFontDescriptor.\n\n4. (performance) Refactor FontRegistry to use the ResourceManager tree in order to benefit from shared allocations (like Images currently do).\n\n5. (feature) Wherever there is a prominent method that returns a global Font, provide a version that returns a FontDescriptor. Refactor where necessary such that a concrete Font won\u0027t be allocated as long as clients are only calling the descriptor version.",
    "Created an attachment (id\u003d49782)\nPatch that provides this enhancement\n\n",
    "Some examples of where the new helper methods come in handy:\n\n---------------------------------------------------------------------------\nExample 1 (from bug 150593): Constructing a style variant on an existing font\n\n// The old way:\nFont font\u003d ...\nFontData[] fontData\u003d font.getFontData();\nfor (int a\u003d 0; a \u003c fontData.length; a++)\n    fontData[a].setStyle(style);\nFontDescriptor descriptor\u003d FontDescriptor.createFrom(fontData);\n\n// The new way:\nFontDescriptor descriptor \u003d FontDescriptor.createFrom(font).setStyle(style);\n\n\n---------------------------------------------------------------------------\nExample 2: Obtaining a variant of the default font\n\n// Old way:\nImageDescriptor descriptor \u003d ImageDescriptor.create(JFaceResources.getFontRegistry()\n.getBold(JFaceResources.DEFAULT_FONT));\n\n// New way:\nImageDescriptor descriptor \u003d JFaceResources.getDefaultFontDescriptor().addStyle(SWT.BOLD);\n\n---------------------------------------------------------------------------\nExample 3: obtaining FontData[] from an ImageDescriptor\n\n// Old way\nFont tempFont \u003d descriptor.createFont(Display.getCurrent());\nFontData[] result \u003d tempFont.getFontData();\ndescriptor.destroyFont(tempFont);\n\n// New way\nFontData[] result \u003d descriptor.getFontData();\n\n---------------------------------------------------------------------------\nExample 4: obtaining a height variant on an existing font descriptor.\n\n// Old way:\nFont tempFont \u003d descriptor.createFont(Display.getCurrent());\nFontData[] result \u003d tempFont.getFontData();\ndescriptor.destroyFont(tempFont);\nfor (int a\u003d 0; a \u003c fontData.length; a++)\n    fontData[a].setHeight(height);\nFontDescriptor result \u003d FontDescriptor.createFrom(fontData);\n\n// New way:\nFontDescriptor result \u003d descriptor.setHeight(height);\n\n\n---------------------------------------------------------------------------\nExample 4: Obtaining a Font from FontRegistry that only needs to remain allocated for as long as it is in use.\n\n// Old way: impossible. Fonts in FontRegistry remain allocated forever.\n\n// New way:\n\n// Allocate a ResourceManager\nResourceManager resources \u003d new LocalResourceManager(JFaceResources.getResources());\n\n// Get the font descriptor\nFontDescriptor descriptor \u003d JFaceResources.getFontRegistry().getFontDescriptor(FONT_ID);\n\n// Note: the following line depends on the patch from bug 150593\nFont myFont \u003d (Font)resources.get(descriptor);\n\n// ...Use the font....\n\n// Deallocate the font\nresources.dispose();\n",
    "Clarification on comment 0:\n\nWhat I said: \"- FontDescriptors are provided globally\".\n\nWhat I meant: \"Global methods that identify fonts do so by returning FontDescriptors rather than Fonts\".",
    "Created an attachment (id\u003d49987)\nBugfixed patch\n\n",
    "This enhancement makes a lot of sense to me.\nSo I give a big \"+1\"",
    "This patch breaks the ThemeAPITest.testNoValFont test. Please resubmit after you have run the suites and tested this.",
    "Here is the trace\n\njunit.framework.AssertionFailedError: expected:\u003c[1|Tahoma|8|0|WINDOWS|1|-11|0|0|0|400|0|0|0|1|0|0|0|0|Tahoma\u003e but was:\u003c[1|Tahoma|8|0|WINDOWS|1|0|0|0|0|0|0|0|0|1|0|0|0|0|Tahoma\u003e\n\tat junit.framework.Assert.fail(Assert.java:47)\n\tat org.eclipse.ui.tests.themes.ThemeTest.assertArrayEquals(ThemeTest.java:32)\n\tat org.eclipse.ui.tests.themes.ThemeAPITest.testNoValFont(ThemeAPITest.java:392)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:58)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication$1.run(UITestApplication.java:105)\n\tat org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)\n\tat org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:123)\n\tat org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3367)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3012)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1914)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1878)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:419)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:95)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication.run(UITestApplication.java:45)\n\tat org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:78)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:104)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:74)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:348)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:165)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.eclipse.core.launcher.Main.invokeFramework(Main.java:341)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:285)\n\tat org.eclipse.core.launcher.Main.run(Main.java:987)\n\tat org.eclipse.core.launcher.Main.main(Main.java:962)\n\n",
    "The original patch passed the test suites on Eclipse 3.2 under GTK.\n\nI\u0027d like to continue contributing patches to Eclipse, but it\u0027s hard for a\nmember of the community to test on every possible platform and continually\nmerge patches with head until they get committed. \n\nHere\u0027s what I\u0027ll do: I\u0027ll break the patch into two chunks.\n\nThe first patch adds the new API without changing the way existing code works.\nIt passes the test suites for me on I20060920-1200-linux-gtk, and it shouldn\u0027t\nbreak anything on any other platform since it doesn\u0027t change any code that is\nused by the Eclipse SDK.\n\nThe second patch makes use of the new API to permit FontRegistry to benefit\nfrom shared allocations. This is almost certainly responsible for the test\nfailure you\u0027ve observed on Windows, so it will need some polish before it can\nbe committed. I don\u0027t actually need this change for my own use, so I\u0027m not\nplanning to develop it further... but I\u0027m attaching it here in case the\ncomponent owner finds it helpful.",
    "Created an attachment (id\u003d50604)\nPatch that adds the new API.\n\nThis patch adds the new API.\n\nThis is actually the only patch that I need in my app, and it is relatively safe since it\u0027s mostly additions. The only actual changes are to the static factory methods in FontDescriptor, which aren\u0027t used by the Eclipse SDK.\n\nPasses the test suites on I20060920-1200-linux-GTK.\n",
    "Created an attachment (id\u003d50606)\nAdds shared allocations to FontRegistry\n\nAdds shared allocations to FontRegistry. This patch applies to version 1.35 of FontRegistry, but the new API methods will conflict if it is applied after the other patch. Use the version from this patch rather than the other one.\n\nNote: this is known to cause test failures on Windows. It is being attached here as-is in case the component owner finds it helpful. The problem is most likely in readResourceBundle and might be caused by the fact that the new version calls filterData immediately when parsing the data. I haven\u0027t investigated it further.\n",
    "Thanks Stefan. Fonts and colours are always tricky business so fundamental changes to how we use them require a lot of testing. Breaking this up is the best way to do this.\n\nI\u0027ll look into at least the API for M3.",
    "API portion of the patch released for build \u003e20060926. The changes to the registry have been broken into Bug 158560",
    "Verified in 20061031-0635"
  ],
  "commentCreationDates": [
    "2006-09-09T00:13:59+02:00",
    "2006-09-09T00:15:47+02:00",
    "2006-09-09T00:53:16+02:00",
    "2006-09-09T00:57:34+02:00",
    "2006-09-12T22:35:43+02:00",
    "2006-09-16T00:53:24+02:00",
    "2006-09-19T21:12:35+02:00",
    "2006-09-20T22:20:15+02:00",
    "2006-09-21T00:02:16+02:00",
    "2006-09-21T00:09:04+02:00",
    "2006-09-21T00:21:26+02:00",
    "2006-09-21T13:19:49+02:00",
    "2006-09-25T16:16:13+02:00",
    "2006-10-31T18:07:11+01:00"
  ],
  "traces": [
    {
      "exceptionType": "junit.framework.AssertionFailedError",
      "message": "expected:\u003c[1|Tahoma|8|0|WINDOWS|1|-11|0|0|0|400|0|0|0|1|0|0|0|0|Tahoma\u003e but was:\u003c[1|Tahoma|8|0|WINDOWS|1|0|0|0|0|0|0|0|0|1|0|0|0|0|Tahoma\u003e",
      "elements": [
        {
          "method": "junit.framework.Assert.fail",
          "source": "Assert.java:47"
        },
        {
          "method": "org.eclipse.ui.tests.themes.ThemeTest.assertArrayEquals",
          "source": "ThemeTest.java:32"
        },
        {
          "method": "org.eclipse.ui.tests.themes.ThemeAPITest.testNoValFont",
          "source": "ThemeAPITest.java:392"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:324"
        },
        {
          "method": "junit.framework.TestCase.runTest",
          "source": "TestCase.java:154"
        },
        {
          "method": "junit.framework.TestCase.runBare",
          "source": "TestCase.java:127"
        },
        {
          "method": "junit.framework.TestResult$1.protect",
          "source": "TestResult.java:106"
        },
        {
          "method": "junit.framework.TestResult.runProtected",
          "source": "TestResult.java:124"
        },
        {
          "method": "junit.framework.TestResult.run",
          "source": "TestResult.java:109"
        },
        {
          "method": "junit.framework.TestCase.run",
          "source": "TestCase.java:118"
        },
        {
          "method": "junit.framework.TestSuite.runTest",
          "source": "TestSuite.java:208"
        },
        {
          "method": "junit.framework.TestSuite.run",
          "source": "TestSuite.java:203"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run",
          "source": "JUnit3TestReference.java:128"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.TestExecution.run",
          "source": "TestExecution.java:38"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:460"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:673"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run",
          "source": "RemoteTestRunner.java:386"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main",
          "source": "RemotePluginTestRunner.java:58"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.UITestApplication$1.run",
          "source": "UITestApplication.java:105"
        },
        {
          "method": "org.eclipse.swt.widgets.RunnableLock.run",
          "source": "RunnableLock.java:35"
        },
        {
          "method": "org.eclipse.swt.widgets.Synchronizer.runAsyncMessages",
          "source": "Synchronizer.java:123"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runAsyncMessages",
          "source": "Display.java:3367"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:3012"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1914"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1878"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:419"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:149"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:95"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.UITestApplication.run",
          "source": "UITestApplication.java:45"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:78"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication",
          "source": "EclipseAppLauncher.java:104"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start",
          "source": "EclipseAppLauncher.java:74"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:348"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:165"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:324"
        },
        {
          "method": "org.eclipse.core.launcher.Main.invokeFramework",
          "source": "Main.java:341"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:285"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:987"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:962"
        }
      ],
      "number": 0,
      "commentIndex": 7,
      "bugId": "156775",
      "date": "2006-09-20T22:20:15+02:00",
      "product": "Platform",
      "component": "UI",
      "severity": "enhancement"
    }
  ],
  "groupId": "156775",
  "bugId": "156775",
  "date": "2006-09-09T00:13:59+02:00",
  "product": "Platform",
  "component": "UI",
  "severity": "enhancement"
}