{
  "comments": [
    "In my own language, I do this:\n\n1) Right click on a var in the Variables view, choose Watch\n2) Switch to the Expressions view, keep STEP\u0027ing until the program ends\n3) My Watched var is still listed, even though I have called\nDebugPlugin.getDefault().getExpressionManager().removeExpression(variable);\n4) If I switch to the Variables view and then back, then the Watch is no \nlonger listed, indicating that a refresh event is not being generated for the \nlast removed Watch\n\n\nI debugged the code and this code does get called in \nExpressionmanager.removeExpressions:\n\n\t\tif (!removed.isEmpty()) {\n\t\t\tfireUpdate((IExpression[])removed.toArray(new \nIExpression[removed.size()]), REMOVED);\n\t\t}\n\nSo, the event is being fired, but somehow the View is not refreshing. If I \ninsert a breakpoint in the firing above, the simple fact of switching from one \nEclipse (development) to the other (runtime) as I debug is enough to make \nthings work again, as a refresh is forced on the widget (due to the window \noverlapping switches).\n\nI tried to see if JDT had the same problem but it leaves the expressions \naround after a program finishes (not my case) so it is not a good test case, \nit would not test for this bug.",
    "A java \"inspected expression\" removes itself when a debug target complete - and \nthis works. For example, suspend a java program and inspect something \nlike \"System.out\". Resume the program to exit - the inspected expression \ndissappears.",
    "My watched variable has subitems (it is an array), and I noticed that if I \ncollapse the variable ( +foo ) in the Expressions view and have it selected as \nI SETP to program end, I get this in the log:\n\njava.lang.IllegalArgumentException: Argument not valid\n\tat org.eclipse.swt.SWT.error(SWT.java:2318)\n\tat org.eclipse.swt.SWT.error(SWT.java:2262)\n\tat org.eclipse.swt.widgets.Widget.error(Widget.java:385)\n\tat org.eclipse.swt.widgets.Tree.setSelection(Tree.java:1013)\n\tat org.eclipse.jface.viewers.TreeViewer.setSelection\n(TreeViewer.java:226)\n\tat org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget\n(AbstractTreeViewer.java:1261)\n\tat org.eclipse.jface.viewers.StructuredViewer.setSelectionToWidget\n(StructuredViewer.java:1053)\n\tat org.eclipse.jface.viewers.StructuredViewer.preservingSelection\n(StructuredViewer.java:808)\n\tat org.eclipse.jface.viewers.AbstractTreeViewer.remove\n(AbstractTreeViewer.java:1084)\n\tat org.eclipse.jface.viewers.AbstractTreeViewer.remove\n(AbstractTreeViewer.java:1104)\n\tat org.eclipse.debug.internal.ui.views.AbstractDebugEventHandler.remove\n(AbstractDebugEventHandler.java:116)\n\tat \norg.eclipse.debug.internal.ui.views.expression.ExpressionViewEventHandler.acces\ns$4(ExpressionViewEventHandler.java:1)\n\tat \norg.eclipse.debug.internal.ui.views.expression.ExpressionViewEventHandler$2.run\n(ExpressionViewEventHandler.java:84)\n\tat org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)\n\tat org.eclipse.swt.widgets.Synchronizer.runAsyncMessages\n(Synchronizer.java:98)\n\tat org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1815)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)\n\tat org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)\n\tat org.eclipse.core.internal.boot.InternalBootLoader.run\n(InternalBootLoader.java:845)\n\tat org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke\n(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke\n(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:291)\n\tat org.eclipse.core.launcher.Main.run(Main.java:747)\n\tat org.eclipse.core.launcher.Main.main(Main.java:583)\n\n\n",
    "True that inspecting System.out does remove it at program completion. The \ninteresting, however, is that removeExpressions() is not called in this case \n(I have a breakpoint there). So, the mechanism it is using is not the same as \nthe one I am using. Interesting. I wonder what they use, and how come that \nworks. But regardless, I believe the mechanism I am using should work. The \nexception log is also strange.",
    "Generating a Debug.CHANGED event when my var changes seems to have fixed the \nview refresh problem. Weird, but...\n\nAfter implementing equals/hashCode properly for my IVariables and IValues I was \nno longer able to see the exception trace happen, regardless if my var is \nexpanded or collapsed.\n\nI will keep testing, to see if the problem is really gone.",
    "This looks like a tree viewer exception that may have been caused by your \nequals/hashcode implementation.\n\n\nMarking as \"works for me\"."
  ],
  "commentCreationDates": [
    "2003-04-16T20:53:59+02:00",
    "2003-04-16T21:01:52+02:00",
    "2003-04-16T21:13:44+02:00",
    "2003-04-16T21:54:28+02:00",
    "2003-04-16T23:33:06+02:00",
    "2003-04-21T20:30:31+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.IllegalArgumentException",
      "message": "Argument not valid",
      "elements": [
        {
          "method": "org.eclipse.swt.SWT.error",
          "source": "SWT.java:2318"
        },
        {
          "method": "org.eclipse.swt.SWT.error",
          "source": "SWT.java:2262"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.error",
          "source": "Widget.java:385"
        },
        {
          "method": "org.eclipse.swt.widgets.Tree.setSelection",
          "source": "Tree.java:1013"
        },
        {
          "method": "org.eclipse.jface.viewers.TreeViewer.setSelection",
          "source": "TreeViewer.java:226"
        },
        {
          "method": "org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget",
          "source": "AbstractTreeViewer.java:1261"
        },
        {
          "method": "org.eclipse.jface.viewers.StructuredViewer.setSelectionToWidget",
          "source": "StructuredViewer.java:1053"
        },
        {
          "method": "org.eclipse.jface.viewers.StructuredViewer.preservingSelection",
          "source": "StructuredViewer.java:808"
        },
        {
          "method": "org.eclipse.jface.viewers.AbstractTreeViewer.remove",
          "source": "AbstractTreeViewer.java:1084"
        },
        {
          "method": "org.eclipse.jface.viewers.AbstractTreeViewer.remove",
          "source": "AbstractTreeViewer.java:1104"
        },
        {
          "method": "org.eclipse.debug.internal.ui.views.AbstractDebugEventHandler.remove",
          "source": "AbstractDebugEventHandler.java:116"
        },
        {
          "method": "org.eclipse.debug.internal.ui.views.expression.ExpressionViewEventHandler.access$4",
          "source": "ExpressionViewEventHandler.java:1"
        },
        {
          "method": "org.eclipse.debug.internal.ui.views.expression.ExpressionViewEventHandler$2.run",
          "source": "ExpressionViewEventHandler.java:84"
        },
        {
          "method": "org.eclipse.swt.widgets.RunnableLock.run",
          "source": "RunnableLock.java:35"
        },
        {
          "method": "org.eclipse.swt.widgets.Synchronizer.runAsyncMessages",
          "source": "Synchronizer.java:98"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runAsyncMessages",
          "source": "Display.java:1815"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:1549"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1402"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.run",
          "source": "Workbench.java:1385"
        },
        {
          "method": "org.eclipse.core.internal.boot.InternalBootLoader.run",
          "source": "InternalBootLoader.java:845"
        },
        {
          "method": "org.eclipse.core.boot.BootLoader.run",
          "source": "BootLoader.java:461"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:324"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:291"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:747"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:583"
        }
      ],
      "number": 0,
      "commentIndex": 2,
      "bugId": "36592",
      "date": "2003-04-16T21:13:44+02:00",
      "product": "Platform",
      "component": "Debug",
      "severity": "normal"
    }
  ],
  "groupId": "36592",
  "bugId": "36592",
  "date": "2003-04-16T20:53:59+02:00",
  "product": "Platform",
  "component": "Debug",
  "severity": "normal"
}