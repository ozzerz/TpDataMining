{
  "comments": [
    "Created an attachment (id\u003d77997)\nPatch\n\nBuild ID: M20070212-1330\n\nSteps To Reproduce:\nSee discussion below.\n\n\nMore information:\nI am a performance analyst for an adopting product. We are seeing large performance regressions (from the 3.0 release) when importing an old PI and performing a build that creates EJB/Web/App projects. At the end of the build, it seems to hang at 99% (and even after there is no progress bar).\n\nProfiling/sampling reveal that about 34% of the time is spend in the following callstack:\n\n00000ea8_Worker-27_pidtid\norg/eclipse/core/internal/jobs/Worker.run()V\norg/eclipse/jst/j2ee/internal/common/classpath/J2EEComponentClasspathUpdater$ModuleUpdateJob.run(Lorg/eclipse/core/runtime/IProgressMonitor;)Lorg/eclipse/core/runtime/IStatus;\norg/eclipse/core/runtime/SafeRunner.run(Lorg/eclipse/core/runtime/ISafeRunnable;)V\norg/eclipse/jst/j2ee/internal/common/classpath/J2EEComponentClasspathUpdater$1.run()V\norg/eclipse/jst/j2ee/internal/common/classpath/J2EEComponentClasspathUpdater$ModuleUpdateJob.access$1(Lorg/eclipse/jst/j2ee/internal/common/classpath/J2EEComponentClasspathUpdater$ModuleUpdateJob;)V\norg/eclipse/jst/j2ee/internal/common/classpath/J2EEComponentClasspathUpdater$ModuleUpdateJob.processModules()V\norg/eclipse/jst/j2ee/internal/common/classpath/J2EEComponentClasspathContainer.refresh(Z)V\norg/eclipse/wst/common/componentcore/internal/builder/DependencyGraphManager.forceRefresh()V\norg/eclipse/wst/common/componentcore/internal/builder/DependencyGraphManager.buildDependencyGraph()V\n\nThis is caused by the fact that in \n\n    ...$ModuleUpdateJob.processModules()\n\nif the job was scheduled (updateDependencyGraph is true), then the DependencyGraphManager.forceRefresh call is made for each J2EEComponentClasspathContainer (module) that is refreshed. I implemented a small hack to change updateDependencyGraph to false until the processModules loop is finished.\n\nAnother problem was that concurrent threads were accessing DependencyGraphManager.getDependencyGraph(). Since this method is not synchronized, the graph was getting rebuilt for each request. At least this method, if not all the public methods in DependencyGraphManager, should be made \"synchronized\".\n\nAfter these two fixes, time spent in DependencyGraphManager.buildDependencyGraph was only about 2% of build time (instead of 34%).",
    "Jason Can you evaluate these patches? ",
    "To help me understand the stated severity of this bug report, can you explain the impact in terms of \"what the user sees\"? In other words, you say \n\"At the end of the build,\nit seems to hang at 99% (and even after there is no progress bar).\" \nHow long does it do that for? How much longer than before? \n\nAnd while 34% to 2% is good (assuming correct fix) I\u0027m wondering if that completely fixes the issue? Or, for example, does it take a 9 minute task down to 6 minutes? Or ... what? \n\nMuch thanks for the extra information. \n\n",
    "With my proposed change, in our scenario, we see about a 1000 sec reduction in the first build time (about 50% reduction). When we were on an Eclipse 3.0 base, we had the entire first build down to about 700 s... We are still working through other regressions since stepping up to Eclipse 3.2.\n\n\n",
    "ok, thanks. While we don\u0027t have a completely documented process yet, part of it will be to add \"requestPatch\" in the status whiteboard, so I\u0027ve done that here. \n\nIf accepted, then, there\u0027d eventually be a patch available on \nhttp://download.eclipse.org/webtools/patches/\n\nBut, we need to be very careful not to get too many of those, so I\u0027d like to be sure we sort of know \"whole list\" before deciding any particular one of them. \n\nThanks. \n\n",
    "The dependency graph manager is a well known performance bottle neck.  These\npatches; are you proposing them for 1.5.x, 2.x, or for 3.0?  I ask because one of the solutions we are considering for 3.0 is to rewrite the dependency graph manager completely so it incrementally updates with each change rather than rebuilding the graph completely with each change.  This would reduce the performance from a function to the size of the workspace to a function of the size of the change, which most typically is 1.",
    "That would be a great improvement, one I thought about recommending myself. Unfortunately, we need a patch for 1.5.\n",
    "This is a stop-ship issue for our product. As directed by my team lead, I am upping the severity.\n",
    "I checked the latest CVS streams and it appears that this is still an issue. We would like this to get into the earliest possible live stream (Eclipse 3.3.x) as well as the latest (Eclipse 3.4). If the changes could also be backported to Eclipse 3.2.2 and a patch provided, that would be great. However, we realize that Eclipse 3.2.2 is not live and that we\u0027d own any changes requested on that stream through patches.\n\n\n",
    "Hey Randall, I tried to apply the patch to the R1_5_maintenance stream, and this patch file isn\u0027t applying properly.  Could you supply another patch file?",
    "Created an attachment (id\u003d79155)\nFixed patch\n\nI had custom project names in the previous patch.\n\n\n",
    "I\u0027m worried about the addition of the synchronized methods.  If you look at the change history, for DependencyGraphManager, version 1.8, these synchronized methods would be effectively undoing the changes that went in for bug 147878.\n\nThe remainder of your patch seems safe.  Could you please try rerunning your scenario without the synchronized methods?",
    "My trace showed that a lot of extra time was spent building the dependency graph in parallel for multiple requests. My patch is not the only way to fix that.\n\nHowever, the bulk of time is a result of the problems in J2EEComponentClasspathUpdater that my patch shows one way to get around. So if I had to choose, I\u0027d prefer the changes to this class. However, the fact that DependencyGraphManager works on the same instance among potentially multiple parallel threads concurrently is very concerning.\n",
    "Thanks for the update.  Yes, I agree that there should be better syncrhonization with the DependnecyGraphManager, however, considering past deadlocks I can\u0027t recommend we add the syncrhonization stamps at this time.  Otherwise, I agree with  your patch.",
    "Without the synchronized methods, I get a lot (10 for this scenario) of the following messages in the console log:\n\n*** ERROR ***: Wed Sep 26 12:16:24 CDT 2007    org.eclipse.wst.common.internal.emfworkbench.edit.ClientAccessRegistryException: IWAE0011E Key already used to access Resource : org.eclipse.wst.common.internal.emfworkbench.EditModelLeastUsedCache@3b583b58\n    This exception was generated to indicate an invalid usage of reference counts.\n     Typically, this occurs on attempts to open an already open artifact edit.\n     Make sure the dispose method is called when done accessing.\n     Please examine the stack trace.\n     Client Access Exception of type INVALID_ACCESS_KEY \n    org.eclipse.wst.common.internal.emfworkbench.edit.ClientAccessRegistryException: IWAE0011E Key already used to access Resource : org.eclipse.wst.common.internal.emfworkbench.EditModelLeastUsedCache@3b583b58\n    This exception was generated to indicate an invalid usage of reference counts.\n     Typically, this occurs on attempts to open an already open artifact edit.\n     Make sure the dispose method is called when done accessing.\n     Please examine the stack trace.\n     Client Access Exception of type INVALID_ACCESS_KEY \n    \tat org.eclipse.wst.common.internal.emfworkbench.edit.ReadOnlyClientAccessRegistry.access(ReadOnlyClientAccessRegistry.java:32)\n    \tat org.eclipse.wst.common.internal.emfworkbench.integration.EditModel.access(EditModel.java:944)\n    \tat org.eclipse.wst.common.internal.emfworkbench.EditModelLeastUsedCache.access(EditModelLeastUsedCache.java:78)\n    \tat org.eclipse.wst.common.internal.emfworkbench.EMFWorkbenchContext.getEditModelForRead(EMFWorkbenchContext.java:144)\n    \tat org.eclipse.wst.common.internal.emfworkbench.integration.EditModelNature.getEditModelForRead(EditModelNature.java:49)\n    \tat org.eclipse.wst.common.internal.emfworkbench.integration.EditModelNature.getEditModelForRead(EditModelNature.java:39)\n    \tat org.eclipse.wst.common.componentcore.ModuleCoreNature.getModuleStructuralModelForRead(ModuleCoreNature.java:241)\n    \tat org.eclipse.wst.common.componentcore.internal.StructureEdit.\u003cinit\u003e(StructureEdit.java:320)\n    \tat org.eclipse.wst.common.componentcore.internal.StructureEdit.getStructureEditForRead(StructureEdit.java:119)\n    \tat org.eclipse.wst.common.componentcore.internal.resources.VirtualComponent.getMetaResources(VirtualComponent.java:207)\n    \tat org.eclipse.wst.common.componentcore.internal.resources.VirtualContainer.members(VirtualContainer.java:159)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualRootFolder.superMembers(EARVirtualRootFolder.java:29)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualRootFolder.superMembers(EARVirtualRootFolder.java:25)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences(EARVirtualComponent.java:160)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences(EARVirtualComponent.java:184)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences(EARVirtualComponent.java:184)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences(EARVirtualComponent.java:184)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences(EARVirtualComponent.java:184)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences(EARVirtualComponent.java:184)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences(EARVirtualComponent.java:184)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences(EARVirtualComponent.java:184)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences(EARVirtualComponent.java:154)\n    \tat org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getReferences(EARVirtualComponent.java:200)\n    \tat org.eclipse.jst.j2ee.componentcore.J2EEModuleVirtualComponent.getManifestReferences(J2EEModuleVirtualComponent.java:152)\n    \tat org.eclipse.jst.j2ee.componentcore.J2EEModuleVirtualComponent.getReferences(J2EEModuleVirtualComponent.java:70)\n    \tat org.eclipse.wst.common.componentcore.internal.builder.DependencyGraphManager.getDependencyReferences(DependencyGraphManager.java:200)\n    \tat org.eclipse.wst.common.componentcore.internal.builder.DependencyGraphManager.buildDependencyGraph(DependencyGraphManager.java:176)\n    \tat org.eclipse.wst.common.componentcore.internal.builder.DependencyGraphManager.constructIfNecessary(DependencyGraphManager.java:77)\n    \tat org.eclipse.wst.common.componentcore.internal.builder.DependencyGraphManager.getDependencyGraph(DependencyGraphManager.java:252)\n    \tat org.eclipse.wst.common.componentcore.internal.resources.VirtualComponent.getReferencingComponents(VirtualComponent.java:428)\n    \tat org.eclipse.jst.j2ee.internal.project.J2EEProjectUtilities.getReferencingEARProjects(J2EEProjectUtilities.java:651)\n    \tat com.ibm.ast.ws.ext.validator.WsExtValidator.validateIbmWebServicesBndXmi(WsExtValidator.java:329)\n    \tat com.ibm.ast.ws.ext.validator.WsExtValidator.validateUsingUris(WsExtValidator.java:232)\n    \tat com.ibm.ast.ws.ext.validator.WsExtValidator.validate(WsExtValidator.java:196)\n    \tat com.ibm.ast.ws.ext.validator.WsExtValidator.validateInJob(WsExtValidator.java:173)\n    \tat org.eclipse.wst.validation.internal.operations.ValidatorJob.run(ValidatorJob.java:70)\n    \tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)\n\nThis is mainly what scares me, not the increased time spent in the method.\n",
    "(In reply to comment #14)\nRandall,\nthough not familiar with the WST code at hand, it sounds like you are confronted to a concurrent access issue.\nThe ClientAccessRegistryException is thrown by the synchronized method ReadOnlyClientAccessRegistry#access(Object accessorKey),\nwhen not finding the given accessorKey.",
    "(In reply to comment #14)\nI\u0027m also concerned about this.\n\nRemoving synchronization to prevent deadlocks can\u0027t be the right answer. It is way better to get a deadlock than a random, mostly unreproducible problem, caused by code that isn\u0027t threadsafe.  \n\nFixing it by locking things in the right order is the only answer.  ",
    "FYI - We are another adopter, we are running some tests as well to help quantity the benefit of this patch. We hope to post the results within a day or so.",
    "(In reply to comment #14)\n\nIt seems like this is triggered because there is a cache that holds onto models (up to 10 of them) and it uses it\u0027s singleton key to request access.\n\nIt looks like the cache is evicting models, before the clients are finished with them. Another client comes in, the cache doesn\u0027t think it has a model, and it tries to get another model with it\u0027s key. This triggers the exception.\n\nI think the cache needs to be smarter and check to see if the model has been released before it evicts in completely.\n\n\n",
    "Created an attachment (id\u003d79576)\npossible patch for ClientAcessRegistryException\n\nRandall, I would be curious to know if this patch fixes the ClientAcessRegistryException\u0027s that you were seeing. ",
    "Created an attachment (id\u003d79653)\npatch that doesn\u0027t use java 5\n\nSame patch except I removed the Java 5 changes (I didn\u0027t realize that WTP 1.5.5 was still on Java 1.4)",
    "Created an attachment (id\u003d79655)\nClient Registry Patch\n\nIt would help if I uploaded the right file :-)\n\nThis is a patch to make the synchronization block a bit bigger, to protect against the case of the collection being updated, but the model not yet being accessed or released.",
    "Created an attachment (id\u003d79805)\nRevised patch\n\nJust to be clear, I believe we are considering the changes in the Classpath Updater and Container to prevent excessive rebuilds of the graph.  Not introducing any serialization blocks at this time",
    "Created an attachment (id\u003d79819)\ncombined patch with bug 204287\n\nTo be redundant, because bug 204287 touches one of the same classes as this bug, \nI\u0027m attaching a patch file that shows 202820 and 204287 combined. \n",
    "Hmmm, this needs some more work. \n\nAfter applying the combined fixes, 16 of our JUnit\u0027s failed. \nSee \nhttp://download.eclipse.org/webtools/patches/drops/R1.5/P-P20071005155534-20071005155534/",
    "yes, this does need some more work.  those failures are directly related to the classpath not being updated properly.",
    "I assume that the unit tests were run against the patch as combined with 204287. Let\u0027s first narrow done which patch is causing the failures. Also, do you guys have a hunch as to what might be going wrong? As I don\u0027 have access to he unit tests, I\u0027m not sure how I can help out here.\n",
    "My guess is it is the portion from this bug and not the portion from bug 204287.  I\u0027ll try running the tests locally to see what happens.",
    "(In reply to comment #27)\n\u003e My guess is it is the portion from this bug and not the portion from bug\n\u003e 204287.  I\u0027ll try running the tests locally to see what happens.\n\u003e \n\nThat was my assumption too, so I backed out both, and re-applied the patch \nfrom bug 204287 ... and I was surprised there were still 16 failures. \nhttp://download.eclipse.org/webtools/patches/drops/R1.5/P-P20071005190333-20071005190333/\n\nI would have thought Chuck or Jason would have ran these test locally first? \nI\u0027ll continue to back out, to confirm I haven\u0027t messed up something. \n\n\n",
    "(In reply to comment #28)\n\u003e (In reply to comment #27)\n\u003e[...]\n\u003e \n\u003e That was my assumption too, so I backed out both, and re-applied the patch \n\u003e from bug 204287 ... and I was surprised there were still 16 failures. \n\u003e \n\u003e[...]\n\nThe tests ran fine when I backed out all changes, so have attached the failing JUnit summaries to bug 204287. \n\n",
    "Created an attachment (id\u003d79837)\nthread dump during JUnit test hang\n\n\nI applied (only) the patch for this bug and in the first attempt one of the JUnit Suites hung. I do not know if the hang was related to this patch per se, or if it\u0027s one of the occasional hangs we see from time to time ... but, I will attach the thread dumps I took, so they are recorded here as another piece of data. \n",
    "Created an attachment (id\u003d79838)\nsecond thread dump taken a few seconds later\n\n",
    "(In reply to comment #30)\n\u003e Created an attachment (id\u003d79837) [details]\n\u003e [...] and in the first attempt one of the\n\u003e JUnit Suites hung. ...\n\nSubsequent runs did not hang, so will assume for now the hangs were unrelated to this patch and are simply the ones we see occasionally. \n\nI have opened bug 205642 to capture the information there. \n\n\n\n",
    "(From update of attachment 79837)\nmoved to  bug 205642",
    "(From update of attachment 79838)\nmoved to bug 205642",
    "(From update of attachment 79819)\nnot a good idea!",
    "(In reply to comment #32)\nFYI - I looked through the thread dump. The cause of the deadlock was the JSPIndexManager. It triggered a bunch of classpath stuff, including trying to set the classpath. Setting the classpath required a lock on a project, which was held by some validator jobs, which were waiting for the JSPIndexmanager to release the lock created by this line:\n\nat org/eclipse/jst/jsp/core/internal/java/JSPTranslation.createCompilationUnit(JSPTranslation.java:458)\n\nI don\u0027t think this is related to the patch ... but I don\u0027t know for sure.",
    "patch committed to R1_5_5_patches branch and \nis available in patch builds \u003e P20071009162612\n\nBe sure any followup work for R2.0.2 or R3.0.0 is complete (or, a new bug open to address in those streams). \n\n",
    "When I first investigated this defect, it appeared that the same problem existed in the 2.0 and 3.0 branches. How can I make sure that this change gets put into those branches?\n",
    "Created an attachment (id\u003d80284)\nPatch for 202 \u0026 30\n\nThis is the same patch as 79805 but for the 202 and 30 streams.",
    "this has been checked into both 202 and 30 streams."
  ],
  "commentCreationDates": [
    "2007-09-10T18:43:53+02:00",
    "2007-09-10T18:57:57+02:00",
    "2007-09-13T16:08:07+02:00",
    "2007-09-13T16:16:48+02:00",
    "2007-09-13T16:29:13+02:00",
    "2007-09-13T16:35:18+02:00",
    "2007-09-13T16:47:34+02:00",
    "2007-09-18T21:34:21+02:00",
    "2007-09-25T16:50:30+02:00",
    "2007-09-25T19:29:33+02:00",
    "2007-09-25T20:12:57+02:00",
    "2007-09-25T23:20:05+02:00",
    "2007-09-26T00:11:52+02:00",
    "2007-09-26T07:55:46+02:00",
    "2007-09-26T19:28:38+02:00",
    "2007-09-26T20:37:08+02:00",
    "2007-10-01T16:05:15+02:00",
    "2007-10-01T16:06:40+02:00",
    "2007-10-02T20:50:06+02:00",
    "2007-10-02T21:36:13+02:00",
    "2007-10-03T18:25:49+02:00",
    "2007-10-03T18:37:47+02:00",
    "2007-10-05T16:01:16+02:00",
    "2007-10-05T17:52:28+02:00",
    "2007-10-05T18:40:48+02:00",
    "2007-10-05T19:23:36+02:00",
    "2007-10-05T21:03:34+02:00",
    "2007-10-05T21:24:09+02:00",
    "2007-10-05T21:35:45+02:00",
    "2007-10-06T01:54:10+02:00",
    "2007-10-06T02:21:09+02:00",
    "2007-10-06T02:22:26+02:00",
    "2007-10-06T20:17:56+02:00",
    "2007-10-06T20:20:18+02:00",
    "2007-10-06T20:20:57+02:00",
    "2007-10-06T20:22:27+02:00",
    "2007-10-08T14:44:37+02:00",
    "2007-10-10T02:38:01+02:00",
    "2007-10-10T20:17:15+02:00",
    "2007-10-12T22:54:12+02:00",
    "2007-10-12T22:56:51+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.wst.common.internal.emfworkbench.edit.ClientAccessRegistryException",
      "message": "IWAE0011E Key already used to access Resource : org.eclipse.wst.common.internal.emfworkbench.EditModelLeastUsedCache@3b583b58     This exception was generated to indicate an invalid usage of reference counts.      Typically, this occurs on attempts to open an already open artifact edit.      Make sure the dispose method is called when done accessing.      Please examine the stack trace.      Client Access Exception of type INVALID_ACCESS_KEY",
      "elements": [
        {
          "method": "org.eclipse.wst.common.internal.emfworkbench.edit.ReadOnlyClientAccessRegistry.access",
          "source": "ReadOnlyClientAccessRegistry.java:32"
        },
        {
          "method": "org.eclipse.wst.common.internal.emfworkbench.integration.EditModel.access",
          "source": "EditModel.java:944"
        },
        {
          "method": "org.eclipse.wst.common.internal.emfworkbench.EditModelLeastUsedCache.access",
          "source": "EditModelLeastUsedCache.java:78"
        },
        {
          "method": "org.eclipse.wst.common.internal.emfworkbench.EMFWorkbenchContext.getEditModelForRead",
          "source": "EMFWorkbenchContext.java:144"
        },
        {
          "method": "org.eclipse.wst.common.internal.emfworkbench.integration.EditModelNature.getEditModelForRead",
          "source": "EditModelNature.java:49"
        },
        {
          "method": "org.eclipse.wst.common.internal.emfworkbench.integration.EditModelNature.getEditModelForRead",
          "source": "EditModelNature.java:39"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.ModuleCoreNature.getModuleStructuralModelForRead",
          "source": "ModuleCoreNature.java:241"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.StructureEdit.\u003cinit\u003e",
          "source": "StructureEdit.java:320"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.StructureEdit.getStructureEditForRead",
          "source": "StructureEdit.java:119"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.resources.VirtualComponent.getMetaResources",
          "source": "VirtualComponent.java:207"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.resources.VirtualContainer.members",
          "source": "VirtualContainer.java:159"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualRootFolder.superMembers",
          "source": "EARVirtualRootFolder.java:29"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualRootFolder.superMembers",
          "source": "EARVirtualRootFolder.java:25"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences",
          "source": "EARVirtualComponent.java:160"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences",
          "source": "EARVirtualComponent.java:184"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences",
          "source": "EARVirtualComponent.java:184"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences",
          "source": "EARVirtualComponent.java:184"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences",
          "source": "EARVirtualComponent.java:184"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences",
          "source": "EARVirtualComponent.java:184"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences",
          "source": "EARVirtualComponent.java:184"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences",
          "source": "EARVirtualComponent.java:184"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getLooseArchiveReferences",
          "source": "EARVirtualComponent.java:154"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.util.EARVirtualComponent.getReferences",
          "source": "EARVirtualComponent.java:200"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.J2EEModuleVirtualComponent.getManifestReferences",
          "source": "J2EEModuleVirtualComponent.java:152"
        },
        {
          "method": "org.eclipse.jst.j2ee.componentcore.J2EEModuleVirtualComponent.getReferences",
          "source": "J2EEModuleVirtualComponent.java:70"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.builder.DependencyGraphManager.getDependencyReferences",
          "source": "DependencyGraphManager.java:200"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.builder.DependencyGraphManager.buildDependencyGraph",
          "source": "DependencyGraphManager.java:176"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.builder.DependencyGraphManager.constructIfNecessary",
          "source": "DependencyGraphManager.java:77"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.builder.DependencyGraphManager.getDependencyGraph",
          "source": "DependencyGraphManager.java:252"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.resources.VirtualComponent.getReferencingComponents",
          "source": "VirtualComponent.java:428"
        },
        {
          "method": "org.eclipse.jst.j2ee.internal.project.J2EEProjectUtilities.getReferencingEARProjects",
          "source": "J2EEProjectUtilities.java:651"
        },
        {
          "method": "com.ibm.ast.ws.ext.validator.WsExtValidator.validateIbmWebServicesBndXmi",
          "source": "WsExtValidator.java:329"
        },
        {
          "method": "com.ibm.ast.ws.ext.validator.WsExtValidator.validateUsingUris",
          "source": "WsExtValidator.java:232"
        },
        {
          "method": "com.ibm.ast.ws.ext.validator.WsExtValidator.validate",
          "source": "WsExtValidator.java:196"
        },
        {
          "method": "com.ibm.ast.ws.ext.validator.WsExtValidator.validateInJob",
          "source": "WsExtValidator.java:173"
        },
        {
          "method": "org.eclipse.wst.validation.internal.operations.ValidatorJob.run",
          "source": "ValidatorJob.java:70"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 0,
      "commentIndex": 14,
      "bugId": "202820",
      "date": "2007-09-26T19:28:38+02:00",
      "product": "Web Tools",
      "component": "J2EE Standard Tools",
      "severity": "critical"
    }
  ],
  "groupId": "202820",
  "bugId": "202820",
  "date": "2007-09-10T18:43:53+02:00",
  "product": "Web Tools",
  "component": "J2EE Standard Tools",
  "severity": "critical"
}