{
  "comments": [
    "After compiling the attached source file and class file with\n\najc -inpath . -outjar t.jar Tracer.aj\n\n(on any of 1.2.1, 1.5.0M2 or the June 2005 snapshot) and then attempting to run\nit with\n\ngij -classpath ./t.jar:$CLASSPATH Test\n\nthe following error is obtained:\n\nException in thread \"main\" java.lang.VerifyError: verification failed at PC 1 in\nTest:newTest_aroundBody2((I)LTest;): branch out of range\n   at java.lang.VMClassLoader.resolveClass(java.lang.Class)\n(/usr/lib/libgcj.so.6.0.0)\n   at java.lang.Class.initializeClass() (/usr/lib/libgcj.so.6.0.0)\n   at java.lang.Class.forName(java.lang.String, boolean, java.lang.ClassLoader)\n(/usr/lib/libgcj.so.6.0.0)\n   at gnu.java.lang.MainThread.run() (/usr/lib/libgcj.so.6.0.0)\n\nAn excerpt from the output of\n\njavap -private -classpath t.jar -c Test\n\nshows that the generated switch is indeed bogus:\n\nprivate static final Test newTest_aroundBody2(int);\n  Code:\n   0:   iload_0\n   1:   tableswitch{ //0 to 0\n                0: -1157627302;\n                default: 16 }\n   20:  invokespecial   #3; //Method \"\u003cinit\u003e\":()V\n   23:  areturn",
    "Created an attachment (id\u003d25148)\nClass file to be weaved\n",
    "Created an attachment (id\u003d25149)\nAspect\n",
    "Moving to P1 as any verify error is bad...",
    "Sorry its taken a while to get to this ... darn generics has slowed us down so much.\n\nI assume you used javac or something to build Test.java before using ajc to\nbinary weave it?\n\nWhat I\u0027m doing to recreate is:\n\njavac -d outputfolder Test.java\najc -inpath outputfolder Tracer.aj\njava Test\n\nand I get:\n\nException in thread \"main\" java.lang.VerifyError: (class: Test, method:\nnewTest_aroundBody2 signature: (I)LTest;) Illegal default target in switch\n\ndisassembling that method:\n\nprivate static final Test newTest_aroundBody2(int);\n  Code:\n   Stack\u003d2, Locals\u003d1, Args_size\u003d1\n   0:\tiload_0\n   1:\ttableswitch{ //0 to 0\n\t\t0: -1157627302;\n\t\tdefault: 16 }\n   20:\tinvokespecial\t#3; //Method \"\u003cinit\u003e\":()V\n   23:\tareturn\n  LineNumberTable: \n   line 16: 0\n   line 19: 16\n\nbefore any advice got tangled up in things, the newTest() method looked like this:\n\npublic static Test newTest(int);\n  Code:\n   Stack\u003d2, Locals\u003d1, Args_size\u003d1\n   0:\tiload_0\n   1:\tlookupswitch{ //0\n\t\tdefault: 12 }\n   12:\tnew\t#2; //class Test\n   15:\tdup\n   16:\tinvokespecial\t#3; //Method \"\u003cinit\u003e\":()V\n   19:\tareturn\n  LineNumberTable: \n   line 16: 0\n   line 19: 12\n\nIf I compile it all together with ajc:\n\najc Test.java Tracer.aj \n\nthen the result works - it seems that the switch statement is optimized away\nbecause it only has a default entry.  I will take a quick look at tableswitch\nbut I don\u0027t think this will be fixed for M3.",
    "I\u0027ve reduced the testcase to something simpler.  Here is the test class:\n\npublic class Test {\n\n    public static Test newTest(int i) {\n        switch(i) {\n          default: return null;\n        }\n    }\n}\n\nand here is the aspect:\n\naspect Tracer {\n  Object around (): execution(* newTest(..)) { return proceed();}\n}\n\nIf you follow the steps I outlined earlier, this also blows up.  I tried\nmodifying the switch to include an entry:\n\n    public static Test newTest(int i) {\n        switch(i) {\n          case 1:  return null;\n          default: return null;\n        }\n    }\n\nso that I could just compile entirely with ajc but that works fine, the\naroundbody in the result looks like:\n\nprivate static final Test newTest_aroundBody0(int);\n  Code:\n   Stack\u003d1, Locals\u003d1, Args_size\u003d1\n   0:   iload_0\n   1:   tableswitch{ //1 to 1\n                1: 20;\n                default: 22 }\n   20:  aconst_null\n   21:  areturn\n   22:  aconst_null\n   23:  areturn\n  LineNumberTable:\n   line 10: 0\n   line 11: 20\n   line 12: 22\n\nstarting to suspect BCEL more and more...",
    "Ok... BCEL bug.  The problem occurs when we perform \u0027extractInstructions\u0027 for\ncreating the body of the around advice.  In order to do that we use a routine\ncalled \u0027copyInstruction\u0027.\n\nIf you look in the code generated by the javac run, it looks like this:\n\npublic static Test newTest(int);\n  Code:\n   Stack\u003d1, Locals\u003d1, Args_size\u003d1\n   0:   iload_0\n   1:   lookupswitch{ //0\n                default: 12 }\n   12:  aconst_null\n   13:  areturn\n  LineNumberTable:\n   line 4: 0\n   line 5: 12\n\nNotice that a lookupswitch has been used.  The copyinstruction() routine copies\na select (like lookupswitch) by just building a new \u0027SELECT\u0027 object and letting\nBCEL work out the best way to represent the select based on the number of\ntargets in the select.  BCEL thinks its better to represent a select with no\ntargets (the case we have here) with a TABLESWITCH rather than LOOKUPSWITCH.\n\nHowever, thats wrong - and there are two bugs lurking.  My first fix is to say\nif there are no targets then use a LOOKUPSWITCH - my around body now looks like\nthis:\n\nprivate static final Test newTest_aroundBody0(int);\n  Code:\n   Stack\u003d1, Locals\u003d1, Args_size\u003d1\n   0:   iload_0\n   1:   lookupswitch{ //0\n                default: 12 }\n   12:  aconst_null\n   13:  areturn\n  LineNumberTable:\n   line 4: 0\n   line 5: 12\n\nperfect!\n\nThe other lurking problem is that a TABLESWITCH is defined as:\n\nTABLESWITCH (0xaa)\n\u003c0-3\u003e padding bytes\ndefaultbytes1-4\nlowbyte1-4\nhighbyte1-4\njumpoffsets...\n\nSo in our case we create a TABLESWITCH where lowbyte\u003d0 and highbyte\u003d0 but the\ndefinition of the instruction says that the number of jumpoffsets must be\n(high-low+1).  BCEL doesnt write out any entries in the case where there are no\ntargets when it should write out at least *one* - if it doesnt then decompilers\nand verifiers will choke.\n\nHowever... I haven\u0027t fixed this problem as there seems to be more issues lurking\nin TABLESWITCH - if we write out those 4 missing bytes, we\u0027ll need to ensure the\n\u0027length\u0027 of the instruction is managed correctly too.  Given that so far the\nonly way I\u0027ve seen a damaged TABLESWITCH is when its been incorrectly created\ninstead of a LOOKUPSWITCH (and that can no longer happen) I won\u0027t fix\nTABLESWITCH until I see a bug that shows the problem.\n\nfix checked in, waiting on build.",
    "fix available in latest dev build, see download page."
  ],
  "commentCreationDates": [
    "2005-07-21T21:16:55+02:00",
    "2005-07-21T21:18:03+02:00",
    "2005-07-21T21:19:27+02:00",
    "2005-07-22T10:36:16+02:00",
    "2005-08-24T16:26:24+02:00",
    "2005-08-24T16:47:23+02:00",
    "2005-08-25T13:37:50+02:00",
    "2005-08-25T16:27:23+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.VerifyError",
      "message": "verification failed at PC 1 in Test:newTest_aroundBody2((I)LTest;): branch out of range",
      "elements": [
        {
          "method": "java.lang.VMClassLoader.resolveClass",
          "source": "java.lang.Class"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "104720",
      "date": "2005-07-21T21:16:55+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "104720",
  "bugId": "104720",
  "date": "2005-07-21T21:16:55+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}