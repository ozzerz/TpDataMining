{
  "comments": [
    "Build ID: M20070212-1330\n\nSteps To Reproduce:\nI can only reproduce this on my java code base, although it occurs on every site including Windows Vista, Ubuntu, Red Hat and using Java 1.5 and 1.6 and different versions of Eclipse (including 3.3R4). We can\u0027t pin what file causes it, though, because it is inconsistent, but the error\u0027s the same.\n\nMore information:\nWe cannot figure out how to get around this bug, so coding and testing for our project is blocked, and we have a deadline in a month, which is why I gave this a high severity. The following is the error Eclipse gives us:\n\nInternal compiler error java.lang.NullPointerException at \n org.eclipse.jdt.internal.compiler.ast.FieldReference.resolveType\n (FieldReference.java:557) at \n org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType\n (MessageSend.java:310) at \n org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType\n (MessageSend.java:310) at \n org.eclipse.jdt.internal.compiler.ast.ForeachStatement.resolve\n (ForeachStatement.java:353) at \n org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStat\n ements(AbstractMethodDeclaration.java:432) at \n org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements\n (MethodDeclaration.java:190) at \n org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve\n (AbstractMethodDeclaration.java:403) at \n org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve\n (TypeDeclaration.java:1047) at \n org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve\n (TypeDeclaration.java:1088) at \n org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve\n (TypeDeclaration.java:976) at \n org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve\n (TypeDeclaration.java:1094) at \n org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve\n (CompilationUnitDeclaration.java:353) at \n org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:596) at \n org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:411) at \n org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile\n (AbstractImageBuilder.java:353) at \n org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile\n (BatchImageBuilder.java:171) at \n org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile\n (AbstractImageBuilder.java:290) at \n org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build\n (BatchImageBuilder.java:59) at \n org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:\n 241) at org.eclipse.jdt.internal.core.builder.JavaBuilder.build\n (JavaBuilder.java:169) at org.eclipse.core.internal.events.BuildManager\n $2.run(BuildManager.java:603) at org.eclipse.core.runtime.SafeRunner.run\n (SafeRunner.java:37) at \n org.eclipse.core.internal.events.BuildManager.basicBuild\n (BuildManager.java:167) at \n org.eclipse.core.internal.events.BuildManager.basicBuild\n (BuildManager.java:201) at org.eclipse.core.internal.events.BuildManager\n $1.run(BuildManager.java:230) at org.eclipse.core.runtime.SafeRunner.run\n (SafeRunner.java:37) at \n org.eclipse.core.internal.events.BuildManager.basicBuild\n (BuildManager.java:233) at \n org.eclipse.core.internal.events.BuildManager.basicBuildLoop\n (BuildManager.java:252) at \n org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:\n 285) at org.eclipse.core.internal.events.AutoBuildJob.doBuild\n (AutoBuildJob.java:154) at org.eclipse.core.internal.events.AutoBuildJob.run\n (AutoBuildJob.java:217) at org.eclipse.core.internal.jobs.Worker.run\n (Worker.java:58)\n\nThe code base has a heavy and complex use of generics. The odd thing is the error occurs in the code that has not changed much for months. Here is the code for the file it seems to break on for most of us:\n\npackage util.graph;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport util.ArrayCollection;\nimport util.Grouping;\nimport util.HashGrouping;\nimport util.IdentityHashGrouping;\nimport util.MultiMap;\nimport util.Tag;\nimport util.VariaticFunction;\nimport util.pair.PairedList;\n\npublic abstract class RecursiveExpressionGraph\u003c\n\t\tG extends RecursiveExpressionGraph\u003cG,V,L\u003e,\n\t\tV extends RecursiveExpressionVertex\u003cG,V,L\u003e, L\u003e\n\t\textends ExpressionGraph\u003cG,V,L\u003e {\n\tprotected final Grouping\u003cV\u003e mGrouping \u003d new IdentityHashGrouping\u003cV\u003e();\n\t\n\tpublic RecursiveExpressionGraph() {super(4);}\n\n\tpublic void trimInsignificant() {\n\t\tsuper.trimInsignificant();\n\t\tCollection\u003cV\u003e trimmed \u003d new ArrayCollection\u003cV\u003e();\n\t\tfor (V rep : mGrouping.getRepresentatives())\n\t\t\tif (!getVertices().contains(rep))\n\t\t\t\ttrimmed.add(rep);\n\t\tfor (V rep : trimmed)\n\t\t\tmGrouping.ungroup(rep);\n\t}\n\t\n\tpublic V createPlaceHolder() {\n\t\treturn makeHolderVertex();\n\t}\n\tpublic V createPlaceHolder(L label) {\n\t\treturn makeHolderVertex(label);\n\t}\n\t\n\tprotected abstract V makeHolderVertex();\n\tprotected abstract V makeHolderVertex(L label);\n\t\n\tprotected interface IVertex\u003cG extends RecursiveExpressionGraph\u003cG,V,L\u003e,\n\t\t\tV extends IVertex\u003cG,V,L\u003e,L\u003e extends ExpressionGraph.IVertex\u003cG,V,L\u003e,\n\t\t\tRecursiveExpressionVertex\u003cG,V,L\u003e {\n\t\tpublic void setParents(Set\u003cV\u003e parents);\n\t\tpublic Set\u003cV\u003e getParents();\n\t\tpublic PairedList\u003cTag,Object\u003e getTags();\n\t\tpublic void setTags(PairedList\u003cTag,Object\u003e tags);\n\t}\n\t\n\tprotected static abstract class HolderVertex\n\t\t\t\u003cG extends RecursiveExpressionGraph\u003cG,V,L\u003e,\n\t\t\tV extends IVertex\u003cG,V,L\u003e, L\u003e extends ExpressionGraph.Vertex\u003cG,V,L\u003e\n\t\t\timplements IVertex\u003cG,V,L\u003e {\n\t\tprotected V mReplacement \u003d null;\n\t\t\n\t\tpublic HolderVertex(L label) {super(label);}\n\t\t\n\t\tpublic L getLabel() {\n\t\t\treturn mReplacement \u003d\u003d null ? super.getLabel()\n\t\t\t\t\t: mReplacement.getLabel();\n\t\t}\n\t\t\n\t\tpublic boolean hasChildren() {\n\t\t\treturn mReplacement !\u003d null \u0026\u0026 mReplacement.hasChildren();\n\t\t}\n\t\tpublic boolean hasChildren(V... children) {\n\t\t\treturn mReplacement !\u003d null \u0026\u0026 mReplacement.hasChildren(children);\n\t\t}\n\t\tpublic boolean hasChildren(List\u003c? extends V\u003e children) {\n\t\t\treturn mReplacement !\u003d null \u0026\u0026 mReplacement.hasChildren(children);\n\t\t}\n\t\tpublic List\u003c? extends V\u003e getChildren() {\n\t\t\treturn mReplacement \u003d\u003d null ? Collections.\u003cV\u003eemptyList()\n\t\t\t\t\t: mReplacement.getChildren();\n\t\t}\n\t\tpublic V getChild(int i) {\n\t\t\treturn mReplacement \u003d\u003d null ? getChildren().get(i)\n\t\t\t\t\t: mReplacement.getChild(i);\n\t\t}\n\t\tpublic int getChildCount() {\n\t\t\treturn mReplacement \u003d\u003d null ? 0 : mReplacement.getChildCount();\n\t\t}\n\t\t\n\t\tpublic \u003cE\u003e E evaluate(VariaticFunction\u003cL,E,E\u003e evaluator) {\n\t\t\treturn mReplacement \u003d\u003d null ? evaluator.get(getLabel())\n\t\t\t\t\t: mReplacement.evaluate(evaluator);\n\t\t}\n\t\tpublic \u003cE\u003e E evaluateVertex(VariaticFunction\u003c? super V,E,E\u003e evaluator) {\n\t\t\treturn mReplacement \u003d\u003d null ? evaluator.get(getSelf())\n\t\t\t\t\t: mReplacement.evaluateVertex(evaluator);\n\t\t}\n\t\t\n\t\tpublic boolean isPlaceHolder() {return mReplacement \u003d\u003d null;}\n\t\t\n\t\tpublic void replaceWith(V replacement) {\n\t\t\tif (mReplacement !\u003d null)\n\t\t\t\tthrow new IllegalStateException();\n\t\t\tif (replacement.isPlaceHolder())\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\tboolean hadParents \u003d replacement.hasParents();\n\t\t\tmReplacement \u003d replacement;\n\t\t\treplacement.addParents(mParents);\n\t\t\tmParents \u003d replacement.getParents();\n\t\t\tmReplacement.getTags().addAll(mTags);\n\t\t\tmTags \u003d mReplacement.getTags();\n\t\t\tgetGraph().mGrouping.group(mReplacement, getSelf());\n\t\t\tGrouping\u003cV\u003e grouping \u003d null;\n\t\t\tif (hadParents) {\n\t\t\t\tgrouping \u003d new HashGrouping\u003cV\u003e();\n\t\t\t\tif (mergeParents(grouping)) {\n\t\t\t\t\tapplyGrouping(grouping);\n\t\t\t\t\tgrouping \u003d null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (V similar\n\t\t\t\t\t: getGraph().mTracker.get(replacement.getChildCount())\n\t\t\t\t\t.get(replacement.getLabel())) {\n\t\t\t\tif (similar.equals(replacement))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (grouping \u003d\u003d null)\n\t\t\t\t\tgrouping \u003d new HashGrouping\u003cV\u003e();\n\t\t\t\tif (merge(replacement, similar, grouping)) {\n\t\t\t\t\tmergeParents(grouping);\n\t\t\t\t\tapplyGrouping(grouping);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprotected boolean mergeParents(Grouping\u003cV\u003e grouping) {\n\t\t\tList\u003cMultiMap\u003cL,V\u003e\u003e tracker \u003d getGraph().mTracker;\n\t\t\tboolean anyChange \u003d false;\n\t\t\tfor (boolean changed \u003d true; changed; ) {\n\t\t\t\tchanged \u003d false;\n\t\t\t\tfor (int arity \u003d 1; arity \u003c tracker.size(); arity++)\n\t\t\t\t\tfor (Set\u003c? extends V\u003e verts\n\t\t\t\t\t\t\t: tracker.get(arity).valueSets()) {\n\t\t\t\t\t\tif (verts.size() \u003c\u003d 1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (V left : verts)\n\t\t\t\t\t\t\tfor (V right : verts) {\n\t\t\t\t\t\t\t\tif (grouping.isGrouped(left, right))\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tboolean same \u003d true;\n\t\t\t\t\t\t\t\tfor (int child \u003d arity; child-- !\u003d 0; )\n\t\t\t\t\t\t\t\t\tif (!grouping.isGrouped(\n\t\t\t\t\t\t\t\t\t\t\tleft.getChild(child),\n\t\t\t\t\t\t\t\t\t\t\tright.getChild(child))) {\n\t\t\t\t\t\t\t\t\t\tsame \u003d false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (same)\n\t\t\t\t\t\t\t\t\tchanged |\u003d grouping.group(left, right);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tanyChange |\u003d changed;\n\t\t\t}\n\t\t\treturn anyChange;\n\t\t}\n\t\t\n\t\tprotected boolean merge(V left, V right, Grouping\u003cV\u003e grouping) {\n\t\t\tif (grouping.isGrouped(left, right))\n\t\t\t\treturn true;\n\t\t\tif (left.isPlaceHolder() || right.isPlaceHolder())\n\t\t\t\treturn false;\n\t\t\tif (left.getChildCount() !\u003d right.getChildCount())\n\t\t\t\treturn false;\n\t\t\tif (!left.hasLabel(right.getLabel()))\n\t\t\t\treturn false;\n\t\t\tgrouping.group(left, right);\n\t\t\tfor (int child \u003d 0; child \u003c left.getChildCount(); child++)\n\t\t\t\tif (!merge(left.getChild(child), right.getChild(child),\n\t\t\t\t\t\tgrouping))\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tprotected void applyGrouping(Grouping\u003cV\u003e grouping) {\n\t\t\tG graph \u003d getGraph();\n\t\t\tList\u003cMultiMap\u003cL,V\u003e\u003e tracker \u003d graph.mTracker;\n\t\t\tSet\u003cV\u003e vertices \u003d graph.mVertices;\n\t\t\tMap\u003cL,V\u003e leaves \u003d graph.mLeaves;\n\t\t\tGrouping\u003cV\u003e masterGrouping \u003d graph.mGrouping;\n\t\t\tfor (V rep : grouping.getRepresentatives())\n\t\t\t\tfor (V friend : grouping.getGroup(rep))\n\t\t\t\t\tif (!rep.equals(friend)) {\n\t\t\t\t\t\tvertices.remove(friend);\n\t\t\t\t\t\tif (friend.isLeaf())\n\t\t\t\t\t\t\tleaves.remove(friend);\n\t\t\t\t\t\ttracker.get(friend.getChildCount())\n\t\t\t\t\t\t\t\t.removeValue(friend.getLabel(), friend);\n\t\t\t\t\t\tif (friend.unmakeSignificant())\n\t\t\t\t\t\t\trep.makeSignificant();\n\t\t\t\t\t\trep.addParents(friend.getParents());\n\t\t\t\t\t\trep.getTags().addAll(friend.getTags());\n\t\t\t\t\t\tfor (V associate : masterGrouping.getGroup(friend)) {\n\t\t\t\t\t\t\tassociate.setParents(rep.getParents());\n\t\t\t\t\t\t\tassociate.setTags(rep.getTags());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmasterGrouping.group(rep, friend);\n\t\t\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\treturn mReplacement \u003d\u003d null ? super.toString()\n\t\t\t\t\t: mReplacement.toString();\n\t\t}\n\t}\n\t\n\tprotected static abstract class LeafVertex\n\t\t\t\u003cG extends RecursiveExpressionGraph\u003cG,V,L\u003e,\n\t\t\tV extends IVertex\u003cG,V,L\u003e, L\u003e\n\t\t\textends ExpressionGraph.LeafVertex\u003cG,V,L\u003e implements IVertex\u003cG,V,L\u003e\n\t\t\t{\n\t\tpublic LeafVertex(L label) {super(label);}\n\t\t\n\t\tpublic boolean isPlaceHolder() {return false;}\n\t\tpublic void replaceWith(V replacement) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\t\n\tprotected static abstract class UniVertex\n\t\t\t\u003cG extends RecursiveExpressionGraph\u003cG,V,L\u003e,\n\t\t\tV extends IVertex\u003cG,V,L\u003e, L\u003e\n\t\t\textends ExpressionGraph.UniVertex\u003cG,V,L\u003e implements IVertex\u003cG,V,L\u003e {\n\t\tpublic UniVertex(L label, V child) {super(label, child);}\n\t\t\n\t\tpublic boolean isPlaceHolder() {return false;}\n\t\tpublic void replaceWith(V replacement) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\t\n\tprotected static abstract class MultiVertex\n\t\t\t\u003cG extends RecursiveExpressionGraph\u003cG,V,L\u003e,\n\t\t\tV extends IVertex\u003cG,V,L\u003e, L\u003e\n\t\t\textends ExpressionGraph.MultiVertex\u003cG,V,L\u003e implements IVertex\u003cG,V,L\u003e\n\t\t\t{\n\t\tpublic MultiVertex(L label, V[] children) {super(label, children);}\n\t\t\n\t\tpublic boolean isPlaceHolder() {return false;}\n\t\tpublic void replaceWith(V replacement) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}",
    "We figured out a way around the bug, at least a temporary way, that may shed some light on its cause. We split our project into 3 projects based on our primary packages, with a dependency chain. Now it compiles and things run fine, at least for now. Hopefully this unpredictable bug won\u0027t come up again before it gets fixed.",
    "Could you please attach a test case that can be self-contained?\nThis will help us to track it down.\nThanks.",
    "Created an attachment (id\u003d71799)\nHere is a zip file of our entire project folder. We grant you full use of this code for debugging Eclipse. Please consult with us if you want to use the code for any other purpose.\n\nThank you for your help, we really appreciate your promptness. Here is a zip file of our entire project folder. We grant you full use of this code for debugging Eclipse. Please consult with us if you want to use the code for any other purpose.\n\nI\u0027ve imported this folder as an existing project into a completely new workspace (Eclipse 3.2.2 using Java 5) and it still produced the error, so hopefully it does the same for you.\n\nBefore importing this folder, place these two jars in the lib folder:\nhttp://math.nist.gov/javanumerics/jama/Jama-1.0.2.jar\nhttp://www.sable.mcgill.ca/software/sootclasses-2.2.4.jar\nYou\u0027ll have to set the JRE system library in the build-path to a 1.5 one of course.\n\nIf you have any questions, please feel free to ask. Thanks again for the quick response!",
    "Reproduced in latest (3.4 stream).\n\njava.lang.NullPointerException\nat org.eclipse.jdt.internal.compiler.ast.FieldReference.resolveType(FieldReference.java:566)\nat org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:334)\nat org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:334)\nat org.eclipse.jdt.internal.compiler.ast.ForeachStatement.resolve(ForeachStatement.java:392)\nat org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:429)\nat org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:198)\nat org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:399)\nat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1084)\nat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1154)\nat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1013)\nat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1163)\nat org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:365)\nat org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:623)\nat org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)\nat org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:362)\nat org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:173)\nat org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:299)\nat org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:59)\nat org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:251)\nat org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:177)\nat org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:629)\nat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\nat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:166)\nat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:197)\nat org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:249)\nat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\nat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:252)\nat org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:305)\nat org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:337)\nat org.eclipse.core.internal.resources.Workspace.build(Workspace.java:330)\nat org.eclipse.ui.actions.GlobalBuildAction$1.run(GlobalBuildAction.java:183)\nat org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)",
    "Offending field reference is:\n\"getGraph().mTracker\" in RecursiveExpressionGraph.java",
    "This comes from the fact that we get an exception while attempting to resolve the field from ExpressionGraph, leaving unresolved field bindings in the field array (problem 1: in case of badness, unresolved fields should be discarded).\n\nNow the exception seems to occur because of a reentering call into field lookup while still connecting type hierarchies (and resolving single type imports).\n\nSourceTypeBinding.fields() line: 607\t\nParameterizedTypeBinding.fields() line: 336\t\nParameterizedTypeBinding.getField(char[], boolean) line: 518\t\nCompilationUnitScope(Scope).findField(TypeBinding, char[], InvocationSite, boolean) line: 878\t\nCompilationUnitScope.findSingleStaticImport(char[][]) line: 519\t\nCompilationUnitScope.findSingleImport(char[][], boolean) line: 502\t\nCompilationUnitScope.resolveSingleImport(ImportBinding) line: 696\t\nClassScope(Scope).getTypeOrPackage(char[], int) line: 2393\t\nClassScope(Scope).getType(char[]) line: 2141\t\nParameterizedSingleTypeReference.internalResolveType(Scope, ReferenceBinding, boolean) line: 98\t\nParameterizedSingleTypeReference.resolveType(ClassScope) line: 222\t\nParameterizedSingleTypeReference(TypeReference).resolveTypeArgument(ClassScope, ReferenceBinding, int) line: 191\t\nParameterizedSingleTypeReference.internalResolveType(Scope, ReferenceBinding, boolean) line: 145\t\nParameterizedSingleTypeReference.resolveType(ClassScope) line: 222\t\nParameterizedSingleTypeReference(TypeReference).resolveSuperType(ClassScope) line: 114\t\nClassScope.findSupertype(TypeReference) line: 1123\t\nClassScope.connectSuperInterfaces() line: 921\t\nClassScope.connectTypeHierarchy() line: 967\t\nClassScope.connectMemberTypes() line: 809\t\nClassScope.connectTypeHierarchy() line: 974\t\nCompilationUnitScope.connectTypeHierarchy() line: 290\t\nLookupEnvironment.completeTypeBindings() line: 218\t\nCompiler.internalBeginToCompile(ICompilationUnit[], int) line: 603\t\nCompiler.beginToCompile(ICompilationUnit[]) line: 357\t\nCompiler.compile(ICompilationUnit[]) line: 371\t\nBatchImageBuilder(AbstractImageBuilder).compile(SourceFile[], SourceFile[], boolean) line: 362\t\nBatchImageBuilder.compile(SourceFile[], SourceFile[], boolean) line: 175\t\nBatchImageBuilder(AbstractImageBuilder).compile(SourceFile[]) line: 299\t\nBatchImageBuilder.build() line: 59\t\nJavaBuilder.buildAll() line: 253\t\nJavaBuilder.build(int, Map, IProgressMonitor) line: 172\t\nBuildManager$2.run() line: 629\t\nSafeRunner.run(ISafeRunnable) line: 37\t\nBuildManager.basicBuild(int, IncrementalProjectBuilder, Map, MultiStatus, IProgressMonitor) line: 166\t\nBuildManager.basicBuild(IProject, int, ICommand[], MultiStatus, IProgressMonitor) line: 197\t\nBuildManager$1.run() line: 249\t\nSafeRunner.run(ISafeRunnable) line: 37\t\nBuildManager.basicBuild(IProject, int, MultiStatus, IProgressMonitor) line: 252\t\nBuildManager.basicBuildLoop(IProject[], IProject[], int, MultiStatus, IProgressMonitor) line: 305\t\nBuildManager.build(int, IProgressMonitor) line: 337\t\nWorkspace.build(int, IProgressMonitor) line: 330\t\nGlobalBuildAction$1.run(IProgressMonitor) line: 183\t\nWorker.run() line: 55\t\n\n",
    "It feels that we shouldn\u0027t even attempt to resolve the import to a field in the context of a type hierarchy resolution (i.e. only a member type could be relevant there).",
    "Created an attachment (id\u003d81059)\nProposed patch\n\nThe patch mimics the method support for reentrance into fields after resolving static imports. Basically, when building fields, reset the flags telling that fields were sorted\u0026complete; in case the question got asked during hierarchy resolution, while the field bindings hadn\u0027t been created yet.",
    "Simpler testcase:\np/X.java [\npackage p;\nimport static r.Y.Z;\nimport q.*;\npublic class X\u003cT\u003e extends Z\u003cT\u003e {\n   Z\u003cT\u003e getZ() { return null; } \n\tvoid bar() {\n\t\tSystem.out.println(getZ().value);\n\t}\n}\n\n]\nq/Z.java [\npackage q;\nimport r.Y;\npublic class Z\u003cT\u003e extends Y\u003cT\u003e {\n}\n\n]\nr/Y.java [\npackage r;\npublic class Y\u003cT\u003e extends V\u003cT\u003e{\n\tinterface Z {}\n}\n\n]\nr/V.java [\npackage r;\npublic class V\u003cT\u003e {\n\tpublic Runnable value;\n}\n\n]",
    "Added StaticImportTest#test055-056",
    "*** Bug 207433 has been marked as a duplicate of this bug. ***",
    "Released for 3.4M3\nReleased for 3.3.2\nFixed",
    "Ross - sorry it took so long to get to it.\nThe fix should soon be available in a 3.2.2 integration build (official 3.3.2 is scheduled for february 2008).\n\nGiven you seem to be testing extensively Java5 constructs, I would offer to post a patch so you can enjoy better developing with these (please report any issue you\u0027d find with it). Are you interested ?",
    "We would love a patch. We have all these hacks in our infrastructure to get around the problem. Thanks for fixing it! I have a tendency to push compilers. javac won\u0027t compile it either, but for different reasons. It doesn\u0027t like narrowed return types, but it also seems to have a problem with generic constructors (as in the constructor method is generic, not the class).\nWe may have found another bug, but it\u0027s in the type checking, and a logic bug, not an exception being thrown. I haven\u0027t posted anything because I can\u0027t tell if it\u0027s a bug or not. In some ways it makes sense and in other ways it doesn\u0027t. I\u0027m positive that it would be type-safe, but the details of the semantics for generics may not accept it. Should I post the \"bug\" anyways?\nAgain, thanks for taking the effort to fix this bug, since we may be the only ones with crazy enough constructs to cause it, heheh.",
    "If you have suspicions, please log more bugs against JDT/Core (using [1.5][compiler] as a prefix in the title).\n\nIf it ends up not being an issue, we will close it; no big deal (better safe than sorry).\n\nActually, the patch I can offer it for Eclipse 3.3, is that ok ? Or do you need it for 3.2 ?",
    "Released fix in 3.2 maintenance branch.",
    "(In reply to comment #16)\n\u003e Released fix in 3.2 maintenance branch.\n\u003e \nPatch on top of 3.2.2 is now available at: \nhttp://www.eclipse.org/jdt/core/r3.2/index.php#UPDATES\n",
    "FYI - in forthcoming 3.4M3 (end of next week), you should be able to compile clean the original testcase you attached to this bug. \nI am seeing quite numerous unchecked warnings, but on the surface they seem legite.\n",
    "(In reply to comment #12)\n\u003e Released for 3.3.2\n\u003e Fixed\n\u003e \nPatch on top of 3.3.1 is now available at: \nhttp://www.eclipse.org/jdt/core/r3.3/index.php#UPDATES\n",
    "After figuring out how to install it, the patch for 3.2 is working,\neven for the current version of our project.\nI think I have 3.3 at home, so I can test that patch later.\nAs to the warnings, we change our warning settings from the default, so that\u0027s probably where those come up.\nI have a deadline in 3 weeks, after that I\u0027ll get around to posting the other possible bug I mentioned before.\nThanks for the help! This should make things much smoother for us.",
    "Verified for 3.4 M3 using build I20071029-0010.",
    "Both patches are working for all of us, and we are greatful!",
    "Glad it worked. Keep us posted of the next problems you find (in new bug reports).",
    "NPE is quite severe in compiler. The fix is trivial.",
    "+1 for 3.3.2"
  ],
  "commentCreationDates": [
    "2007-06-18T23:35:02+02:00",
    "2007-06-19T00:04:14+02:00",
    "2007-06-19T02:35:40+02:00",
    "2007-06-19T22:45:03+02:00",
    "2007-10-23T17:49:05+02:00",
    "2007-10-23T18:46:02+02:00",
    "2007-10-23T19:05:44+02:00",
    "2007-10-23T19:13:56+02:00",
    "2007-10-24T15:44:56+02:00",
    "2007-10-25T15:29:35+02:00",
    "2007-10-25T15:36:03+02:00",
    "2007-10-25T15:50:34+02:00",
    "2007-10-25T16:03:06+02:00",
    "2007-10-25T16:05:56+02:00",
    "2007-10-25T21:49:31+02:00",
    "2007-10-26T13:28:22+02:00",
    "2007-10-26T14:57:02+02:00",
    "2007-10-26T16:34:26+02:00",
    "2007-10-26T16:59:07+02:00",
    "2007-10-26T18:14:48+02:00",
    "2007-10-27T01:21:57+02:00",
    "2007-10-29T14:45:22+01:00",
    "2007-10-29T19:51:46+01:00",
    "2007-10-30T12:11:24+01:00",
    "2007-11-22T15:33:37+01:00",
    "2007-11-23T14:20:41+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.FieldReference.resolveType",
          "source": "FieldReference.java:557"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType",
          "source": "MessageSend.java:310"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType",
          "source": "MessageSend.java:310"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.ForeachStatement.resolve",
          "source": "ForeachStatement.java:353"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements",
          "source": "AbstractMethodDeclaration.java:432"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements",
          "source": "MethodDeclaration.java:190"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve",
          "source": "AbstractMethodDeclaration.java:403"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:1047"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:1088"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:976"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:1094"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve",
          "source": "CompilationUnitDeclaration.java:353"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.process",
          "source": "Compiler.java:596"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:411"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:353"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile",
          "source": "BatchImageBuilder.java:171"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:290"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build",
          "source": "BatchImageBuilder.java:59"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll",
          "source": "JavaBuilder.java:  241"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.JavaBuilder.build",
          "source": "JavaBuilder.java:169"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$2.run",
          "source": "BuildManager.java:603"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:167"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:201"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$1.run",
          "source": "BuildManager.java:230"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:233"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuildLoop",
          "source": "BuildManager.java:252"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.build",
          "source": "BuildManager.java:  285"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.doBuild",
          "source": "AutoBuildJob.java:154"
        },
        {
          "method": "org.eclipse.core.internal.events.AutoBuildJob.run",
          "source": "AutoBuildJob.java:217"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "193210",
      "date": "2007-06-18T23:35:02+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "critical"
    },
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.FieldReference.resolveType",
          "source": "FieldReference.java:566"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType",
          "source": "MessageSend.java:334"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType",
          "source": "MessageSend.java:334"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.ForeachStatement.resolve",
          "source": "ForeachStatement.java:392"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements",
          "source": "AbstractMethodDeclaration.java:429"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements",
          "source": "MethodDeclaration.java:198"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve",
          "source": "AbstractMethodDeclaration.java:399"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:1084"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:1154"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:1013"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:1163"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve",
          "source": "CompilationUnitDeclaration.java:365"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.process",
          "source": "Compiler.java:623"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:392"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:362"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile",
          "source": "BatchImageBuilder.java:173"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:299"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build",
          "source": "BatchImageBuilder.java:59"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll",
          "source": "JavaBuilder.java:251"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.JavaBuilder.build",
          "source": "JavaBuilder.java:177"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$2.run",
          "source": "BuildManager.java:629"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:166"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:197"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager$1.run",
          "source": "BuildManager.java:249"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuild",
          "source": "BuildManager.java:252"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.basicBuildLoop",
          "source": "BuildManager.java:305"
        },
        {
          "method": "org.eclipse.core.internal.events.BuildManager.build",
          "source": "BuildManager.java:337"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.build",
          "source": "Workspace.java:330"
        },
        {
          "method": "org.eclipse.ui.actions.GlobalBuildAction$1.run",
          "source": "GlobalBuildAction.java:183"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:55"
        }
      ],
      "number": 1,
      "commentIndex": 4,
      "bugId": "193210",
      "date": "2007-10-23T17:49:05+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "critical"
    }
  ],
  "groupId": "193210",
  "bugId": "193210",
  "date": "2007-06-18T23:35:02+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "critical"
}