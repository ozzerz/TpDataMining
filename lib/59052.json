{
  "comments": [
    "Cheetah-03\n\nThe following program doesn\u0027t reconcile properly:\n interface Predicate\u003cT\u003e {\n  boolean is(T t);\n }\n interface List\u003cT\u003e {\n  List\u003cT\u003e select(Predicate\u003cT\u003e p);\n }\n class ArrayList\u003cT\u003e implements List\u003cT\u003e, Iterable\u003cT\u003e {\n  public List\u003cT\u003e select(Predicate\u003cT\u003e p) {\n   ArrayList\u003cT\u003e result \u003d new ArrayList\u003cT\u003e();\n   for (T t : this) {\n    if (p.is(t)) result.add(t);\n   }\n   return result;\n  }\n }\n\n\n\nException in thread \"org.eclipse.jdt.internal.ui.text.JavaReconciler\" \njava.lang.IllegalArgumentException: Not yet implemented: convert(class \norg.eclipse.jdt.internal.compiler.ast.ForeachStatement)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1792)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:398)\n\tat org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations\n(ASTConverter.java:209)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1936)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:931)\n\tat org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:244)\n\tat org.eclipse.jdt.internal.core.CompilationUnit.buildStructure\n(CompilationUnit.java:151)\n\tat org.eclipse.jdt.internal.core.Openable.generateInfos\n(Openable.java:183)\n\tat org.eclipse.jdt.internal.core.JavaElement.openWhenClosed\n(JavaElement.java:543)\n\tat org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent\n(CompilationUnit.java:970)\n\tat \norg.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation\n(ReconcileWorkingCopyOperation.java:58)\n\tat org.eclipse.jdt.internal.core.JavaModelOperation.run\n(JavaModelOperation.java:700)\n\tat org.eclipse.jdt.internal.core.JavaModelOperation.runOperation\n(JavaModelOperation.java:739)\n\tat org.eclipse.jdt.internal.core.CompilationUnit.reconcile\n(CompilationUnit.java:1111)\n\tat org.eclipse.jdt.internal.core.CompilationUnit.reconcile\n(CompilationUnit.java:1080)\n\tat \norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile\n(JavaReconcilingStrategy.java:85)\n\tat \norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile\n(JavaReconcilingStrategy.java:118)\n\tat \norg.eclipse.jface.text.reconciler.CompositeReconcilingStrategy.reconcile\n(CompositeReconcilingStrategy.java:83)\n\tat \norg.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile\n(JavaCompositeReconcilingStrategy.java:97)\n\tat org.eclipse.jface.text.reconciler.MonoReconciler.process\n(MonoReconciler.java:76)\n\tat \norg.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run\n(AbstractReconciler.java:189)",
    "I added a regression test to be sure that the conversion in AST.LEVEL_3_0 is not\na problem.\nWhen the ast level can be set for a reconcile operation, this should be fixed.",
    "*** Bug 59023 has been marked as a duplicate of this bug. ***",
    "Move to JDT/UI.\nIn 1.5 mode, please set AST level to 3.0.",
    "We can now set the AST but we need to see whether resources are allocated to fix\n1.5 bugs before 3.0 committed items are done.\n",
    "removing target milestone",
    "this is now AST.JLS3 right? I will try to put this in for RC1.\n",
    "We cannot do this for now: we use a shared/chached AST for the active editor.\nLots of functions are written against this AST and expect JSL2 (syntax coloring,\nmark occurrences, quick fixes, refactoring). They would be broken unless ported\ni.e. it might get worse (stuff might break in the UI thread and the editor might\nstop working at all) than better when we simply change the AST level.\n",
    "*** Bug 63761 has been marked as a duplicate of this bug. ***",
    "*** Bug 63985 has been marked as a duplicate of this bug. ***",
    "I\u0027m not a developer of Eclipse, but one suggestion might be the following:\n\nCouldn\u0027t you add a the possibility to somehow suppress the dialog displaying \nthe error (which it does on my system, see bug 63985 for details) from \nappearing all the time? I can live with some things not working (after all, \nthis is test-stuff), but the window appearing all the time bothers me.\n\nI can file a RFE later. For now I wanted to ask if there is anything I can do.\n\nUnfortunately, my next Java project should be 1.5 code, therefore I kind of \ndepend on at least some 1.5 support.",
    "Olivier, I think it would be better if no IllegalArgumentException is thrown but\nwe still get an AST but one with nodes markes as malformed .\n\nNot everybody will change to AST.JLS3 right away, there will e.g. contributed\nplugins written for Eclipse 3.0 that will try to build an ASTs with AST.JLS2 and\nit can always happen that the user enters something that looks like 1.5 code.\nClients of ASTParser.createAST don\u0027t expect IllegalArgumentExceptions.\n\nMoving to jdt.core",
    "1.5 programs are not representable in AST 2 level. Creating malformed nodes or \nno nodes doesn\u0027t seem much different in the end, as malformed nodes couldn\u0027t \nbe trusted anyway.\n\nBack to UI land for leveraging AST 3 level usage.",
    "ASTParser.createAST does not spec that IllegalArgumentException to be thrown. \nThe current way of the ASTParser to communicate that the source can\u0027t be \nparsed is to return a malformed tree.\nJeem, is that correct?\n\n",
    "*** Bug 65880 has been marked as a duplicate of this bug. ***",
    "I second Martin\u0027s opinion. \n\nThrowing IllegalArgumentExceptions forces everybody to convert all of his \ncode. Marking the tree as malformed would give clients the possibility to do \nthe conversion step by step.",
    "Dirk and Martin are right: ASTParser.createAST (and \nICompilationUnit.reconcile) indicates that the source can\u0027t be parsed by \nreturning an AST with node(s) marked as MALFORMED. If a JLS2 ASTParser is \nasked to parse a program containing a 1.5-only construct like an enhanced for, \nit should be returning an AST with a malformed node of some sort; it should \nnot be throwing an exception.\n",
    "We (Erich, Philippe and I) discussed this on the phone and agreed that the AST \nshould be marked as malformed in this case. Now IAE should be thrown.\n\nThe open question is which nodes are still present in the AST and which are \nmarked as malformed. The more complete the AST is the better it is for the \ntooling. However marking types as malformed doesn\u0027t make to much sense either.\n\nFor example for a statement like List\u003cString\u003e s\u003d new List\u003cString\u003e(); it is \nfine to mark the whole class instance creation node as malformed.\n\nSo I opt to mark statementa and \"larger\" expressions (for example an method \nclass argument) as malformed.",
    "Dirk - what about attaching AST3 node and tagging them as malformed into an \nAST2 tree ? Think of how we would represent a foreach statement, and enum \ndeclaration ?",
    "Philippe,  That would be difficult. If you have a JLS2 AST, you cannot \ninstantiate any of the new JLS3 node types like EnhancedForStatement",
    "Then we have a problem.\nWhat should be the node that should be tagged as malformed? For a parameterized\ntype, we can take its erasure. But for a enhanced for statement, there is no\nequivalent.",
    "Maybe you could mark the parent of the statement (probably a block) as \nmalformed and have it contain only the parseable statements. The foreach code \nwould then be not be represented by any node and just treated like whitespace.\n\nIt would also be ok to skip all statements following the unknown code, but of \ncourse the more we have the better result we have for features like quick fix \nand semantic highlighting.",
    "Reasonable AST2 placeholders feel more reasonable(empty statement or erased \ntype reference) and these should be marked as malformed. \nWhat would be a reasonable placeholder for type parameters ?\n\nclass X \u003cE\u003e { }\n\n--\u003e\nclass X {} and type decl is malformed ?",
    "*** Bug 67763 has been marked as a duplicate of this bug. ***",
    "First draft released. I will double-check it is working fine. 1.5 code should\nnot produce IllegalArgumentException in JLS2 mode anymore.",
    "Fix for bug 68602 has been released.",
    "BTW when will there be an update available on the update site?",
    "There is no more updates on the update site. The 1.5 stream has been merged back\ninto HEAD. So latest integration builds contains our latest 1.5 submission.\nCheck the jdt/core buildnotes to find out what bugs have been fixed.",
    "I close it. Please open new bugs if you still find errors in DOM/AST tree\ncreation with generics.\nFixed and released in HEAD.\nRegression tests added.",
    "Verified in I200409212000."
  ],
  "commentCreationDates": [
    "2004-04-19T13:04:59+02:00",
    "2004-04-19T16:42:33+02:00",
    "2004-04-19T16:43:08+02:00",
    "2004-04-19T17:01:40+02:00",
    "2004-04-20T11:58:00+02:00",
    "2004-05-19T16:00:17+02:00",
    "2004-05-19T16:41:36+02:00",
    "2004-05-24T16:02:15+02:00",
    "2004-05-25T12:11:23+02:00",
    "2004-05-25T23:34:38+02:00",
    "2004-05-26T11:25:04+02:00",
    "2004-06-05T17:28:51+02:00",
    "2004-06-05T17:40:13+02:00",
    "2004-06-06T10:37:56+02:00",
    "2004-06-06T16:21:35+02:00",
    "2004-06-07T12:35:21+02:00",
    "2004-06-07T17:58:42+02:00",
    "2004-06-14T14:24:47+02:00",
    "2004-06-14T17:28:50+02:00",
    "2004-06-14T17:36:59+02:00",
    "2004-06-14T17:40:09+02:00",
    "2004-06-14T18:22:41+02:00",
    "2004-06-17T18:36:41+02:00",
    "2004-06-18T16:23:40+02:00",
    "2004-06-19T01:12:40+02:00",
    "2004-06-29T04:46:08+02:00",
    "2004-06-29T11:47:52+02:00",
    "2004-08-09T21:04:26+02:00",
    "2004-08-19T21:58:24+02:00",
    "2004-09-22T15:31:57+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.IllegalArgumentException",
      "message": "Not yet implemented: convert(class  org.eclipse.jdt.internal.compiler.ast.ForeachStatement)",
      "elements": [
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:1792"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:398"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations",
          "source": "ASTConverter.java:209"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:1936"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:931"
        },
        {
          "method": "org.eclipse.jdt.core.dom.AST.convertCompilationUnit",
          "source": "AST.java:244"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.buildStructure",
          "source": "CompilationUnit.java:151"
        },
        {
          "method": "org.eclipse.jdt.internal.core.Openable.generateInfos",
          "source": "Openable.java:183"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaElement.openWhenClosed",
          "source": "JavaElement.java:543"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent",
          "source": "CompilationUnit.java:970"
        },
        {
          "method": "org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation",
          "source": "ReconcileWorkingCopyOperation.java:58"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.run",
          "source": "JavaModelOperation.java:700"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.runOperation",
          "source": "JavaModelOperation.java:739"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.reconcile",
          "source": "CompilationUnit.java:1111"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.reconcile",
          "source": "CompilationUnit.java:1080"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile",
          "source": "JavaReconcilingStrategy.java:85"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile",
          "source": "JavaReconcilingStrategy.java:118"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.CompositeReconcilingStrategy.reconcile",
          "source": "CompositeReconcilingStrategy.java:83"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile",
          "source": "JavaCompositeReconcilingStrategy.java:97"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.MonoReconciler.process",
          "source": "MonoReconciler.java:76"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run",
          "source": "AbstractReconciler.java:189"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "59052",
      "date": "2004-04-19T13:04:59+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "59052",
  "bugId": "59052",
  "date": "2004-04-19T13:04:59+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}