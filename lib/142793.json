{
  "comments": [
    "While working with the jdt the following error occured: (this is the .log file)\n\n!ENTRY org.eclipse.jdt.ui 4 2 2006-05-19 18:38:13.282\n!MESSAGE Problems occurred when invoking code from plug-in: \"org.eclipse.jdt.ui\".\n!STACK 0\njava.lang.NullPointerException\n        at org.eclipse.jdt.core.dom.ASTConverter.createFakeEmptyStatement(ASTConverter.java:3319)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2462)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1708)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2347)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:511)\n        at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:179)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2637)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1236)\n        at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)\n        at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:187)\n        at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:229)\n        at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:505)\n        at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:993)\n        at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:131)\n        at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:71)\n        at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:720)\n        at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:779)\n        at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1123)\n        at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:97)\n        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n        at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:82)\n        at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:145)\n        at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)\n        at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:94)\n        at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:75)\n        at org.eclipse.jdt.internal.ui.text.JavaReconciler.process(JavaReconciler.java:342)\n        at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:204)\n!ENTRY org.eclipse.jdt.ui 4 0 2006-05-19 18:38:13.364\n!MESSAGE Error in JDT Core during reconcile\n!STACK 0\njava.lang.NullPointerException\n        at org.eclipse.jdt.core.dom.ASTConverter.createFakeEmptyStatement(ASTConverter.java:3319)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2462)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1708)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2347)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:511)\n        at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:179)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2637)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1236)\n        at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)\n        at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:187)\n        at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:229)\n        at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:505)\n        at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:993)\n        at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:131)\n        at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:71)\n        at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:720)\n        at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:779)\n        at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1123)\n        at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:97)\n        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n        at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:82)\n        at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:145)\n        at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)\n        at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:94)\n        at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:75)\n        at org.eclipse.jdt.internal.ui.text.JavaReconciler.process(JavaReconciler.java:342)\n        at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:204)\n\n!ENTRY org.eclipse.ui 4 4 2006-05-19 18:43:13.425\n!MESSAGE Unhandled event loop exception\n\n!ENTRY org.eclipse.ui 4 0 2006-05-19 18:43:13.428\n!MESSAGE PermGen space\n!STACK 0\njava.lang.OutOfMemoryError: PermGen space\n\nI am experising this problem since M6 or RC1. Also My colleagues have encoutered this error for many times, but we could not reproduce the exact steps...\n\nWe found that the error is occuring only of 64 bits(AMD) machines and not on 32 bits(if that could help).\n\nWe are willing to help trace the error but dont know from where to start.  \n\nI have tried M6, RC1, RC2, RC3 and also Callisto RC1 and RC2,(not sure for M5 and below) but the error is occuring atleast once a day. \nWhen the error occures the workbench is closed.\n\nIt does not make any difference to set the vmargs -Xms -Xmx. The computer I am working on has 1GB RAM and values for -Xmx512m -Xmx768m have not helped.\n\nI will attache my complete eclipse configuration.\nOnce again - I am willing to help but dont know what to look for...",
    "Created an attachment (id\u003d42031)\nmy eclipse configuration (in UTF-8)\n\nThis is my eclipse configuration. The file is in UTF-8.",
    "I\u0027ll investigate.",
    "Could you please provide the compiler\u0027s preferences of the project where this is failing?\nIt would also help a lot if you could provide a test case. Ideally the compilation unit where the problem occurs.\nThanks.",
    "This would mean that you have a foreach statement with null as its action.\nI don\u0027t see how this is possible.\nCould you please try with the JIT disabled?",
    "Created an attachment (id\u003d42040)\njdt.core.prefs\n\nThe compiler settings for the project.",
    "I have start my eclipse with ./eclipse -Djava.compiler\u003d.\nI will work this way for a couple of days to see if this will help.",
    "Would it be possible to get the project as well?\nIs it 100% reproducable?\n\nSince you said this doesn\u0027t occur on 32 bits machine, I wonder if this is not a VM bug.\nYou might want to try a different VM.",
    "Providing a test case is difficult for me because I did not notice on which file does the error occured. But from now on I will be more careful to notice that and create an attachement with this file on the first opportunity.",
    "I can reproduce the stacktrace with the following test case\n\npublic class X {\n\n\tvoid bar(Collection\u003cString\u003e c) {\n\t\tfor(String s: c) {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\nBut when the NPE occurs my workbench isn\u0027t closed.",
    "Trying a different VM was the first thing to do when I saw the problem does not occur on 32 bit machines. \nI have tried sun-jdk-1.5.0.06, sun-jdk-1.5.0.05, sun-jre-bin-1.5.0.06 (I have not installed them especially for this problem - I just have them installed).",
    "I am not sure that the java.lang.OutOfMemoryError: PermGen space and the NPE are related.",
    "Yes the test case in comment_9 from David Audel  really cause the exception.\nBut this time the workbench does not close??? Strange... \n\nBut having this code in the file and scrolling throught this piece of code by hiding it, clicking on the file and then showing it makes the exception be thrown many times...\nJust scrolling does not throw the exception. You have to hide the foreach, then click on the file and then scroll to the foreach...",
    "With the test case of comment_9 the exception is thrown also on 32 bits machine. I just tried it...",
    "Martin, Philippe,\n\nThis is a case where the statement recovery failed and the action of the foreach statement is null.\nWe could try to create an fake empty statement, but in this case we would need to find a \"good\" position.\nWe could use the end position of the parent node since we need to ensure that the positions of this node is inside the position of its parent.\nWhat do you think?\n",
    "I confirm the explanation of Olivier.\n\nThe fake empty statement with the end of the \u0027foreach\u0027 as position would be good.\nWith a test case like\npublic class X {\n  void bar(Collection\u003cString\u003e c) {\n    for(String s: c) {\n      try {\n        bar();\n      }\n    }\n  }\n}\nthe resulting ast would be\npublic class X {\n  void bar(Collection\u003cString\u003e c) {\n    for(String s: c);\n    {\n       bar();\n    }\n  }\n}\n\nThis ast isn\u0027t correct but as the statement recovery has failed, the ast cannot be correct.\n\nFor the test case of comment 9, the statement recovery can probably be fixed, but the statement recovery can failed for another reason. So the ASTConverter should add the protection suggested by Olivier even if we fix the test case scenario.\n\nNote: the same problem cannot occurs for \u0027for\u0027, \u0027do\u0027 or \u0027while\u0027.",
    "I\u0027ll prepare a patch that will implement the proposal in comment 14.",
    "Created an attachment (id\u003d42057)\nProposed fix\n\n",
    "Created an attachment (id\u003d42059)\nRegression test\n\n",
    "With David\u0027s patch (he will post it after more testing), I get a better recovered tree. The for has a recovered block that contains a recovered try.\nI believe that both patches are useful. David\u0027s one covers this specific case and my patch makes the ast conversion more resilient to error or missing recovery in the error recovery.\nI would update the regression test if the patch from David is being released.\n\nIf David is confident with his patch, I would recommend it for 3.2 since this impact the reconciling (editing inside a CU and not just incorrect code).",
    "Candidate for RC6",
    "After discussing with David, I would suggest we address the NPE for RC6, and defer changing the statement recovery, since other similar cases need to be investigated, and recovered AST may be discussed (ie. is \"try {...}\" to be recovered into \"try{...}finally{}\" or rather as a block with no try ?).\nAlso, the recovery issue is orthogonal, David pls enter a separate PR for it.\n\n+1 for 3.2RC6. The NPE fix looks good.\n\nMartin/Dani - pls cast your vote.",
    "Mike - pls cast your vote\n\nOverall, the current behavior is a regression over 3.1. No client may notice the DOM AST difference compared to 3.1, as in 3.1, there was no statement recovery, and thus offending method body would have been empty.",
    "I opened a new bug report for the recovery problem with try statement (bug 143001).",
    "I\u0027m confused about the statement\n  int endPosition \u003d parent.getStartPosition() + parent.getLength() - 1;\nThat would point to the last character (inside) the parent statement\nCan the node make any assumptions about the parent and it\u0027s length?\nWhat if the parent is a block and has more than one child?\nImportant for AST clients is that all child positions are in order and never overlap.\n",
    "I don\u0027t see how a statement with a length 0 can overlap with any other statement.",
    "parent.getStartPosition() + parent.getLength() - 1 is the last inclusive position of the parent.",
    "If a client requests and AST without recovery will it still go through ASTConverter.createFakeEmptyStatement(...) (if not, where can I see this) and if so, will still go through the ASTRecoveryPropagator code? Or in simpler words: how is it guaranteed that the two changes are always called/used together?\n\nSecond question: is it 100% impossible that in  ASTRecoveryPropagator.visit(EmptyStatement) endPosition gets \u003c 0?",
    "The fake node marked with *\n\na.) parent [0, 5]\n  child 1 [0, 5]\n  child 2* [4, 0]   -\u003e child 2 is overlapping with child 1\n\nb.) parent [0, 5]\n  child 1 [0, 2]\n  child 2* [4, 0]\n  child 3 [3, 2]\n                    -\u003e child 2 is in wrong order:\n                       it\u0027s range must be between 2 and 3\n",
    "(In reply to comment #27)\n\u003e If a client requests and AST without recovery will it still go through\n\u003e ASTConverter.createFakeEmptyStatement(...) (if not, where can I see this) and\n\u003e if so, will still go through the ASTRecoveryPropagator code? Or in simpler\n\u003e words: how is it guaranteed that the two changes are always called/used\n\u003e together?\nIf there is no statement recovery, the createFakeEmptyStatement() cannot be called with null.\n",
    "What positions would you suggest for this fake node?\n",
    "I think you have to look at your left sibling at take its end position (and length 0)\n\na.) parent [0, 5]\n  child 1 [0, 5]\n  child 2* [5, 0]\n\nb.) parent [0, 5]\n  child 1 [0, 2]\n  child 2* [2, 0]\n  child 3 [3, 2]\n\nb.) parent [0, 5]\n  child 1* [0, 0]\n  child 2 [0, 3]\n  child 3 [3, 2]\n\n",
    "We could also don\u0027t set any position for the fake empty statement, but this would break the assumption that children are always included in the range of their parent except if we have a way to tag this node to say that it might not follow this rule.\nHow do we do it with the ast rewrite? What position do you give to inserted nodes ?\n\nI don\u0027t see how:\na.) parent [0, 5]\n  child 1 [0, 5]\n  child 2* [5, 0]\n\nare nodes with valid positions. 5 is not within the range of the parent.\nthe length is exclusive. So the parent contains positions from 0 to 4 inclusive. 5 cannot be a starting position of one of the children.",
    "The inserted nodes in the AST have -1, 0. It doesn\u0027t matter there, but so far for AST\u0027s createdby the ASTParser we could assume that all node have a position.\n\nCase a.) is of course dicussable but at least I think it wouldn\u0027t break our (and the ASTRewriter\u0027s) assumptions.\n\n",
    "(In reply to comment #27)\n\u003e Second question: is it 100% impossible that in \n\u003e ASTRecoveryPropagator.visit(EmptyStatement) endPosition gets \u003c 0?\nTo get endPosition \u003c 0, this means that the parent is empty at the position 0 (start \u003d 0 and length \u003d 0). I can test it, but I don\u0027t believe this is a valid case.",
    "The only other solution I can see is to propagate the null back up and completely remove the \"wrong\" statement.\nWhat do you prefer?",
    "will this discussion lead to an updated version of the patch?",
    "If necessary, yes.\nWe have two approaches here:\n1) Try to get the \"right\" sibling and update the positions of the fake empty statement with these positions.\n2) Don\u0027t create a fake empty statement for the null case. This needs to propagate the null back up to be removed from the right block. Then no positions need to be updated since the statement doesn\u0027t exist anymore after the conversion.\n\nIf the statement is not null, the existing cases where we create fake empty statements are perfect fine as is. The null case can only happen during the recovery. I will attach a new patch that reflects this other approach.",
    "Created an attachment (id\u003d42294)\nNew patch\n\nThis patch is removing all statements that are converted to null (handling of the createFakeEmptyStatement returning a null value).\nLet me know which one you prefer. Of course the original test case is also fixed with this patch. The method body ends up being empty in the following case:\n\npublic class X {\n\n        void bar(Collection\u003cString\u003e c) {\n                for(String s: c) {\n                        try {\n\n                        }\n                }\n        }\n}\n\nMartin and Markus, let me know if this affects JDT/UI. All DOM test cases from JDT/Core are passing with this patch.",
    "I believe that the second patch is safer. Removing the culprit statement leaves an AST tree well formed.\nShould the block be marked as MALFORMED? The ast recovery propagator is already tagging it as RECOVERED.",
    "Marin, Dani, Philippe and Mike,\n\nLet me know if you approve the second patch.",
    "Does the patch include code that provides the final answer your question \"Should the block be marked as MALFORMED?\"\n\n",
    "The block is marked as RECOVERED. Do we also want it tagged as MALFORMED?\nMy patch doesn\u0027t tag it as MALFORMED. It depends if this is required or not. I believe RECOVERED is good enough.\nMartin and Daniel, do you want it tagged as MALFORMED?",
    "I think the last approach is the way to go. RECOVERED is enough.\nThe only small fix I suggest is to be nicer if the elso block has a problem: No need to skip the whole if statement.\nthat means, change:\n\tfinal Statement elseStatement \u003d convert(statement2);\n\tif (elseStatement \u003d\u003d null) return null;\n\tifStatement.setElseStatement(elseStatement);\nto\n\tfinal Statement elseStatement \u003d convert(statement2);\n\tif (elseStatement !\u003d null) \n\t     ifStatement.setElseStatement(elseStatement);",
    "+1 for 3.2 RC6.",
    "+1",
    "(In reply to comment #43)\nOk, I\u0027ll preserve the if statement if the else statement conversion returns null.\nDo I have your +1 then for RC6?",
    "+1 for 3.2RC6",
    "+1",
    "Fixed and released in HEAD.\nRegression test added in org.eclipse.jdt.core.tests.dom.ASTConverter15Test.test0220",
    "Verified in I20060526-0010 for 3.2RC6",
    "Not sure if the bug is the same but I download the eclipse RC6 \nfrom Fri, 26 May 2006 -- 00:10 (-0400), and without changing any preferences and configurations I started working and after some time I noticed the following exception has occured:\n\n!ENTRY org.eclipse.jdt.ui 4 2 2006-05-30 12:03:50.786\n!MESSAGE Problems occurred when invoking code from plug-in: \"org.eclipse.jdt.ui\".\n!STACK 0\njava.lang.IllegalArgumentException\n        at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2599)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:483)\n        at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:179)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2420)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:511)\n        at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:179)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1242)\n        at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)\n        at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:187)\n        at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:229)\n        at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:505)\n        at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:993)\n        at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:131)\n        at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:71)\n        at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:720)\n        at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:779)\n        at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1123)\n        at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:97)\n        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)\n        at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:82)\n        at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:145)\n        at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)\n        at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:94)\n        at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:75)\n        at org.eclipse.jdt.internal.ui.text.JavaReconciler.process(JavaReconciler.java:342)\n        at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:204)\n\nI tried to reproduce the error but again I had no such luck.",
    "The stack traces are different. Please open a separate bug report.",
    "Was verified."
  ],
  "commentCreationDates": [
    "2006-05-19T17:59:14+02:00",
    "2006-05-19T18:01:36+02:00",
    "2006-05-19T18:03:54+02:00",
    "2006-05-19T18:05:55+02:00",
    "2006-05-19T18:08:57+02:00",
    "2006-05-19T18:35:25+02:00",
    "2006-05-19T18:38:51+02:00",
    "2006-05-19T18:40:17+02:00",
    "2006-05-19T18:41:24+02:00",
    "2006-05-19T18:44:29+02:00",
    "2006-05-19T18:45:40+02:00",
    "2006-05-19T18:51:11+02:00",
    "2006-05-19T18:53:02+02:00",
    "2006-05-19T19:02:11+02:00",
    "2006-05-19T19:15:27+02:00",
    "2006-05-19T19:45:27+02:00",
    "2006-05-19T19:52:09+02:00",
    "2006-05-19T20:22:01+02:00",
    "2006-05-19T20:22:46+02:00",
    "2006-05-19T21:43:03+02:00",
    "2006-05-20T13:16:04+02:00",
    "2006-05-22T17:17:05+02:00",
    "2006-05-22T17:19:04+02:00",
    "2006-05-22T17:25:47+02:00",
    "2006-05-23T18:20:41+02:00",
    "2006-05-23T18:23:40+02:00",
    "2006-05-23T18:24:07+02:00",
    "2006-05-23T18:26:23+02:00",
    "2006-05-23T18:33:34+02:00",
    "2006-05-23T18:36:56+02:00",
    "2006-05-23T18:47:29+02:00",
    "2006-05-23T19:09:21+02:00",
    "2006-05-23T19:13:36+02:00",
    "2006-05-23T19:22:39+02:00",
    "2006-05-23T19:30:09+02:00",
    "2006-05-23T19:42:33+02:00",
    "2006-05-23T19:56:02+02:00",
    "2006-05-23T20:02:28+02:00",
    "2006-05-23T20:09:13+02:00",
    "2006-05-23T20:26:38+02:00",
    "2006-05-23T21:10:40+02:00",
    "2006-05-23T21:25:58+02:00",
    "2006-05-23T22:14:41+02:00",
    "2006-05-24T10:22:03+02:00",
    "2006-05-24T10:25:44+02:00",
    "2006-05-24T15:38:47+02:00",
    "2006-05-24T17:20:36+02:00",
    "2006-05-24T17:44:34+02:00",
    "2006-05-24T17:47:59+02:00",
    "2006-05-25T02:52:34+02:00",
    "2006-05-26T17:36:11+02:00",
    "2006-05-30T11:40:51+02:00",
    "2006-05-30T13:38:16+02:00",
    "2006-05-30T13:38:40+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.createFakeEmptyStatement",
          "source": "ASTConverter.java:3319"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:2462"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:1708"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:2347"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:511"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations",
          "source": "ASTConverter.java:179"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:2637"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:1236"
        },
        {
          "method": "org.eclipse.jdt.core.dom.AST.convertCompilationUnit",
          "source": "AST.java:270"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.buildStructure",
          "source": "CompilationUnit.java:187"
        },
        {
          "method": "org.eclipse.jdt.internal.core.Openable.generateInfos",
          "source": "Openable.java:229"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaElement.openWhenClosed",
          "source": "JavaElement.java:505"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent",
          "source": "CompilationUnit.java:993"
        },
        {
          "method": "org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent",
          "source": "ReconcileWorkingCopyOperation.java:131"
        },
        {
          "method": "org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation",
          "source": "ReconcileWorkingCopyOperation.java:71"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.run",
          "source": "JavaModelOperation.java:720"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.runOperation",
          "source": "JavaModelOperation.java:779"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.reconcile",
          "source": "CompilationUnit.java:1123"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run",
          "source": "JavaReconcilingStrategy.java:97"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile",
          "source": "JavaReconcilingStrategy.java:82"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile",
          "source": "JavaReconcilingStrategy.java:145"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile",
          "source": "CompositeReconcilingStrategy.java:86"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile",
          "source": "JavaCompositeReconcilingStrategy.java:94"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.MonoReconciler.process",
          "source": "MonoReconciler.java:75"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.JavaReconciler.process",
          "source": "JavaReconciler.java:342"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run",
          "source": "AbstractReconciler.java:204"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "142793",
      "date": "2006-05-19T17:59:14+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.createFakeEmptyStatement",
          "source": "ASTConverter.java:3319"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:2462"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:1708"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:2347"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:511"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations",
          "source": "ASTConverter.java:179"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:2637"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:1236"
        },
        {
          "method": "org.eclipse.jdt.core.dom.AST.convertCompilationUnit",
          "source": "AST.java:270"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.buildStructure",
          "source": "CompilationUnit.java:187"
        },
        {
          "method": "org.eclipse.jdt.internal.core.Openable.generateInfos",
          "source": "Openable.java:229"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaElement.openWhenClosed",
          "source": "JavaElement.java:505"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent",
          "source": "CompilationUnit.java:993"
        },
        {
          "method": "org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent",
          "source": "ReconcileWorkingCopyOperation.java:131"
        },
        {
          "method": "org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation",
          "source": "ReconcileWorkingCopyOperation.java:71"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.run",
          "source": "JavaModelOperation.java:720"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.runOperation",
          "source": "JavaModelOperation.java:779"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.reconcile",
          "source": "CompilationUnit.java:1123"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run",
          "source": "JavaReconcilingStrategy.java:97"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile",
          "source": "JavaReconcilingStrategy.java:82"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile",
          "source": "JavaReconcilingStrategy.java:145"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile",
          "source": "CompositeReconcilingStrategy.java:86"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile",
          "source": "JavaCompositeReconcilingStrategy.java:94"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.MonoReconciler.process",
          "source": "MonoReconciler.java:75"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.JavaReconciler.process",
          "source": "JavaReconciler.java:342"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run",
          "source": "AbstractReconciler.java:204"
        }
      ],
      "number": 1,
      "commentIndex": 0,
      "bugId": "142793",
      "date": "2006-05-19T17:59:14+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.IllegalArgumentException",
      "elements": [
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.setSourceRange",
          "source": "ASTNode.java:2599"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:483"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations",
          "source": "ASTConverter.java:179"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:2659"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:2420"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:511"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations",
          "source": "ASTConverter.java:179"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:2659"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:1242"
        },
        {
          "method": "org.eclipse.jdt.core.dom.AST.convertCompilationUnit",
          "source": "AST.java:270"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.buildStructure",
          "source": "CompilationUnit.java:187"
        },
        {
          "method": "org.eclipse.jdt.internal.core.Openable.generateInfos",
          "source": "Openable.java:229"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaElement.openWhenClosed",
          "source": "JavaElement.java:505"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent",
          "source": "CompilationUnit.java:993"
        },
        {
          "method": "org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent",
          "source": "ReconcileWorkingCopyOperation.java:131"
        },
        {
          "method": "org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation",
          "source": "ReconcileWorkingCopyOperation.java:71"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.run",
          "source": "JavaModelOperation.java:720"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.runOperation",
          "source": "JavaModelOperation.java:779"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.reconcile",
          "source": "CompilationUnit.java:1123"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run",
          "source": "JavaReconcilingStrategy.java:97"
        },
        {
          "method": "org.eclipse.core.runtime.SafeRunner.run",
          "source": "SafeRunner.java:37"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile",
          "source": "JavaReconcilingStrategy.java:82"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile",
          "source": "JavaReconcilingStrategy.java:145"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile",
          "source": "CompositeReconcilingStrategy.java:86"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile",
          "source": "JavaCompositeReconcilingStrategy.java:94"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.MonoReconciler.process",
          "source": "MonoReconciler.java:75"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.JavaReconciler.process",
          "source": "JavaReconciler.java:342"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run",
          "source": "AbstractReconciler.java:204"
        }
      ],
      "number": 2,
      "commentIndex": 51,
      "bugId": "142793",
      "date": "2006-05-30T11:40:51+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "142793",
  "bugId": "142793",
  "date": "2006-05-19T17:59:14+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}