{
  "comments": [
    "copy of my proposal for @AJ if pointcut I came up with today and that everyone\nagree with\n---\n\nHere are my thought on the if() pointcut for @AJ stuff.\nI don\u0027t think it is reasonable to have string based if(....) bodies so\nhere is the proposal I am starting on - the main idea is : the\n@Pointcut annotated method acts as the if body (hence the if body is\nalready at hand etc etc)\n\nso simple !\nAlex\n\n// if() is somehow implicit ie we can know we have an if when we have\n// a static boolean @Pointcut annotatated method\n// TODO TBD -may help toString(), parsing and tools if we require the\nif() marker\n@Aspect\npublic class IfAspect {\n\n   static int I;\n\n   @Pointcut(\"execution(* Foo.do()) \u0026\u0026 if()\") // if(IfAspect.test())\n   public static boolean test() {\n       return I \u003e 0;\n   }\n\n   @Pointcut(\"execution(* Foo.do()) \u0026\u0026 if()\") //\nif(IfAspect.test2(thisJoinPoint)\n   public static boolean test2(JoinPoint jp) {// will require JP flags\n       return jp.getSignature().getName().startsWith(\"baz\") \u0026\u0026 I \u003e 0;\n   }\n\n   @Pointcut(\"execution(* Foo.do(int)) \u0026\u0026 args(val) \u0026\u0026 if()\")\n   public static boolean test3(int val) {//use of formal binding is\nstraightforward\n       return val + I \u003e 0;\n   }\n\n   @Before(\"test()\")\n   public void doBefore() {\n       System.out.println(\"IfAspect.doBefore\");\n   }\n\n   @Before(\"test2()\")\n   public void doBefore2() {\n       System.out.println(\"IfAspect.doBefore2\");\n   }\n\n   @Before(\"execution(* Foo.do()) \u0026\u0026 if()\") // enclosingDef is not a\n@Pointcut returning boolean, with public static access\n   public void doBefore3() {\n       System.out.println(\"NO WAY - compiler error\");\n   }\n}\n\n  ReplyReply to allForward\n\t\t\n\t\t\nAdrian Colyer \t\nto me, Andrew, Jonas\n\t More options\t  11:25 am (5 hours ago)\n\nI like the idea of the method containing the body of the if() pointcut - very\nelegant!  I don\u0027t think we want to make the if() completely implicit, so:\n\n@Pointcut(\"execution(* Foo.*(..))\")\npublic static boolean fooThings() {\n  return true;\n}\n\nshould be an error, and\n\n@Pointcut(\"execution(* Foo.*(..)) \u0026\u0026 if(true)\")\npublic void fooThings() {}\n\nwould also be an error (not allowed to specify body for if() pointcut in\nannotation style),\n\nbut\n\n@Pointcut(\"execution(* Foo.*(..)) \u0026\u0026 if()\")\npublic static boolean fooThings() {\n  return true;\n}\n\nis great!\n\n-- Adrian\nAdrian_Colyer@uk.ibm.com\n\n\nAlexandre Vasseur \u003cavasseur@gmail.com\u003e\n\n08/06/2005 10:02\nPlease respond to\nAlexandre Vasseur \u003cavasseur@gmail.com\u003e\n\n\t\nTo\n\tAdrian Colyer/UK/IBM@IBMGB, Andrew Clement/UK/IBM@IBMGB\ncc\n\tJonas Bon?r \u003cjboner@gmail.com\u003e\nSubject\n\tif pointcut in @AJ\n\n\t\n\n- Show quoted text -\n\n\n\nHere are my thought on the if() pointcut for @AJ stuff.\nI don\u0027t think it is reasonable to have string based if(....) bodies so\nhere is the proposal I am starting on - the main idea is : the\n@Pointcut annotated method acts as the if body (hence the if body is\nalready at hand etc etc)\n\nso simple !\nAlex\n\n// if() is somehow implicit ie we can know we have an if when we have\n// a static boolean @Pointcut annotatated method\n// TODO TBD -may help toString(), parsing and tools if we require the\nif() marker\n@Aspect\npublic class IfAspect {\n\n   static int I;\n\n   @Pointcut(\"execution(* Foo.do()) \u0026\u0026 if()\") // if(IfAspect.test())\n   public static boolean test() {\n       return I \u003e 0;\n   }\n\n   @Pointcut(\"execution(* Foo.do()) \u0026\u0026 if()\") //\nif(IfAspect.test2(thisJoinPoint)\n   public static boolean test2(JoinPoint jp) {// will require JP flags\n       return jp.getSignature().getName().startsWith(\"baz\") \u0026\u0026 I \u003e 0;\n   }\n\n   @Pointcut(\"execution(* Foo.do(int)) \u0026\u0026 args(val) \u0026\u0026 if()\")\n   public static boolean test3(int val) {//use of formal binding is\nstraightforward\n       return val + I \u003e 0;\n   }\n\n   @Before(\"test()\")\n   public void doBefore() {\n       System.out.println(\"IfAspect.doBefore\");\n   }\n\n   @Before(\"test2()\")\n   public void doBefore2() {\n       System.out.println(\"IfAspect.doBefore2\");\n   }\n\n   @Before(\"execution(* Foo.do()) \u0026\u0026 if()\") // enclosingDef is not a\n@Pointcut returning boolean, with public static access\n   public void doBefore3() {\n       System.out.println(\"NO WAY - compiler error\");\n   }\n}\n\n\n  ReplyReply to allForwardInvite Adrian to Gmail\n\t\t\n\t\t\nAlexandre Vasseur \t\nto Adrian, Andrew, Jonas\n\t More options\t  1:52 pm (2? hours ago)\nGreat - I reach the same \"if() is required\" conclusion\nthat was one of the last burden we had to go thru in terms of\nsemantics equivalence.\n\nThere is one implicit consequence: an anonymous pointcut\n(@Before(...)) cannot contain an if() in the @AJ style. That\u0027s the\nsmall special case to pay...\n\nAlex\n- Show quoted text -\n\nOn 6/8/05, Adrian Colyer \u003cadrian_colyer@uk.ibm.com\u003e wrote:\n\u003e\n\u003e I like the idea of the method containing the body of the if() pointcut -\n\u003e very elegant!  I don\u0027t think we want to make the if() completely implicit,\n\u003e so:\n\u003e\n\u003e @Pointcut(\"execution(* Foo.*(..))\")\n\u003e public static boolean fooThings() {\n\u003e   return true;\n\u003e }\n\u003e\n\u003e should be an error, and\n\u003e\n\u003e @Pointcut(\"execution(* Foo.*(..)) \u0026\u0026 if(true)\")\n\u003e public void fooThings() {}\n\u003e\n\u003e would also be an error (not allowed to specify body for if() pointcut in\n\u003e annotation style),\n\u003e\n\u003e but\n\u003e\n\u003e @Pointcut(\"execution(* Foo.*(..)) \u0026\u0026 if()\")\n\u003e public static boolean fooThings() {\n\u003e   return true;\n\u003e }\n\u003e\n\u003e is great!\n\u003e\n\u003e -- Adrian\n\u003e  Adrian_Colyer@uk.ibm.com\n\u003e\n\u003e\n\u003e\n\u003e  Alexandre Vasseur \u003cavasseur@gmail.com\u003e\n\u003e\n\u003e 08/06/2005 10:02\n\u003e\n\u003e Please respond to\n\u003e  Alexandre Vasseur \u003cavasseur@gmail.com\u003e\n\u003e\n\u003e\n\u003e To Adrian Colyer/UK/IBM@IBMGB, Andrew Clement/UK/IBM@IBMGB\n\u003e\n\u003e cc Jonas Bon?r \u003cjboner@gmail.com\u003e\n\u003e\n\u003e Subject if pointcut in @AJ\n\u003e\n\u003e\n\u003e\n\u003e\n\u003e\n\u003e Here are my thought on the if() pointcut for @AJ stuff.\n\u003e  I don\u0027t think it is reasonable to have string based if(....) bodies so\n\u003e  here is the proposal I am starting on - the main idea is : the\n\u003e  @Pointcut annotated method acts as the if body (hence the if body is\n\u003e  already at hand etc etc)\n\u003e\n\u003e  so simple !\n\u003e  Alex\n\u003e\n\u003e  // if() is somehow implicit ie we can know we have an if when we have\n\u003e  // a static boolean @Pointcut annotatated method\n\u003e  // TODO TBD -may help toString(), parsing and tools if we require the\n\u003e  if() marker\n\u003e  @Aspect\n\u003e  public class IfAspect {\n\u003e\n\u003e     static int I;\n\u003e\n\u003e     @Pointcut(\"execution(* Foo.do()) \u0026\u0026 if()\") // if(IfAspect.test())\n\u003e     public static boolean test() {\n\u003e         return I \u003e 0;\n\u003e     }\n\u003e\n\u003e     @Pointcut(\"execution(* Foo.do()) \u0026\u0026 if()\") //\n\u003e  if(IfAspect.test2(thisJoinPoint)\n\u003e     public static boolean test2(JoinPoint jp) {// will require JP flags\n\u003e         return jp.getSignature().getName().startsWith(\"baz\") \u0026\u0026 I \u003e 0;\n\u003e     }\n\u003e\n\u003e     @Pointcut(\"execution(* Foo.do(int)) \u0026\u0026 args(val) \u0026\u0026 if()\")\n\u003e     public static boolean test3(int val) {//use of formal binding is\n\u003e  straightforward\n\u003e         return val + I \u003e 0;\n\u003e     }\n\u003e\n\u003e     @Before(\"test()\")\n\u003e     public void doBefore() {\n\u003e         System.out.println(\"IfAspect.doBefore\");\n\u003e     }\n\u003e\n\u003e     @Before(\"test2()\")\n\u003e     public void doBefore2() {\n\u003e         System.out.println(\"IfAspect.doBefore2\");\n\u003e     }\n\u003e\n\u003e     @Before(\"execution(* Foo.do()) \u0026\u0026 if()\") // enclosingDef is not a\n\u003e  @Pointcut returning boolean, with public static access\n\u003e     public void doBefore3() {\n\u003e         System.out.println(\"NO WAY - compiler error\");\n\u003e     }\n\u003e  }\n\u003e\n\u003e\n\n  ReplyReply to allForward\n\t\t\n\t\t\nAlexandre Vasseur \t\nto Adrian\n\t More options\t  4:12 pm (15 minutes ago)\nI actually like that a lot:\n\n   @Pointcut(\"if()\")\n   public static boolean testONE(JoinPoint jp) {\n       System.out.println(\"\\tIfAspect.testONE\");\n       return jp.getSignature().getName().startsWith(\"do\");\n   }\n\nie a simple method gets turned into a full blown join point testing\nlibrary using regular Java",
    "Some short note to recap\u0027 on the rules:\n\n\"if()\" can only appear in a @Pointcut(..) expression, and appears as is (no\nif(....)). The such annotated method that usually is a \"public void\n\u003cname\u003e(\u003cformals\u003e) {}\" must then be a \"public static boolean \u003cname\u003e(\u003cformal ||\nimplicit JoinPoint stuff\u003e) { \u003ctest body\u003e }\"\n\nPointcut composition happens as usual ie formal AND implicit JoinPoint stuff\nmust be then bounded:\n\n@Pointcut(\"if() \u0026\u0026 args(i)\")\npublic static boolean test(JoinPoint jp, int i, JoinPoint.EnclosingStaticPart\nesjp) {\n   //... see implicit jp and esjp but explicit i\n   return true;\n}\n\n@Before(\"test(jp, val, enc) \u0026\u0026 someOtherPointcut()\") // all bound\npublic void beforeStuff(JoinPoint jp, JoinPoint.Enclosin.. enc, int val) {\n   ...\n}\n\n",
    "assigned to Adrian since some work for AJ-JDT stuff:\n\n1/ in IfPointcut, testmethod can be null sometime (at least a NPE happens now).\nThe important thing is that I handle the IfPointcut as for @style IF the\nextraParamFlag \u003d\u003d -1. So testMethod can perhaps be there (that would perhaps\nsave a lookup if it is there - but then it must be the user if body and not the\najc_if_xxx one..)\n\n2/ language rules have changed a bit (see below)\n\nTo work on it use the AtAjSyntaxTest, testIf method, and uncomment in syntax.xml\nwhere there is a    \u003c!-- FIXME AV - Adrian in JDT stuff --\u003e note.\n\n\nThanks\n/ (I wish I could do that myself - if so, just tell me if I should and what is\nthe process, where is the readme to do it etc etc)\n\nD:\\java\\jdk1.5.0_01\\bin\\java -Didea.launcher.port\u003d7534\n\"-Didea.launcher.library\u003dD:\\Program Files\\IntelliJ-IDEA-4.5\\bin\\breakgen.dll\"\n-Dfile.encoding\u003dwindows-1252 -classpath\n\"D:\\java\\jdk1.5.0_01\\jre\\lib\\charsets.jar;D:\\java\\jdk1.5.0_01\\jre\\lib\\deploy.jar;D:\\java\\jdk1.5.0_01\\jre\\lib\\javaws.jar;D:\\java\\jdk1.5.0_01\\jre\\lib\\jce.jar;D:\\java\\jdk1.5.0_01\\jre\\lib\\jsse.jar;D:\\java\\jdk1.5.0_01\\jre\\lib\\plugin.jar;D:\\java\\jdk1.5.0_01\\jre\\lib\\rt.jar;D:\\java\\jdk1.5.0_01\\jre\\lib\\ext\\dnsns.jar;D:\\java\\jdk1.5.0_01\\jre\\lib\\ext\\localedata.jar;D:\\java\\jdk1.5.0_01\\jre\\lib\\ext\\sunjce_provider.jar;D:\\java\\jdk1.5.0_01\\jre\\lib\\ext\\sunpkcs11.jar;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\tests\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\testing-drivers\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\bridge\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\lib\\junit\\junit.jar;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\util\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\weaver\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\runtime\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\bcel-builder\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\lib\\regexp\\jakarta-regexp-1.2.jar;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\testing-util\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\lib\\jdiff\\jdiff.jar;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\asm\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\testing\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\lib\\ant\\lib\\ant.jar;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\lib\\ant\\lib\\ant-launcher.jar;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\testing-client\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\ajde\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\org.aspectj.ajdt.core\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\org.eclipse.jdt.core\\jdtcore-for-aspectj.jar;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\taskdefs\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\lib\\commons\\commons.jar;D:\\java\\jdk1.5.0_01\\lib\\tools.jar;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\loadtime\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\aspectj5rt\\bin;D:\\aw\\cvs_aj\\org.aspectj-HEAD\\modules\\loadtime5\\bin;D:\\Program\nFiles\\IntelliJ-IDEA-4.5\\lib\\idea_rt.jar\"\ncom.intellij.rt.execution.application.AppMain\ncom.intellij.rt.execution.junit2.JUnitStarter -ideVersion5\norg.aspectj.systemtest.ajc150.ataspectj.AtAjSyntaxTests,testIfPointcut\nLOADING SUITE: ..\\tests\\src\\org\\aspectj\\systemtest\\ajc150\\ataspectj\\syntax.xml\nTEST: IfPointcutTest\t...test \"IfPointcutTest\" failed\nUnexpected error messages:\n\terror at (no source information available)\nC:\\Temp\\ajcSandbox\\ajcTest26370.tmp\\ataspectj\\IfPointcutTest.java:0::0 Internal\ncompiler error\njava.lang.NullPointerException\n\tat org.aspectj.weaver.patterns.IfPointcut.write(IfPointcut.java:120)\n\tat org.aspectj.weaver.patterns.AndPointcut.write(AndPointcut.java:119)\n\tat\norg.aspectj.weaver.ResolvedPointcutDefinition.write(ResolvedPointcutDefinition.java:72)\n\tat\norg.aspectj.weaver.AjAttribute$PointcutDeclarationAttribute.write(AjAttribute.java:349)\n\tat org.aspectj.weaver.AjAttribute.getBytes(AjAttribute.java:57)\n\tat org.aspectj.weaver.AjAttribute.getAllBytes(AjAttribute.java:70)\n\tat\norg.aspectj.ajdt.internal.compiler.ast.EclipseAttributeAdapter.getAllBytes(EclipseAttributeAdapter.java:31)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ClassFile.addAttributes(ClassFile.java:676)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateAttributes(TypeDeclaration.java:594)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:578)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:620)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:560)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:628)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:182)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:513)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:330)\n\tat\norg.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:727)\n\tat\norg.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)\n\n...\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:78)\n\n\terror at public static boolean positive(int i) {\n              \nC:\\Temp\\ajcSandbox\\ajcTest26370.tmp\\ataspectj\\IfPointcutTest.java:57:0::0\nPointcuts should have an empty method body\n\terror at public static boolean positive(int i) {\n              \nC:\\Temp\\ajcSandbox\\ajcTest26370.tmp\\ataspectj\\IfPointcutTest.java:57:0::0\nMethods annotated with @Pointcut must return void\nUnexpected fail messages:\n\tabort ABORT -- (NullPointerException) null\nnull\n",
    "I\u0027ll look into this shortly - and also write down any process hints for what has\nto be done in situations like this...",
    "reassign to Adrian for JDT fix",
    "fixed in ValidateAtAspectJAnnotationsVisitor and IfPointcut. When I enable the\nreferenced tests, they still fail but with formal unbound in pointcut errors. Is\nthis expected?? If not we can work some more on this tomorrow.",
    "Yes IfPointcut and IfPointcut2 should pass.\n\nThey pass when -Xdev:NoAtAspectJProcessing is used (see syntax.xml).\n\nWhen I uncomment the FIXME in syntax.xml :\nThe first one complains with a null body for \"positive\" method but the method\ndoes have a body.\nThe second one complains with a formal unbound, but all is bound (and the bcel\nweaver when -Xdev:NoAtAspectJProcessing is used does not complains).\n",
    "ok, will look into it this morning then.",
    "Problem with IfPointcutTest was that when looking for the matching method\ncontaining the test, we iterated over getDeclaredJavaMethods. When the @aspect\nwas compiled by ajc, this isn\u0027t quite right as the @pointcut method becomes\ntreated like a pointcut declaration. Fix was just to iterate over getMethods.\n\nIfPointcut2Test exercised a part of ValidateAtAspectJAnnotationsVisitor that we\nhadn\u0027t gone through before. This was missing the logic to create\n**Implicit**FormalBindings instead of regular FormalBindings for our special types.\n\nBoth tests are now passing for me.\nI\u0027m just running the full suite and then I\u0027ll commit if everything goes ok.\n",
    "ok, fix is committed.",
    "great! I could not figure out those details in order to fix that one.",
    "was M3 remind",
    "was M3 remind"
  ],
  "commentCreationDates": [
    "2005-06-08T16:28:41+02:00",
    "2005-06-08T16:35:30+02:00",
    "2005-06-09T14:27:43+02:00",
    "2005-06-09T14:43:34+02:00",
    "2005-07-05T11:45:03+02:00",
    "2005-08-15T18:56:49+02:00",
    "2005-08-16T17:22:33+02:00",
    "2005-08-17T09:42:14+02:00",
    "2005-08-17T10:26:03+02:00",
    "2005-08-17T10:41:37+02:00",
    "2005-08-17T10:55:23+02:00",
    "2005-09-27T15:27:11+02:00",
    "2005-09-27T15:28:39+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.aspectj.weaver.patterns.IfPointcut.write",
          "source": "IfPointcut.java:120"
        },
        {
          "method": "org.aspectj.weaver.patterns.AndPointcut.write",
          "source": "AndPointcut.java:119"
        },
        {
          "method": "org.aspectj.weaver.ResolvedPointcutDefinition.write",
          "source": "ResolvedPointcutDefinition.java:72"
        },
        {
          "method": "org.aspectj.weaver.AjAttribute$PointcutDeclarationAttribute.write",
          "source": "AjAttribute.java:349"
        },
        {
          "method": "org.aspectj.weaver.AjAttribute.getBytes",
          "source": "AjAttribute.java:57"
        },
        {
          "method": "org.aspectj.weaver.AjAttribute.getAllBytes",
          "source": "AjAttribute.java:70"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.ast.EclipseAttributeAdapter.getAllBytes",
          "source": "EclipseAttributeAdapter.java:31"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ClassFile.addAttributes",
          "source": "ClassFile.java:676"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateAttributes",
          "source": "TypeDeclaration.java:594"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode",
          "source": "TypeDeclaration.java:578"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode",
          "source": "TypeDeclaration.java:620"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode",
          "source": "TypeDeclaration.java:560"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode",
          "source": "TypeDeclaration.java:628"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode",
          "source": "CompilationUnitDeclaration.java:182"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process",
          "source": "Compiler.java:513"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:330"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation",
          "source": "AjBuildManager.java:727"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild",
          "source": "AjBuildManager.java:206"
        }
      ],
      "number": 0,
      "commentIndex": 2,
      "bugId": "98952",
      "date": "2005-06-09T14:27:43+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "98952",
  "bugId": "98952",
  "date": "2005-06-08T16:28:41+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}