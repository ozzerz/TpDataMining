{
  "comments": [
    "As we have been looking at enabling CDT with EFS support, we\u0027ve noticed a few issues.  Some notes are here:  http://wiki.eclipse.org/PTP/designs/remote/EFS.  In summary although URIs are useful for accessing a file on a remote system, they are not very good for doing path manipulation.\n\nWe also want to have code that is largely agnostic about where a path is coming from, not have duplicate APIs for dealing with both IPaths for local files and URIs for remote files, etc.\n\nWe have determined that there is a need for a new path representation which bridges local (native) paths and URIs.\n\nIn order to provide interoperability with EFS this new representation will have to be able to convert to a valid URI, but this should only be done when interacting directly with EFS itself, otherwise information may be lost.\n\nRequirements:\n    * Track the OS the original path was created for, and be able to extract the original path.\n    * Convert the path to another OS\n    * Convert the path to be relative to another machine (most likely with a different root directory and potentially on a different OS).\n    * Distinguish between local, remote, and local-relative-to-remote paths.\n    * Provides a toURI() method\n    * Provides utility functions for path manipulation (append, get at segment, get the file extension, etc.) similar to what is contained in IPath.\n    \nI have a draft of an interface, IUniversalPath, which fulfils these requirements.  Greg, Jason, and myself have iterated on this a couple of times, and now I\u0027d like to get some more feedback on it before we start using it.  I will attach the interface to this bug for review.  I\u0027m currently working on a concrete implementation (UniversalHierarchicalPath) in the meantime.",
    "Created an attachment (id\u003d80897)\nProposed interface.  Requires Java 5.\n\n",
    "Do we need a whole new interface or can we get buy with a utility that converts URIs to IPath\u0027s?\n\nAlso, make sure whatever you do to remember that parent nodes in the URI don\u0027t necessarily map to parent nodes in the file system. In particular, folders in the virtual file system may or may not map to folders in the file system, and even if they do map to real folders, they may contain files that they don\u0027t on the file system. That\u0027s why I\u0027d prefer to hide the real file system as much as possible.",
    "(In reply to comment #2)\n\u003e Do we need a whole new interface or can we get buy with a utility that converts\n\u003e URIs to IPath\u0027s?\n\nNo, because an IPath will lose information such as what machine the URI points to, for example.\n",
    "Why doesn\u0027t IUniversalPath extend IPath or URI? URI was probably envisioned by its creators as something universal that can eventually replace all other path representations. IUniversalPath seems to fragment the field even more instead of bringing unification.",
    "(In reply to comment #4)\n\u003e Why doesn\u0027t IUniversalPath extend IPath or URI? URI was probably envisioned by\n\u003e its creators as something universal that can eventually replace all other path\n\u003e representations. IUniversalPath seems to fragment the field even more instead\n\u003e of bringing unification.\n\nImplementing IPath would mean we are directly substitutable for any IPath, which we are not.  Clients that use IPaths are typically expecting local paths.\n\nURI is a final class so unfortunately you can\u0027t extend it.",
    "I\u0027m still confused. Can you give an example of where a IUniversalPath would be used?",
    "(In reply to comment #0)\n\u003e As we have been looking at enabling CDT with EFS support, we\u0027ve noticed a few\n\u003e issues.  Some notes are here:  http://wiki.eclipse.org/PTP/designs/remote/EFS. \n\nOn the Wiki it is stated that\n\n\u003e There is no device field in a URI. I.e., it\u0027s not legal to have c: in a URI. \n\nThat\u0027s not true. The path component may contain \u0027:\u0027.\n\nI also tried the example code on the Wiki and in my case it printed:\n\nfile:/c:/a/b/c\n",
    "(In reply to comment #7)\n\u003e (In reply to comment #0)\n\u003e \u003e As we have been looking at enabling CDT with EFS support, we\u0027ve noticed a few\n\u003e \u003e issues.  Some notes are here:  http://wiki.eclipse.org/PTP/designs/remote/EFS. \n\u003e \n\u003e On the Wiki it is stated that\n\u003e \n\u003e \u003e There is no device field in a URI. I.e., it\u0027s not legal to have c: in a URI. \n\u003e \n\u003e That\u0027s not true. The path component may contain \u0027:\u0027.\n\u003e \n\u003e I also tried the example code on the Wiki and in my case it printed:\n\u003e \n\u003e file:/c:/a/b/c\n\u003e \n\nIt\u0027s legal to have a \u0027:\u0027 in the first segment only if the path is absolute, so file:c:/a/b/c is not legal. In any case, I think the point is that we need to preserve the device and path as it exists on the remote machine. The URI loses this distinction, since there is no way to distinguish this from the path /c:/a/b/c (assuming \u0027:\u0027 is legal in a directory name).",
    "(In reply to comment #6)\n\u003e I\u0027m still confused. Can you give an example of where a IUniversalPath would be\n\u003e used?\n\u003e \n\nOne example would be where my project is located on a remote Windows machine, and I\u0027m going to be building on this machine. My local machine (running Eclipse) is Unix. Eclipse is computing the build dependencies locally, but issuing remote commands to the build host (or constructing makefiles that are executed remotely). Eclipse must perform path operations locally, but these paths represent locations on the remote machine. If IPath is used, then the path will be assumed to be a Unix path even though it is actually a Windows path (since IPath only represents a local path). I can\u0027t convert this path to a string to send as part of the remote build command, since I have no way of reconstructing the original Windows path, and it may also change the semantics of path operations.",
    "(In reply to comment #8)\n\u003e It\u0027s legal to have a \u0027:\u0027 in the first segment only if the path is absolute, so\n\u003e file:c:/a/b/c is not legal. In any case, I think the point is that we need to\n\u003e preserve the device and path as it exists on the remote machine. The URI loses\n\u003e this distinction, since there is no way to distinguish this from the path\n\u003e /c:/a/b/c (assuming \u0027:\u0027 is legal in a directory name).\n\nInternet Explorer uses the following URI for a file on my file system:\n\n   file:///C:/Documents%20and%20Settings/dschaefer/Desktop/CDT_ESE.pdf\n\nThis seems to be the standard URI format for Windows paths.",
    "(In reply to comment #9)\n\u003e One example would be where my project is located on a remote Windows machine,\n\u003e and I\u0027m going to be building on this machine. My local machine (running\n\u003e Eclipse) is Unix. Eclipse is computing the build dependencies locally, but\n\u003e issuing remote commands to the build host (or constructing makefiles that are\n\u003e executed remotely). Eclipse must perform path operations locally, but these\n\u003e paths represent locations on the remote machine. If IPath is used, then the\n\u003e path will be assumed to be a Unix path even though it is actually a Windows\n\u003e path (since IPath only represents a local path). I can\u0027t convert this path to a\n\u003e string to send as part of the remote build command, since I have no way of\n\u003e reconstructing the original Windows path, and it may also change the semantics\n\u003e of path operations.\n\nWhat kind of path operations are you thinking about? If all you\u0027re doing is converting URI\u0027s to file system path locations, why couldn\u0027t you simply convert them to a String? If you are doing some other operation, they you really have to ask the FileSystem to do it since you can\u0027t make assumpmtions on how the parent/child relationships in paths are actually implemented.",
    "(In reply to comment #10)\n\u003e (In reply to comment #8)\n\u003e \u003e It\u0027s legal to have a \u0027:\u0027 in the first segment only if the path is absolute, so\n\u003e \u003e file:c:/a/b/c is not legal. In any case, I think the point is that we need to\n\u003e \u003e preserve the device and path as it exists on the remote machine. The URI loses\n\u003e \u003e this distinction, since there is no way to distinguish this from the path\n\u003e \u003e /c:/a/b/c (assuming \u0027:\u0027 is legal in a directory name).\n\u003e \n\u003e Internet Explorer uses the following URI for a file on my file system:\n\u003e \n\u003e    file:///C:/Documents%20and%20Settings/dschaefer/Desktop/CDT_ESE.pdf\n\u003e \n\u003e This seems to be the standard URI format for Windows paths.\n\u003e \n\nThe path /C:/Documents and Settings/dschaefer/Desktop/CDT_ESE.pdf on my Mac uses the identical URI in Safari.",
    "(In reply to comment #8)\n\u003e It\u0027s legal to have a \u0027:\u0027 in the first segment only if the path is absolute, so\n\u003e file:c:/a/b/c is not legal.\n\nThe javadoc for the constructor says:\n\n\"If a path is given then it is appended. Any character not in the unreserved,\npunct, escaped, or other categories, and not equal to the slash character (\u0027/\u0027)\nor the commercial-at character (\u0027@\u0027), is quoted.\"\n\npunct: The characters in the string \",;:$\u0026+\u003d\"\n\nThe BNF listed in Appendix A of RFC 2396 also says that this is legal.  The\npath part can be absolute or an \"opaque_part\", which can contain colons.  So it\nwould seem the colon can appear as an un-escaped literal in the path segment.\n\nLegal doesn\u0027t mean it behaves \"correctly\" though.  The complication is when you\ntry to construct a URI from a String.  This runs a parser according to the\ngrammar listed in RFC 2396.  If you have a colon, then it falls under the\n\"opaque_part\" production in the grammar, and doesn\u0027t get parsed as a path.\n\nHere are some examples:\n\nExample #1:\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\n\npublic class test {\n\n        /**\n         * @param args\n         */\n        public static void main(String[] args) {\n                try {\n                        URI uri \u003d new URI(\"file:c:/a/b/c\");\n\n                        System.out.println(\"Path: \" + uri.getPath());\n                        // prints:  \"Path: null\"\n                        System.out.flush();\n                } catch (URISyntaxException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                }\n\n\n\n        }\n\n}\n\nExample #2:\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\n\npublic class test {\n\n        /**\n         * @param args\n         */\n        public static void main(String[] args) {\n                try {\n                        URI uri \u003d new URI(\"file://c:/a/b/c\");\n\n                        System.out.println(\"Path: \" + uri.getPath());\n                        // prints: \"Path: /a/b/c\"\n                        System.out.flush();\n                } catch (URISyntaxException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                }\n\n\n\n        }\n\n}\n\n\nThe above cases are not what you\u0027d expect.  Microsoft has their own URI\nimplementation (which has been in the news recently due to its security\nvulnerabilities), and this likely accounts for the different behaviour you see\nin your browser.\n\nIf you create the URI using one of the alternate constructors, you get other\nproblems...\n\nExample #3:\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\n\npublic class test {\n\n        /**\n         * @param args\n         */\n        public static void main(String[] args) {\n                try {\n                        URI uri \u003d new URI(\"file\", null, \"C:/a/b/c\", null);\n\n                        System.out.println(\"URI \u003d \" + uri.toString());\n                        System.out.println(\"Path: \" + uri.getPath());\n                        System.out.flush();\n                } catch (URISyntaxException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                }\n\n\n\n        }\n\n}\n\nWhen you try to run this you get:\n\njava.net.URISyntaxException: Relative path in absolute URI: file:C:/a/b/c\n        at java.net.URI.checkPath(URI.java:1787)\n        at java.net.URI.\u003cinit\u003e(URI.java:662)\n        at java.net.URI.\u003cinit\u003e(URI.java:764)\n        at test.main(test.java:12)\n\nSo, ok, if we force the path to be absolute...\n\nExample #4:\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\n\npublic class test {\n\n        /**\n         * @param args\n         */\n        public static void main(String[] args) {\n                try {\n                        URI uri \u003d new URI(\"file\", null, \"/C:/a/b/c\", null);\n\n                        System.out.println(\"URI \u003d \" + uri.toString());\n                        System.out.println(\"Path: \" + uri.getPath());\n                        System.out.flush();\n                } catch (URISyntaxException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                }\n\n\n\n        }\n\n}\n\nOutput:\n\nURI \u003d file:/C:/a/b/c\nPath: /C:/a/b/c\n\nSo the last case works... but the following is still a problem:\n\n\u003e In any case, I think the point is that we need to\n\u003e preserve the device and path as it exists on the remote machine. The URI loses\n\u003e this distinction, since there is no way to distinguish this from the path\n\u003e /c:/a/b/c (assuming \u0027:\u0027 is legal in a directory name).\n\u003e \n\nThis is a valid point no matter what the URI implementation",
    "(In reply to comment #11)\n\u003e What kind of path operations are you thinking about? If all you\u0027re doing is\n\u003e converting URI\u0027s to file system path locations, why couldn\u0027t you simply convert\n\u003e them to a String? If you are doing some other operation, they you really have\n\u003e to ask the FileSystem to do it since you can\u0027t make assumpmtions on how the\n\u003e parent/child relationships in paths are actually implemented.\n\nMy question still stands, though. I assume you are going to ask the file system to generate the path. Why can\u0027t it just be a String?",
    "Here are some thoughts from someone who:\n\n-  Hasn\u0027t been writing code for Eclipse for 1.5 years\n-  Thinks he remembers how IPath\u0027s and IResource\u0027s work\n-  Has only a conceptual knowledge of EFS\n\nIf I say something that is just plain wrong, let me know.\n\nI\u0027ll try to explain what I think we need in CDT.  This is not a detailed proposal and not well thought out, like Chris\u0027 is.\n\nThe basic idea is that we need a way for a CDT component (editor, builder, indexer, debugger, ...) to be able to ask:\n\nI\u0027m here, tell me how to (most efficiently) get to this file that I need.\n\nYes, I know that using EFS it might not be an actual physical file, but I\u0027m going to ignore that for now.\n\nWhat does \"here\" mean.  I think we need to be able to define \"locations\" that are of interest to CDT components.  Two obvious \"locations\" are the Workspace directory and the Project directory.  IResource handles them, but that\u0027s not enough.  IPath is a little more general, but when it gives you a relative path, the immediate question is \"relative to what?\"\n\nTherefore, here are some other locations:\n-  The BuilderWorkingDirectory: the directory in which the build is run\n-  The DebuggerExecutableDirectory: the directory which the debugger considers to be the root directory of the debuggee executable(s)\n-  The DebuggerWorkingDirectory: the directory which the debugger sets as the working directory of the debuggee\n-  The IndexerSourceDirectory: the directory which the indexer considers to be the base source directory of the files it is indexing\n-  The EditorSourceDirectory: the directory which the editor considers to be the base source directory of the files it is editing\n-  UserSourceDirectory: the place considered by the user to be where his sources are located - I guess a project may need to define multiple source directories\n-  etc\n\nProjects contain references to many files.  It is best (value judgement...) when these references are relative to a \"logical\" location.  If they are, then a project can be moved from one physical location to another and the logical locations can be re-mapped.\n\nFor support for remote projects, we want these locations to support multiple file systems (Windows, Linux, CygWin, other...) and to identify which one they belong to.\n\nFor the project file references, the user would need to be responsible for mapping the UserSourceDirectories to physical locations.  For the CDT component locations, it could be the responsibility of the Configuration (with help from the tool-chain) to set the defaults for the component locations.  \n\nThe CDT components can be distributed and the sources can be distributed.\n\nWhen a CDT component asks \"I\u0027m here, where is this file I need?\", \"here\" is a logical location or relative to a logical location.  The IUniversalPath (or whatever it is called) of the source is a logical location or relative to a logical location.  The answer to the question would be some path decription that could be used with some file service provider (maybe EFS) to get the contents of the file.  The routine that answers the question would probably need to consult with file system specific path resolvers - e.g., code that knows how to build paths on Windows, Linux, or other.\n\nThis is a very \"broad brush\" proposal.  Hopefully it is helpful in some way.\n\nLeo",
    " (In reply to comment #14)\n\u003e (In reply to comment #11)\n\u003e \u003e What kind of path operations are you thinking about? If all you\u0027re doing is\n\u003e \u003e converting URI\u0027s to file system path locations, why couldn\u0027t you simply\n\u003e convert\n\u003e \u003e them to a String? If you are doing some other operation, they you really have\n\u003e \u003e to ask the FileSystem to do it since you can\u0027t make assumpmtions on how the\n\u003e \u003e parent/child relationships in paths are actually implemented.\n\u003e \n\u003e My question still stands, though. I assume you are going to ask the file system\n\u003e to generate the path. Why can\u0027t it just be a String?\n\n\nStrings are difficult to manipulate.  It\u0027s the same reason people use IPath rather than String.  I don\u0027t think it\u0027s practical to say that everywhere in CDT that we use IPath that we\u0027re going to switch to using Strings.  The amount of path manipulation code in Managed Build alone that would have to now parse and manipulate Strings would be boggling.\n\nAs far as asking the FileSystem to do it, the IFilesystem has no path manipulation facilities.  You can get an IFileStore from the IFileSystem (even if it doesn\u0027t exist) and pull the URI from it, but in order to get the IFileStore object in the first place you need to know the URI or IPath, so really you have a chicken and egg problem.  Alternately, you could navigate the hierarchy to the first existing parent, and then create a handle to each element in the path as you drill down by just using its name, but that\u0027s really clunky IMO, and certainly the type of thing you\u0027d want to abstract away from with something like IUniversalPath.\n\nThe idea with the IUniversalPath stuff is that you can have a different implementation of it if your URI behaves differently.  I think the default implementation I\u0027m working for hierarchical URIs is going to cover 99% of the use cases though.  Any sensible filesystem is likely to be using hierarchical URIs, because modern filesystems are hierarchical (and even the crazy old non-hierarchical IBM filesystems can be accessed hierarchically now).  If you really have a crazy filesystem that requires that you navigate the IFilesystem hierarchy to figure out what your crazy URI will be, you can create a new implementation of IUniversalPath that does that.",
    " (In reply to comment #15)\n\u003e The basic idea is that we need a way for a CDT component (editor, builder,\n\u003e indexer, debugger, ...) to be able to ask:\n\u003e \n\u003e I\u0027m here, tell me how to (most efficiently) get to this file that I need.\n\u003e \n\nLeo,\n\nTake a look at http://wiki.eclipse.org/images/d/dd/Service_Model_For_Remote_Projects.pdf.\n\nI think that addresses part of what you are talking about.  It\u0027s admittedly not 100% fleshed out yet and we\u0027re planning some changes, but you can get the gist of it.  Each service provider is theoretically going to have its own set of configuration settings that it cares about.  Basically what you\u0027re talking about is each \"local\" provider (local in this case means the operation runs locally... the files themselves might be local or remote) needs to have a base directory.\n\nI had figured on the service model stuff being something that would live in PTP as opposed to CDT, but that\u0027s open to debate.\n\nThis probably merits a separate bugzilla.\n\n\u003eThe answer to the question would be some path decription that could be used with some file service provider (maybe EFS) to get the \u003econtents of the file.  The routine that answers the question would probably need to consult with file system specific path resolvers - e.g., \u003ecode that knows how to build paths on Windows, Linux, or other.\n\nMy thought would be that there would be a UniversalPathFactory that you would use when creating paths.  It would know which IUniversalPath implementation is appropriate for the IFilesystem that you\u0027re using.",
    "Created an attachment (id\u003d81292)\nupdated patch\n\n",
    "Continuing on with the concept of \"locations\", I think it would be useful for a \"service provider\" to have a \"location\" similar to what resource/file would have.  An example is, if the code that is generating the makefile for a project build is running where Eclipse is running and the source files and make are running on different machine(s), then the code in CDT can take these two \"locations\" and decide how the source files need to be referenced in the makefile.  If the \"service provider\" is generating the makefile, then I\u0027m concerned that a lot of the project data would need to be sent to the \"service provider\".\n\nI don\u0027t how the processing of the other potential service providers (e.g., indexer, debugger) would be split.  Does it make sense in all cases for the code that determines the paths needed to be used by the service provider to get to the resource/files that it needs, be in the Eclipse code and not in the service provider?\n\nLeo\n\n",
    "Created an attachment (id\u003d85201)\nUpdated patch.\n\nI am attaching an updated patch for people to review.  This patch includes:\n\n* updates to the IUniversalPath interface\n* supplied implementation of IUniversalPath (UniversalHierarchicalPath).  A lot of the implementation is borrowed from the platform\u0027s Path class.\n* JUnit test suite for UniversalHierarchicalPath.  Tests are included for both local paths and URI paths.\n* IPathFactory interface to facilitate creation of proper path objects for a given filesystem\n* RSEPathFactory\n* PathFactoryManager and associated extension point for managing contributed path factories\n\nI intend to check this in next week.  I am currently working in my private workspace on migrating the CModel and clients to using these interfaces."
  ],
  "commentCreationDates": [
    "2007-10-22T21:04:58+02:00",
    "2007-10-22T21:14:13+02:00",
    "2007-10-22T21:15:46+02:00",
    "2007-10-22T21:20:48+02:00",
    "2007-10-22T21:36:58+02:00",
    "2007-10-22T21:40:35+02:00",
    "2007-10-22T21:55:14+02:00",
    "2007-10-23T14:38:35+02:00",
    "2007-10-24T14:37:12+02:00",
    "2007-10-24T14:50:48+02:00",
    "2007-10-24T16:00:18+02:00",
    "2007-10-24T16:08:50+02:00",
    "2007-10-24T16:19:37+02:00",
    "2007-10-24T16:54:44+02:00",
    "2007-10-24T17:18:12+02:00",
    "2007-10-25T00:24:30+02:00",
    "2007-10-26T15:34:51+02:00",
    "2007-10-26T16:07:37+02:00",
    "2007-10-26T21:27:12+02:00",
    "2007-10-26T22:11:12+02:00",
    "2007-12-13T17:34:49+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.net.URISyntaxException",
      "message": "Relative path in absolute URI: file:C:/a/b/c",
      "elements": [
        {
          "method": "java.net.URI.checkPath",
          "source": "URI.java:1787"
        },
        {
          "method": "java.net.URI.\u003cinit\u003e",
          "source": "URI.java:662"
        },
        {
          "method": "java.net.URI.\u003cinit\u003e",
          "source": "URI.java:764"
        },
        {
          "method": "test.main",
          "source": "test.java:12"
        }
      ],
      "number": 0,
      "commentIndex": 13,
      "bugId": "207078",
      "date": "2007-10-24T16:54:44+02:00",
      "product": "CDT",
      "component": "cdt-core",
      "severity": "enhancement"
    }
  ],
  "groupId": "207078",
  "bugId": "207078",
  "date": "2007-10-22T21:04:58+02:00",
  "product": "CDT",
  "component": "cdt-core",
  "severity": "enhancement"
}