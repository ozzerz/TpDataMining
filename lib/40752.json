{
  "comments": [
    "following error occured during compiling my project. here is exception from \nlog. see java file below (i removed all methods except one, so there are a lot \nof comiplation errors, but the problem occurs even if all is okay there)\n\n\n!ENTRY org.eclipse.core.resources 2 75 Jul 25, 2003 15:12:34.100\n!MESSAGE Errors during build.\n!SUBENTRY 1 org.eclipse.jdt.core 2 75 Jul 25, 2003 15:12:34.100\n!MESSAGE org.eclipse.jdt.internal.compiler.lookup.ArrayBinding\n!STACK 0\njava.lang.ClassCastException: \norg.eclipse.jdt.internal.compiler.lookup.ArrayBinding\n\tat org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType\n(MessageSend.java:273)\n\tat org.eclipse.jdt.internal.compiler.ast.Expression.resolveTypeExpecting\n(Expression.java:447)\n\tat org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve\n(IfStatement.java:258)\n\tat org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:108)\n\tat org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve\n(ForStatement.java:321)\n\tat org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:108)\n\tat org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve\n(IfStatement.java:261)\n\tat org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:108)\n\tat org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve\n(IfStatement.java:261)\n\tat org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:108)\n\tat org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve\n(IfStatement.java:261)\n\tat \norg.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatement\ns(AbstractMethodDeclaration.java:361)\n\tat \norg.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements\n(MethodDeclaration.java:140)\n\tat \norg.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve\n(AbstractMethodDeclaration.java:351)\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve\n(TypeDeclaration.java:846)\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve\n(TypeDeclaration.java:887)\n\tat \norg.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve\n(CompilationUnitDeclaration.java:270)\n\tat org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)\n\tat org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:328)\n\tat org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile\n(AbstractImageBuilder.java:198)\n\tat org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile\n(AbstractImageBuilder.java:171)\n\tat org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build\n(BatchImageBuilder.java:51)\n\n\npackage com.bc.pt.graphing;\n\nimport java.awt.*;\nimport java.io.*;\nimport java.util.*;\n\n\nimport com.bc.expr.*;\n\n/**\n * This class is for drawing one graph\n */\npublic class SimpleGraph\n{\n\t/**\n\t * Get orientation of graph. If independent variable is x then \n\u003ccode\u003eorient\u003d0\u003c/code\u003e, if independent variable is y then \u003ccode\u003eorient\u003d1\u003c/code\u003e\n\t */\n\t\tprotected int orient;\t\t\t\t// graph \norientation\n\n\t\tprivate final static int HORZ\t\t\u003d 0;\n\t\tprivate final static int VERT\t\t\u003d 1;\n\n\t\tprivate int type;\t\t\t\t// graph type \n(equality, inequality)\n\n\t\tprivate final static int NONE\t\t\u003d -1;\n\t\tprivate final static int EQUAL\t\t\u003d 0;\n\t\tprivate final static int LESS\t\t\u003d 1;\n\t\tprivate final static int MORE\t\t\u003d 2;\n\t\tprivate final static int DOTS\t\t\u003d 3;\n\t\tprivate final static int IMPLICIT\t\u003d 4;\n\t\tprivate final static int PARAM\t\t\u003d 5;\n\n\t\tprivate boolean implicit \u003d false;\n\n\t\tprivate ExprChunk expr \u003d null;\n\t\tprivate ExprChunk exprX \u003d null;\t// expression to graph\n\t\tprivate ExprChunk exprY \u003d null;\t// expression to graph\n\t\tprivate Dot[] dots \u003d null;\n\n\t\tprivate static final ExprChunk t \u003d new ExprChunk\n(ExprChunk.VARIABLE,\"t\");\n\n\t\tprivate ExprContext varsX;\t\t// variables to use in \nexpression (for exprX)\n\t\tprivate ExprContext varsY;\t\t// variables to use in \nexpression (for exprY)\n\t\tprivate String depVarX;\t\t\t// name of dependant \nvariable (for exprX)\n\t\tprivate String depVarY;\t\t\t// name of dependant \nvariable (for exprY)\n\t\tprivate String depVar1,depVar2;\n\n\t\tprivate double minArg \u003d Double.NaN;\n\t\tprivate double maxArg \u003d Double.NaN;\n\n\t\tprivate double[] singularPoints\u003dnew double[0];\n\t\tprivate boolean[] drawedSingular\u003dnew boolean[0];\n\n\t\tprivate String minArgDot \u003d \"none\";\n\t\tprivate String maxArgDot \u003d \"none\";\n\n\t\tprivate int xSteps \u003d 100;\n\t\tprivate int ySteps \u003d 100;\n\t\tprivate int tSteps \u003d 100;\n\t\tprivate boolean previousIn\u003dtrue;\n\n\t\tprotected Style style \u003d new Style();  //style for drawing lines\n\n\t\tprotected boolean isUpdated \u003d false;\t// true is graph is \nchanged since previous paint\n\t\n\t\tprivate String interpolator \u003d null;\n\t\n\t\tprivate int dotRadius \u003d 4; // to change radius for dots\n\t/**\n\t * Coordinate plane where this graph is drawn\n\t */\n\t\tprotected Coordinates cp;\t\t\t// coordinate \nplane\n\n\t/**\n\t * Color for filling\n\t */\n\t\tprotected Color fillColor \u003d Color.cyan;\n\t/**\n\t * Filling pattern\n\t */\n\t\tprotected int[] fillPattern;\n\n\t/**\n\t * Is empty place in filling and in drawing line transparent\n\t */\n\t\tprotected boolean isTransparent \u003d true;\n\t/**\n\t *  Indicates whether to draw dots or not  \n\t */\t\n\t\tprivate String drawDots\u003dnull;\n\n\t\tprivate static Hashtable fillPatterns \u003d new Hashtable();\n\t\tprivate double[][] grid;\t//values of a function on a grid\n\n\t\tprivate double yMin, yMax, xMin, xMax;\n\n\t\tprotected Color bgColor \u003d Color.white;\n\n\t\tprivate static int[] pow \u003d \n{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n\n\n\n\t/**\n\t * Used to paint graphs and other over-axes elements\n\t */\n\tpublic synchronized void paint(Graphics g)\n\t{\n\t\t//System.out.println(\"paint: \"+type+\" \"+this.hashCode());\n\t\tif (type \u003d\u003d NONE) return;\n\n\t\tdouble minx \u003d orient \u003d\u003d HORZ ? Math.min(cp.getMinX(),cp.getMaxX\n()) : Math.min(cp.getMinY(),cp.getMaxY());\n\t\tdouble maxx \u003d orient \u003d\u003d HORZ ? Math.max(cp.getMinX(),cp.getMaxX\n()) : Math.max(cp.getMinY(),cp.getMaxY());\n\t\tdouble miny \u003d orient \u003d\u003d HORZ ? Math.min(cp.getMinY(),cp.getMaxY\n()) : Math.min(cp.getMinX(),cp.getMaxX());\n\t\tdouble maxy \u003d orient \u003d\u003d HORZ ? Math.max(cp.getMinY(),cp.getMaxY\n()) : Math.max(cp.getMinX(),cp.getMaxX());\n\n\t\tColor oldColor \u003d g.getColor();\n\t\tdouble[] curveParam\u003dnew double[]{0};\n\t\tif (type \u003d\u003d DOTS \u0026\u0026 dots!\u003dnull \u0026\u0026 dots.length\u003e0){\n\t\t\tif (interpolator \u003d\u003d null){\n\t\t\t\tPoint p0 \u003d null, p1 \u003d null;\n\t\t\t\tfor(int i\u003d0;i\u003cdots.length;i++) \n\t\t\t\t{\n\t\t\t\t\tp0 \u003d point(dots[i].x,dots[i].y);\n\t\t\t\t\tp0.y++;\n\t\t\t\t\tif (p0 !\u003d null \u0026\u0026 p1 !\u003d null) \nstyle.drawLine(g,p0.x,p0.y,p1.x,p1.y,curveParam);\n\t\t\t\t\tp1 \u003d p0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif (interpolator.equals(\"func\"))\n\t\t\t\t{\n\t\t\t\t\tInterpolator interp \u003d new \nSplineInterpolator();\n\t\t\t\t\tfor(int i\u003d0;i\u003cdots.length;i++) \n\t\t\t\t\t{\n\t\t\t\t\t\tinterp.addPoint(dots[i]);\n\t\t\t\t\t}\n\t\t\t\t\tg.setColor(style.lineColor);\n\t\t\t\t\tPoint p0 \u003d null, p1 \u003d null;\n\t\t\t\t\tdouble t0 \u003d dots[0].x, t1 \u003d dots\n[dots.length-1].x;\n\t\t\t\t\tdouble kt \u003d (t1-t0)/(double)tSteps;\n\t\t\t\t\tfor (int n\u003d0;n\u003c\u003dtSteps;n++) \n\t\t\t\t\t{\n\t\t\t\t\t\tp0 \u003d p1;\n\t\t\t\t\t\tdouble t \u003d t0 + kt*n;\n\t\t\t\t\t\tp1 \u003d point(t,interp.getValue\n(t));\n\t\t\t\t\t\tif (p0!\u003dnull)\n\t\t\t\t\t\t\tstyle.drawLine\n(g,p0.x,p0.y,p1.x,p1.y,curveParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{//parametric\n\t\t\t\t\tInterpolator interpx \u003d \ninterpolator.equals(\"line\") ? (Interpolator)new LinearInterpolator() : new \nSplineInterpolator();\n\t\t\t\t\tInterpolator interpy \u003d \ninterpolator.equals(\"line\") ? (Interpolator)new LinearInterpolator() : new \nSplineInterpolator();\n\t\t\t\t\tdouble t\u003d0.0;\n\t\t\t\t\tfor(int i\u003d0;i\u003cdots.length;i++) \n\t\t\t\t\t{\n\t\t\t\t\t\tinterpx.addPoint(new Dot(t,dots\n[i].x));\n\t\t\t\t\t\tinterpy.addPoint(new Dot(t,dots\n[i].y));\n\t\t\t\t\t\tt+\u003d1.0;\n\t\t\t\t\t}\n\t\t\t\t\tg.setColor(style.lineColor);\n\t\t\t\t\tPoint p0 \u003d null, p1 \u003d null;\n\t\t\t\t\tfor (t\u003d0;t\u003c(double)dots.length-1.0;t+\u003d\n(double)dots.length/(double)tSteps) \n\t\t\t\t\t{\n\t\t\t\t\t\tp0 \u003d p1;\n\t\t\t\t\t\tp1 \u003d point(interpx.getValue\n(t),interpy.getValue(t));\n\t\t\t\t\t\tif (p0!\u003dnull)\n\t\t\t\t\t\t\tstyle.drawLine\n(g,p0.x,p0.y,p1.x,p1.y,curveParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (interpolator \u003d\u003d null || drawDots!\u003dnull){\n\t\t\t\tif (drawDots \u003d\u003d null || drawDots.toLowerCase\n().equals(\"always\")){\n\t\t\t\t\tPoint p0;\n\t\t\t\t\tfor(int i\u003d0;i\u003cdots.length;i++) \n\t\t\t\t\t{\n\t\t\t\t\t\tp0 \u003d point(dots[i].x,dots[i].y);\n\t\t\t\t\t\tp0.y++;\n\t\t\t\t\t\tif (fillPattern.equals((int[])\nfillPatterns.get(\"EMPTY\"))) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tg.setColor(bgColor);\n\t\t\t\t\t\t\tg.fillOval(p0.x - \ndotRadius,p0.y-dotRadius,2*dotRadius,2*dotRadius);\n\t\t\t\t\t\t\tg.setColor\n(style.lineColor);\n\t\t\t\t\t\t\tg.drawOval(p0.x - \ndotRadius,p0.y-dotRadius,2*dotRadius,2*dotRadius);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tg.setColor\n(style.lineColor);\n\t\t\t\t\t\t\tg.fillOval(p0.x - \ndotRadius,p0.y-dotRadius,2*dotRadius,2*dotRadius);\n\t\t\t\t\t\t\tg.setColor(oldColor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\telse if (implicit) \n\t\t{\n\t\t\tg.setColor(style.lineColor);\n\t\t\tdrawImplicitCurve(g);\n\t\t\tg.setColor(oldColor);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tg.setColor(style.lineColor);\n\t\t\tPoint p0 \u003d null, p1 \u003d null;\n\t\t\tPoint dot0 \u003d null, dot1\u003dnull;\n\t\t\tboolean skipped \u003d false;\n\t\t\tdouble p0d[] \u003d null, p1d[] \u003d null;\n\t\t\tdouble prevFY\u003d0, prevFX\u003d0, prevDFY\u003d0, dfy \u003d 0;\n\t\t\tdouble t0 \u003d getMinArg(), t1 \u003d getMaxArg();\n\t\t\tdouble derivXmin \u003d Double.NaN, derivXmax \u003d Double.NaN;\n\t\t\tdouble[] arrowHadlePointsXmin \u003d null, \narrowHadlePointsXmax \u003d null;\n\n\t\t\t//x0\u003dstartParam,x1\u003dendParam\n\t\t\tdouble fx\u003d0,fy\u003d0;\n\t\t\tdouble kt \u003d (t1-t0)/(double)tSteps;\n\t\t\tpreviousIn\u003dtrue;\n\t\t\tfor (int n\u003d0;n\u003c\u003dtSteps;n++) {\n\t\t\t\tp0\u003dp1;\n\t\t\t\tp0d \u003d p1d;\n\t\t\t\tprevFY \u003d fy;\n\t\t\t\tprevFX \u003d fx;\n\t\t\t\tprevDFY \u003d dfy;\n\t\t\t\tdouble t \u003d t0 + kt*n;\n\t\t\t\tdouble distance \u003d kt;\n\t\t\t\tint nearestSP \u003d -1;\n\t\t\t\tfor (int sp \u003d 0; sp \u003c singularPoints.length; \nsp++){\n\t\t\t\t\tif (!drawedSingular[sp] \u0026\u0026 Math.abs\n(singularPoints[sp]-(t-kt))\u003cdistance){\n\t\t\t\t\t\tdistance \u003d Math.abs\n(singularPoints[sp]-(t-kt));\n\t\t\t\t\t\tnearestSP \u003d sp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nearestSP!\u003d-1){\n\t\t\t\t\tt \u003d singularPoints[nearestSP];\n\t\t\t\t\tdrawedSingular[nearestSP]\u003dtrue;\n\t\t\t\t}\n\t\t\t\tif (type \u003d\u003d PARAM) {\n\t\t\t\t\tif (depVarY !\u003d null \u0026\u0026 depVarX !\u003d null) \n{\n\t\t\t\t\t\tvarsY.setVariable(depVarY,new \nDouble(t));\n\t\t\t\t\t\tvarsX.setVariable(depVarX,new \nDouble(t));\n\t\t\t\t\t\tfy \u003d getYValue(t);\n\t\t\t\t\t\tfx \u003d getXValue(t);\n\t\t\t\t\t\tp1d \u003d (Double.isNaN(fx) || \nDouble.isInfinite(fx) || Double.isNaN(fy) || Double.isInfinite(fy)) ? null : \norient \u003d\u003d HORZ ? pointD(fx,fy) : pointD(fy,fx);\n\n\t\t\t\t\t\tif(n\u003d\u003d1 || n \u003d\u003d tSteps){\n\t\t\t\t\t\t\tdouble[] pPrev \u003d \nDouble.isNaN(prevFY) || Double.isInfinite(prevFY) ? null : orient \u003d\u003d HORZ ? \npointD(prevFX,prevFY) : pointD(prevFY,prevFX);\n\t\t\t\t\t\t\tdouble[] pCur \u003d \nDouble.isNaN(fy) || Double.isInfinite(fy) ? null : orient \u003d\u003d HORZ ? pointD\n(fx,fy) : pointD(fy,fx);\n\t\t\t\t\t\t\tif (pPrev!\u003dnull \u0026\u0026 pCur!\n\u003dnull){\n\t\t\t\t\t\t\t\tif(n\u003d\u003d1){\n\t\t\t\t\t\t\t\t\n\tarrowHadlePointsXmin \u003d new double[] {pPrev[0], pPrev[1], pCur[0], pCur\n[1]};\n\t\t\t\t\t\t\t\t\n\tderivXmin \u003d (-pCur[1]+pPrev[1])/(pCur[0]-pPrev[0]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\n\tarrowHadlePointsXmax \u003d new double[] {pCur[0], pCur[1], pPrev[0], pPrev\n[1]};\n\t\t\t\t\t\t\t\t\n\tderivXmax \u003d (-pCur[1]+pPrev[1])/(pCur[0]-pPrev[0]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t} else if (depVarY !\u003d null) {\n\t\t\t\t\tvarsY.setVariable(depVarY,new Double\n(t));\n\t\t\t\t\tfy \u003d getValue(t);\n\t\t\t\t\tfx \u003d t;\n\t\t\t\t\t//define derivative at the points Xmin \nand Xmax\n\t\t\t\t\tp1d \u003d Double.isNaN(fy) || \nDouble.isInfinite(fy) ? null : orient \u003d\u003d HORZ ? pointD(fx,fy) : pointD(fy,fx);\n\n\t\t\t\t\tif(n\u003d\u003d1 || n \u003d\u003d tSteps){\n\t\t\t\t\t\tdouble[] pPrev \u003d Double.isNaN\n(prevFY) || Double.isInfinite(prevFY) ? null : orient \u003d\u003d HORZ ? pointD\n(prevFX,prevFY) : pointD(prevFY,prevFX);\n\t\t\t\t\t\tdouble[] pCur \u003d Double.isNaN\n(fy) || Double.isInfinite(fy) ? null : orient \u003d\u003d HORZ ? pointD(fx,fy) : pointD\n(fy,fx);\n\n\t\t\t\t\t\tif (pPrev !\u003d null \u0026\u0026 pCur !\u003d \nnull){\n\t\t\t\t\t\t\tif(n\u003d\u003d1){\n\t\t\t\t\t\t\t\n\tarrowHadlePointsXmin \u003d new double[] {pPrev[0], pPrev[1], pCur[0], pCur\n[1]};\n\t\t\t\t\t\t\t\tderivXmin \u003d (-\npCur[1]+pPrev[1])/(pCur[0]-pPrev[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\n\tarrowHadlePointsXmax \u003d new double[] {pCur[0], pCur[1], pPrev[0], pPrev\n[1]};\n\t\t\t\t\t\t\t\tderivXmax \u003d (-\npCur[1]+pPrev[1])/(pCur[0]-pPrev[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp1 \u003d (p1d \u003d\u003d null) ? null : new Point( (int)p1d\n[0], (int)p1d[1] );\n\t\t\t\tboolean currentIn \u003d fy \u003e miny \u0026\u0026 fy \u003c maxy \u0026\u0026 \nfx \u003e minx \u0026\u0026 fx \u003c maxx;\n\t\t\t\tdfy \u003d fy - prevFY;\n\t\t\t\tif (p0 !\u003d null \u0026\u0026 p1 !\u003d null) {\n\t\t\t\t\tif (n\u003d\u003d1){\n\t\t\t\t\t\tdot0 \u003d new Point(p0);\n\t\t\t\t\t}\n\t\t\t\t\tif (n\u003d\u003dtSteps){\n\t\t\t\t\t\tdot1 \u003d new Point(p1);\n\t\t\t\t\t}\n\t\t\t\t\tif (currentIn || previousIn  ||  \nskipped){\n\t\t\t\t\t\tboolean skip \u003d false;\n\t\t\t\t\t\tif (p0 !\u003d null  \u0026\u0026  n \u003c tSteps  \n\u0026\u0026  singularPoints.length \u003d\u003d 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (n \u003e 1  \u0026\u0026  \ncurrentIn  \u0026\u0026  Math.abs( dfy - prevDFY ) \u003c 0.00000001 \u0026\u0026 type !\u003d PARAM)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// this line \nsegment is a continuation of the previous segment\n\t\t\t\t\t\t\t\tskip \u003d true;\n\t\t\t\t\t\t\t\tp1 \u003d p0;\n\t\t\t\t\t\t\t\tp1d \u003d p0d;\n\t\t\t\t\t\t\t\tcurrentIn \u003d \npreviousIn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tskip \u003d skip || (Math.abs(p0d[0]-\np1d[0])\u003e1e4) || (Math.abs(p0d[1]-p1d[1])\u003e1e4);\n\t\t\t\t\t\t//System.out.print( skip ? \"-\n\" : \"d\" );\n\t\t\t\t\t\tif (! skip )\n\t\t\t\t\t\t\tstyle.drawLineD(g,p0d\n[0],p0d[1],p1d[0],p1d[1],curveParam,true);\n\t\t\t\t\t\tskipped \u003d skip;\n\t\t\t\t\t}else\n\t\t\t\t\t\tstyle.flush(g);\n                                        \n\t\t\t\t}\n\t\t\t\tpreviousIn \u003d currentIn;\n\t\t\t\tif (nearestSP!\u003d-1) {\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dot0 !\u003d null){\n\t\t\t\tstyle.flush(g);\n\t\t\t\tif (minArgDot.equals(\"opened\") || \nminArgDot.equals(\"open\")) {\n\t\t\t\t\tColor old \u003d g.getColor();\n\t\t\t\t\tg.setColor(bgColor);\n\t\t\t\t\tg.fillOval(dot0.x-4,dot0.y-4,8,8);\n\t\t\t\t\tg.setColor(old);\n\t\t\t\t\tg.drawOval(dot0.x-4,dot0.y-4,8,8);\n\t\t\t\t}\n\t\t\t\telse if (minArgDot.equals(\"closed\")){\n\t\t\t\t\tg.fillOval(dot0.x-4,dot0.y-4,8,8);\n\t\t\t\t\tg.drawOval(dot0.x-4,dot0.y-4,8,8);\n\t\t\t\t}else if(minArgDot.equals(\"arrow-like\")){\n\t\t\t\t\tdrawArrow(g, dot0, derivXmin, \narrowHadlePointsXmin);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dot1 !\u003d null){\n\t\t\t\tstyle.flush(g);\n\t\t\t\tif (maxArgDot.equals(\"opened\") || \nmaxArgDot.equals(\"open\")) {\n\t\t\t\t\tColor old \u003d g.getColor();\n\t\t\t\t\tg.setColor(bgColor);\n\t\t\t\t\tg.fillOval(dot1.x-4,dot1.y-4,8,8);\n\t\t\t\t\tg.setColor(old);\n\t\t\t\t\tg.drawOval(dot1.x-4,dot1.y-4,8,8);\n\t\t\t\t}\n\t\t\t\telse if (maxArgDot.equals(\"closed\")){\n\t\t\t\t\tg.fillOval(dot1.x-4,dot1.y-4,8,8);\n\t\t\t\t\tg.drawOval(dot1.x-4,dot1.y-4,8,8);\n\t\t\t\t}else if(maxArgDot.equals(\"arrow-like\")){\n\t\t\t\t\tdrawArrow(g, dot1, derivXmax, \narrowHadlePointsXmax);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstyle.flush(g);\n\n\t\tg.setColor(oldColor);\n\t\tisUpdated \u003d true;\n\t}\n\n\n\n}",
    "this problem is in the following line of the code:\n\nif (fillPattern.equals((int[])fillPatterns.get(\"EMPTY\"))) ; \n",
    "proposed patch, sorry i didn\u0027t downloaded sdk yet, so i didn\u0027t verify it\nIndex: CastExpression.java\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nRCS \nfile: /home/eclipse/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compi\nler/ast/CastExpression.java,v\nretrieving revision 1.45\ndiff -u -r1.45 CastExpression.java\n--- CastExpression.java\t22 Jul 2003 11:30:47 -0000\t1.45\n+++ CastExpression.java\t25 Jul 2003 11:46:57 -0000\n@@ -244,7 +244,7 @@\n \t * Cast expressions will considered as useful if removing them all \nwould actually bind to a different method\n \t * (no fine grain analysis on per casted argument basis, simply \nseparate widening cast from narrowing ones)\n \t */\n-\tpublic static void checkNeedForArgumentCasts(BlockScope scope, \nExpression receiver, ReferenceBinding receiverType, MethodBinding binding, \nExpression[] arguments, TypeBinding[] argumentTypes, final InvocationSite \ninvocationSite) {\n+\tpublic static void checkNeedForArgumentCasts(BlockScope scope, \nExpression receiver, TypeBinding receiverType, MethodBinding binding, Expression\n[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite) \n{\n \t\n \t\tif (scope.environment().options.getSeverity\n(CompilerOptions.UnnecessaryTypeCheck) \u003d\u003d ProblemSeverities.Ignore) return;\n \t\t\n@@ -346,7 +346,7 @@\n \t\t}\n \t}\n \n-\tprivate static void checkAlternateBinding(BlockScope scope, Expression \nreceiver, ReferenceBinding receiverType, MethodBinding binding, Expression[] \narguments, TypeBinding[] originalArgumentTypes, TypeBinding[] \nalternateArgumentTypes, final InvocationSite invocationSite) {\n+\tprivate static void checkAlternateBinding(BlockScope scope, Expression \nreceiver, TypeBinding receiverType, MethodBinding binding, Expression[] \narguments, TypeBinding[] originalArgumentTypes, TypeBinding[] \nalternateArgumentTypes, final InvocationSite invocationSite) {\n \n \t\t\tInvocationSite fakeInvocationSite \u003d new InvocationSite()\n{\t\n \t\t\t\tpublic boolean isSuperAccess(){ return \ninvocationSite.isSuperAccess(); }\n@@ -357,7 +357,7 @@\n \t\t\t};\t\n \t\t\tMethodBinding bindingIfNoCast;\n \t\t\tif (binding.isConstructor()) {\n-\t\t\t\tbindingIfNoCast \u003d scope.getConstructor\n(receiverType, alternateArgumentTypes, fakeInvocationSite);\n+\t\t\t\tbindingIfNoCast \u003d scope.getConstructor\n((ReferenceBinding)receiverType, alternateArgumentTypes, fakeInvocationSite);\n \t\t\t} else {\n \t\t\t\tbindingIfNoCast \u003d receiver.isImplicitThis()\n \t\t\t\t\t? scope.getImplicitMethod\n(binding.selector, alternateArgumentTypes, fakeInvocationSite)\nIndex: MessageSend.java\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nRCS \nfile: /home/eclipse/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compi\nler/ast/MessageSend.java,v\nretrieving revision 1.49\ndiff -u -r1.49 MessageSend.java\n--- MessageSend.java\t22 Jul 2003 11:30:47 -0000\t1.49\n+++ MessageSend.java\t25 Jul 2003 11:46:58 -0000\n@@ -267,7 +267,7 @@\n \t\t\targuments[i].implicitWidening(binding.parameters[i], \nargumentTypes[i]);\n \t\t}\n \t\tif (containsCast) {\n-\t\t\tCastExpression.checkNeedForArgumentCasts(scope, \nthis.receiver, (ReferenceBinding)receiverType, binding, this.arguments, \nargumentTypes, this);\n+\t\t\tCastExpression.checkNeedForArgumentCasts(scope, \nthis.receiver, receiverType, binding, this.arguments, argumentTypes, this);\n \t\t}\n \t}\n \t//-------message send that are known to fail at compile time-----------\n",
    "i put my current oth.eclipse.jdt.core (patched) to 3.0 M2 and it solved the \nproblem.",
    "Reproduced on simple test case:\n\npublic class X {\n\tpublic void foo(Map map) {\n\t\tint[] fillPattern \u003d new int[0];\n\t\tif (fillPattern.equals((int[])map.get(\"x\"))) {\n\t\t}\n\t}\n}\n\n",
    "Contributed fix is good. Integrated. \nRegression test added.",
    "Fixed",
    "Thanks for the patch, makes our life much easier \u003cg\u003e",
    "*** Bug 40953 has been marked as a duplicate of this bug. ***",
    "Verified."
  ],
  "commentCreationDates": [
    "2003-07-25T13:20:29+02:00",
    "2003-07-25T13:28:31+02:00",
    "2003-07-25T13:48:59+02:00",
    "2003-07-25T14:00:23+02:00",
    "2003-07-25T14:08:02+02:00",
    "2003-07-25T14:23:11+02:00",
    "2003-07-25T14:23:30+02:00",
    "2003-07-25T14:43:12+02:00",
    "2003-07-30T21:35:14+02:00",
    "2003-08-28T10:54:51+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ClassCastException",
      "message": "org.eclipse.jdt.internal.compiler.lookup.ArrayBinding",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType",
          "source": "MessageSend.java:273"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.Expression.resolveTypeExpecting",
          "source": "Expression.java:447"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve",
          "source": "IfStatement.java:258"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.Block.resolve",
          "source": "Block.java:108"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve",
          "source": "ForStatement.java:321"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.Block.resolve",
          "source": "Block.java:108"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve",
          "source": "IfStatement.java:261"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.Block.resolve",
          "source": "Block.java:108"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve",
          "source": "IfStatement.java:261"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.Block.resolve",
          "source": "Block.java:108"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve",
          "source": "IfStatement.java:261"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements",
          "source": "AbstractMethodDeclaration.java:361"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements",
          "source": "MethodDeclaration.java:140"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve",
          "source": "AbstractMethodDeclaration.java:351"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:846"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:887"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve",
          "source": "CompilationUnitDeclaration.java:270"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.process",
          "source": "Compiler.java:533"
        },
        {
          "method": "org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:328"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:198"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile",
          "source": "AbstractImageBuilder.java:171"
        },
        {
          "method": "org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build",
          "source": "BatchImageBuilder.java:51"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "40752",
      "date": "2003-07-25T13:20:29+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "40752",
  "bugId": "40752",
  "date": "2003-07-25T13:20:29+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}