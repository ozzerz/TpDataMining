{
  "comments": [
    "I have a simple class:\n\npublic class Swit {\n\n  protected Swit() {\n    this(3);\n  }\n\n  protected Swit(int p) {\n    switch (p) {\n      case 3: break;\n    }\n  }\n}\n\nAnd a simpl(ish) aspect:\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.Signature;\nimport org.aspectj.lang.reflect.SourceLocation;\n\npublic aspect FFDC {\n\n    pointcut initializers( ) : staticinitialization( * ) || initialization( \n*.new(..) );\n    pointcut methodsAndConstructors( ) : execution(* *(..)) || execution(new\n(..) );\n    pointcut guarded( ) :  initializers( ) || methodsAndConstructors( );    \n\n    final pointcut nonStaticContext( Object o ) : this( o );\n\n    after(Object o) throwing(Throwable t) : guarded( ) \u0026\u0026 nonStaticContext( \no ) { }\n\n}\n\nCompiling these two with \u0027ajc Swit.java FFDC.java\u0027 results in:\ntrouble in: \npublic class Swit extends java.lang.Object:\n  protected void \u003cinit\u003e():\n                    ALOAD_0     // Swit this   (line 4)\n                    ICONST_3\n                    ISTORE_3\n                    ASTORE_2\n                    ALOAD_2   (line 7)\n                    INVOKESPECIAL java.lang.Object.\u003cinit\u003e ()V\n    initialization(void Swit.\u003cinit\u003e())\n    | catch java.lang.Throwable -\u003e E2\n    | | constructor-execution(void Swit.\u003cinit\u003e(int))\n    | | | catch java.lang.Throwable -\u003e E1\n    | | | |         ILOAD_3   (line 8)\n    | | | |         TABLESWITCH\n    | | | |           3: \tnull\n    | | | |           default: \tL0\n    | | | |     L0: GOTO L1   (line 11)\n    | | | catch java.lang.Throwable -\u003e E1\n    | | |       E1: ASTORE 4\n    | | |           INVOKESTATIC FFDC.aspectOf ()LFFDC;\n    | | |           ALOAD_2\n    | | |           ALOAD 4\n    | | |           INVOKEVIRTUAL FFDC.ajc$afterThrowing$FFDC$1d8 \n(Ljava/lang/Object;Ljava/lang/Throwable;)V\n    | | |           ALOAD 4\n    | | |           ATHROW\n    | | constructor-execution(void Swit.\u003cinit\u003e(int))\n    | |         L1: NOP\n    | | constructor-execution(void Swit.\u003cinit\u003e())\n    | | | catch java.lang.Throwable -\u003e E0\n    | | | |         RETURN   (line 5)\n    | | | catch java.lang.Throwable -\u003e E0\n    | | |       E0: ASTORE_1\n    | | |           INVOKESTATIC FFDC.aspectOf ()LFFDC;\n    | | |           ALOAD_0\n    | | |           ALOAD_1\n    | | |           INVOKEVIRTUAL FFDC.ajc$afterThrowing$FFDC$1d8 \n(Ljava/lang/Object;Ljava/lang/Throwable;)V\n    | | |           ALOAD_1\n    | | |           ATHROW\n    | | constructor-execution(void Swit.\u003cinit\u003e())\n    | catch java.lang.Throwable -\u003e E2\n    |           E2: ASTORE 6\n    |               INVOKESTATIC FFDC.aspectOf ()LFFDC;\n    |               ALOAD_0\n    |               ALOAD 6\n    |               INVOKEVIRTUAL FFDC.ajc$afterThrowing$FFDC$1d8 \n(Ljava/lang/Object;Ljava/lang/Throwable;)V\n    |               ALOAD 6\n    |               ATHROW\n    initialization(void Swit.\u003cinit\u003e())\n  end protected void \u003cinit\u003e()\n\n  protected void \u003cinit\u003e(int):\n                    ALOAD_0     // Swit this   (line 7)\n                    INVOKESPECIAL java.lang.Object.\u003cinit\u003e ()V\n    initialization(void Swit.\u003cinit\u003e(int))\n    | catch java.lang.Throwable -\u003e E1\n    | | constructor-execution(void Swit.\u003cinit\u003e(int))\n    | | | catch java.lang.Throwable -\u003e E0\n    | | | |         ILOAD_1     // int arg0   (line 8)\n    | | | |         TABLESWITCH\n    | | | |           3: \tnull\n    | | | |           default: \tL0\n    | | | |     L0: RETURN   (line 11)\n    | | | catch java.lang.Throwable -\u003e E0\n    | | |       E0: ASTORE_2\n    | | |           INVOKESTATIC FFDC.aspectOf ()LFFDC;\n    | | |           ALOAD_0\n    | | |           ALOAD_2\n    | | |           INVOKEVIRTUAL FFDC.ajc$afterThrowing$FFDC$1d8 \n(Ljava/lang/Object;Ljava/lang/Throwable;)V\n    | | |           ALOAD_2\n    | | |           ATHROW\n    | | constructor-execution(void Swit.\u003cinit\u003e(int))\n    | catch java.lang.Throwable -\u003e E1\n    |           E1: ASTORE_3\n    |               INVOKESTATIC FFDC.aspectOf ()LFFDC;\n    |               ALOAD_0\n    |               ALOAD_3\n    |               INVOKEVIRTUAL FFDC.ajc$afterThrowing$FFDC$1d8 \n(Ljava/lang/Object;Ljava/lang/Throwable;)V\n    |               ALOAD_3\n    |               ATHROW\n    initialization(void Swit.\u003cinit\u003e(int))\n  end protected void \u003cinit\u003e(int)\n\nend public class Swit\nABORT\nException thrown from AspectJ 1.1.0\n\nThis might be logged as a bug already -- find current bugs at\n  http://bugs.eclipse.org/bugs/buglist.cgi?product\u003dAspectJ\u0026component\u003dCompiler\n\nBugs for exceptions thrown have titles File:line from the top stack, \ne.g., \"SomeFile.java:243\"\n\nIf you don\u0027t find the exception below in a bug, please add a new bug\nat http://bugs.eclipse.org/bugs/enter_bug.cgi?product\u003dAspectJ\nTo make the bug a priority, please include a test program\nthat can reproduce this exception.\nnull\njava.lang.NullPointerException\n\tat org.aspectj.weaver.bcel.LazyMethodGen.remap(LazyMethodGen.java:892)\n\tat org.aspectj.weaver.bcel.LazyMethodGen.packBody\n(LazyMethodGen.java:800)\n\tat org.aspectj.weaver.bcel.LazyMethodGen.pack(LazyMethodGen.java:706)\n\tat org.aspectj.weaver.bcel.LazyMethodGen.getMethod\n(LazyMethodGen.java:284)\n\tat org.aspectj.weaver.bcel.LazyClassGen.writeBack\n(LazyClassGen.java:164)\n\tat org.aspectj.weaver.bcel.LazyClassGen.getJavaClass\n(LazyClassGen.java:169)\n\tat org.aspectj.weaver.bcel.BcelWeaver.dump(BcelWeaver.java:417)\n\tat org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:364)\n\tat org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:335)\n\tat org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:272)\n\tat \norg.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFile\ns(AjBuildManager.java:256)\n\tat org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild\n(AjBuildManager.java:164)\n\tat org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild\n(AjBuildManager.java:78)\n\tat org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:106)\n\tat org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)\n\tat org.aspectj.tools.ajc.Main.run(Main.java:217)\n\tat org.aspectj.tools.ajc.Main.runMain(Main.java:155)\n\tat org.aspectj.tools.ajc.Main.main(Main.java:72)\n\n1 fail|abort",
    "I should add.  If I stop the first constructor from calling the second, the \nproblem goes away.",
    "This is an easy to reproduce bug, and I\u0027m raising it to a P2/critical bug \nbecause it\u0027s fairly serious.\n\nMy quick investigation suggests that the bug is caused by the Select \ninstruction have two targets that are both the same InstructionHandle, and \nthat is causing problems to the code movement in \nBcelClassWeaver.genInlineInstructions.  I\u0027m cc\u0027ing Erik since this is his code \nand he has the most experience with bcel\u0027s instruction target code.\n\nA test is in bugs/NewSwitch.java and ajcTestsFailing.xml.\n\nAs a work-around/improvement, I believe that you shouldn\u0027t include \ninitialization join points in your FFDC code in 1.1.  In 1.1, all constructor-\nexecution join points include any non-static initializer code since there\u0027s no \nway to separate that code from the actual constructor body in a bytecode form.\n\ninitialization join points are very expensive to implement because they \nrequire inlining of constructor bodies.  Since you don\u0027t appear to need them \nhere, you\u0027d be better off without them.",
    "After some investigation ... this problem is due to the fact that cloning \nSelect instructions is not working as expected.  Because Java clone() is being \nused, the InstructionHandle[] array field \u0027targets\u0027 within the Select \ninstruction is not copied, only the reference is copied.\n\nThis means the code in genInlineInstructions() which inlines the constructor \ncode from one constructor to the other breaks because when it patches up \nthe \u0027targets\u0027 for any Select instructions that get inlined - when it modifies \nany of the \u0027targets\u0027 entries, it is breaking the original version of the Select \nstatement.  The remap() function was blowing up when processing the select \nstatement as it was attempting to lookup an instructionhandle that only existed \nin the method where the same statement had just been inlined.\n\nAm I making sense ?\n\nAnyway... its a BCEL bug to do with Select() not implementing clone/copy quite \nright.  The patch in aspectj to get around it is to programmatically build a \ncopy of the select statement (Using the SWITCH class) and inline the copy.\n\nI\u0027ve run all the tests (I believe) and it works, and the NewSwitch test now \nworks too.  Here is the patch for BcelClassWeaver:\n\n--------------------8\u003c------------------------\n\nIndex: BcelClassWeaver.java\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nRCS \nfile: /home/technology/org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/Bc\nelClassWeaver.java,v\nretrieving revision 1.13\ndiff -u -r1.13 BcelClassWeaver.java\n--- BcelClassWeaver.java\t2 May 2003 06:28:16 -0000\t1.13\n+++ BcelClassWeaver.java\t15 Jul 2003 13:56:06 -0000\n@@ -44,6 +44,7 @@\n import org.apache.bcel.generic.PUTSTATIC;\n import org.apache.bcel.generic.RET;\n import org.apache.bcel.generic.ReturnInstruction;\n+import org.apache.bcel.generic.SWITCH;\n import org.apache.bcel.generic.Select;\n import org.apache.bcel.generic.Type;\n import org.aspectj.bridge.IMessage;\n@@ -462,7 +463,28 @@\n \t\t\t\t\tdest \u003d ret.append\n(fact.createBranchInstruction(Constants.GOTO, end));\n \t\t\t\t}\n \t\t\t} else if (fresh instanceof BranchInstruction) {\n-\t\t\t\tdest \u003d ret.append((BranchInstruction) fresh);\n+\t\t\t\tif (fresh instanceof Select) {\n+\t\t\t      // Bugzilla #39479\n+\t\t\t      // Need to manually copy Select instructions - if \nwe rely on the the \u0027fresh\u0027 object\n+\t\t\t      // created by copy() above, the InstructionHandle \narray \u0027targets\u0027 inside the Select\n+\t\t\t      // object will not have been deep copied, so \nmodifying targets in fresh will modify\n+\t\t\t      // the original Select - not what we want !  (It \nis a bug in BCEL to do with cloning\n+\t\t\t      // Select objects).\n+\t\t\t\t  Select freshSelect \u003d (Select)fresh;\n+\t\t\t\t  \n+\t\t\t\t  // Create a new targets array that looks just \nlike the existing one\n+\t\t\t\t  InstructionHandle[] targets \u003d new \nInstructionHandle[freshSelect.getTargets().length];\n+\t\t\t\t  for (int i \u003d 0; i \u003c targets.length; i++) {\n+\t\t\t\t\ttargets[i] \u003d freshSelect.getTargets()\n[i];\n+\t\t\t\t  }\n+\t\t\t\t  \n+\t\t\t\t  // Create a new select statement with the new \ntargets array\n+\t\t\t\t  SWITCH switchStatement \u003d new SWITCH\n(freshSelect.getMatchs(),targets,freshSelect.getTarget());\n+\t\t\t\t  Select sel \u003d (Select)\nswitchStatement.getInstruction();\t\n+\t\t\t\t  dest \u003d ret.append((BranchInstruction)sel);\n+\t\t\t\t} else {\n+ \t\t\t\t  dest \u003d ret.append((BranchInstruction) fresh);\n+\t\t\t\t}\n \t\t\t} else if (\n \t\t\t\tfresh instanceof LocalVariableInstruction || \nfresh instanceof RET) {\n \t\t\t\tIndexedInstruction indexed \u003d \n(IndexedInstruction) fresh;\n\n--------------------8\u003c------------------------\n\n\nIs that fix ok?\n",
    "Created an attachment (id\u003d5462)\nPatch for BCELClassWeaver\n\nSorry about embedding the patch in the previous comment - I thought it would\nwork.  it doesnt, you cant cut/paste it from the bug report into Eclipse. \nHopefully attaching the patch like this will be better.",
    "*** Bug 40109 has been marked as a duplicate of this bug. ***",
    "Fix implemented based on excellent patch contributed by Andy Clement.  One \nimprovement was made to generalize the patch with a single method \norg.aspectj.weaver.bcel.Utility.copyInstruction\nthat works-around the bug in Select.copy().  Changed all calls to\nInstruction.copy() to use this new method, would be nice to add the\nrule:\n   \t * declare error:\n   \t *     call(* Instruction.copy()) \u0026\u0026 within(org.aspectj.weaver)\n   \t *       \u0026\u0026 !withincode(* Utility.copyInstruction(Instruction)):\n   \t *     \"use Utility.copyInstruction to work-around bug in Select.copy\n()\";\n",
    "updated target milestone field to 1.1.1"
  ],
  "commentCreationDates": [
    "2003-06-30T15:21:02+02:00",
    "2003-06-30T15:22:19+02:00",
    "2003-07-03T02:10:13+02:00",
    "2003-07-15T16:04:25+02:00",
    "2003-07-15T16:14:04+02:00",
    "2003-07-17T01:28:04+02:00",
    "2003-07-17T01:30:35+02:00",
    "2003-08-28T14:06:26+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.aspectj.weaver.bcel.LazyMethodGen.remap",
          "source": "LazyMethodGen.java:892"
        },
        {
          "method": "org.aspectj.weaver.bcel.LazyMethodGen.packBody",
          "source": "LazyMethodGen.java:800"
        },
        {
          "method": "org.aspectj.weaver.bcel.LazyMethodGen.pack",
          "source": "LazyMethodGen.java:706"
        },
        {
          "method": "org.aspectj.weaver.bcel.LazyMethodGen.getMethod",
          "source": "LazyMethodGen.java:284"
        },
        {
          "method": "org.aspectj.weaver.bcel.LazyClassGen.writeBack",
          "source": "LazyClassGen.java:164"
        },
        {
          "method": "org.aspectj.weaver.bcel.LazyClassGen.getJavaClass",
          "source": "LazyClassGen.java:169"
        },
        {
          "method": "org.aspectj.weaver.bcel.BcelWeaver.dump",
          "source": "BcelWeaver.java:417"
        },
        {
          "method": "org.aspectj.weaver.bcel.BcelWeaver.weave",
          "source": "BcelWeaver.java:364"
        },
        {
          "method": "org.aspectj.weaver.bcel.BcelWeaver.weave",
          "source": "BcelWeaver.java:335"
        },
        {
          "method": "org.aspectj.weaver.bcel.BcelWeaver.weave",
          "source": "BcelWeaver.java:272"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles",
          "source": "AjBuildManager.java:256"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild",
          "source": "AjBuildManager.java:164"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild",
          "source": "AjBuildManager.java:78"
        },
        {
          "method": "org.aspectj.ajdt.ajc.AjdtCommand.doCommand",
          "source": "AjdtCommand.java:106"
        },
        {
          "method": "org.aspectj.ajdt.ajc.AjdtCommand.runCommand",
          "source": "AjdtCommand.java:60"
        },
        {
          "method": "org.aspectj.tools.ajc.Main.run",
          "source": "Main.java:217"
        },
        {
          "method": "org.aspectj.tools.ajc.Main.runMain",
          "source": "Main.java:155"
        },
        {
          "method": "org.aspectj.tools.ajc.Main.main",
          "source": "Main.java:72"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "39479",
      "date": "2003-06-30T15:21:02+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "critical"
    }
  ],
  "groupId": "39479",
  "bugId": "39479",
  "date": "2003-06-30T15:21:02+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "critical"
}