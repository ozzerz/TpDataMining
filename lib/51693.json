{
  "comments": [
    "This is a bench mark for string drawing and measuring. I will run it on \ndifferent platforms and add the result here.\n\nimport org.eclipse.swt.graphics.*;\nimport org.eclipse.swt.widgets.*;\n\n\npublic class StringBench {\n\t\nstatic final int COUNT \u003d 100000;\n\t\nstatic void test(String msg, GC gc) {\n\tlong time;\n\tString s1 \u003d \"Hello\", s2 \u003d \"There\";\n\ttime \u003d -System.currentTimeMillis();\n\tfor (int i\u003d0; i\u003cCOUNT; i++) {\n\t\tgc.drawString(s1, 10, 50, true);\n\t\tgc.drawString(s2, 10, 150, true);\n\t}\n\tSystem.out.println (msg + \" drawString() - count\u003d\" + COUNT + \" time\u003d\" \n+ (System.currentTimeMillis() + time) + \" ms\");\n\ttime \u003d -System.currentTimeMillis();\n\tfor (int i\u003d0; i\u003cCOUNT; i++) {\n\t\tgc.stringExtent(s1);\n\t\tgc.stringExtent(s2);\n\t}\n\tSystem.out.println (msg + \" stringExtent() - count\u003d\" + COUNT + \" \ntime\u003d\" + (System.currentTimeMillis() + time) + \" ms\");\n}\n\npublic static void main (String [] args) {\n\tDisplay display \u003d new Display ();\n\tShell shell \u003d new Shell (display);\n\tshell.setSize(500, 500);\n\tshell.open ();\n\tGC gc \u003d new GC (shell);\n\ttest(\"Control\", gc);\n\tgc.dispose ();\n\tImage image \u003d new Image(display, 500, 500);\n\tgc \u003d new GC(image);\n\ttest(\"Image\", gc);\n\tgc.dispose();\n\timage.dispose();\n//\twhile (!shell.isDisposed ()) {\n//\t\tif (!display.readAndDispatch ()) display.sleep ();\n//\t}\n\tdisplay.dispose ();\n}\n}",
    "Windows Xp Professinal Version 2002 Service Pack 1\nPentium 4 CPU 2.00GHz\n512MB of RAM\n\nControl drawString() - count\u003d100000 time\u003d1563 ms\nControl stringExtent() - count\u003d100000 time\u003d672 ms\nImage drawString() - count\u003d100000 time\u003d1313 ms\nImage stringExtent() - count\u003d100000 time\u003d656 ms\n",
    "Mac OS X Version 10.3.1\nDual 1.25 GHz PowerPC G4\n2 MB L3 cache per processor\n1GB DDR SDRAM\n\nControl drawString() - count\u003d100000 time\u003d15905 ms\nControl stringExtent() - count\u003d100000 time\u003d10701 ms\nImage drawString() - count\u003d100000 time\u003d13494 ms\nImage stringExtent() - count\u003d100000 time\u003d10562 ms\n",
    "Mac OS X Version 10.2.8\nDual 1.25 GHz PowerPC G4\n2 MB L3 cache per processor\n1GB DDR SDRAM\n\nControl drawString() - count\u003d100000 time\u003d29251 ms\nControl stringExtent() - count\u003d100000 time\u003d15897 ms\nImage drawString() - count\u003d100000 time\u003d23810 ms\nImage stringExtent() - count\u003d100000 time\u003d15392 ms",
    "PowerBook G4 AL\nMac OS X Version 10.3.2\n1.25 GHz PowerPC G4\n512k L2 cache\n0 MB L3 cache\n1.5GB DDR SDRAM\n\njava version \"1.4.2_03\"\nJava(TM) 2 Runtime Environment, Standard Edition (build 1.4.2_03-117.1)\nJava HotSpot(TM) Client VM (build 1.4.2-34, mixed mode)\n\nControl drawString() - count\u003d100000 time\u003d19218 ms\nControl stringExtent() - count\u003d100000 time\u003d11150 ms\nImage drawString() - count\u003d100000 time\u003d13708 ms\nImage stringExtent() - count\u003d100000 time\u003d11085 ms\n",
    "Note: One line of the bench was wrapped at a bad spot (inside a string literal).",
    "That\u0027s definately faster than me, Andre ;-)\n\nPowerBook G4 AL\nMac OS X Version 10.3.2\n1 GHz PowerPC G4\n512k L2 cache\n0 MB L3 cache\n1.5GB DDR SDRAM\n\njava version \"1.4.2_03\"\nJava(TM) 2 Runtime Environment, Standard Edition (build 1.4.2_03-117.1)\nJava HotSpot(TM) Client VM (build 1.4.2-34, mixed mode)\n\nControl drawString() - count\u003d100000 time\u003d22934 ms\nControl stringExtent() - count\u003d100000 time\u003d15211 ms\nImage drawString() - count\u003d100000 time\u003d18847 ms\nImage stringExtent() - count\u003d100000 time\u003d14706 ms\n",
    "GTK - glib2-2.2.1-1/gtk2-2.2.1-4/pango-1.2.1-3\nIntel(R) Pentium(R) 4 CPU 2.53GHz\nMem 512Mb\n\nControl drawString() - count\u003d100000 time\u003d28093 ms\nControl stringExtent() - count\u003d100000 time\u003d11064 ms\nImage drawString() - count\u003d100000 time\u003d16439 ms\nImage stringExtent() - count\u003d100000 time\u003d10852 ms",
    "Motif\nIntel(R) Pentium(R) 4 CPU 2.53GHz\nMem 512Mb\n\nControl drawString() - count\u003d100000 time\u003d6959 ms\nControl stringExtent() - count\u003d100000 time\u003d1768 ms\nImage drawString() - count\u003d100000 time\u003d2643 ms\nImage stringExtent() - count\u003d100000 time\u003d1736 ms",
    "This is a funny (sad?) one:\n\nWindows 2000 on Virtual PC 6.1 on my PowerBook\n(same configuration as comment 4)\nJRE 1.4.1\n\nControl drawString() - count\u003d100000 time\u003d8732 ms\nControl stringExtent() - count\u003d100000 time\u003d1382 ms\nImage drawString() - count\u003d100000 time\u003d3896 ms\nImage stringExtent() - count\u003d100000 time\u003d1022 ms",
    "My results for Windows xp thinkpad celeron 1Ghz 512ram eclipse 3.0M7\n\nControl drawString() - count\u003d100000 time\u003d1071 ms\nControl stringExtent() - count\u003d100000time\u003d361 ms\nImage drawString() - count\u003d100000 time\u003d1222 ms\nImage stringExtent() - count\u003d100000time\u003d310 ms\n\nI will post my results for same machine next",
    "These are my results for linux on the same thinkpad celeron 1Ghz 512ram as above\nwith eclipse 3.0M7\n\nGTK 2.2.4 gnome 2.4 blackdown jvm 1.4\n\nControl drawString() - count\u003d100000 time\u003d14662 ms\nControl stringExtent() - count\u003d100000time\u003d9836 ms\nImage drawString() - count\u003d100000 time\u003d17375 ms\nImage stringExtent() - count\u003d100000time\u003d9944 ms\n\nquite a performance difference",
    "Comment to #7:\n\nNote: Pango 1.2.5 is much faster than 1.2.1",
    "I\u0027ve added an attachment to Bug #37683 which should contain gc.drawString() \nfrom SWT. This attachment should have been made here. Sorry for that. \n \nThere is a bug (I admit, it\u0027s a quick hack based on an example from GTK+) \nwhich slows it down tremendously but maybe this \"bug\" helps us to find why \nit\u0027s slow in SWT. \n \nSee my comments at \nhttps://bugs.eclipse.org/bugs/show_bug.cgi?id\u003d37683#c156 \n \nI guess if someone who knows about SWT can look at my code, he should be able \nto find the problem very quickly. If it looks OK, we can pass the benchmark on \nto Owen Taylor so he can have a look. Timings are with Pango 1.2.5. \n \n(Owen Taylor is responsible for Pango). \n \nSee also \nhttp://bugzilla.gnome.org/show_bug.cgi?id\u003d129473 \n(Bug report at GNOME). ",
    "There has been some confusion why my test contains gdk_draw_text(). The reason \nis that I wanted to see how fast string rendering can get (without AA, complex \nlayout, etc). gdk_draw_text() is (almost) the fastest way to render a string, \nso no matter how much we improve Pango, we\u0027ll never get better than that. \n \nBasically, this test is there to decide whether we must avoid to render at all \nto get decent performance. \n \nI\u0027ll attach a new test in a minute which changes the numbers slightly: Now, \nthey will show how many call/second the test can make. Benchmark3.java runs \neach test for 10 seconds, the C version for a fixed amount of time. \n \nHere are some figures: \n \nJava version: \n \ngc.drawText 1939 \ngc.drawText 2 5409 \ngc.stringExtent 6215 \ngc.textExtent 6251 \n \nC version: \n \ngc.gdk_draw_text 79923 \ngc.drawText 1407 \ngc.stringExtent 8600 \n \nNotes: I\u0027ve omitted textExtend because it\u0027s basically the same as stringExtent \nin SWT 3.0 \n \nAs you can clearly see, rendering directly is about ten times faster (80K \nagainst 8.6K) than getting the extent of the string via Pango which doesn\u0027t \nmake sense in my eyes. I mean: It should take more time to copy a lot of pixel \ninformation into a complex bitmap than to add some numbers!? Even if you take \nthe gfx hardward into account, my main CPU should still add numbers quicker \nthan that. \n \nI\u0027ll add a comment to the respective bug in Pango. ",
    "Created an attachment (id\u003d8198)\nV3 of the Java/C benchmark\n\nRun the C version with \"make c\" and the Java version with \"make gtk\" after\ncopying all *.so and *.jar files from eclipse.swt.gtk_3.0.0 into the directory\nBenchmark3/swt-gtk/",
    "I\u0027ve now started to take the code of GC.java apart. My benchmark already \ncontains copies of the relevant code used in the tests in a class called \nMyGC.java which allows me to do some quick hacks. \n \nWhile doing so, I noticed something which made my worry: All methods on \nOS.java are synchronized. Why is that? Doesn\u0027t SWT already make sure that \neverything is single threaded? Creating such a tremendous amount of locks (we \ncall these methods by the ton) is probably biting a big chunk out of the \nperformance. \n \nCan one of the SWT developers, who can compile the C code of SWT, try to \nremove all the synchronized strings out of OS.java and run my benchmark once \nbefore and once after? ",
    "OS must be synchronized because SWT graphics can happen in any thread.  If there\nis more than a single thread in GTK at a time, it will GP.\n\nOn GTK, by commenting out OS.gdk_draw_layout_with_colors() in GC from\ndrawString() and OS.pango_layout_get_size() from stringExtent() it is clear that\nall of the time is in these two Pango calls. Compare these results to comment #7.\n\nGTK - glib2-2.2.1-1/gtk2-2.2.1-4/pango-1.2.1-3\nIntel(R) Pentium(R) 4 CPU 2.53GHz\nMem 512Mb\n\nControl drawString() - count\u003d100000 time\u003d1182 ms\nControl stringExtent() - count\u003d100000 time\u003d1022 ms\nImage drawString() - count\u003d100000 time\u003d962 ms\nImage stringExtent() - count\u003d100000 time\u003d1005 ms",
    "Aaron, the benchmark we are using for string drawing and measuring is \nStringBench.  It\u0027s much simpler.  Feel free to construct a similar C benchmark \nand post the times.  Thanks.",
    "\u003e comment #17: \n\u003e OS must be synchronized because SWT graphics can happen in any thread. \n\u003e If there is more than a single thread in GTK at a time, it will GP. \n \nI know; the interesting question is: How much performance would this give? \n \nIt should be simple to create a version of OS.java without synchronization. If \nthat gives \u003e\u003e 10%, then it might be worth it to create OS and UOS \n(unsynchronized). The latter calls could be used when SWT components render \nthemselves. \n \n\u003e On GTK, by commenting out OS.gdk_draw_layout_with_colors() in GC from \n\u003e drawString() and OS.pango_layout_get_size() from stringExtent() it is \n\u003e clear that all of the time is in these two Pango calls. Compare these \n\u003e results to comment #7 \n \nYes, I can second that. Taking all code out of MyGC.java except these two \ncalls doesn\u0027t change the timing much. \n \n\u003e comment #18: \n\u003e Use StringBench \n \nWell, I guess we have nailed it down but I can have a look if StringBench is \nreally different from my benchmark. Where can I find it? ",
    "It\u0027s in this bug report (but not as an attachment).\n\nYou can\u0027t have some methods synchronized and some not or you will GP.  Only \none thread, GUI or non-GUI can be in GTK at a time.",
    "\u003e StringBench \n \nMy benchmark does basically the same thing; turning StringBench into C \nwouldn\u0027t yield any new insights because the complex stuff was to convert \ndrawString() from SWT to C. \n \n\u003e Synchronized stuff \n \nOk, then how about a more global lock? SWT components could get the lock in \nthe redraw() method (or repaint() or whatever it is called). Then, java \nwouldn\u0027t need to sync for every OS call. IIRC, Java just ignores a lock which \nyou already own. \n \nBut the point here is: Would it be worth it? Can someone please give it a try? \nmaybe the performance impact of this is so small that this whole discussion is \nmute. OTOH, if the impact is big, it might be worth it. But unless this \nquestion is answered, all conclusions are useless. ",
    "After a little more thinking, the solution is quite simple: Just add \n \n....synchronized (OS.class) { \n \n....} \n \naround the rendering code; that\u0027s what the \"native synchronized\" statements do \nin OS.java. The results are interesting: Simple calls like gc.setLineWidth() \nget 10 times faster while gc.drawText() almost doesn\u0027t change. Overall, I\u0027d \nsay the speedup is roughly 5-10%. \n \nSince it\u0027s simple to apply, I\u0027d suggest to post a comment on the SWT developer \nlist. Components with a complex redraw method can then add these two lines and \nget some extra speed (almost) for free. ",
    "We already have the lock in paint because paint happens when the event is \ndispatched and dispatching acquires the lock.  Simple calls get faster because \nthe time is in acquiring the lock, not querying the OS.\n\nOver all, I don\u0027t think it\u0027s worth it.  Perhaps you could try running \nBenchmark2 from #32683 and publishing the results there?  This report concerns \nstring draw.  Thanks.",
    "Oops, bug #37683 ...",
    "Re: #23 and #24: My benchmark tests string drawing and line drawing to make \nsure that I test the same things as Benchmark2. So the timings of Benchmark3 \nare in fact compatible to Benchmark2 (my tests just show how many calls can be \nmade per second while Bench2 shows how long 1 million calls take; the latter \nis IMHO easier to compare). \n \nAs for the lock: I\u0027ve searched the whole source with grep -r and couldn\u0027t find \na place where a lock to OS.class is acquired, so I think that you\u0027re wrong \nthere: You get a new lock each time you call on gtk function and that can be \nexpensive. \n \nFor a fix, I suggest to add a lock in Display.readAndDispatch(). Should give \nany SWT app on GTK a free performance boost of about 2-5%. ",
    "Owen Taylor of GNOME fame answered my questions regarding to Pango. Here is \nwhat he said (see the full reply at \nhttp://bugzilla.gnome.org/show_bug.cgi?id\u003d129473): \n \n- [...] Text drawing is another matter, I know plenty of things \n  that could be done to make AA text drawing 10 times or \n  more faster, but X development is a huge mess at the moment. \n \nSo text rendering is just plain slow, especially when we want to use AA text \nrendering. \n \nThen I asked how about a special handler for ASCII. His reply: \n \n- Special casing ASCII is not interesting to me, because \n  as soon as I do that, application authors lose touch \n  with how their app will perform for many of their  \n  users. \n \n- Modern processors do well in tight loops. This is why \n  it\u0027s easy to make blitting a few bitmap characters \n  faster than analyzing the same characters and laying \n  them out. Plus XDrawText tends to be HW accelerated \n  (though it\u0027s plenty fast enough in software) \n \nComment: XDrawText is fast because it\u0027s in HW while AA rendering is usually \nnot accelerated. \n \n- Your timings above indicate that in your benchmark, the \n  real bottleneck is Xft drawing, not Pango layout.  \n  By doing measurements of what Eclipse does in real \n  applications, you\u0027d be able to figure out if that \n  is the case in real life as well. \n \nComment: So I guess this means that using Xft directly won\u0027t help much. \n \n- I took a short look at the C benchmark yesterday, and other \n  than setting the background in draw_layout_line_with_colors() \n  it\u0027s not doing anything obviously stupid that would  \n  cause noticeable performance updates. \n \nComment: Clearing the background can be expensive. That is why most apps draw \nthe background and then just render the text over it. \n \n- Applications that want to look reasonable usually draw \n  to a backing pixmap, this prevents the user seeing \n  clear/redraw flashing. I assume that SWT does this \n  in some fashion, but then again, maybe not... \n \n  GDK provides a nice convenient interface to this \n  with gdk_window_begin_paint_rect/region(), though \n  apps can also do it manually if they want. \n \nComment: I haven\u0027t seen any place where SWT renders to an offscreen bitmap. \nDoes it? \n \nIf it doesn\u0027t, is that an option? \n \n- Whether drawing to an offscreen pixmap is faster \n  or not than drawing to the screen depends a lot \n  on particular system details. Because of deficencies \n  in XFree86, it is occasionally *much* faster, but \n  it\u0027s not reliably faster. \n \nComment: Since X allows to redirect the display to another computer, it must \nmake some compromises. When you look at it as a client/server architecture, \nthen the app is a client of a server which can draw on a screen. This means \nthat any drawing command must be converted to a network format (a binary \nstring), transported over some kind of socket (TCP/IP or a socket on disk \nin /tmp/.X11-unix/) and then the server can execute it. \n \nThat\u0027s the reason why avoiding drawing something saves so much time. \n \nJust in the last few years, things like shared memory have started to come up \nwhich enhanve performance considerably. So today, it\u0027s possible to request a \nshared pixmap from the server (only locally, so you cannot start a program \nwhich uses this over a network) and render directly to it. This is fast but \nnot very portable. \n \nConclusion: The only way to get SWT text rendering faster by an order or two \n(which is what we\u0027re after), we must drop Pango and AA text rendering or wait \nfor someone to optimize XFree86. ",
    "Arron, WRT comment #25, the method OS.gtk_main_iteration() inside of \nDisplay.readAndDispatch() acquires the lock when it dispatches an operating \nsystem event.",
    "\u003e Conclusion: The only way to get SWT text rendering faster by an\n\u003e order or two (which is what we\u0027re after), we must drop Pango and\n\u003e AA text rendering or wait for someone to optimize XFree86. \n\nWe are never dropping Pango as long as GTK embraces it.",
    "Re #27: What about the rendering in runDeferredEvents()? Doesn\u0027t SWT collect \nall rendering events and then dispatch them all at once? ",
    "No.  Some events are queued, some are not.  Paint events are not queued.",
    "Re #28: If we must use Pango, then the only options are to heavily optimize  \nEclipse to make sure that we never draw anything unecessarily and to try to  \nrender the text widget to an offscreen bitmap.  ",
    "Created an attachment (id\u003d8279)\nStyledText benchmark\n\nThis is a simple benchmark which shows how fast StyledText is during rendering.\nHere are the timings on my Linux box:\n\nset no text 1567\nsetText 1 line 549\nsetText 2 lines 437\n\nWhether I lock OS or not doesn\u0027t change the results much.",
    "When you look at the timings in comment 32 and the ones in V3 of the \nbenchmark, you can see that drawing using drawString() is four to ten times \nfaster than styledText.getContent().setText(\"two\\nlines\"); \nstyledText.repaint(); \n \nCan someone with a working profiles run StyledText benchmark, please? I\u0027d like \nto see in which calls the time gets lost. I mean, drawString() is slow \nalready ... \n \nAnd something else which I noticed: On Windows, text rendering is non-AA. \nMaybe someone can investigate how to disable AA in Pango? ",
    "On a WinNT 4.0SP6a system with Pentium III/1Ghz and onboard Intel gfx, I get \nthis:\n\nWinNT 4.0 without OS lock\n\nset no text 471\nsetText 1 line 226\nsetText 2 lines 221\n\nWinNT 4.0 with OS lock\n\nset no text 502\nsetText 1 line 236\nsetText 2 lines 223\n\nAgain, the OS lock doesn\u0027t seem to change much. What is interesting, though, is \nthe fact that Eclipse feels more responsive on this HW, while it still is much \ninferiour to my PC at home (dual P-III with 1GHz and an NVIDIA gfx card).\n\nThe UI of Eclipse 3.0M7 still feels much less responive than 2.1.2 on it except \nfor some things: Speed of the text rendering feels OK but input sometimes lags \nbegind. Also, java completion is sometimes instantly and sometimes takes a \nrather long coffee break.\n\nFrom these observations, I conclude that the speed of string rendering alone is \nnot the sole cause of the performance problems which we experience on Linux.\n\nSo again, the old saying hold true: It\u0027s impossible to say where the \nperformance goes to by looking at the source and guessing. One must use a \nprofiler.\n\nCan someone direct me to a (free/OSS) profiler which I can download and run \nEclipse in so I can get some real numbers?",
    "After running StyledText benchmark on WINDOWS(!) in hyades, I find that 75% of \nthe time is spent in these three methods:\n\n- Display.getLastEventTime() (called from Widget.sendEvent())\n- StyledText.performPaint() calls OS.getDC() (via GC.GC() -\u003e\n  Image.internal_new_GC() -\u003e Display.internal_new_GC(GCData))\n- StyledText.performPaint() eventually gc.dispose() which calls OS.releaseDC()\n\nIt seems to me that (like on Unix), getting the current system time and \ncreating/disposing GCs is expensive.\n\nSo I tried to optimize these two. Sun did put some effort into enhancing \nSystem.currentTimeMillis(), so I thought I could use that instead of \ngetLastEventTime() (a benchmark shows that cTM() is 2-3 times faster than gLET\n()) but I don\u0027t know the semantics of gLET() and there is no javadoc comment in \nDisplay.java. Anyone?\n\nNext, I cached the image and GC in performPaint(). Here are the timings for \nthis:\n\nWinNT 4.0 without caching:\n\nset no text 502\nsetText 1 line 236\nsetText 2 lines 223\n\nWith cached line buffer:\n\nset no text 832\nsetText 1 line 399\nsetText 2 lines 384\n\nThat\u0027s about 1.6 times faster. Tonight, I\u0027ll try the same on Linux and send you \na patch for StyledText so everyone can have a look.",
    "I don\u0027t know whether the following is relevant to you, but StyledText (probably the biggest and most \nimportant client of string rendering), implements its own double buffering mechanism.\nSee StyledText.performPaint(...).",
    "Yes, fixing string drawing won\u0027t fix Eclipse.  This problem report is focusing \non string drawing because it is a known area where Windows is faster than \nevery other platform.",
    "Is your Profiler lying?  Try making Display.getLastEventTime() return zero.  \nIs everything faster?  Also, your benchmarks should measure times over one \nsecond (longer times are better).  This helps with benchmark stability.",
    "Created an attachment (id\u003d8318)\nPatch against M07 SWT source\n\nOk, I\u0027ve now verified my patch. On linux, I get about 80-100% better\nperformance from my StyledText benchmark when using a cache for the GC and the\nImage used in StyledText to do double buffering in performPaint().\n\nSome background: The patch caches the image which is created in performPaint.\nNext time when the method is called, the patch checks if the image is large\nenough (the widget might have been resized), allocates a larger image if\nnecessary, and then copies the damaged part of the image into the destination\ndrawable.\n\nPlease have a look and if you like the patch (except for the indentation ;-),\ninclude it in M8.",
    "Re comment 38: \n \n\u003e Is your Profiler lying? \n \nWell, it seems that hyades has an issue with Display.getLastEventTime(). You \ncan ignore this part of my post. ",
    "Felipe, can you check out the M07 SWT source patch and associated benchmark.  \nThanks.",
    "Re #39:\n\nWow, 80-100% better performance. I\u0027ll definitely try\nyour patch later. Right now I\u0027m very busy.\n\nOne comment: Is there any particularly reason to test if 1 \u003d\u003d 0?\n\n+                  if (1 \u003d\u003d 0 || lineBuffer \u003d\u003d null\n+                    || lastLineSize.x \u003c clientArea.width\n+                    || lastLineSize.y \u003c renderHeight\n+\n+                )\n",
    "Re #37:\n\n\u003e\u003e This problem report is focusing \n\u003e\u003e on string drawing because it is a known area where Windows is faster than \n\u003e\u003e every other platform.\n\nWindows isn\u0027t necessarily faster than every other platform. FOX is\nactually faster at string drawing.",
    "Re #42: \n\n\u003e 1 \u003d\u003d 0\n\nThat was just to be able to disable the test quickly :-) I missed that when I \ncleaned the patch.",
    "Re #44 :\n\nNah, I done buy that ;-)  You can\u0027t disable the test by\naltering 1\u003d\u003d0 to 1\u003d\u003d1 or something else. \n\nBut any way, forget it, I\u0027m only teasing. I\u0027m really looking\nforward to try your patch. :-)\n",
    "I tested Aaron\u0027s patch and it made StyledText slower for me.\nMy testcase is to put a whole bunch of text and a few styles on the StyledText\nand measure the time to draw/update 200 times.\nMy machine is a IBM IntelliStation Z Pro running RedHat 9.\nResults:\nNo Patch:\nTime: 7401 (ms), Time: 7319 (ms), Time: 7775 (ms), Time: 6935 (ms)\n\nPatch:\nTime: 10127 (ms), Time: 9818 (ms), Time: 10138 (ms), Time: 10156 (ms)\n",
    "Created an attachment (id\u003d8332)\nFelipe\u0027s benchmark\n",
    "Re #46: \n \n\u003e Patch makes things slower in Felipe\u0027s benchmark \n \nI can second that, here are my numbers: \n \nWith: 9475 7368 7180 7119 \nWithout: 7997 6366 6861 6296 6177 \n \nObservations: \n \n1. The test becomes faster with every iteration. Why is this? \n \n2. I\u0027ve added a counter in GC(Drawable,boolean). It shows that during each \ntest run, about 500 GCs are created. Is it possible that the syntax \nhighlightning always creates new GCs? \n \nWhen I start Eclipse and scroll around a bit, about 100 GCs/s are created (and \ndestrory). \n \nSince my benchmark shows that creating GCs is costly, I\u0027ll run Felipe\u0027s \nbenchmark with the profiler to see where these GCs are created. ",
    "Aaron, I\u0027ve tried your patch, but I\u0027m afraid I havn\u0027t\nbeen able to measure any significant difference.\n\nI\u0027ve measured the time spent in performPaint by inserting\n\nlong start \u003d System.currentTimeMillis(); \n\nas the first line and\n\nlong stop \u003d System.currentTimeMillis(); \nSystem.out.println ( \" \" + (stop-start) ); \n\nas the last lines. By scrolling up and down in the javaviewer\nexample I haven\u0027t seen performPaint go faster than 45 ms\n(on my 233 Hz dinosaur), with or without your patch.\n\nWhat is interesting is that even thou performPaint uses\n45 ms to do a redraw there is approx. 1/2 sec from I hit \nthe PageDown key until I see the update on the screen. \n\nSomething very rotten is going on and I think we shall find\nthe answer somewhere in GTK or how the event queue are \nimplemented. String drawing or measuring are very slow but \nI actually don\u0027t think its our biggest problem.\n",
    "Re #49: \n \n\u003e Routine doesn\u0027t get faster with patch \n \nSteen, this is simply not possible. There must be a speed difference. (for \nexample, I allocate the image just once). Can you put a System.out in there to \nsee how often the image is created? Here, it\u0027s created two times: Once, when \nthe component is created and then again, when it is scrolled for the first \ntime. \n \nA possible explanation could be that currentTimeMillis() can\u0027t time something \nwith less than 45ms on your hardware. Because of some optimizations which Sun \nhas made in this call, it\u0027s not reliable with small timings (I have a \n\"resolution\" here of about 10ms). \n \nSuggestion: Add a counter and print the time only after 10 or 100 invocations. ",
    "In order to get real numbers, you need to measure things that are greater than \none second (the longer the better).",
    "*** Bug 4585 has been marked as a duplicate of this bug. ***",
    "*** Bug 4615 has been marked as a duplicate of this bug. ***",
    "PowerBook G4 AL\nMac OS X 10.4 (8A393)\n1.25 GHz PowerPC G4\n512k L2 cache\n0 MB L3 cache\n2GB DDR SDRAM\n\njava version \"1.4.2_07\"\nJava(TM) 2 Runtime Environment, Standard Edition (build 1.4.2_07-200)\nJava HotSpot(TM) Client VM (build 1.4.2-49, mixed mode)\n\nControl drawString() - count\u003d100000 time\u003d15363 ms\nControl stringExtent() - count\u003d100000 time\u003d10073 ms\nImage drawString() - count\u003d100000 time\u003d14187 ms\nImage stringExtent() - count\u003d100000 time\u003d10030 ms",
    "iMac\tIntel Core Duo 1.83 GHz\nMac OS X 10.4.5 (8G1454)\nL2 Cache (shared): 2 MB\nMemory: 1.5 GB\nBus Speed: 667 MHz\n\njava version \"1.5.0_06\"\nJava(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_06-103)\nJava HotSpot(TM) Client VM (build 1.5.0_06-57, mixed mode)\n\nControl drawString() - count\u003d100000 time\u003d8228 ms\nControl stringExtent() - count\u003d100000 time\u003d5054 ms\nImage drawString() - count\u003d100000 time\u003d7456 ms\nImage stringExtent() - count\u003d100000 time\u003d5094 ms",
    "Debian Unstable (AMD 2.4Ghz, 2G Ram, Nvidia GeForce FX 5200)\nGTK 2.8.17-1\nPango 1.12.1-2\nCario 1.0.4-1\n\nControl drawString() - count\u003d100000 time\u003d30911 ms\nControl stringExtent() - count\u003d100000time\u003d9714 ms\nImage drawString() - count\u003d100000 time\u003d30414 ms\nImage stringExtent() - count\u003d100000time\u003d9628 ms\n\nI enabled advanced graphics (gc.setAdvanced(true))\nand got:\n\nControl drawString() - count\u003d100000 time\u003d9646 ms\nControl stringExtent() - count\u003d100000time\u003d10001 ms\nImage drawString() - count\u003d100000 time\u003d8703 ms\nImage stringExtent() - count\u003d100000time\u003d9710 ms\n\nAbout 3x faster. However, enabling advanced (cairo) graphics slows down fill* routines considerably (things like fillRectangle, etc...).\n\nOne of the things I read about text performance is that AA is slow on linux (http://vektor.ca/eclipse/gtk-performance-notes.html).  Owen Taylor said that pango is naturally slower than motif because it does a lot more.  I am wondering if we *have* to do a lot more.  I think Pango does a great job, but is there a way to (programmatically) turn some of these features off (or maybe this is a really bad idea).  I tired gc.setAntialias(SWT.OFF) but this had not effect on the performance numbers.  \n\nI also tried to disable AA in my fonts.conf file, but again no change.  \n\nAlso, in http://bugzilla.gnome.org/show_bug.cgi?id\u003d129473, Owen says that Pango can draw about 9,000 8 digit numbers in a second.  The numbers in this bug report suggests that windows can draw close to 10x that amount in a second.  I don\u0027t know how much it will effect eclipse performance, but I am personally working on an application that requires animation and I am trying to get my FrameRate up :)\n\n- ian",
    "It\u0027s the 3.2 end game so we aren\u0027t really looking at this.  If you comment out all string drawing either in your application or in SWT (just make it do nothing), does your frame rate go up?",
    "MacBook Pro    Intel Core Duo 2 GHz\nMac OS X 10.4.6 (8I1119)\nL2 Cache (shared): 2 MB\nMemory: 2 GB\nBus Speed: 667 MHz\n\njava version \"1.5.0_06\"\nJava(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_06-112)\nJava HotSpot(TM) Client VM (build 1.5.0_06-64, mixed mode, sharing)\n\nControl drawString() - count\u003d100000 time\u003d7652 ms\nControl stringExtent() - count\u003d100000 time\u003d4774 ms\nImage drawString() - count\u003d100000 time\u003d6886 ms\nImage stringExtent() - count\u003d100000 time\u003d4735 ms\n\n\nAnd now the fun part:\n\nSame benchmark on Windows XP Professional SP2\nrunning on same hardware inside\nParallels Workstation 2.11 Beta4 for Mac OS X\n\njava version \"1.5.0_06\"\nJava(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_06-b05)\nJava HotSpot(TM) Client VM (build 1.5.0_06-b05, mixed mode, sharing)\n\nControl drawString() - count\u003d100000 time\u003d2744 ms\nControl stringExtent() - count\u003d100000 time\u003d100 ms\nImage drawString() - count\u003d100000 time\u003d2123 ms\nImage stringExtent() - count\u003d100000 time\u003d140 ms",
    "(In reply to comment #57)\n\u003e It\u0027s the 3.2 end game so we aren\u0027t really looking at this.  If you comment out\n\u003e all string drawing either in your application or in SWT (just make it do\n\u003e nothing), does your frame rate go up?\n\u003e \n\nThanks for the quick reply Steve.\nI know the end game is here, and I am not expecting a fix anytime soon, I just wanted to post these numbers while I had them available. I am not even sure this is an SWT problem.  I think SWT performance on GTK+ has improved tenfold since the early days of eclipse :)\n\nAs for my FPS, yep it more than doubles when I remove the text rendering.  It goes from about 8 to 16 FPS when I am not rendering the text.  It is currently rendering about 5,000 chars.  This doesn\u0027t tell us much because I would expect it to improve without the text rendering.  An interesting note is that when I remove the text drawing from windows it doesn\u0027t change the performance much.\n\n- ian",
    "Pango can be slow, but we did some good work to make it faster\nin pango 1.12.  For more details and pointers, see Federico\u0027s activity\nlog from October:\n\n  http://primates.ximian.com/~federico/news-2005-10.html\n\nIf you want to know more about how to optimize pango, drop by\n#performance on irc.gimp.org sometime and we can talk about it.\nThere are some more things in the profiles that can be brought\ndown if you\u0027re interested in hacking around.",
    "I have spent a few days hacking with GTK and Pango (Just using them to get some idea how they work).  I now have a better understanding of what Pango does and why it runs slower than Windows (and even AWT) font rendering.  Pango does a much better job of text layout than any of these other tools (especially for scripts and international fonts).  \n\nHowever, in some application areas you just want to render labels (character arrays) at pre-determined X,Y locations without the full pango pipeline.  (For example: an information visualization tool for medical ontologys rendering and animating hundreds of medical terms).  Some GTK users have suggested I bypass Pango and just draw to X directly (I didn\u0027t mention to them I was doing this through SWT).  So this got me thinking, can we address this bug by adding a Quality flag to SWT that is a \"hint\" about how high quality we want the rendering?  If we want High Quality then SWT.GTK could use Pango (the default), and if we don\u0027t care about quality, then we can simply bypass it and use gdk_draw_string (I know it is deprecated) or some other lower level text primitive?\n\nCheers,\nIan",
    "We looked into this a while back and decided against it (see https://bugs.eclipse.org/bugs/show_bug.cgi?id\u003d37683#c134).\n\nIn your application, if you knew that you were on GTK, only drawing English text, didn\u0027t care about the font, etc, etc, you could call the low level X, xft, or GDK text drawing routines.",
    "Thanks Steve.\n\nI am actually doing this in Draw2D / GEF.  I extended their label and I am now caching the entire label to an image.  I invalidate the image if the text changes (or the size changes) but since the most common operation is move, I can just reuse the image.  This has greatly improved performance.  When I do scaling animations, I do a mix of scaling the image and occasionally re-draw the text (like google maps).  \n\nI may try your solution with the low level calls. Are these exposed through the GC or OS layer?  I didn\u0027t see them there, but there are a lot of routines.  ( I guess it would have to be in the OS layer since it is specific to GTK).\n\nCheers,\nIan",
    "At one point the natives were there but Billy deleted them.",
    "Adding to Java benchmarks for Leopard. This will make it more visible inside Apple.",
    "Because nobody notices when things improve, I thought I would post this:\nGTK+ Debian Unstable\nPango 2.14.8-3\nAMD 3800+\n\nControl drawString() - count\u003d100000 time\u003d14151 ms\nControl stringExtent() - count\u003d100000time\u003d4865 ms\nImage drawString() - count\u003d100000 time\u003d13790 ms\nImage stringExtent() - count\u003d100000time\u003d4848 ms\n\nThis is about 2x faster than before.  Pango has come a long way.  And while it is still slower than Windows, I personally think the fonts look nicer.",
    "Interesting.  You should test Pango HEAD and cairo master branch.",
    "MacBook Pro    Intel Core 2 Duo 2.33 GHz\nMac OS X 10.4.8 (8N1037)\nL2 Cache (shared): 4 MB\nMemory: 3 GB\nBus Speed: 667 MHz\n\njava version \"1.5.0_06\"\nJava(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_06-113)\nJava HotSpot(TM) Client VM (build 1.5.0_06-68, mixed mode, sharing)\n\nSWT 3320:\n\nControl drawString() - count\u003d100000 time\u003d6352 ms\nControl stringExtent() - count\u003d100000 time\u003d3604 ms\nImage drawString() - count\u003d100000 time\u003d4747 ms\nImage stringExtent() - count\u003d100000 time\u003d3607 ms\n\nAnd again the fun part:\n\nSame benchmark on Windows XP Professional SP2\nrunning on same hardware inside\nParallels Desktop for Mac\nBuild 3106 Beta 3 (28. Dezember 2006)\n\njava version \"1.5.0_10\"\nJava(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_10-b03)\nJava HotSpot(TM) Client VM (build 1.5.0_10-b03, mixed mode, sharing)\n\nControl drawString() - count\u003d100000 time\u003d1662 ms\nControl stringExtent() - count\u003d100000 time\u003d80 ms\nImage drawString() - count\u003d100000 time\u003d1512 ms\nImage stringExtent() - count\u003d100000 time\u003d80 ms\n",
    "Latest pango 1.15.x and cairo 1.3.x should give you something very near the Windows performance for extents, and not much worse for rendering.",
    "Behdad, please post the results.",
    "(In reply to comment #70)\n\u003e Behdad, please post the results.\n\nUmm, I\u0027ve been trying to seduce someone to try and post results :).  Without being lazy, I\u0027m far from that high in the stack to tinker with SWT (or Java for that matter).  Andrew, maybe you can do that?",
    "(In reply to comment #71)\n\u003e (In reply to comment #70)\n\u003e \u003e Behdad, please post the results.\n\u003e \n\u003e Umm, I\u0027ve been trying to seduce someone to try and post results :).  Without\n\u003e being lazy, I\u0027m far from that high in the stack to tinker with SWT (or Java for\n\u003e that matter).  Andrew, maybe you can do that?\n\nYeah, I\u0027ve been meaning to do this.  I\u0027ll try to get to it today.\n\n",
    "Kevin, you also have an intel mac os running Parallels with vista and fc6. Check comment #68, can you test it too ?",
    "I got the latest pango and cairo graphics and gave this a try.  With gc.setAdvanced(true) I get slightly better results, but still not near windows performance.  (with it set to false I get the same as before)\n\nControl drawString() - count\u003d100000 time\u003d11221 ms\nControl stringExtent() - count\u003d100000time\u003d5230 ms\nImage drawString() - count\u003d100000 time\u003d11381 ms\nImage stringExtent() - count\u003d100000time\u003d5506 ms\n\nMaybe there is something wrong with my install:\n(Everything else is from Debian unstable, pango and cairo and build from their latest release, SWT is from 3.3M4).\n\nduff:~# ldconfig -v | grep cairo\n        libsvg-cairo.so.1 -\u003e libsvg-cairo.so.1.0.1\n        libpangocairo-1.0.so.0 -\u003e libpangocairo-1.0.so.0.1502.0\n        libcairo.so.2 -\u003e libcairo.so.2.10.3\n\nduff:~# ldconfig -v | grep pango\n        libpangomm-1.4.so.1 -\u003e libpangomm-1.4.so.1.0.29\n        libpangocairo-1.0.so.0 -\u003e libpangocairo-1.0.so.0.1502.0\n        libpangoxft-1.0.so.0 -\u003e libpangoxft-1.0.so.0.1400.8\n        libpangox-1.0.so.0 -\u003e libpangox-1.0.so.0.1400.8\n        libpango-1.0.so.0 -\u003e libpango-1.0.so.0.1502.0\n        libpangoft2-1.0.so.0 -\u003e libpangoft2-1.0.so.0.1502.0\n\nAre these the versions you expect? \n\nWhat exactly does advanced graphics do for font rendering?\n\n\n\n",
    "(In reply to comment #74)\n\u003e I got the latest pango and cairo graphics and gave this a try.  With\n\u003e gc.setAdvanced(true) I get slightly better results, but still not near windows\n\u003e performance.  (with it set to false I get the same as before)\n\nOk, I need to dig into seeing what the test and SWT are doing then.  The 80ms time for extents computation for 100000 iterations can only mean one of two things: 1) bogus measurement, 2) cached extents.\n\nIf cached extents is the case, then it should be possible to do the same on pango.  Pango 1.15.2 caches layout extents if you use it properly, so now it\u0027s down to swt to use it properly (cache the layout, and use the readonly accessors).  Read:\n\n  http://mail.gnome.org/archives/gtk-devel-list/2006-December/msg00105.html\n\n\u003e Control drawString() - count\u003d100000 time\u003d11221 ms\n\u003e Control stringExtent() - count\u003d100000time\u003d5230 ms\n\u003e Image drawString() - count\u003d100000 time\u003d11381 ms\n\u003e Image stringExtent() - count\u003d100000time\u003d5506 ms\n\u003e \n\u003e Maybe there is something wrong with my install:\n\u003e (Everything else is from Debian unstable, pango and cairo and build from their\n\u003e latest release, SWT is from 3.3M4).\n\u003e \n\u003e duff:~# ldconfig -v | grep cairo\n\u003e         libsvg-cairo.so.1 -\u003e libsvg-cairo.so.1.0.1\n\u003e         libpangocairo-1.0.so.0 -\u003e libpangocairo-1.0.so.0.1502.0\n\u003e         libcairo.so.2 -\u003e libcairo.so.2.10.3\n\u003e \n\u003e duff:~# ldconfig -v | grep pango\n\u003e         libpangomm-1.4.so.1 -\u003e libpangomm-1.4.so.1.0.29\n\u003e         libpangocairo-1.0.so.0 -\u003e libpangocairo-1.0.so.0.1502.0\n\u003e         libpangoxft-1.0.so.0 -\u003e libpangoxft-1.0.so.0.1400.8\n\u003e         libpangox-1.0.so.0 -\u003e libpangox-1.0.so.0.1400.8\n\u003e         libpango-1.0.so.0 -\u003e libpango-1.0.so.0.1502.0\n\u003e         libpangoft2-1.0.so.0 -\u003e libpangoft2-1.0.so.0.1502.0\n\u003e \n\u003e Are these the versions you expect? \n\nAssuming that SWT is using pangocairo, yes.\n\n\u003e What exactly does advanced graphics do for font rendering?\n\nNo idea.\n",
    "(In reply to comment #75)\n\u003e \u003e What exactly does advanced graphics do for font rendering?\n\u003e \n\u003e No idea.\n\nSorry, that question was for the SWT team.  No worries, I have figured it out.  When advanced graphics is true SWT uses: (with some additional setup of course)\n\nCairo.cairo_move_to(cairo, x, y);\nOS.pango_cairo_show_layout(cairo, data.layout\n\nto actually render the text.\n\nWhen it is set to false it uses:\nint /*long*/ pixmap \u003d OS.gdk_pixmap_new(OS.GDK_ROOT_PARENT(), width, height, -1);\nif (pixmap \u003d\u003d 0) SWT.error(SWT.ERROR_NO_HANDLES);\nint /*long*/ gdkGC \u003d OS.gdk_gc_new(pixmap);\nOS.gdk_gc_set_foreground(gdkGC, black);\nOS.gdk_draw_rectangle(pixmap, gdkGC, 1, 0, 0, width, height);\nOS.gdk_gc_set_foreground(gdkGC, data.foreground);\nOS.gdk_draw_layout_with_colors(pixmap, gdkGC, 0, 0, layout, null, background);\nOS.g_object_unref(gdkGC);\nOS.gdk_draw_drawable(data.drawable, handle, pixmap, 0, 0, x, y, width, height);\nOS.g_object_unref(pixmap);\n\nI am currently trying to strip out only the OS layer (the native methods) that SWT uses to perform the benchmark.  This may help determine if SWT is using Pango correctly.   \n",
    "(In reply to comment #76)\n\u003e (In reply to comment #75)\n\u003e \u003e \u003e What exactly does advanced graphics do for font rendering?\n\u003e \u003e \n\u003e \u003e No idea.\n\u003e \n\u003e Sorry, that question was for the SWT team.  No worries, I have figured it out. \n\u003e When advanced graphics is true SWT uses: (with some additional setup of course)\n\u003e \n\u003e Cairo.cairo_move_to(cairo, x, y);\n\u003e OS.pango_cairo_show_layout(cairo, data.layout\n\nThis is fine, assuming that OS.pango_cairo_show_layout calls pango_cairo_show_layout().\n\n\u003e to actually render the text.\n\u003e \n\u003e When it is set to false it uses:\n\u003e int /*long*/ pixmap \u003d OS.gdk_pixmap_new(OS.GDK_ROOT_PARENT(), width, height,\n\u003e -1);\n\u003e if (pixmap \u003d\u003d 0) SWT.error(SWT.ERROR_NO_HANDLES);\n\u003e int /*long*/ gdkGC \u003d OS.gdk_gc_new(pixmap);\n\u003e OS.gdk_gc_set_foreground(gdkGC, black);\n\u003e OS.gdk_draw_rectangle(pixmap, gdkGC, 1, 0, 0, width, height);\n\u003e OS.gdk_gc_set_foreground(gdkGC, data.foreground);\n\u003e OS.gdk_draw_layout_with_colors(pixmap, gdkGC, 0, 0, layout, null, background);\n\u003e OS.g_object_unref(gdkGC);\n\u003e OS.gdk_draw_drawable(data.drawable, handle, pixmap, 0, 0, x, y, width, height);\n\u003e OS.g_object_unref(pixmap);\n\nThis is not optimal, to say the least.  No idea why a temp pixmap is used.\n\n\u003e I am currently trying to strip out only the OS layer (the native methods) that\n\u003e SWT uses to perform the benchmark.  This may help determine if SWT is using\n\u003e Pango correctly.   \n\nThanks.  A tool you may find useful is the bprobe tool in GNOME svn.  With bprobe, you can write probes really quickly to see for example how many times pango_layout_new() is called, without recompiling pango or SWT.  Let me know if you need help with that.",
    "I\u0027ll look into the profiler, it may help, but for now I have isolated a few lines that seem to be causing some of the slowness (at least on the text extent part).\n\ntime \u003d -System.currentTimeMillis();\nfor (int i\u003d0; i\u003cCOUNT; i++) {\n  OS.pango_layout_set_text(layout, new byte[]{\u0027a\u0027,\u0027b\u0027,\u0027c\u0027,\u0027d\u0027,\u0027e\u0027}, 5);\n  int[] width \u003d new int[1], height \u003d new int[1];\n  OS.pango_layout_get_size(data.layout, width, height);\n  OS.pango_layout_set_text(layout, new byte[]{\u0027f\u0027,\u0027g\u0027,\u0027h\u0027,\u0027i\u0027,\u0027j\u0027}, 5);\n  OS.pango_layout_get_size(data.layout, width, height);\n}\nSystem.out.println (msg + \" stringExtent() - count\u003d\" + COUNT + \"time\u003d\" + (System.currentTimeMillis() + time) + \" ms\");\n\nThis takes about 5 seconds for 100,000 iterations.\nThe OS.* simply call the native methods with the same name.  This is (basically) the way SWT is using Pango to calculate text extents.  It is much faster if you don\u0027t change the text during each iteration, but I don\u0027t think that is realistic. \n\nIf GTK is \u003c 2.8 it uses:\n\ncairo_font_extents_t font_extents \u003d new cairo_font_extents_t();\nCairo.cairo_font_extents(cairo, font_extents);\ncairo_text_extents_t extents \u003d new cairo_text_extents_t();\nCairo.cairo_text_extents(cairo, buffer, extents);\n\n\n",
    "I\u0027m obviously doing something wrong but I can\u0027t think of what it is.  I can\u0027t get StringBench to run on gtk64.  I\u0027ve got 3.3M4 and the 1.5 Sun 64-bit JVM.  3.3M4 runs fine but StringBench gives:\n\nException in thread \"main\" java.lang.UnsatisfiedLinkError: memmove\n\tat org.eclipse.swt.internal.gtk.OS.memmove(Native Method)\n\tat org.eclipse.swt.internal.Converter.wcsToMbcs(Converter.java:67)\n\tat org.eclipse.swt.internal.Converter.wcsToMbcs(Converter.java:54)\n\tat org.eclipse.swt.widgets.Display.\u003cclinit\u003e(Display.java:126)\n\tat tests.StringBench.main(StringBench.java:30)\n\nI\u0027m using Fedora 6.  Any help appreciated.",
    "How are you launching the Java application?  From within Eclipse?  Sorry, I am using the 32 bit version of everything.  Does anyone know if GTK64 properly gets the .SO file out of the JAR file (the work in Bug #166865)\n\nAlso, \nWhat happens if you wrote:\ntime \u003d -System.currentTimeMillis();\nfor (int i\u003d0; i\u003cCOUNT; i++) {\n  OS.pango_layout_set_text(layout, new byte[]{\u0027a\u0027,\u0027b\u0027,\u0027c\u0027,\u0027d\u0027,\u0027e\u0027}, 5);\n  int[] width \u003d new int[1], height \u003d new int[1];\n  OS.pango_layout_get_size(data.layout, width, height);\n  OS.pango_layout_set_text(layout, new byte[]{\u0027f\u0027,\u0027g\u0027,\u0027h\u0027,\u0027i\u0027,\u0027j\u0027}, 5);\n  OS.pango_layout_get_size(data.layout, width, height);\n}\nSystem.out.println (msg + \" stringExtent() - count\u003d\" + COUNT + \"time\u003d\" +\n(System.currentTimeMillis() + time) + \" ms\");\n\nin C?  You can probably get a GTK app up and running faster than me that initializes pango and then does the set text (as above) followed by get_size.  Those numbers may help too.",
    "(In reply to comment #78)\n\u003e I\u0027ll look into the profiler, it may help, but for now I have isolated a few\n\u003e lines that seem to be causing some of the slowness (at least on the text extent\n\u003e part).\n\nThanks.\n\n\u003e time \u003d -System.currentTimeMillis();\n\u003e for (int i\u003d0; i\u003cCOUNT; i++) {\n\u003e   OS.pango_layout_set_text(layout, new byte[]{\u0027a\u0027,\u0027b\u0027,\u0027c\u0027,\u0027d\u0027,\u0027e\u0027}, 5);\n\u003e   int[] width \u003d new int[1], height \u003d new int[1];\n\u003e   OS.pango_layout_get_size(data.layout, width, height);\n\u003e   OS.pango_layout_set_text(layout, new byte[]{\u0027f\u0027,\u0027g\u0027,\u0027h\u0027,\u0027i\u0027,\u0027j\u0027}, 5);\n\u003e   OS.pango_layout_get_size(data.layout, width, height);\n\u003e }\n\u003e System.out.println (msg + \" stringExtent() - count\u003d\" + COUNT + \"time\u003d\" +\n\u003e (System.currentTimeMillis() + time) + \" ms\");\n\u003e \n\u003e This takes about 5 seconds for 100,000 iterations.\n\u003e The OS.* simply call the native methods with the same name.  This is\n\u003e (basically) the way SWT is using Pango to calculate text extents.  It is much\n\u003e faster if you don\u0027t change the text during each iteration, but I don\u0027t think\n\u003e that is realistic. \n\nRight.  However, a extent calculation plus a rendering has become a lot cheaper in Pango 1.15.2.  That is, none of the two become much faster, but if you do both, one is almost free now.\n\nI\u0027m also curious in how you are measuring it on Windows (as in, the equivalent of the above code).\n\n\u003e If GTK is \u003c 2.8 it uses:\n\u003e \n\u003e cairo_font_extents_t font_extents \u003d new cairo_font_extents_t();\n\u003e Cairo.cairo_font_extents(cairo, font_extents);\n\u003e cairo_text_extents_t extents \u003d new cairo_text_extents_t();\n\u003e Cairo.cairo_text_extents(cairo, buffer, extents);\n\nThis is totally broken for everything other than ASCII, but doesn\u0027t really matter I guess.",
    "Hello Andrew, I believe the problem you have is not your fault but a bug in SWT. Grant, do you still have a 64bit linux machine ? Can you try the benchmark there ?\n\nIan \u0026 Behdad: when you use advance graphics in SWT you are really using a different technology. For example, on windows it uses GDI for normal mode and GDI+ for advance mode. On GTK it uses GDK for normal mode and Cairo for advance mode. The application should set advance mode when it needs to use \u0027advance\u0027 features like transform or alpha.\n\nIan: Usually if you compare SWT PI code versus native C code you are really going to measure the time SWT waste to cross the JNI layer. In past benchmarks this number was close to zero.",
    "(In reply to comment #82)\n\u003e Ian \u0026 Behdad: when you use advance graphics in SWT you are really using a\n\u003e different technology. For example, on windows it uses GDI for normal mode and\n\u003e GDI+ for advance mode. On GTK it uses GDK for normal mode and Cairo for advance\n\u003e mode. The application should set advance mode when it needs to use \u0027advance\u0027\n\u003e features like transform or alpha.\n\nThanks Felipe, that is why I was confused about advanced graphics.  I have used SWT advanced graphics for other operations, but it seems that SWT (GTK version at least) handles text rendering differently when Advanced is set to true.  It seems to run faster, and according to Behdad (who knows a lot more about this than I ever will) the non-advanced way is not optimal. \n\n\u003e Ian: Usually if you compare SWT PI code versus native C code you are really\n\u003e going to measure the time SWT waste to cross the JNI layer. In past benchmarks\n\u003e this number was close to zero.\n\u003e \nFigured as much.  I was just hoping that by creating a C version with similar time measurements, the Pango guys may be able to tell us if we are using Pango correctly (especially now that they have done improvements in caching).\n\nThanks for the tips Felipe. Any help here is greatly appreciated :)",
    "(In reply to comment #81)\n\u003e Right.  However, a extent calculation plus a rendering has become a lot cheaper\n\u003e in Pango 1.15.2.  That is, none of the two become much faster, but if you do\n\u003e both, one is almost free now.\nMakes sense. However, I would assume that if I just rendered the same text continually it should be fast then.  But even the following code takes \u003e 5 seconds:\n\nfor (int i\u003d0; i\u003cCOUNT; i++) {\n  Cairo.cairo_move_to(cairo, 10, 50);\n  OS.pango_cairo_show_layout(cairo, data.layout);\n  Cairo.cairo_move_to(cairo, 10, 150);\n  OS.pango_cairo_show_layout(cairo, data.layout);\n}\n\n(Note: I just move the location and draw the same text (\"Hello\") repeatedly) \n \n\u003e I\u0027m also curious in how you are measuring it on Windows (as in, the equivalent\n\u003e of the above code).\n\nNot sure exactly, but the benchmark basically moves the cursor, sets the text to \"Hello\" and renders it, then it moves the cursor, sets the text to \"There\" and renders it.  It repeats this 100,000 times.  I don\u0027t know if caching works here since the text continuously changes.\n\nThen the benchmark does the same thing, but instead of rendering the text it just gets the extents.  Again the text continually changes.\n\nI hope this helps, and thanks for following this Behdad!\n",
    "\u003e I\u0027m also curious in how you are measuring it on Windows (as in, the equivalent\n\u003e of the above code).\n\nIn normal mode:\nOS.GetTextExtentPoint32W(handle, buffer, length, size);\nIn advance mode:\nint format \u003d Gdip.StringFormat_Clone(Gdip.StringFormat_GenericTypographic());\nGdip.StringFormat_SetFormatFlags(format, Gdip.StringFormat_GetFormatFlags(format) | Gdip.StringFormatFlagsMeasureTrailingSpaces);\nGdip.Graphics_MeasureString(data.gdipGraphics, buffer, buffer.length, data.gdipFont, pt, format, bounds);\nGdip.StringFormat_delete(format);\n\nGTK has more code running really, you need to create a pangolayout before you can measure anything.\n",
    "Andrew: Please make sure you are running the 64bits version of SWT on your 64bits machine. In the download page look for Linux (x86_64/GTK 2). Personally I would run in a 32bits machine like everyone else in the problem report.",
    "\u003e This is not optimal, to say the least.  No idea why a temp pixmap is used.\n\nThis code is doing XOR, the normal case it is only a call to:\ngdk_draw_layout_with_colors()\n",
    "(In reply to comment #87)\n\u003e \u003e This is not optimal, to say the least.  No idea why a temp pixmap is used.\n\u003e \n\u003e This code is doing XOR, the normal case it is only a call to:\n\u003e gdk_draw_layout_with_colors()\n\u003e \nSorry about that guys... I didn\u0027t see that if statement.  That was my fault :(",
    "(In reply to comment #86)\n\u003e Andrew: Please make sure you are running the 64bits version of SWT on your\n\u003e 64bits machine.\n\nI am.  I eventually got it working by pointing LD_LIBRARY_PATH (it also worked with java.library.path) to the exploded 64-bit JNI .sos.\n\nMy times were similar to Ian\u0027s.  Behdad was working on an equivalent benchmark in C to compare.  I think he\u0027ll have further comments.",
    "Re comment #63:\n\nWindows Vista Business\nrunning inside Parallels Desktop for Mac\nBuild 3106 Beta 3 (28. Dezember 2006)\non\nMacBook Pro  Intel Core 2 Duo 2.33 GHz\nMac OS X 10.4.8 (8N1037)\nL2 Cache (shared): 4 MB\nMemory: 3 GB\nBus Speed: 667 MHz\n\njava version \"1.6.0\"\nJava(TM) SE Runtime Environment (build 1.6.0-b105)\nJava HotSpot(TM) Client VM (build 1.6.0-b105, mixed mode, sharing)\n\nControl drawString() - count\u003d100000 time\u003d2894 ms\nControl stringExtent() - count\u003d100000 time\u003d701 ms\nImage drawString() - count\u003d100000 time\u003d1883 ms\nImage stringExtent() - count\u003d100000 time\u003d211 ms",
    "Oops, my comment #90 is a response to Felipe\u0027s comment #73, not comment #63.",
    "Hardware:\n  Processor: Intel Core 2 Duo 2.16 GHz\n  L2 Cache:\t4 MB\n  Memory:\t2 GB\n  Bus Speed:\t667 MHz\n\nMac OS X 10.4.8\nControl drawString() - count\u003d100000 time\u003d6661 ms\nControl stringExtent() - count\u003d100000 time\u003d3882 ms\nImage drawString() - count\u003d100000 time\u003d5150 ms\nImage stringExtent() - count\u003d100000 time\u003d3952 ms\n\n\nWindows Vista (Parallels)\nControl drawString() - count\u003d100000 time\u003d2464 ms\nControl stringExtent() - count\u003d100000 time\u003d491 ms\nImage drawString() - count\u003d100000 time\u003d2103 ms\nImage stringExtent() - count\u003d100000 time\u003d392 ms\n\n\n\n",
    "Fedora Core 6 running in Parallels - See comment 92 for hardware\n\nControl drawString() - count\u003d100000 time\u003d2464 ms\nControl stringExtent() - count\u003d100000 time\u003d491 ms\nImage drawString() - count\u003d100000 time\u003d2103 ms\nImage stringExtent() - count\u003d100000 time\u003d392 ms",
    "Comment 93 is wrong, I pasted the Vista numbers again.\n\nFedora numbers are:\nControl drawString() - count\u003d100000 time\u003d19881 ms\nControl stringExtent() - count\u003d100000 time\u003d5758 ms\nImage drawString() - count\u003d100000 time\u003d16635 ms\nImage stringExtent() - count\u003d100000 time\u003d6232 ms",
    "One of the things I noticed when configuring my wife\u0027s new laptop was that turning on ClearType caused the string benchmark to be 3..4 times slower. Are people running their XP tests with ClearType on or off?",
    "Mike raises a good point in #95 that reminds me of a problem we ran into with benchmarks and the Mac AWT. On the Mac, text is drawn aliased by default where on Windows (and, by extension, the AWT) it\u0027s antialiased by default. Comment #56 notes this difference on Linux as well. As a result we get clobbered in text benchmarks. Andre, can you try with and without the antialiasing to compare?",
    "Quite true, however, anti-alias should not affect measuring.  I suspect that Windows is highly optimized for English and the other platforms are not.  We should test this theory by benching a Bidi or Japanese string.  Does Windows start sucking or draw the text wrong?",
    "Re #96: turning off antialiasing does not have the expected effect:\n\nantialiasing off:\nControl drawString() - count\u003d100000 time\u003d6015 ms\nControl stringExtent() - count\u003d100000 time\u003d3556 ms\nImage drawString() - count\u003d100000 time\u003d5082 ms\nImage stringExtent() - count\u003d100000 time\u003d3595 ms\n\nantialiasing on:\nControl drawString() - count\u003d100000 time\u003d6063 ms\nControl stringExtent() - count\u003d100000 time\u003d3556 ms\nImage drawString() - count\u003d100000 time\u003d4657 ms\nImage stringExtent() - count\u003d100000 time\u003d3589 ms",
    "(In reply to comment #82)\n\u003e Hello Andrew, I believe the problem you have is not your fault but a bug in\n\u003e SWT. Grant, do you still have a 64bit linux machine ? Can you try the benchmark\n\u003e there ?\n\u003e \nFelipe, Steve, Grant....\nDo you know if this issue has been looked at?  Is this related to not extracting the library file from the Jar?  Would you like me to reopen Bug #166865 (or create another bug).  I don\u0027t think this is related to the benchmark, I just don\u0027t want this issue to get lost in the mix.",
    "Please create a new bug.",
    "(In reply to comment #100)\n\u003e Please create a new bug.\n\u003e \nDone:\nhttps://bugs.eclipse.org/bugs/show_bug.cgi?id\u003d169875",
    "So yeah, Andrew and I did some testing.  And I did the extents test in C too.  Seems like, using Hotspot, one-third of the extent measurement from Java is spent in the Java layer.  With natively compiled CLASSPATH it became half the time.\n\nI profiled the C example.  It\u0027s not very easy to optimize it drastically. 50% of the time is being spent in the OpenType shaper.  I\u0027m doing a rewrite of that code, that may or may not make it faster.  I can go on and make it fast, at the expense of more memory use, but my current feeling is that we shouldn\u0027t need to do that.\n\nAnyway, good point raised about ClearType.  Any comparison to non-ClearType rendering is Apples and Oranges (pun intended ;) )."
  ],
  "commentCreationDates": [
    "2004-02-11T17:57:25+01:00",
    "2004-02-11T18:00:16+01:00",
    "2004-02-11T18:03:00+01:00",
    "2004-02-11T18:28:16+01:00",
    "2004-02-11T18:59:41+01:00",
    "2004-02-11T19:28:47+01:00",
    "2004-02-11T19:43:19+01:00",
    "2004-02-12T18:17:15+01:00",
    "2004-02-12T20:22:31+01:00",
    "2004-02-14T00:45:16+01:00",
    "2004-02-25T00:13:25+01:00",
    "2004-02-25T01:15:26+01:00",
    "2004-02-25T08:44:17+01:00",
    "2004-02-25T23:45:33+01:00",
    "2004-02-26T21:36:33+01:00",
    "2004-02-26T21:42:02+01:00",
    "2004-02-26T22:06:05+01:00",
    "2004-02-26T23:15:29+01:00",
    "2004-02-26T23:18:21+01:00",
    "2004-02-26T23:27:53+01:00",
    "2004-02-26T23:33:43+01:00",
    "2004-02-26T23:47:21+01:00",
    "2004-02-27T00:03:42+01:00",
    "2004-02-27T00:52:21+01:00",
    "2004-02-27T00:53:31+01:00",
    "2004-03-01T19:33:26+01:00",
    "2004-03-01T20:12:44+01:00",
    "2004-03-01T20:48:03+01:00",
    "2004-03-01T20:53:44+01:00",
    "2004-03-01T21:22:09+01:00",
    "2004-03-01T21:25:16+01:00",
    "2004-03-01T22:04:14+01:00",
    "2004-03-02T21:18:45+01:00",
    "2004-03-02T21:26:55+01:00",
    "2004-03-03T09:12:44+01:00",
    "2004-03-03T13:02:50+01:00",
    "2004-03-03T13:42:22+01:00",
    "2004-03-03T15:51:43+01:00",
    "2004-03-03T15:57:40+01:00",
    "2004-03-03T21:06:34+01:00",
    "2004-03-03T21:09:03+01:00",
    "2004-03-03T23:49:38+01:00",
    "2004-03-04T07:17:57+01:00",
    "2004-03-04T07:27:54+01:00",
    "2004-03-04T09:20:28+01:00",
    "2004-03-04T09:34:47+01:00",
    "2004-03-04T17:19:58+01:00",
    "2004-03-04T17:21:01+01:00",
    "2004-03-04T19:16:21+01:00",
    "2004-03-05T07:24:13+01:00",
    "2004-03-05T20:23:38+01:00",
    "2004-03-05T22:16:48+01:00",
    "2004-10-04T18:59:09+02:00",
    "2004-10-04T19:00:51+02:00",
    "2005-03-25T17:22:11+01:00",
    "2006-02-18T09:59:10+01:00",
    "2006-04-24T22:48:19+02:00",
    "2006-04-24T22:57:37+02:00",
    "2006-04-25T00:06:03+02:00",
    "2006-04-25T01:11:08+02:00",
    "2006-04-26T06:03:47+02:00",
    "2006-07-19T21:36:08+02:00",
    "2006-07-26T16:24:36+02:00",
    "2006-07-26T16:43:02+02:00",
    "2006-07-26T17:42:00+02:00",
    "2006-08-17T17:17:54+02:00",
    "2006-12-19T22:43:39+01:00",
    "2006-12-20T01:01:50+01:00",
    "2007-01-04T11:43:20+01:00",
    "2007-01-04T16:15:06+01:00",
    "2007-01-04T16:21:02+01:00",
    "2007-01-04T16:36:11+01:00",
    "2007-01-04T16:41:57+01:00",
    "2007-01-04T17:27:47+01:00",
    "2007-01-04T18:49:27+01:00",
    "2007-01-04T20:09:28+01:00",
    "2007-01-04T21:13:01+01:00",
    "2007-01-04T21:22:22+01:00",
    "2007-01-04T21:54:37+01:00",
    "2007-01-04T22:12:09+01:00",
    "2007-01-04T22:33:26+01:00",
    "2007-01-04T22:34:55+01:00",
    "2007-01-04T23:01:37+01:00",
    "2007-01-04T23:17:59+01:00",
    "2007-01-04T23:37:26+01:00",
    "2007-01-04T23:53:13+01:00",
    "2007-01-04T23:58:37+01:00",
    "2007-01-05T00:06:27+01:00",
    "2007-01-05T00:09:27+01:00",
    "2007-01-05T14:19:11+01:00",
    "2007-01-05T23:26:02+01:00",
    "2007-01-05T23:27:56+01:00",
    "2007-01-07T21:01:35+01:00",
    "2007-01-07T21:08:18+01:00",
    "2007-01-07T21:11:34+01:00",
    "2007-01-08T14:53:39+01:00",
    "2007-01-08T16:41:06+01:00",
    "2007-01-08T17:02:04+01:00",
    "2007-01-08T17:09:17+01:00",
    "2007-01-08T17:41:13+01:00",
    "2007-01-08T18:30:55+01:00",
    "2007-01-08T18:41:41+01:00",
    "2007-01-09T03:21:15+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.UnsatisfiedLinkError",
      "message": "memmove",
      "elements": [
        {
          "method": "org.eclipse.swt.internal.gtk.OS.memmove",
          "source": "Native Method"
        },
        {
          "method": "org.eclipse.swt.internal.Converter.wcsToMbcs",
          "source": "Converter.java:67"
        },
        {
          "method": "org.eclipse.swt.internal.Converter.wcsToMbcs",
          "source": "Converter.java:54"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.\u003cclinit\u003e",
          "source": "Display.java:126"
        },
        {
          "method": "tests.StringBench.main",
          "source": "StringBench.java:30"
        }
      ],
      "number": 0,
      "commentIndex": 79,
      "bugId": "51693",
      "date": "2007-01-04T22:12:09+01:00",
      "product": "Platform",
      "component": "SWT",
      "severity": "normal"
    }
  ],
  "groupId": "51693",
  "bugId": "51693",
  "date": "2004-02-11T17:57:25+01:00",
  "product": "Platform",
  "component": "SWT",
  "severity": "normal"
}