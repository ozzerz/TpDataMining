{
  "comments": [
    "Problem arise for References that are internal to Resources and are persistend in the form\n\n\u003cgroupOfRefs refName\u003d\"referencedObjectID\"\u003e\nother stuff\n\u003c/groupOfRefs\u003e\n\nIf referenced EObjects overrides the method for the ID with following version of the code that computes the ID:\n\n--If the EObject is in a Resource, the ID is computed and returned.\n--If the resource is instead null, null is returned.\n\nif the referenced object is removed form Resource, at save time, it goes into XMLHelperImpl in the method GetUriFragment an at line 659, and asks for the URI Fragment: \"/-1\" is returned. This is then interpreted as a correct URI and added to persistence:\n\n\u003cgroupOfRefs refName\u003d\"/-1\"\u003e\nother stuff\n\u003c/groupOfRefs\u003e\n\nwhat causes after save a\n\njava.lang.ArrayIndexOutOfBoundsException: -1\n at org.eclipse.emf.common.util.BasicEList.get(BasicEList.java:514)\n at \norg.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObjectForURIFragmentRootSegment(ResourceImpl.java:642)\n at \norg.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject(ResourceImpl.java:692)\n at \norg.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject(ResourceImpl.java:671)\n...\n\nEd Merks said:\n\n\"it sounds like ResourceImpl.getURIFragmentRootSegment is called for an object that isn\u0027t really a root object in that resource\"\n\nand he said again:\n\n\"This method in XMLHelperImpl checks for dangling references \n\n  public String getHREF(EObject obj) \n  { \n    InternalEObject o \u003d (InternalEObject) obj; \n\n    URI objectURI \u003d o.eProxyURI(); \n    if (objectURI \u003d\u003d null) \n    { \n      Resource otherResource \u003d obj.eResource(); \n      if (otherResource \u003d\u003d null) \n      { \n        if (resource !\u003d null \u0026\u0026 resource.getID(obj) !\u003d null) \n        { \n          objectURI \u003d getHREF(resource, obj); \n        } \n        else \n        { \n          objectURI \u003d handleDanglingHREF(obj); \n          if (objectURI \u003d\u003d null) \n          { \n            return null; \n          } \n        } \n      } \n      else \n      { \n        objectURI \u003d getHREF(otherResource, obj); \n      } \n    } \n\n    objectURI \u003d deresolve(objectURI); \n\n    return objectURI.toString(); \n  } \n\nBut I can see that when getIDREF is used, no such check is done.  (The later gets called when isResolveProxies is false.)   The same problem occurs in EMF 2.1. This seems like something that should be fixed (as should the handling of failures while looking up a reference).\"\n\n\nProblem to solve are hence 2:\n\n- 1 - the check for dangling references should work for getIDREF too and hence not write refName\u003d\"/-1\" at all\n- 2 - parsing of persistence problems like refName\u003d\"/-1\" should not throw ArrayIndexOutOfBound - should instead throw some kind of wrapped exception.",
    "I\u0027ll reduce the severity to major, since it appears at this point to have been a very long standing problem.  I\u0027ll try to get a fix before next week\u0027s M build...",
    "Created an attachment (id\u003d47811)\nPatches for properly omitting dangling references\n\nThis really wasn\u0027t being handled well at all for IDREF and not so well even for HREF.  The changes are quite extensive and seem perhaps too risky for the maintenance stream.\n\nCould you apply this changes locally for your production purposes and we make them only in the 3.3 stream we start next month?  \n\nAnother workaround is to use the following to delete all your dangling references before you save:\n\n        for (Iterator i \u003d \n               new EcoreUtil.CrossReferencer(resource)\n               {\n                 {\n                  crossReference();\n                 }\n\n                 protected boolean crossReference(EObject eObject, EReference eReference, EObject crossReferencedEObject)\n                 {\n                   return crossReferencedEObject.eResource() \u003d\u003d null;\n                 }\n               }.entrySet().iterator();\n             i.hasNext(); )\n        {\n          Map.Entry entry \u003d (Map.Entry)i.next();\n          for (Iterator j \u003d ((List)entry.getValue()).iterator(); j.hasNext(); )\n          {\n            EcoreUtil.remove((EStructuralFeature.Setting)j.next(), entry.getKey());\n          }\n        }",
    "Created an attachment (id\u003d52996)\nRevised and more well tested changes to fix this bug\n\n",
    "The fix has been committed to CVS.",
    "Fixed in 2.3.0M3.",
    "*** Bug 191431 has been marked as a duplicate of this bug. ***"
  ],
  "commentCreationDates": [
    "2006-08-11T16:35:21+02:00",
    "2006-08-11T20:16:42+02:00",
    "2006-08-12T17:15:02+02:00",
    "2006-10-31T15:44:40+01:00",
    "2006-11-04T16:00:08+01:00",
    "2006-11-10T01:11:17+01:00",
    "2007-06-07T13:05:32+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ArrayIndexOutOfBoundsException",
      "message": "-1",
      "elements": [
        {
          "method": "org.eclipse.emf.common.util.BasicEList.get",
          "source": "BasicEList.java:514"
        },
        {
          "method": "org.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObjectForURIFragmentRootSegment",
          "source": "ResourceImpl.java:642"
        },
        {
          "method": "org.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject",
          "source": "ResourceImpl.java:692"
        },
        {
          "method": "org.eclipse.emf.ecore.resource.impl.ResourceImpl.getEObject",
          "source": "ResourceImpl.java:671"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "153577",
      "date": "2006-08-11T16:35:21+02:00",
      "product": "EMF",
      "component": "XML/XMI",
      "severity": "major"
    }
  ],
  "groupId": "153577",
  "bugId": "153577",
  "date": "2006-08-11T16:35:21+02:00",
  "product": "EMF",
  "component": "XML/XMI",
  "severity": "major"
}