{
  "comments": [
    "I was weaving a 3rd party library and wrote an aspect that should affect both a \nbase class and a derived class, but inadvertently wove only the derived class.  \nThis resulted in the following error. I would like the weaver to catch this \nkind of error at weave (link) time, rather than creating code that results in a \nrt error... I get this error in 1.1.1 final and in a fairly recent version from \nCVS HEAD:\n\njava.lang.AbstractMethodError\n\tat ajee.logging.LogManager.ajc$interMethodDispatch1\n$ajee_logging_LogManager$ajee_logging_Loggable$getLogger(LogManager.java)\n\tat \najee.tracing.ExecutionTracer.ajc$before$ajee_tracing_ExecutionTracer$926\n(ExecutionTracer.java:62)\n\tat library.Derived.\u003cinit\u003e(Derived.java:46)\n\nThis line is a call to super();\n\nI\u0027ve attached a small example that reproduces another error that I think is \nrelated:\nC:\\devel\\test\\ctors\\twoPass\u003ebuild\n\nC:\\devel\\test\\ctors\\twoPass\u003ecall ajc -outjar fullBase.jar sample\\Base.java sampl\ne\\Derived.java\nException in thread \"main\" java.lang.ExceptionInInitializerError\n        at sample.Derived.\u003cinit\u003e(Derived.java:6)\n        at sample.Derived.main(Derived.java:13)\nCaused by: org.aspectj.lang.NoAspectBoundException\n        at sample.Trace.aspectOf(Trace.aj)\n        at sample.Trace.\u003cinit\u003e(Trace.aj:5)\n        at sample.Trace.ajc$postClinit(Trace.aj)\n        at sample.Trace.\u003cclinit\u003e(Trace.aj:5)\n        ... 2 more",
    "Created an attachment (id\u003d7354)\ntest case\n",
    "I can reproduce the failure in the testcase however the NoAspectBoundException \nis because the Trace aspect is advising itself (it is also in the sample \npackage). If a \"!within(Trace)\" is used the testcase runs.\n\nWe need a more representative testcase.",
    "Here\u0027s a revised version that replicates the bug by adding in an interface that \nis woven and that the abstract class implements (which isn\u0027t woven). I also \nexcluded the aspect from affecting itself so the real error is visible:\n\nException in thread \"main\" java.lang.AbstractMethodError: sample.Derived.getLogg\ner()Ljava/util/logging/Logger;\n        at sample.Trace.ajc$interMethodDispatch1$sample_Trace$sample_Trace$Trace\nd$getLogger(Trace.aj)\n        at sample.Trace.ajc$before$sample_Trace$d2(Trace.aj:12)\n        at sample.Derived.\u003cinit\u003e(Derived.java:6)\n        at sample.Derived.main(Derived.java:13)",
    "Created an attachment (id\u003d7511)\nrevised test case that exposes the actual bug\n",
    "Some notes on this bug ... I think there is something that needs fixing, \npossibly with a compiler error message.\n \nExplaining Rons program:\nan interface \u0027Iface\u0027 is implemented by an abstract class \u0027Base\u0027 which is then \nextended with a class \u0027Derived\u0027.\n\nAll three are compiled into a jar.  We then take \u0027Base.class\u0027 out of that jar.\nThe resulting jar with just two classes in it is woven against a Trace aspect. \n(The compiler/weaver can still find Base.class because it is accessible on the \nCLASSPATH). The \u0027Trace\u0027 aspect includes an inner Traced interface onto which \nit ITDs a field and a method.  The aspect declares that all the classes apart \nfrom itself implement \u0027Trace\u0027.\n\nWe then execute the Derived class which blows up trying to find an \nimplementation of the method that was introduced to the interface (getLogger).\n\nI *think* that because getLogger is introduced onto an interface, its \nimplementation would normally be introduced into top-most implementors.  \nDuring the compilation that involved the aspect, Base.class was on CLASSPATH \nso not a target for weaving.  This means getLogger() was not introduced onto \nit, even though the abstract method getLogger was introduced upon the \nTrace.Traced interface (so at runtime this manifests as an \nAbstractMethodError).  It seems that in the inheritance hierarchy we \nconsidered Base.class to be the top most implementor of Traced - even though \nit couldn\u0027t be woven?\n\nTracing the compile that involved the 2 class jar and the aspect, I see a \nmungeNewMethod() for the getLogger ITD on the interface Traced and I see a \nmungeNewField() for the ITDd field on Traced.  I don\u0027t see (obviously) the \nmungeNewMethod() for the getLogger implementation on Base.class.\n\nI think we should have thrown an error on this compile when we couldn\u0027t \nintroduce the method implementation into the right place?\n\nHowever... it is possibly more subtle than that because if I take the \ninterface Iface entirely out of the frame, so I simply have an abstract class \nBase and its subclass Derived and I repeat the steps above, it works - in this \nsituation the getLogger() implementation is put into Derived ?!?\n\nphew.",
    "This bug has strong similarities to #52107.  In this case it seems that the \ncompiler isn\u0027t checking that it has access to the top-most implementors of an \ninterface that has a concrete introduction on it.  My guess is that you want \nto modify the same ResolvedTypeMunger.matches method to also do this check for \nthe top-most implementors when the target type is an interface.",
    "updated to milestone 1.2",
    "marked as target 1.2.1",
    "Progress. And it explains my confused comment made a couple of months back.\n\nWe have interface \u0027Iface\u0027 and implementor of that \u0027Base\u0027 and subclass of Base\ncalled \u0027Derived\u0027.  Iface and Derived are accessible for weaving.\n\nAn aspect makes a non-abstract ITD onto an interface called \u0027Traced\u0027 and also a\ndeclare parents statement for everything (Iface/Base/Derived) to implement \u0027Traced\u0027.\n\nThe problem arises due to an ordering issue - our approach is to go through each\ntype and for each one apply all type mungers then all shadow mungers.  I think\nthis is still right.  The problem here is that we match the munger for the ITD\nagainst the \u0027Derived\u0027 class and correctly discover (at that point in time) that\nit is indeed the top most implementor of \u0027Traced\u0027 because \u0027Base\u0027 wasn\u0027t touched\nby the declare parents statement.  However ... just after we discover it is\n\u0027Derived\u0027 we then move on to \u0027IFace\u0027 and apply the declare parents statement to\nit.  This means IFace implements Traced and therefore Base now implements Traced\neven though we didn\u0027t actually touch Base.  What happens later on is that we\nmake this check:\n\nif (onInterface \u0026\u0026                             // The ITD was on an interface \n    !Modifier.isAbstract(signature.getModifiers()) \u0026\u0026 // It was not abstract\n    gen.genType().isTopmostImplementor(onType)) { // we are looking at the\n                                                  // top most implementor.\n // Stick the body of the ITD method in.\n\nThis fails because isTopmostImplementor now returns false for \u0027Derived\u0027 at the\npoint we do the weave - in this situation we quietly do nothing and so you don\u0027t\nget an implementation of the ITD put anywhere!  \n\nI have changed this slightly so that if we are processing a type that is no\nlonger the top most implementor (when it used to be) then report an error that\nwe need access to the proper top most implementor for weaving:\n\ntype sample.Base must be accessible for weaving interface inter type declaration\nfrom aspect sample.Trace\n\n\nIt is an unusual situation because you are giving some of the top and bottom of\nan inheritance hierarchy to AspectJ but not the middle bit.",
    "Fix checked in - waiting for build.",
    "Fix available:\n\nBUILD COMPLETE -  build.349\nDate of build: 08/20/2004 10:22:41\nTime to build: 93 minutes 15 seconds\nLast changed: 08/20/2004 08:18:14\nLatest good AspectJ jar available at:\ndownload.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar",
    "Fix released as part of AspectJ 1.2.1"
  ],
  "commentCreationDates": [
    "2004-01-07T22:27:35+01:00",
    "2004-01-07T22:28:08+01:00",
    "2004-01-08T15:21:58+01:00",
    "2004-01-21T19:52:58+01:00",
    "2004-01-21T19:53:57+01:00",
    "2004-02-27T15:18:47+01:00",
    "2004-03-05T02:38:20+01:00",
    "2004-03-16T09:56:02+01:00",
    "2004-08-09T21:25:07+02:00",
    "2004-08-19T16:28:07+02:00",
    "2004-08-19T18:45:08+02:00",
    "2004-08-20T14:24:29+02:00",
    "2004-10-21T10:32:46+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.AbstractMethodError",
      "elements": [
        {
          "method": "ajee.logging.LogManager.ajc$interMethodDispatch1$ajee_logging_LogManager$ajee_logging_Loggable$getLogger",
          "source": "LogManager.java"
        },
        {
          "method": "ajee.tracing.ExecutionTracer.ajc$before$ajee_tracing_ExecutionTracer$926",
          "source": "ExecutionTracer.java:62"
        },
        {
          "method": "library.Derived.\u003cinit\u003e",
          "source": "Derived.java:46"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "49657",
      "date": "2004-01-07T22:27:35+01:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.ExceptionInInitializerError",
      "elements": [
        {
          "method": "sample.Derived.\u003cinit\u003e",
          "source": "Derived.java:6"
        },
        {
          "method": "sample.Derived.main",
          "source": "Derived.java:13"
        }
      ],
      "causedBy": {
        "exceptionType": "org.aspectj.lang.NoAspectBoundException",
        "elements": [
          {
            "method": "sample.Trace.aspectOf",
            "source": "Trace.aj"
          },
          {
            "method": "sample.Trace.\u003cinit\u003e",
            "source": "Trace.aj:5"
          },
          {
            "method": "sample.Trace.ajc$postClinit",
            "source": "Trace.aj"
          },
          {
            "method": "sample.Trace.\u003cclinit\u003e",
            "source": "Trace.aj:5"
          }
        ],
        "number": 0,
        "commentIndex": 0
      },
      "number": 1,
      "commentIndex": 0,
      "bugId": "49657",
      "date": "2004-01-07T22:27:35+01:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.AbstractMethodError",
      "message": "sample.Derived.getLogg er()Ljava/util/logging/Logger;",
      "elements": [
        {
          "method": "sample.Trace.ajc$interMethodDispatch1$sample_Trace$sample_Trace$Traced$getLogger",
          "source": "Trace.aj"
        },
        {
          "method": "sample.Trace.ajc$before$sample_Trace$d2",
          "source": "Trace.aj:12"
        },
        {
          "method": "sample.Derived.\u003cinit\u003e",
          "source": "Derived.java:6"
        },
        {
          "method": "sample.Derived.main",
          "source": "Derived.java:13"
        }
      ],
      "number": 2,
      "commentIndex": 3,
      "bugId": "49657",
      "date": "2004-01-21T19:52:58+01:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "49657",
  "bugId": "49657",
  "date": "2004-01-07T22:27:35+01:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}