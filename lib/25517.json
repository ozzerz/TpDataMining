{
  "comments": [
    "I am reporting this bug for a WSAD customer.\n\nI have a simple scenario that will crash the Eclipse workbench.  The key to \nmaking the crash happen seems to be that I need to have two projects whose \nclasspath is dependent on each other with each dependency exported.  \n\nI will attach two .zip files- each containing a Java Project that exhibit this \nbehavior.  Here are the steps to follow:\n\n- Unzip each of these projects into your workspace.  \n- Start Eclipse - verify that IafConfigurationEJB is dependentent on \nIafConfigurationJAVA and vice versa inthe Java Build Paths page. Also notice \nthat each dependendency is exported.\n- Open the com.deere.u90.iaf.configuration.ConfigurationPropertiesHelper \nclass.  In the Outline view, select the GetDefaultDirectory() method and \nselect Refactor-\u003eRename.  Rename the method to GetDefaultDirectoryXX() and \nselect the Next button.  The JVM will crash and the Eclipse will come down.\n\nNote that if you remove the exports or the circular dependency, the crash does \nnot occur.",
    "Created an attachment (id\u003d2289)\nIafConfigurationEJB\n",
    "Created an attachment (id\u003d2290)\nIafConfigurationJAVA\n",
    "Do you have any information printed in the console when the VM exits ?",
    "Moreover, do you have any evidence that JDT/Core is guilty ?",
    "I am not sure if it is the JDT Core that is at fault, but the problem is \nsomewhere in the JDT.  Its hard for me to distinguish the source of problem.  \n\nThere is nothing of consequence written to the .log file and nothing that I \ncan see written to the console when I run with the -consolelog option.  If \nthere are other options you want me to run with or futher debugging you would \nlike me to do, please let me know.  I will be happy to try anything. ",
    "Thanks for checking, we will have to try reproducing it.",
    "Cannot reproduce.\n\nI grabbed wsa-base-20021030_0100-WB202-AD-V50S-GA.zip+wsa-jdk-20021030_0100-\nWB202-AD-V50S-GA.zip.\n\nI unzipped the 2 zip files, and created one EJP project on top of \nIafConfigurationEJB, one Java project on top of IafConfigurationJAVA.\nThe JAVA project did not prereq the EJB one, I added it on the classpath (note \nthat it does not seem to need it anyway).\n\nRefactor worked fine, proposed me two matches (one in each project).\n\nAm I missing something ? Which VM were you using (could just be a VM bug as \nsymptoms seem to indicate). I was using the default wsad/eclipse/jre one which \ncame with the install.\n\n",
    "Was able to reproduce the crash with following steps:\nUnzip the project zips, and then create \"simple\" projects on top of them.\n",
    "By disabling the JIT (-Djava.compiler\u003dnone), a stack overflow gets dumped into \nthe .log. Refactoring is looping:\n\njava.fullversion\u003dJ2RE 1.3.1 IBM Windows 32 build cn131-20020710 (JIT disabled)\nBootLoader constants: OS\u003dwin32, ARCH\u003dx86, WS\u003dwin32, NL\u003den_US\nCommand-line arguments: -os win32 -ws win32 -arch x86 -data \nd:\\eclipse\\wsad\\workspace -install file:D:/eclipse/wsad/eclipse/\n!ENTRY org.eclipse.jdt.ui 4 1 Oct 31, 2002 12:24:50.304\n!MESSAGE Internal Error\n!STACK 0\njava.lang.reflect.InvocationTargetException: java.lang.StackOverflowError\n\tat java.lang.String.compareTo(String.java:1313)\n\tat org.eclipse.core.internal.dtree.AbstractDataTreeNode.childAtOrNull\n(AbstractDataTreeNode.java:208)\n\tat org.eclipse.core.internal.dtree.DeltaDataTree.lookup\n(DeltaDataTree.java:702)\n\tat org.eclipse.core.internal.watson.ElementTree.includes\n(ElementTree.java:706)\n\tat org.eclipse.core.internal.resources.Workspace.getResourceInfo\n(Workspace.java:976)\n\tat org.eclipse.core.internal.resources.Resource.getResourceInfo\n(Resource.java:686)\n\tat org.eclipse.core.internal.resources.Resource.exists\n(Resource.java:538)\n\tat org.eclipse.jdt.internal.core.JavaProject.getSharedProperty\n(JavaProject.java:1468)\n\tat org.eclipse.jdt.internal.core.JavaProject.loadClasspath\n(JavaProject.java:1604)\n\tat org.eclipse.jdt.internal.core.JavaProject.getRawClasspath\n(JavaProject.java:1247)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.addRe\nferencingProjects(RefactoringScopeFactory.java:61)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.addRe\nferencingProjects(RefactoringScopeFactory.java:67)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.addRe\nferencingProjects(RefactoringScopeFactory.java:67)\n        ....\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.addRe\nferencingProjects(RefactoringScopeFactory.java:67)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.addRe\nferencingProjects(RefactoringScopeFactory.java:67)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.addRe\nferencingProjects(RefactoringScopeFactory.java:67)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.addRe\nferencingProjects(RefactoringScopeFactory.java:67)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.creat\ne(RefactoringScopeFactory.java:33)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.creat\ne(RefactoringScopeFactory.java:52)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodRefactoring.creat\neRefactoringScope(RenameMethodRefactoring.java:244)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodRefactoring.getOc\ncurrences(RenameMethodRefactoring.java:285)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodRefactoring.check\nInput(RenameMethodRefactoring.java:214)\n\tat \norg.eclipse.jdt.internal.corext.refactoring.rename.RenameStaticMethodRefactoring\n.checkInput(RenameStaticMethodRefactoring.java:51)\n\tat org.eclipse.jdt.internal.ui.refactoring.CheckConditionsOperation.run\n(CheckConditionsOperation.java:58)\n\tat org.eclipse.jdt.internal.ui.refactoring.CreateChangeOperation.run\n(CreateChangeOperation.java:93)\n\tat org.eclipse.jface.operation.ModalContext$ModalContextThread.run\n(ModalContext.java:98)\n\n\nMoving to JDT/UI\n",
    "George, you should open a defect against your VM provider (is it Husrley?) The \nVM should not crash like that because of a StackOverflowError.\n\nAdam, this can be reproduced in Eclipse 2.0.1",
    "Glancing through the offending code, the method incorrectly rebuilds the list \nof prerequisite projects. It iterates over raw classpaths, but projects could \nbe made available through variables/containers (JDT/Core API supports it).\n\nSuggested fix:\n\tprivate static void addReferencingProjects(IProject focus, List list) \nthrows JavaModelException {\n\t\tIPath path\u003d focus.getProject().getFullPath();\n\t\tIProject[] projects\u003d focus.getProject().getReferencingProjects\n();\n\t\tfor (int i\u003d 0, length\u003d projects.length; i \u003c length; i++) {\n\t\t\tIProject project\u003d projects[i];\n\t\t\tif (list.contains(project)) continue; // break cycle\n\t\t\tIJavaProject javaProject\u003d JavaCore.create(project);\n\t\t\tIClasspathEntry[] classpath\u003d \njavaProject.getResolvedClasspath(true);\n\t\t\tfor (int j\u003d 0, length2\u003d classpath.length; j \u003c length2; \nj++) {\n\t\t\t\tIClasspathEntry entry\u003d classpath[j];\n\t\t\t\tif (entry.getEntryKind() \u003d\u003d \nIClasspathEntry.CPE_PROJECT \u0026\u0026 path.equals(entry.getPath())) {\n\t\t\t\t\tlist.addAll(getSourceRoots\n(javaProject));\n\t\t\t\t\tif (entry.isExported())\n\t\t\t\t\t\taddReferencingProjects\n(javaProject.getProject(), list);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "Actually, in 2.0.1 branch, the fix should rather look like:\n\n\tprivate static void addReferencingProjects(IProject focus, List list) \nthrows JavaModelException {\n\t\tIPath path\u003d focus.getProject().getFullPath();\n\t\tIProject[] projects\u003d focus.getProject().getReferencingProjects\n();\n\t\tfor (int i\u003d 0, length\u003d projects.length; i \u003c length; i++) {\n\t\t\tIProject project\u003d projects[i];\n\t\t\tif (list.contains(project)) continue; // break cycle\t\n\t\t\n\t\t\tIJavaProject javaProject\u003d JavaCore.create(project);\n\t\t\tIClasspathEntry[] classpath\u003d \njavaProject.getResolvedClasspath(true);\n\t\t\tfor (int j\u003d 0, length2\u003d classpath.length; j \u003c length2; \nj++) {\n\t\t\t\tIClasspathEntry entry\u003d classpath[j];\n\t\t\t\tif (entry.getEntryKind() \u003d\u003d \nIClasspathEntry.CPE_PROJECT \u0026\u0026 path.equals(entry.getPath())) {\n\t\t\t\t\tlist.add(javaProject);\n\t\t\t\t\tif (entry.isExported())\n\t\t\t\t\t\taddReferencingProjects\n(javaProject.getProject(), list);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\t",
    "I guess I should have tried the fix before posting it... \u003cg\u003e\n\nThe fix should rather read:\n\n\tprivate static void addReferencingProjects(IProject focus, List list) \nthrows JavaModelException {\n\t\tIPath path\u003d focus.getProject().getFullPath();\n\t\tIProject[] projects\u003d focus.getProject().getReferencingProjects\n();\n\t\tfor (int i\u003d 0, length\u003d projects.length; i \u003c length; i++) {\n\t\t\tIProject project\u003d projects[i];\n\t\t\tIJavaProject javaProject\u003d JavaCore.create(project);\n\t\t\tif (list.contains(javaProject)) continue; // break cycle\n\t\t\t\n\t\t\tIClasspathEntry[] classpath\u003d \njavaProject.getResolvedClasspath(true);\n\t\t\tfor (int j\u003d 0, length2\u003d classpath.length; j \u003c length2; \nj++) {\n\t\t\t\tIClasspathEntry entry\u003d classpath[j];\n\t\t\t\tif (entry.getEntryKind() \u003d\u003d \nIClasspathEntry.CPE_PROJECT \u0026\u0026 path.equals(entry.getPath())) {\n\t\t\t\t\tlist.add(javaProject);\n\t\t\t\t\tif (entry.isExported())\n\t\t\t\t\t\taddReferencingProjects\n(javaProject.getProject(), list);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\t",
    "Here\u0027s the proposed fix. \n\nWe now have a method addReferencingProjectSourceRoots, which finds source roots \nin referencing projects other than focus. This method is implemented in terms \nof another method, addReferencingProjects, which is recursive; the recursive \nmethod adds IJavaProjects to a list.\n\n---8\u003c---\n\n/*******************************************************************************\n * Copyright (c) 2000, 2001 International Business Machines Corp. and others.\n * All rights reserved. This program and the accompanying materials \n * are made available under the terms of the Common Public License v1.0 \n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n * \n * Contributors:\n *     IBM Corporation - initial API and implementation\n ******************************************************************************/\npackage org.eclipse.jdt.internal.corext.refactoring.rename;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\n\nimport org.eclipse.jdt.core.IClasspathEntry;\nimport org.eclipse.jdt.core.IJavaElement;\nimport org.eclipse.jdt.core.IJavaProject;\nimport org.eclipse.jdt.core.IMember;\nimport org.eclipse.jdt.core.IPackageFragment;\nimport org.eclipse.jdt.core.IPackageFragmentRoot;\nimport org.eclipse.jdt.core.JavaCore;\nimport org.eclipse.jdt.core.JavaModelException;\nimport org.eclipse.jdt.core.search.IJavaSearchScope;\nimport org.eclipse.jdt.core.search.SearchEngine;\n\nimport org.eclipse.jdt.internal.corext.util.JdtFlags;\n\npublic class RefactoringScopeFactory {\n\t\n\tprivate RefactoringScopeFactory(){\n\t}\n\t\n\tprivate static IJavaSearchScope create(IJavaProject javaProject) throws \nJavaModelException {\n\t\tList elements\u003d getSourceRoots(javaProject);\n\t\taddReferencingProjectSourceRoots(javaProject.getProject(), \nelements);\n\t\treturn SearchEngine.createJavaSearchScope((IJavaElement[]) \nelements.toArray(new IJavaElement[elements.size()]), false);\n\t}\n\n\tpublic static IJavaSearchScope create(IJavaElement javaElement) throws \nJavaModelException {\n\t\tif (javaElement instanceof IMember) {\n\t\t\tIMember member\u003d (IMember)javaElement;\n\t\t\tif (JdtFlags.isPrivate(member)) {\n\t\t\t\tif (member.getCompilationUnit() !\u003d null)\n\t\t\t\t\treturn \nSearchEngine.createJavaSearchScope(new IJavaElement[]{member.getCompilationUnit\n()});\n\t\t\t\telse \t\n\t\t\t\t\treturn \nSearchEngine.createJavaSearchScope(new IJavaElement[]{member});\n\t\t\t}\t\n\t\t\tif (! JdtFlags.isPublic(member) \u0026\u0026 !JdtFlags.isProtected\n(member) \u0026\u0026 member.getCompilationUnit() !\u003d null) {\n\t\t\t\tIPackageFragment pack\u003d (IPackageFragment)\nmember.getCompilationUnit().getParent();\n\t\t\t\treturn SearchEngine.createJavaSearchScope(new \nIJavaElement[]{pack});\n\t\t\t}\t\n\t\t}\n\t\treturn create(javaElement.getJavaProject());\n\t}\n\t\n\t/**\n\t * Adds to sourceRoots all source roots in projects referencing focus\n\t * (excluding focus itself)\n\t * \n\t * @param focus\t\n\t * @param sourceRoots\t\tSource roots (IPackageFragmentRoot) \nwill be\n\t * added to this list\n\t */\n\tprivate static void addReferencingProjectSourceRoots(IProject focus, \nList sourceRoots) throws JavaModelException  {\n\t\t\n\t\tList projects\u003d new ArrayList();\n\t\taddReferencingProjects(focus, projects);\n\t\t// remove focus project in case it has been added because it\n\t\t// references itself indirectly  \n\t\tprojects.remove(JavaCore.create(focus));\n\t\tsourceRoots.addAll(getAllSourceRootsInProjects(projects));\n\t}\n\t\n\t/**\n\t * Adds to \u003ccode\u003eprojects\u003c/code\u003e IJavaProject objects for all projects\n\t * referenced by focus\n\t * \n\t * @param focus\n\t * @param list\t\tIJavaProjects will be added to this list\n\t * @throws JavaModelException\n\t */\n\tprivate static void addReferencingProjects(IProject focus, List list) \nthrows JavaModelException {\n\t\tIPath path\u003d focus.getProject().getFullPath();\n\t\tIProject[] projects\u003d focus.getProject().getReferencingProjects\n();\n\t\tfor (int i\u003d 0, length\u003d projects.length; i \u003c length; i++) {\n\t\t\tIProject project\u003d projects[i];\n\t\t\tIJavaProject javaProject\u003d JavaCore.create(project);\n\t\t\tif (list.contains(javaProject))\n\t\t\t\tcontinue; // break cycle\t\t\t\n\t\t\tIClasspathEntry[] classpath\u003d \njavaProject.getResolvedClasspath(true);\n\t\t\tfor (int j\u003d 0, length2\u003d classpath.length; j \u003c length2; \nj++) {\n\t\t\t\tIClasspathEntry entry\u003d classpath[j];\n\t\t\t\tif (entry.getEntryKind() \u003d\u003d \nIClasspathEntry.CPE_PROJECT \u0026\u0026 path.equals(entry.getPath())) {\n\t\t\t\t\tlist.add(javaProject);\n\t\t\t\t\tif (entry.isExported())\n\t\t\t\t\t\taddReferencingProjects\n(javaProject.getProject(), list);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * @param projects\t\ta list of IJavaProject\n\t * @return List\t\ta list of IPackageFragmentRoot\n\t */\n\tprivate static List getAllSourceRootsInProjects(List projects) throws \nJavaModelException {\n\t\tList result\u003d new ArrayList();\n\t\tfor(Iterator it\u003d projects.iterator(); it.hasNext();)\n\t\t\tresult.addAll(getSourceRoots((IJavaProject)it.next()));\n\t\t\n\t\treturn result;\n\t}\n\t\n\tprivate static List getSourceRoots(IJavaProject javaProject) throws \nJavaModelException {\n\t\tList elements\u003d new  ArrayList();\n\t\tIPackageFragmentRoot[] roots\u003d \njavaProject.getPackageFragmentRoots();\n\t\t// Add all package fragment roots except archives\n\t\tfor (int i\u003d 0; i \u003c roots.length; i++) {\n\t\t\tIPackageFragmentRoot root\u003d roots[i];\n\t\t\tif (!root.isArchive())\n\t\t\t\telements.add(root);\n\t\t}\n\t\treturn elements;\n\t}\t\t\n}\n\n",
    "Rory\u0027s assessment is related to 2.1 stream while Philippe\u0027s fix is the good one\nfor 2.0.2.\nRory and Claude are currently testing the Philippe\u0027s fix on 2.0.2 stream.\n",
    "We tested and released Philippe\u0027s patch.\n\n-- Claude and Rory.",
    "Must still be fixed against HEAD.",
    "Fix for HEAD will be provided next Monday when Dirk is back. He is one of the\nrefactoring guys.\n",
    "Reminder: the milestone for this defect should probably be 2.0.2",
    "There are two issues here\n1) the target milestone: this should be either 2.0.2 or 2.1 M3 - but not 2.1 M4.\nI think we don\u0027t have a clear rule what we do with PRs that we fix in two or\nmore streams but as far as I can remember we set the milestone to the first\noccurrence of the fix - in this case 2.0.2.\n\n2) the version. This bug was reported against 2.0.2 and Claude now changed it to\nbe 2.1.\n\nGiven the bugzilla restrictions I think the best solution would be to have two\nPRs: one for version 2.0.2 whit target milestone 2.0.2 and the other for 2.1\nwith target milestone 2.1. This will allow us to find the fixed PRs for a given\nrelease (e.g. 2.0.2 or 2.1).\n",
    "Dirk, please see with Rory for proposed patch for HEAD.",
    "Here is my proposed fix for HEAD.\nThe methods compose better with these method choices.\n\n\n/*******************************************************************************\n * Copyright (c) 2000, 2001 International Business Machines Corp. and others.\n * All rights reserved. This program and the accompanying materials \n * are made available under the terms of the Common Public License v1.0 \n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/cpl-v10.html\n * \n * Contributors:\n *     IBM Corporation - initial API and implementation\n ******************************************************************************/\npackage org.eclipse.jdt.internal.corext.refactoring.rename;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\n\nimport org.eclipse.jdt.core.IClasspathEntry;\nimport org.eclipse.jdt.core.IJavaElement;\nimport org.eclipse.jdt.core.IJavaProject;\nimport org.eclipse.jdt.core.IMember;\nimport org.eclipse.jdt.core.IPackageFragment;\nimport org.eclipse.jdt.core.IPackageFragmentRoot;\nimport org.eclipse.jdt.core.JavaCore;\nimport org.eclipse.jdt.core.JavaModelException;\nimport org.eclipse.jdt.core.search.IJavaSearchScope;\nimport org.eclipse.jdt.core.search.SearchEngine;\n\nimport org.eclipse.jdt.internal.corext.util.JdtFlags;\n\npublic class RefactoringScopeFactory {\n\t\n\tpublic static IJavaSearchScope create(IJavaElement javaElement) throws \nJavaModelException {\n\t\tif (javaElement instanceof IMember) {\n\t\t\tIMember member\u003d (IMember)javaElement;\n\t\t\tif (JdtFlags.isPrivate(member)) {\n\t\t\t\tif (member.getCompilationUnit() !\u003d null)\n\t\t\t\t\treturn \nSearchEngine.createJavaSearchScope(new IJavaElement[]{member.getCompilationUnit\n()});\n\t\t\t\telse \t\n\t\t\t\t\treturn \nSearchEngine.createJavaSearchScope(new IJavaElement[]{member});\n\t\t\t}\t\n\t\t\tif (! JdtFlags.isPublic(member) \u0026\u0026 !JdtFlags.isProtected\n(member) \u0026\u0026 member.getCompilationUnit() !\u003d null) {\n\t\t\t\tIPackageFragment pack\u003d (IPackageFragment)\nmember.getCompilationUnit().getParent();\n\t\t\t\treturn SearchEngine.createJavaSearchScope(new \nIJavaElement[]{pack});\n\t\t\t}\t\n\t\t}\n\t\treturn create(javaElement.getJavaProject());\n\t}\n\n\tprivate RefactoringScopeFactory(){\n\t}\n\t\n\tprivate static IJavaSearchScope create(IJavaProject javaProject) throws \nJavaModelException {\n\t\treturn SearchEngine.createJavaSearchScope(getAllScopeElements\n(javaProject), false);\n\t}\n\t\n\tprivate static IJavaElement[] getAllScopeElements(IJavaProject project) \nthrows JavaModelException {\n\t\tCollection sourceRoots\u003d getAllSourceRootsInProjects\n(getProjectsInScopeFor(project));\t\t\n\t\treturn (IPackageFragmentRoot[]) sourceRoots.toArray(new \nIPackageFragmentRoot[sourceRoots.size()]);\n\t}\n\t\n\t/**\n\t * @param focus\n\t * @return Collection\t\tcontaining IJavaProject objects\n\t * @throws JavaModelException\n\t */\n\tprivate static Collection getProjectsInScopeFor(IJavaProject focus) \nthrows JavaModelException {\n\t\tSet projects\u003d new HashSet();\n\t\taddReferencingProjects(focus, projects);\n\t\tprojects.add(focus);\n\t\treturn projects;\n\t}\n\t\n\t/**\n\t * Adds to \u003ccode\u003eprojects\u003c/code\u003e IJavaProject objects for all projects\n\t * directly or indirectly referencing focus.\n\t * \n\t * @param focus\n\t * @param projects\t\tIJavaProjects will be added to this set\n\t * @throws JavaModelException\n\t */\n\tprivate static void addReferencingProjects(IJavaProject focus, Set \nprojects) throws JavaModelException {\n\t\tIProject[] referencingProjects\u003d focus.getProject\n().getReferencingProjects();\n\t\tfor (int i\u003d 0; i \u003c referencingProjects.length; i++) {\n\t\t\tIJavaProject candidate\u003d JavaCore.create\n(referencingProjects[i]);\n\t\t\tif(projects.contains(candidate))\n\t\t\t\tcontinue; // break cycle\t\n\t\t\tIClasspathEntry entry\u003d getReferencingClassPathEntry\n(candidate, focus);\n\t\t\tif(entry !\u003d null) {\n\t\t\t\tprojects.add(candidate);\t\t\t\n\t\n\t\t\t\tif(entry.isExported())\n\t\t\t\t\taddReferencingProjects(candidate, \nprojects);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Finds, if possible, a classpathEntry in one given project such that \nthis\n\t * classpath entry references another given project.  If more than one \nentry\n\t * exists for the referenced project and at least one is exported, then \nan\n\t * exported entry will be returned.\n\t * \n\t * @param referencingProject\n\t * @param referencedProject\n\t * @return IClasspathEntry\n\t * @throws JavaModelException\n\t */\n\tprivate static IClasspathEntry getReferencingClassPathEntry\n(IJavaProject referencingProject, IJavaProject referencedProject) throws \nJavaModelException {\n\t\tIClasspathEntry result\u003d null;\n\t\t\n\t\tIPath path\u003d referencedProject.getProject().getFullPath();\n\t\tIClasspathEntry[] classpath\u003d \nreferencingProject.getResolvedClasspath(true);\n\t\tfor (int i\u003d 0; i \u003c classpath.length; i++) {\n\t\t\tIClasspathEntry entry\u003d classpath[i];\n\t\t\tif (entry.getEntryKind() \u003d\u003d IClasspathEntry.CPE_PROJECT \n\u0026\u0026 path.equals(entry.getPath())) {\n\t\t\t\tif(result \u003d\u003d null || !result.isExported())\n\t\t\t\t\tresult\u003d entry;\n\t\t\t}\n\t\t}\n\t\treturn result;\t\n\t}\n\n\t\n\t/**\n\t * @param projects\t\ta collection of IJavaProject\n\t * @return Collection\ta collection of IPackageFragmentRoot, one \nelement\n\t * for each packageFragmentRoot which lies within a project in\n\t * \u003ccode\u003eprojects\u003c/code\u003e.\n\t */\n\tprivate static Collection getAllSourceRootsInProjects(Collection \nprojects) throws JavaModelException {\n\t\tList result\u003d new ArrayList();\n\t\tfor(Iterator it\u003d projects.iterator(); it.hasNext();)\n\t\t\tresult.addAll(getSourceRoots((IJavaProject)it.next()));\n\t\t\n\t\treturn result;\n\t}\n\t\n\tprivate static List getSourceRoots(IJavaProject javaProject) throws \nJavaModelException {\n\t\tList elements\u003d new  ArrayList();\n\t\tIPackageFragmentRoot[] roots\u003d \njavaProject.getPackageFragmentRoots();\n\t\t// Add all package fragment roots except archives\n\t\tfor (int i\u003d 0; i \u003c roots.length; i++) {\n\t\t\tIPackageFragmentRoot root\u003d roots[i];\n\t\t\tif (!root.isArchive())\n\t\t\t\telements.add(root);\n\t\t}\n\t\treturn elements;\n\t}\t\t\n}\n",
    "Clarification:\nIn the 2.0.2 stream, and presumably in the common ancestor of this stream and \nthe 2.1 stream, the RefactoringScopeFactory.create(IJavaProject javaProject) \nmethod constructed a search scope consisting of javaProject and all the \nprojects indirectly or directly referencing it.  In the 2.1 stream, the method \ncurrently constructs a search scope consisting of the Package Fragment Roots of \nthese projects.",
    "PR fixed on 2.0.2 and 2.1 stream."
  ],
  "commentCreationDates": [
    "2002-10-29T21:04:54+01:00",
    "2002-10-29T21:14:14+01:00",
    "2002-10-29T21:14:38+01:00",
    "2002-10-30T12:33:19+01:00",
    "2002-10-30T14:08:25+01:00",
    "2002-10-30T14:42:42+01:00",
    "2002-10-30T22:06:46+01:00",
    "2002-10-31T10:31:58+01:00",
    "2002-10-31T11:16:34+01:00",
    "2002-10-31T11:24:50+01:00",
    "2002-10-31T11:35:16+01:00",
    "2002-10-31T11:49:44+01:00",
    "2002-10-31T12:25:18+01:00",
    "2002-10-31T12:32:50+01:00",
    "2002-10-31T16:18:38+01:00",
    "2002-10-31T16:41:35+01:00",
    "2002-10-31T17:00:06+01:00",
    "2002-10-31T17:05:02+01:00",
    "2002-10-31T17:30:29+01:00",
    "2002-10-31T17:37:10+01:00",
    "2002-11-01T07:46:28+01:00",
    "2002-11-01T09:24:59+01:00",
    "2002-11-05T12:11:12+01:00",
    "2002-11-05T13:13:19+01:00",
    "2002-11-06T11:07:44+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.StackOverflowError",
      "elements": [
        {
          "method": "java.lang.String.compareTo",
          "source": "String.java:1313"
        },
        {
          "method": "org.eclipse.core.internal.dtree.AbstractDataTreeNode.childAtOrNull",
          "source": "AbstractDataTreeNode.java:208"
        },
        {
          "method": "org.eclipse.core.internal.dtree.DeltaDataTree.lookup",
          "source": "DeltaDataTree.java:702"
        },
        {
          "method": "org.eclipse.core.internal.watson.ElementTree.includes",
          "source": "ElementTree.java:706"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.getResourceInfo",
          "source": "Workspace.java:976"
        },
        {
          "method": "org.eclipse.core.internal.resources.Resource.getResourceInfo",
          "source": "Resource.java:686"
        },
        {
          "method": "org.eclipse.core.internal.resources.Resource.exists",
          "source": "Resource.java:538"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getSharedProperty",
          "source": "JavaProject.java:1468"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.loadClasspath",
          "source": "JavaProject.java:1604"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getRawClasspath",
          "source": "JavaProject.java:1247"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.addReferencingProjects",
          "source": "RefactoringScopeFactory.java:61"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.addReferencingProjects",
          "source": "RefactoringScopeFactory.java:67"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.refactoring.rename.RefactoringScopeFactory.addReferencingProjects",
          "source": "RefactoringScopeFactory.java:67"
        }
      ],
      "number": 0,
      "commentIndex": 9,
      "bugId": "25517",
      "date": "2002-10-31T11:24:50+01:00",
      "product": "JDT",
      "component": "UI",
      "severity": "critical"
    }
  ],
  "groupId": "25517",
  "bugId": "25517",
  "date": "2002-10-29T21:04:54+01:00",
  "product": "JDT",
  "component": "UI",
  "severity": "critical"
}