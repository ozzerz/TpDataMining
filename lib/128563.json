{
  "comments": [
    "Let\u0027s say we have the following project:\nsrc1/package1/A.java\n              B.java\nsrc2/package2/C.java\n\nThe output path of src1 is classes1\nThe output path of src2 is classes2\n\nTherefore when compiling, Eclipse generates the following classes:\n\n./classes1/package1/A.class\n                    B.class\n./classes2/package2/C$MyInner.class\n                    C.class\n\n\nHere are the A, B, C classes:\n\n---------------------------------\npackage package1;\n\nabstract class A\n{\n    protected final void outerMethod()\n    {\n    }\n}\n---------------------------------\npackage package1;\n\npublic class B extends A\n{\n}\n---------------------------------\npackage package2;\n\nimport package1.B;\n\npublic class C extends B\n{\n    private final MyInner myInner \u003d new MyInner();\n    \n    private class MyInner\n    {\n        public void innerMethod()\n        {\n            C.this.outerMethod();\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        final C c \u003d new C();\n        c.myInner.innerMethod();\n    }\n}\n---------------------------------\n\nThe problem is: although it compiles successfully, the output of the program is:\n\njava.lang.IllegalAccessError: tried to access class package1.A from class package2.C\n\tat package2.C.access$0(C.java:1)\n\tat package2.C$MyInner.innerMethod(C.java:13)\n\tat package2.C.main(C.java:22)\n\nStill with the Eclipse compiler, if classes A, B, C are in the same packages (package1 and package2) BUT in the SAME source folder (so the classes are generated in the same output folder), the code successfully executes.\n\nWith Sun\u0027s javac, whether one or two source/output folders, no IllegalAccessError is thrown.\n\n--------------\nWindows XP (no service pack)\nEclipse 3.2M5 running with Java 1.5.0 update 6\nJRE used: 1.4.2_08",
    "The difference between our behavior and javac is that the access method on C doesn\u0027t use the same invocation for the outerMethod() call.\nThey do the call using C as the declaring class and we do it using A.\n\nI found something quite interesting. If you move the classes from the two output folders into the same directory and you run from there, it works fine. We generate exactly the same bytecodes in both cases. The VM should behave the same. Might be a VM bug.\n\nChanging the class A to be public is fixing the issue as well.\n\nOur access method looks like this:\n  // Method descriptor #33 (Lpackage2/C;)V\n  // Stack: 1, Locals: 1\n  static synthetic void access$0(package2.C arg0);\n    0  aload_0\n    1  invokevirtual package1.A.foo() : void [35]\n    4  return\n      Line numbers:\n        [pc: 0, line: 1]\n\njavac access method looks like that:\n\n  // Method descriptor #23 (Lpackage2/C;)V\n  // Stack: 1, Locals: 1\n  static synthetic void access$100(package2.C arg0);\n    0  aload_0\n    1  invokevirtual package2.C.foo() : void [1]\n    4  return\n      Line numbers:\n        [pc: 0, line: 5]\n\nNote the different declaring class. Changing this should be enough to fix this issue.",
    "Nice work Olivier!\n\nYes, I also found out that moving the classes in the same package solves the problem! Interesting indeed.\n\nI also found that making A public solves the problem. This is how I\u0027m temporarily working with Eclipse. In our project, I\u0027ve privately checked-out several classes as a workaround to this problem. But I can\u0027t work that way in the long term since everyone don\u0027t use Eclipse in my team and my co-workers are reluctant to make A public since this would violate encapsulation and since having A package private is perfectly valid.\n\nWhen you write:\n\n\u003e Note the different declaring class. Changing this should be enough to fix this\n\u003e issue.\n\ndoes it mean that the Eclipse team will change the generated bytecode to use C as the declaring class, as does javac ?\n\nOverall, I think IllegalAccessError shoudn\u0027t occur if the compiler said it is OK. I think they should occur only when trying to violate access rules with reflection or if the bytecode was changed or if some code hasn\u0027t been recompiled...etc...\n\nThanks again for your fantastic work.",
    "We now have the same problem in HEAD of eclipse with the following mapping:\npackage1.A \u003d\u003e org.eclipse.jface.viewers.BaseLabelProvider\npackage1.B \u003d\u003e org.eclipse.jface.viewers.LabelProvider\npackage2.C \u003d\u003e org.eclipse.jdt.ui.examples.JavaElementLightweightDecorator (in org.eclipse.jdt.ui.tests plug-in)\n\nAs I see it, this is a VM bug, since JLS3 6.6.2.1 explicitly allows this situation."
  ],
  "commentCreationDates": [
    "2006-02-20T00:02:37+01:00",
    "2006-03-09T15:47:53+01:00",
    "2006-03-09T16:27:08+01:00",
    "2006-09-25T19:06:41+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.IllegalAccessError",
      "message": "tried to access class package1.A from class package2.C",
      "elements": [
        {
          "method": "package2.C.access$0",
          "source": "C.java:1"
        },
        {
          "method": "package2.C$MyInner.innerMethod",
          "source": "C.java:13"
        },
        {
          "method": "package2.C.main",
          "source": "C.java:22"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "128563",
      "date": "2006-02-20T00:02:37+01:00",
      "product": "JDT",
      "component": "Core",
      "severity": "major"
    }
  ],
  "groupId": "128563",
  "bugId": "128563",
  "date": "2006-02-20T00:02:37+01:00",
  "product": "JDT",
  "component": "Core",
  "severity": "major"
}