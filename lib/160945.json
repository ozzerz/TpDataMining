{
  "comments": [
    "I\u0027ve been doing some testing and happens to have some class instrumented by AJ at compile time. This class is also matches for the load time weaving and LTW fail with the following exception. If I remove compile-time weaving it works just fine.\n\n19:05:13,418  INFO AspectJ Weaver:55 - [AspectJ] processing reweavable type com.tctest.spring.aj.ConfigurableBean: com\\tctest\\spring\\aj\\ConfigurableBean.java\norg.aspectj.apache.bcel.classfile.ClassFormatException: File: \u0027com/tctest/spring/aj/ConfigurableBean\u0027: Invalid byte tag in constant pool: 0\n\tat org.aspectj.apache.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:261)\n\tat org.aspectj.apache.bcel.classfile.ClassParser.parse(ClassParser.java:162)\n\tat org.aspectj.weaver.bcel.Utility.makeJavaClass(Utility.java:528)\n\tat org.aspectj.weaver.bcel.BcelWeaver.processReweavableStateIfPresent(BcelWeaver.java:1296)\n\tat org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1049)\n\tat org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:284)\n\tat org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:212)\n\tat org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)\n\tat org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)\n\tat sun.instrument.TransformerManager.transform(TransformerManager.java:122)\n\tat sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)\n\tat java.lang.ClassLoader.defineClass1(Native Method)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:620)\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)\n\tat org.apache.catalina.loader.WebappClassLoader.findClassInternal(WebappClassLoader.java:1812)\n\tat org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:866)\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1319)\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1198)\n\tat org.springframework.util.ClassUtils.forName(ClassUtils.java:177)\n\tat org.springframework.beans.factory.support.AbstractBeanDefinition.resolveBeanClass(AbstractBeanDefinition.java:313)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory.java:912)\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:165)\n\tat org.springframework.context.support.AbstractApplicationContext.getBeanNamesForType(AbstractApplicationContext.java:687)\n\tat org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:397)\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:330)\n\tat org.springframework.web.context.support.AbstractRefreshableWebApplicationContext.refresh(AbstractRefreshableWebApplicationContext.java:156)\n\tat org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:246)\n\tat org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:184)\n\tat org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:49)\n\tat org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:3729)\n\tat org.apache.catalina.core.StandardContext.start(StandardContext.java:4187)\n\tat org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1013)\n\tat org.apache.catalina.core.StandardHost.start(StandardHost.java:718)\n\tat org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1013)\n\tat org.apache.catalina.core.StandardEngine.start(StandardEngine.java:442)\n\tat org.apache.catalina.core.StandardService.start(StandardService.java:450)\n\tat org.apache.catalina.core.StandardServer.start(StandardServer.java:709)\n\tat org.apache.catalina.startup.Catalina.start(Catalina.java:551)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:294)\n\tat org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:432)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)",
    "Created an attachment (id\u003d51991)\nclass file that cause this failure\n\n",
    "a tricky bug.  the problem appears to be with the diff stored in the class file for recovering the unwoven data.  I have recreated it by trying to weave a very simple aspect into the type attached here.  The problem is more likely to be with the first step though, that creates the embedded diff data.  Is there any way I could have the inputs to the first stage of compilation? (the configurable bean and the aspect?) Is the Configurable bean type built from source with the aspect?",
    "(In reply to comment #2)\n\u003e a tricky bug.  the problem appears to be with the diff stored in the class file\n\u003e for recovering the unwoven data.  I have recreated it by trying to weave a very\n\u003e simple aspect into the type attached here.  The problem is more likely to be\n\u003e with the first step though, that creates the embedded diff data.  Is there any\n\u003e way I could have the inputs to the first stage of compilation? (the\n\u003e configurable bean and the aspect?) Is the Configurable bean type built from\n\u003e source with the aspect?\n\nAndy, does the stored diff contain any method offsets or references to the class constant pool?\n\nIn my case, original class had been compiled from the source and adviced by iajc. Then that class is instrumented by custom ASM-based bytecode transformer. So, it is possible that this transformer change the constant pool and the method offsets, because ASM does not know AJ\u0027s custom attributes and just pass their content trough as is.\n\nHere are the source for configurable bean. It is been advised by @Configurable advice that is packaged with Spring 2.0.\n\n-------------\npackage com.tctest.spring.aj;\n\nimport java.io.Serializable;\n\nimport org.springframework.beans.factory.annotation.Configurable;\n\n@Configurable\npublic class ConfigurableBean implements Serializable {\n  private static final long serialVersionUID \u003d 1L;\n  \n  private String property1;\n  private String property2;\n  \n  public ConfigurableBean() {\n  }\n  \n  public String getProperty1() {\n    return this.property1;\n  }\n  \n  public String getProperty2() {\n    return this.property2;\n  }\n  \n  public void setProperty1(String property1) {\n    this.property1 \u003d property1;\n  }\n  \n  public void setProperty2(String property2) {\n    this.property2 \u003d property2;\n  }\n  \n}",
    "Oh .......\n\nThe diff is of a particular format that we determined was efficient and can be applied by us to a class to get us back to the unwoven class - it is below the level of the class structure - all it knows about a class file is that its a constant pool followed by \u0027bytes of stuff\u0027, it doesn\u0027t know anything about method offsets or field descriptors or anything.  We support \u0027reweaving\u0027 in this because undoing the weaving to reweave the type or reweaving already woven bytecode is too complex.  So - it looks like your secondary transform meant the diff could no longer be applied (or rather we did apply it but it produces bad bytes)\n\nThe options seem to be:\n\n1. compile time weave aspect1, LTW with aspect2, apply your transform\n2. apply your transform, compile time weave aspect1, LTW aspect2\n\nor similar variants, but we don\u0027t support other styles of transform occurring in-between two aspectj weaving steps (perhaps a harsh restriction).  Intermediate transforms effectively make the code impossible to reweave - all I could probably manage is a nicer error than the ClassFormatException...\n\nCan you not capture your transform as an aspect? that would make all the problems go away...\n",
    "Andy,\n\nWhen using the compressed from of -Xreweavable (the default) should we employ some form of fingerprint or check-sum (perhaps just file size) to ensure the byte-code has not been modified? Is this what you are alluding to when when you say \"all I could probably manage is a nicer error than the ClassFormatException...\"? This fingerprint would then be used by the \"processing reweavable type\" logic to determine the integrity of the class.\n",
    "(In reply to comment #4)\n\u003e The diff is of a particular format that we determined was efficient and can be\n\u003e applied by us to a class to get us back to the unwoven class - it is below the\n\u003e level of the class structure - all it knows about a class file is that its a\n\u003e constant pool followed by \u0027bytes of stuff\u0027, it doesn\u0027t know anything about\n\u003e method offsets or field descriptors or anything.  We support \u0027reweaving\u0027 in\n\u003e this because undoing the weaving to reweave the type or reweaving already woven\n\u003e bytecode is too complex.  So - it looks like your secondary transform meant the\n\u003e diff could no longer be applied (or rather we did apply it but it produces bad\n\u003e bytes)\n\nThis is definetely unfortunate...\n\nI guess the only way to make reweaving work after such intermediate transformations is to somehow isolate method instructions introduced/removed at the 1st weaving step. Constant pool changes could be made more resistant if you\u0027d always add to the constant pool and make those diffs not to use any offsets in the pool... e.g. somehow similar to how ASM handle constant pool data.\n\n\u003e The options seem to be:\n\u003e 1. compile time weave aspect1, LTW with aspect2, apply your transform\n\u003e 2. apply your transform, compile time weave aspect1, LTW aspect2\n\nRight. I already checked and both of them works.\n\n\u003e or similar variants, but we don\u0027t support other styles of transform occurring\n\u003e in-between two aspectj weaving steps (perhaps a harsh restriction). \n\u003e Intermediate transforms effectively make the code impossible to reweave - all I\n\u003e could probably manage is a nicer error than the ClassFormatException...\n\nWould it be possible to allow to ignore this error and log a warning or something?\nI also wonder if you can somehow check if reweaved advice is the same as the one that already woven in?\n\n\u003e Can you not capture your transform as an aspect? that would make all the\n\u003e problems go away...\n\nI am afraid this problem will became quite common soon since not all transformations can be implemented on AspectJ (at least in real world). For example, instrumentation that is done by JDO/JPA implementations...",
    "A complex diff that takes into account instructions/members/constant pool entries added and removed would slow us down quite a lot ... and not everyone wants to reweave so it is a shame to make everyone suffer for it.  So next you might say make it optional - but i\u0027d say no-one takes into account whether they need their output to be reweavable or not and would set it off, causing problems for someone further down the line.\n\n\u003e Would it be possible to allow to ignore this error and log a warning\n\u003e or something?\n\nWhen you say \u0027ignore the error\u0027 - what would we then weave? would we weave the already previously woven code and assume it is safe?  We can\u0027t do that - the first weave will have introduced all sorts of artifacts and juggled instructions around - all of which will be different join points for the secondary weave.\n\n\u003e I also wonder if you can somehow check if reweaved advice is the same as \n\u003e the one that already woven in?\n\nYes, we could do that - but I believe it is a lot of work - for things like inlined around advice, potentially a lot of extra meta data to store so we can identify what went were previously, bloating class files further.\n\nThis is the first time this problem has been hit - I agree it may become more of an issue in the future.",
    "(In reply to comment #7)\n\u003e A complex diff that takes into account instructions/members/constant pool\n\u003e entries added and removed would slow us down quite a lot ... and not everyone\n\u003e wants to reweave so it is a shame to make everyone suffer for it.  So next you\n\u003e might say make it optional - but i\u0027d say no-one takes into account whether they\n\u003e need their output to be reweavable or not and would set it off, causing\n\u003e problems for someone further down the line.\n\nIt not necessary have to slow things down. All depends how you do it. :-)\n\n\u003e \u003e Would it be possible to allow to ignore this error and log a warning\n\u003e \u003e or something?\n\u003e \n\u003e When you say \u0027ignore the error\u0027 - what would we then weave? would we weave the\n\u003e already previously woven code and assume it is safe?  We can\u0027t do that - the\n\u003e first weave will have introduced all sorts of artifacts and juggled\n\u003e instructions around - all of which will be different join points for the\n\u003e secondary weave.\n\nI meant just completely skip the ltw weaving and leave class as is, don\u0027t even apply the diff.\n\n\u003e \u003e I also wonder if you can somehow check if reweaved advice is the same as \n\u003e \u003e the one that already woven in?\n\u003e \n\u003e Yes, we could do that - but I believe it is a lot of work - for things like\n\u003e inlined around advice, potentially a lot of extra meta data to store so we can\n\u003e identify what went were previously, bloating class files further.\n\nDepends how you do that. For instance you can just calculate and save check sum (e.g. md5) for each aspect class aplied to the instrumented class. Then, if those check sums are the same in the runtime, you don\u0027t need to reweave...",
    "\u003eI meant just completely skip the ltw weaving and leave class as is, don\u0027t even\n\u003eapply the diff.\nNo. A user, either with a pointcut or aop.xml configuration, can explicitly exclude a class from weaving. On the other hand the compiler cannot exclude a class because it tried and failed to weave it.\n\n\u003eDepends how you do that. For instance you can just calculate and save check sum\n\u003e(e.g. md5) for each aspect class aplied to the instrumented class. Then, if\n\u003ethose check sums are the same in the runtime, you don\u0027t need to reweave...\nWe would not only have to calculate check-sums for all the aspects concerned (and store the numbers for those used at each stage in the byte-code) but also for each class to see if it had changed. How expensive is md5 generation? Also what if intermediate, non-AspectJ instrumentation introduced new join points?",
    "(In reply to comment #9)\n\u003e \u003eI meant just completely skip the ltw weaving and leave class as is, don\u0027t even\n\u003e \u003eapply the diff.\n\u003e No. A user, either with a pointcut or aop.xml configuration, can explicitly\n\u003e exclude a class from weaving. On the other hand the compiler cannot exclude a\n\u003e class because it tried and failed to weave it.\n\nMakes sense.\n\n\u003e \u003eDepends how you do that. For instance you can just calculate and save check sum\n\u003e \u003e(e.g. md5) for each aspect class aplied to the instrumented class. Then, if\n\u003e \u003ethose check sums are the same in the runtime, you don\u0027t need to reweave...\n\u003e We would not only have to calculate check-sums for all the aspects concerned\n\u003e (and store the numbers for those used at each stage in the byte-code) but also\n\u003e for each class to see if it had changed. \n\nWon\u0027t be enough to only include aspects for matched joinpoints?\n\n\u003e How expensive is md5 generation? \n\nNot that much actually and it runs on a fixed memory boundaries, so it should be quite fast when bytecode is already in memory. BTW, md5 is calculated when computing implicit serialVersionUid for serializable classes, but you can use simpler and shorter checksum, like crc32.\n\n\u003e Also what if intermediate, non-AspectJ instrumentation introduced new join points?\n\nGood point! Can AspectJ only instrument those new join points? :-)",
    "\u003eWon\u0027t be enough to only include aspects for matched joinpoints?\nI think there\u0027s a chicken and egg problem here. We don\u0027t know which aspects will match until we weave and we won\u0027t weave unless we think something has changed. Generating the md5 for each aspect is not a problem as it will be done once but doing it for every class is new overhead.\n\n\u003eGood point! Can AspectJ only instrument those new join points? :-)\nThe 3rd party instrumentation may introduce join points which may be matched by an aspect. This aspect, not necessarily authored by the same owner, may reasonably assume all classes that should match will match. If you miss some out the resulting behaviour may be unpredictable.",
    "(In reply to comment #11)\n\u003e \u003eWon\u0027t be enough to only include aspects for matched joinpoints?\n\u003e I think there\u0027s a chicken and egg problem here. We don\u0027t know which aspects\n\u003e will match until we weave and we won\u0027t weave unless we think something has\n\u003e changed. \n\nMy thinking was along these lines:\n\n-- at compile-time AJ could resolve all the matching advices and record those that are applied\n-- at load-time AJ could again if there are matching advices, then check which of those already applied (or require to be reapplied due to advice change) and then apply the new ones.\n\n\u003e Generating the md5 for each aspect is not a problem as it will be done\n\u003e once but doing it for every class is new overhead.\n\nYou would have to do it anyways in order to check if class had been changed.\n\n\u003e \u003eGood point! Can AspectJ only instrument those new join points? :-)\n\u003e The 3rd party instrumentation may introduce join points which may be matched by\n\u003e an aspect. This aspect, not necessarily authored by the same owner, may\n\u003e reasonably assume all classes that should match will match. If you miss some\n\u003e out the resulting behaviour may be unpredictable.\n\nBut that will be a different/new aspect, so it will be applied to whathever matches at that time. Responsibility would be on that intermediate instrumentation...",
    "There is a contract here.\n1. When we weave a class we ensure it will execute on any JVM\n2. When we weave a class we ensure it can be woven again\n3. When we weave a class we ensure it can be instrumented by a 3rd party\n\nWhat we don\u0027t guarantee is that between 2 AspectJ weaving steps a 3rd party can modify the code.\n\n\u003e\u003e Can you not capture your transform as an aspect? that would make all the\n\u003e\u003e problems go away...\n\n\u003eI am afraid this problem will became quite common soon since not all\n\u003etransformations can be implemented on AspectJ (at least in real world). For\n\u003eexample, instrumentation that is done by JDO/JPA implementations...\nYes but can _you_ implement _your_ transform, the subject of _this_ bug report, using AspectJ? This would solve other problems that we have identified such as whether or not new join points should be matched or reconciling precedence.\n\nCoexistence with other byte-code enhancement technologies will probably required multiple -javagents which is not supported in Java 5. ",
    "(In reply to comment #13)\n\u003e \u003eI am afraid this problem will became quite common soon since not all\n\u003e \u003etransformations can be implemented on AspectJ (at least in real world). For\n\u003e \u003eexample, instrumentation that is done by JDO/JPA implementations...\n\u003e Yes but can _you_ implement _your_ transform, the subject of _this_ bug report,\n\u003e using AspectJ? This would solve other problems that we have identified such as\n\u003e whether or not new join points should be matched or reconciling precedence.\n\nI am afraid that is not an option. The complexity of transformation is quite high and certain things can\u0027t be done in AspectJ. As I said, my transformation is not unique in that sense.\n\n\u003e Coexistence with other byte-code enhancement technologies will probably\n\u003e required multiple -javagents which is not supported in Java 5. \n\nWhat do you mean? It is allowed to specify multiple agents.",
    "\u003eI am afraid that is not an option. The complexity of transformation is quite\n\u003ehigh and certain things can\u0027t be done in AspectJ. As I said, my transformation\n\u003eis not unique in that sense.\nWhile we are not trying to take over the world :-) it would be interesting to discover what you need to do that isn\u0027t currently supported by AspectJ.\n\n\u003eWhat do you mean? It is allowed to specify multiple agents.\nI was (mistakenly) thinking of the older interface. You can specify -javaagent multiple times although the option specification (http://java.sun.com/j2se/1.5.0/docs/api/java/lang/instrument/package-summary.html) is not explicit about the order in which they will be invoked: it is assumed that it\u0027s the order in which they are configured. In which case the solution is to specify -javaagent:aspectjweaver.jar first."
  ],
  "commentCreationDates": [
    "2006-10-14T01:09:43+02:00",
    "2006-10-14T01:11:55+02:00",
    "2006-10-16T16:05:17+02:00",
    "2006-10-16T17:04:00+02:00",
    "2006-10-16T17:26:16+02:00",
    "2006-10-16T17:51:40+02:00",
    "2006-10-16T18:22:37+02:00",
    "2006-10-16T18:39:07+02:00",
    "2006-10-16T19:13:57+02:00",
    "2006-10-17T10:26:05+02:00",
    "2006-10-17T10:40:41+02:00",
    "2006-10-17T14:06:44+02:00",
    "2006-10-17T14:55:44+02:00",
    "2006-10-18T10:28:55+02:00",
    "2006-10-18T10:54:56+02:00",
    "2006-10-18T11:34:49+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.aspectj.apache.bcel.classfile.ClassFormatException",
      "message": "File: \u0027com/tctest/spring/aj/ConfigurableBean\u0027: Invalid byte tag in constant pool: 0",
      "elements": [
        {
          "method": "org.aspectj.apache.bcel.classfile.ClassParser.readConstantPool",
          "source": "ClassParser.java:261"
        },
        {
          "method": "org.aspectj.apache.bcel.classfile.ClassParser.parse",
          "source": "ClassParser.java:162"
        },
        {
          "method": "org.aspectj.weaver.bcel.Utility.makeJavaClass",
          "source": "Utility.java:528"
        },
        {
          "method": "org.aspectj.weaver.bcel.BcelWeaver.processReweavableStateIfPresent",
          "source": "BcelWeaver.java:1296"
        },
        {
          "method": "org.aspectj.weaver.bcel.BcelWeaver.weave",
          "source": "BcelWeaver.java:1049"
        },
        {
          "method": "org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes",
          "source": "WeavingAdaptor.java:284"
        },
        {
          "method": "org.aspectj.weaver.tools.WeavingAdaptor.weaveClass",
          "source": "WeavingAdaptor.java:212"
        },
        {
          "method": "org.aspectj.weaver.loadtime.Aj.preProcess",
          "source": "Aj.java:65"
        },
        {
          "method": "org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform",
          "source": "ClassPreProcessorAgentAdapter.java:55"
        },
        {
          "method": "sun.instrument.TransformerManager.transform",
          "source": "TransformerManager.java:122"
        },
        {
          "method": "sun.instrument.InstrumentationImpl.transform",
          "source": "InstrumentationImpl.java:155"
        },
        {
          "method": "java.lang.ClassLoader.defineClass1",
          "source": "Native Method"
        },
        {
          "method": "java.lang.ClassLoader.defineClass",
          "source": "ClassLoader.java:620"
        },
        {
          "method": "java.security.SecureClassLoader.defineClass",
          "source": "SecureClassLoader.java:124"
        },
        {
          "method": "org.apache.catalina.loader.WebappClassLoader.findClassInternal",
          "source": "WebappClassLoader.java:1812"
        },
        {
          "method": "org.apache.catalina.loader.WebappClassLoader.findClass",
          "source": "WebappClassLoader.java:866"
        },
        {
          "method": "org.apache.catalina.loader.WebappClassLoader.loadClass",
          "source": "WebappClassLoader.java:1319"
        },
        {
          "method": "org.apache.catalina.loader.WebappClassLoader.loadClass",
          "source": "WebappClassLoader.java:1198"
        },
        {
          "method": "org.springframework.util.ClassUtils.forName",
          "source": "ClassUtils.java:177"
        },
        {
          "method": "org.springframework.beans.factory.support.AbstractBeanDefinition.resolveBeanClass",
          "source": "AbstractBeanDefinition.java:313"
        },
        {
          "method": "org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass",
          "source": "AbstractBeanFactory.java:912"
        },
        {
          "method": "org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType",
          "source": "DefaultListableBeanFactory.java:165"
        },
        {
          "method": "org.springframework.context.support.AbstractApplicationContext.getBeanNamesForType",
          "source": "AbstractApplicationContext.java:687"
        },
        {
          "method": "org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors",
          "source": "AbstractApplicationContext.java:397"
        },
        {
          "method": "org.springframework.context.support.AbstractApplicationContext.refresh",
          "source": "AbstractApplicationContext.java:330"
        },
        {
          "method": "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext.refresh",
          "source": "AbstractRefreshableWebApplicationContext.java:156"
        },
        {
          "method": "org.springframework.web.context.ContextLoader.createWebApplicationContext",
          "source": "ContextLoader.java:246"
        },
        {
          "method": "org.springframework.web.context.ContextLoader.initWebApplicationContext",
          "source": "ContextLoader.java:184"
        },
        {
          "method": "org.springframework.web.context.ContextLoaderListener.contextInitialized",
          "source": "ContextLoaderListener.java:49"
        },
        {
          "method": "org.apache.catalina.core.StandardContext.listenerStart",
          "source": "StandardContext.java:3729"
        },
        {
          "method": "org.apache.catalina.core.StandardContext.start",
          "source": "StandardContext.java:4187"
        },
        {
          "method": "org.apache.catalina.core.ContainerBase.start",
          "source": "ContainerBase.java:1013"
        },
        {
          "method": "org.apache.catalina.core.StandardHost.start",
          "source": "StandardHost.java:718"
        },
        {
          "method": "org.apache.catalina.core.ContainerBase.start",
          "source": "ContainerBase.java:1013"
        },
        {
          "method": "org.apache.catalina.core.StandardEngine.start",
          "source": "StandardEngine.java:442"
        },
        {
          "method": "org.apache.catalina.core.StandardService.start",
          "source": "StandardService.java:450"
        },
        {
          "method": "org.apache.catalina.core.StandardServer.start",
          "source": "StandardServer.java:709"
        },
        {
          "method": "org.apache.catalina.startup.Catalina.start",
          "source": "Catalina.java:551"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:585"
        },
        {
          "method": "org.apache.catalina.startup.Bootstrap.start",
          "source": "Bootstrap.java:294"
        },
        {
          "method": "org.apache.catalina.startup.Bootstrap.main",
          "source": "Bootstrap.java:432"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:585"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "160945",
      "date": "2006-10-14T01:09:43+02:00",
      "product": "AspectJ",
      "component": "LTWeaving",
      "severity": "critical"
    }
  ],
  "groupId": "160945",
  "bugId": "160945",
  "date": "2006-10-14T01:09:43+02:00",
  "product": "AspectJ",
  "component": "LTWeaving",
  "severity": "critical"
}