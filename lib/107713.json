{
  "comments": [
    "Whenever I change any file and save(auto-compile) I get this in a popup.\n\nClassCastException thrown: \norg.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType cannot be cast to \norg.aspectj.weaver.bcel.BcelObjectType\n\nThis started happening when I wrote these aspects.\n\nBefore this started happening the IDE showed this line as an error.\n\nb.support.firePropertyChange( property,\n\t\t\t( oldval \u003d\u003d null ) ? oldval : new String(oldval),\n\t                      new String(newval));\n\n\n----------------------------------------------------------------\n/**\n * \n */\npackage com.blueprint.util.mixin.test;\n\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.lang.reflect.Field;\nimport com.blueprint.util.mixin.test.*;\nimport org.aspectj.lang.Signature;\n\npublic aspect PropertySupportAspect {\n\t\n\t\tPropertyChangeSupport PropertySupport.support \u003d new \nPropertyChangeSupport(this);\n\n\t\tpublic interface PropertySupport{\n\t\t\t  public void addPropertyChangeListener( \nPropertyChangeListener listener );\n\t\t\t  public void addPropertyChangeListener( String \npropertyName,\n\t\t\t\t                                     \nPropertyChangeListener listener );\n\t\t\t  public void removePropertyChangeListener( String \npropertyName,\n\t\t\t\t                                        \nPropertyChangeListener listener );\n\t\t\t  public void removePropertyChangeListener( \nPropertyChangeListener listener );\n\t\t\t  public void hasListeners( String propertyName );\n\t\t}\n\t\t\n\t\tpublic void PropertySupport.addPropertyChangeListener\n(PropertyChangeListener listener){\n\t\t    support.addPropertyChangeListener(listener);\n\t\t}\n\t\t\n\t\tpublic void PropertySupport.addPropertyChangeListener( String \npropertyName,\n\t\t                                                       \nPropertyChangeListener listener){\n\n\t\t\tsupport.addPropertyChangeListener(propertyName, \nlistener);\n\t    }\n\t    \n\t\tpublic void PropertySupport.removePropertyChangeListener( \nString propertyName,\n\t\t\t                                                      \nPropertyChangeListener listener) {\n\t\t\tsupport.removePropertyChangeListener(propertyName, \nlistener);\n\t    }\n\t\t\n\t\tpublic void PropertySupport.removePropertyChangeListener\n(PropertyChangeListener listener) {\n\t\t    support.removePropertyChangeListener(listener);\n\t\t}\n\t\t\n\t\tpublic void PropertySupport.hasListeners(String propertyName) {\n\t\t    support.hasListeners(propertyName);\n\t\t}\n\n\t\tpointcut callSetter( Bean b ) \n\t    : call( public void com.blueprint.util.test.Bean.setName( \nString ) ) \u0026\u0026 target( b );\n\t\t\n\t\tvoid around( Bean b ) : callSetter( b )  {\n\t\t    String propertyName \u003d getField( \nthisJoinPointStaticPart.getSignature() ).\n\t\t    \t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tgetName\n();\n\t\t\tSystem.out.println( \"The property is [\" + propertyName \n+ \"]\" );\n\t\t\tString oldValue \u003d b.getName();\n\t\t    proceed( b );\n\t\t    firePropertyChange( b, propertyName, oldValue, b.getName\n());\n\t\t}\n\n\t    private Field getField( Signature signature ){\n\t    \tField field \u003d null;\n\t\t\tSystem.out.println( \"Getting the field name of [\" \n+signature.getName() + \"]\" );\n\t    \t\n\t    \ttry{\n\t    \t\tString methodName \u003d signature.getName();\n\t    \t\tfield \u003d signature.getDeclaringType().\n\t\t\t\t\t\t\t\n\tgetDeclaredField( methodName.\n\t\t\t\t\t\t\t\t\t\n\t\t\t   substring( 3,\n\t\t\t\t\t\t\t\t\t\n\t\t                  methodName.length() ).\n\t\t\t\t\t\t\t\t\t\n\t\t                  \t\t\ttoLowerCase());\n\t    \t\tfield.setAccessible(true);\n\t    \t}catch( NoSuchFieldException nsfe ){\n\t    \t\tnsfe.printStackTrace();\n\t    \t}\n\t\t\treturn field;\n\t\t}\n\n\t\tvoid firePropertyChange( Bean b,\n\t\t\t\t\t String property,\n\t\t\t\t\t String oldval,\n\t\t\t\t\t String newval) {\n\t\tSystem.out.println( \"The property is [\" + property + \"]\");\n\t\tSystem.out.println( \"The old value is [\" + oldval + \"]\");\n\t\tSystem.out.println( \"The new value is [\" + newval + \"]\");\n\t\tb.support.firePropertyChange( property,\n\t\t\t\t\t( oldval \u003d\u003d null ) ? oldval : new \nString(oldval),\n\t\t\t            new String(newval));\n\t\t}\n\t\t\n}\n----------------------------------------------------------------\nimport java.io.Serializable;\n\npublic class Bean implements Serializable{\n\t\n\tprivate String name;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName( String name ) {\n\t\tthis.name \u003d name;\n\t}\n}\n----------------------------------------------------------------\npublic aspect BeanSupport {\n     declare parents: Bean implements PropertySupportAspect.PropertySupport;\n}\n----------------------------------------------------------------",
    "Hi,\nPlease could you add your Eclipse and AJDT versions.\nThanks.\n",
    "AJDT version: 1.2.1 for Eclipse 3.1\n\u003e Hi,\n\u003e Please could you add your Eclipse and AJDT versions.\n\u003e Thanks.\n\n",
    "I didn\u0027t see the ClassCastException popup, but I could reproduce the compiler\nerror for the referenced line (b.support cannot be resolved). This compilation\nerror only appears after an incremental build, not after a full build. Passing\nover to AspectJ.",
    "Shame we don\u0027t have the stack trace for the classcastexception :(\n\nDepending on where some type originated from it will be represented as an\nEclipseSourceType (if it came from source) or a BcelObjectType (if it came from\na .class file on disk).  The classcast occurs when someone is making\nassumptions.  They shouldn\u0027t really need to make assumptions as they both\nimplement the same interface.\n\nAnyway - I might have some insights on the problem where the member is missing\npost incremental compile.  I came across a similar situation when working on\nbinary weaving of generic ITDs.\n\nIf we look at AjLookupEnvironment.weaveIntertypeDeclarations - it is passed a\nset of type mungers.  The first thing the method does is look for a weaver state\ninfo - if it finds one then it retrieves the set of type mungers from the info\nobject and reapplies them to the type ... THEN it returns.  It never seems to\napply the set of them that was passed in - if you just comment out the return so\nit continues through the method applying the new ones too, that causes an\nexisting test or two to fail.  In the incremental case we are likely to\nencounter the state info attributes, if doing a full build then we don\u0027t.\n\nI haven\u0027t had time to resolve this descrepancy but I think its where I\u0027d start\nlooking for all incremental ITD related problems we are having...",
    "I picked up this trace from the old log entries. This could be the one you are \nlooking for.\n\n\njava.lang.ClassCastException: \norg.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType cannot be cast to \norg.aspectj.weaver.bcel.BcelObjectType\n\tat org.aspectj.weaver.bcel.BcelWorld.getBcelObjectType\n(BcelWorld.java:414)\n\tat org.aspectj.weaver.bcel.BcelWeaver.getClassType\n(BcelWeaver.java:1121)\n\tat org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:946)\n\tat org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave\n(AjCompilerAdapter.java:286)\n\tat org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling\n(AjCompilerAdapter.java:165)\n\tat \norg.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspec\ntj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)\n\tat org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile\n(Compiler.java:368)\n\tat \norg.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation\n(AjBuildManager.java:727)\n\tat org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild\n(AjBuildManager.java:229)\n\tat \norg.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild\n(AjBuildManager.java:147)\n\tat org.aspectj.ajde.internal.CompilerAdapter.compile\n(CompilerAdapter.java:116)\n\tat org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run\n(AspectJBuildManager.java:191)\n",
    "Ok ...  It happens when we go to retrieve any reweavable state for a file - now\ngiven that if the delegate is really an EclipseSourceType then it *cant* have\nany reweavable state, i\u0027ve put in the guards to allow for this case\n(getBcelObjectType() returns NULL if the delegate is an EclipseSourceType, and\nit says so in its new javadoc - so its up to the caller to handle).\n\nMaybe removing the classcastexception will affect the missing member problem.\n\nfix checked in.",
    "Can you confirm whether this is fixed in the recent AJDT builds?",
    "This particular code is working fine.\n\n",
    "thanks for verifying!"
  ],
  "commentCreationDates": [
    "2005-08-23T12:56:58+02:00",
    "2005-08-23T13:01:13+02:00",
    "2005-08-23T13:31:13+02:00",
    "2005-08-23T14:45:14+02:00",
    "2005-08-24T09:31:39+02:00",
    "2005-08-26T09:51:04+02:00",
    "2005-08-26T11:10:38+02:00",
    "2005-10-28T15:24:47+02:00",
    "2005-10-31T05:24:07+01:00",
    "2005-10-31T07:57:57+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ClassCastException",
      "message": "org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType cannot be cast to  org.aspectj.weaver.bcel.BcelObjectType",
      "elements": [
        {
          "method": "org.aspectj.weaver.bcel.BcelWorld.getBcelObjectType",
          "source": "BcelWorld.java:414"
        },
        {
          "method": "org.aspectj.weaver.bcel.BcelWeaver.getClassType",
          "source": "BcelWeaver.java:1121"
        },
        {
          "method": "org.aspectj.weaver.bcel.BcelWeaver.weave",
          "source": "BcelWeaver.java:946"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave",
          "source": "AjCompilerAdapter.java:286"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling",
          "source": "AjCompilerAdapter.java:165"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0",
          "source": "CompilerAdapter.aj:70"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:368"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation",
          "source": "AjBuildManager.java:727"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild",
          "source": "AjBuildManager.java:229"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild",
          "source": "AjBuildManager.java:147"
        },
        {
          "method": "org.aspectj.ajde.internal.CompilerAdapter.compile",
          "source": "CompilerAdapter.java:116"
        },
        {
          "method": "org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run",
          "source": "AspectJBuildManager.java:191"
        }
      ],
      "number": 0,
      "commentIndex": 5,
      "bugId": "107713",
      "date": "2005-08-26T09:51:04+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "107713",
  "bugId": "107713",
  "date": "2005-08-23T12:56:58+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}