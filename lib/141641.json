{
  "comments": [
    "It is not possible to avoid Eclipse error log entry when arguments to model method evaluate into OclInvalid.\n\nconsider following ocl expression:\n\nself.process.getObject(self.objectRef.objectId)\n\nwhen self.objectRef evaluates into null, self.objectRef.objectId becomes OclInvalid. The code of EvaluationVisitorImpl.java, lines 1225- (the last few lines of visitOperationCallExp method) is trying to pass OclInvalid as argument(s) to the method - which ends up with class cast exception, Eclipse log entry and result becomes OclInvalid.\n\nThe problem is not about the result (which is correct - OclInvalid) but just to avoid logging of error message in Eclipse log file. (think of an error log that contains all typos one made writing java code... :-)\n\nThe current code (EvaluationVisitorImpl.java, lines 1225-):\n\n// evaluate args\nList evalArgs \u003d new LinkedList();\nfor (Iterator it \u003d args.iterator(); it.hasNext();) {\n   OCLExpression arg \u003d (OCLExpression) it.next();\n   Object evalArg \u003d arg.accept(this);\n   // result is undefined if any arg is\n   if (evalArg \u003d\u003d null)\n       return null;\n   evalArgs.add(evalArg);\n} \n\nThe null check should be extended and check if the arguments are OclInvalid, and return OclInvalid instead of allowing to pass these arguments to the java method, catching exception, logging it and returning OclInvalid. \n\nwhith out this, Eclipse error log is poluted with entries like:\n\njava.lang.IllegalArgumentException: java.lang.ClassCastException@1552393\nat sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\nat java.lang.reflect.Method.invoke(Unknown Source)\nat org.eclipse.emf.ocl.expressions.impl.EvaluationVisitorImpl.visitOperationCallExp(EvaluationVisitorImpl.java:1250)\nat org.eclipse.emf.ocl.expressions.impl.OperationCallExpImpl.accept(OperationCallExpImpl.java:252)\nat org.eclipse.emf.ocl.query.impl.QueryImpl.evaluate(QueryImpl.java:224)\n...\n \nor:\n \njava.lang.IllegalArgumentException: argument type mismatch\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\nat java.lang.reflect.Method.invoke(Unknown Source)\nat org.eclipse.emf.ocl.expressions.impl.EvaluationVisitorImpl.visitOperationCallExp(EvaluationVisitorImpl.java:1250)\nat org.eclipse.emf.ocl.expressions.impl.OperationCallExpImpl.accept(OperationCallExpImpl.java:252)\nat org.eclipse.emf.ocl.query.impl.QueryImpl.evaluate(QueryImpl.java:224)\n...\n \nThe only problem can be if the method expects OclInvalid, but if any part of the expression is invalid shouldn\u0027t that make the whole expression invalid? (apart of the the one special method - oclIsUndefined). I am not sure what exactly does the spec state about such situation.",
    "Created an attachment (id\u003d41500)\nproposed patch for org.eclipse.emf.ocl\n\nWith this patch, OCL_INVALID will be returned when any argument is OCL_INVALID at code line 1231. A null pointer check is also added prior to invoking the method in the same code area.",
    "Committed the attached patch."
  ],
  "commentCreationDates": [
    "2006-05-13T00:16:12+02:00",
    "2006-05-15T22:14:37+02:00",
    "2006-05-16T21:40:19+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.IllegalArgumentException",
      "message": "java.lang.ClassCastException@1552393",
      "elements": [
        {
          "method": "sun.reflect.GeneratedMethodAccessor6.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.emf.ocl.expressions.impl.EvaluationVisitorImpl.visitOperationCallExp",
          "source": "EvaluationVisitorImpl.java:1250"
        },
        {
          "method": "org.eclipse.emf.ocl.expressions.impl.OperationCallExpImpl.accept",
          "source": "OperationCallExpImpl.java:252"
        },
        {
          "method": "org.eclipse.emf.ocl.query.impl.QueryImpl.evaluate",
          "source": "QueryImpl.java:224"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "141641",
      "date": "2006-05-13T00:16:12+02:00",
      "product": "MDT",
      "component": "OCL",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.IllegalArgumentException",
      "message": "argument type mismatch",
      "elements": [
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.emf.ocl.expressions.impl.EvaluationVisitorImpl.visitOperationCallExp",
          "source": "EvaluationVisitorImpl.java:1250"
        },
        {
          "method": "org.eclipse.emf.ocl.expressions.impl.OperationCallExpImpl.accept",
          "source": "OperationCallExpImpl.java:252"
        },
        {
          "method": "org.eclipse.emf.ocl.query.impl.QueryImpl.evaluate",
          "source": "QueryImpl.java:224"
        }
      ],
      "number": 1,
      "commentIndex": 0,
      "bugId": "141641",
      "date": "2006-05-13T00:16:12+02:00",
      "product": "MDT",
      "component": "OCL",
      "severity": "normal"
    }
  ],
  "groupId": "141641",
  "bugId": "141641",
  "date": "2006-05-13T00:16:12+02:00",
  "product": "MDT",
  "component": "OCL",
  "severity": "normal"
}