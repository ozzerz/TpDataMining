{
  "comments": [
    "- create workbench as described in 1G2NSST: ITPJUI:ALL - Getting exception from builder when using two connected projects\n\t- select JUnit and JUnit2 and delete them\n\nException occurred during event dispatching:\n\ncom.ibm.itp.common.AssertionFailedException: null argument;\n\n\tat com.ibm.itp.common.Assert.isNotNull(Assert.java, Compiled Code)\n\n\tat com.ibm.itp.common.Assert.isNotNull(Assert.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.StructuredContentViewer.unmapElement(StructuredContentViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.AbstractTreeViewer.disassociate(AbstractTreeViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.AbstractTreeViewer.disassociateChildren(AbstractTreeViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.AbstractTreeViewer.disassociate(AbstractTreeViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.AbstractTreeViewer.updatePlus(AbstractTreeViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.StructuredContentViewer$2.run(StructuredContentViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.ContentViewer.preserveSelection(ContentViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.AbstractTreeViewer.preserveSelection(AbstractTreeViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.StructuredContentViewer.doDomainChanged(StructuredContentViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.AbstractTreeViewer.doDomainChanged(AbstractTreeViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.ContentViewer.runDomainChanged(ContentViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.ContentViewer.access$3(ContentViewer.java, Compiled Code)\n\n\tat com.ibm.jface.viewer.ContentViewer$3.run(ContentViewer.java, Compiled Code)\n\n\tat com.ibm.swt.widgets.RunnableLock.run(RunnableLock.java, Compiled Code)\n\n\tat com.ibm.swt.widgets.Display.runAsyncMessages(Display.java, Compiled Code)\n\n\tat com.ibm.swt.widgets.Display.readAndDispatch(Display.java, Compiled Code)\n\n\tat com.ibm.jface.parts.EventLoop.dispatchEventAndSleep(EventLoop.java, Compiled Code)\n\n\tat com.ibm.jface.util.ModalContext.internalBlock(ModalContext.java, Compiled Code)\n\n\tat com.ibm.jface.util.ModalContext.internalExecute(ModalContext.java:192)\n\n\tat com.ibm.jface.util.ModalContext.execute(ModalContext.java:103)\n\n\tat com.ibm.jface.util.ModalContext.execute(ModalContext.java:85)\n\n\tat com.ibm.jface.parts.ProgressMonitorDialog.execute(ProgressMonitorDialog.java:258)\n\n\tat com.ibm.itp.common.Operation.internalRun(Operation.java:315)\n\n\tat com.ibm.itp.common.Operation.run(Operation.java:381)\n\n\tat com.ibm.itp.ui.views.projectexplorer.ResourceViewer.doDelete(ResourceViewer.java:239)\n\n\tat com.ibm.itp.ui.views.projectexplorer.DeleteResourceAction.actionPerformed(DeleteResourceAction.java:35)\n\n\tat com.ibm.jface.ActionContributionItem.widgetSelected(ActionContributionItem.java:386)\n\n\tat com.ibm.swt.widgets.TypedListener.handleEvent(TypedListener.java, Compiled Code)\n\n\tat com.ibm.swt.widgets.EventTable.sendEvent(EventTable.java, Compiled Code)\n\n\tat com.ibm.swt.widgets.Widget.notifyListener(Widget.java, Compiled Code)\n\n\tat com.ibm.swt.widgets.Display.runDeferredEvents(Display.java, Compiled Code)\n\n\tat com.ibm.swt.widgets.Display.readAndDispatch(Display.java, Compiled Code)\n\n\tat com.ibm.jface.parts.EventLoop.dispatchEventAndSleep(EventLoop.java, Compiled Code)\n\n\tat com.ibm.jface.parts.EventLoop.internalRun(EventLoop.java, Compiled Code)\n\n\tat com.ibm.jface.parts.EventLoop.run(EventLoop.java:49)\n\n\tat com.ibm.itp.ui.desktop.Desktop.runEventLoop(Desktop.java:385)\n\n\tat com.ibm.itp.ui.desktop.Desktop.run(Desktop.java:377)\n\n\tat com.ibm.itp.app.Application.showUI(Application.java:538)\n\n\tat com.ibm.itp.app.Application.run(Application.java:434)\n\n\tat com.ibm.itp.app.Application.main(Application.java:212)\n\nNOTES:\n\nDB (12.10.2000 12:45:33)\n\tHere is a simplier test case:\n\t- create solution MTP\n\t- switch to Java perspective\n\t- create project JUnit in package view\n\t- create project JUnit2\n\t- reveal rt.jar in both JUnit and JUnit2\n\t- delete JUnit and JUnit2\n\n\tReason for walkback: the rt.jar in shared between JUnit and JUnit2 (JUnit.rt.jar.equals(JUnit2.rt.jar).\n\tThe viewer\u0027s hashtable mechanism can\u0027t handle this case.\n\nDB (12.10.2000 14:45:54)\n\tJFace fix need. See PR 1G2PK1A: JFUIF:ALL - Viewer should delegate equals and hashCode to content provider\n\nAK (11/16/00 11:18:17 AM)\n\tthe stack trace looks a lot like the one in: 1G4GU97: ITPJUI:WINNT - Walkback in debugger\n\tdoes it mean anything?\n\nTM (16.11.2000 14:48:19)\n\tNot fixed as of today.\n\nNE (01/05/01 5:02:37 PM)\n\tWhy are the jar elements equal if they are contained in different projects?\n\tShouldn\u0027t they be different (non-equal) elements, but which happen to refer to the same file?\n\tEven if you could delegate equals and hashCode to the viewer, what criteria would you use in this case?\n\nDB (08.01.2001 12:33:00)\n\tThe problem in more detail:\n\n\tWhat we get from the java model are two different objects for jars contained in two different projects. But \n\tjar1.equals(jar2) returns true since from a java model perspective the two objects are equal since the refer\n\tto the same underlying rt.jar element (even though they have different parents).\n\n\tSince there isn\u0027t one right equal method we can\u0027t assume that the model implements equals and hashCode in a way \n\tthat fits the viewers\u0027 needs. That\u0027s why we propsed to propagate eqauls and hashCode to the content provider since \n\tit knows about the viewer and the data model and can implement the methods correctly.\n\n\tAnother idea is to create dummy objects that wrap the original elements. These dummy objects can implement \n\thashCode and equals accordingly. The downside of this approach is that you have to insert special code when\n\tyou process update events. If you wrap for example object A with a wrapper A\u0027 then you can\u0027t generate a viewer \n\tupdate event with the changed element A. You have to create one with the element A\u0027. \n\n\tSince viewer update (e.g. domain events) were heavily used in the old platform we came to the conclusion that it is easier\n\tto delegate hashCode and equals to the content provider and to implement an own hash table (for the mapping) instead\n\tof adding special code when processing domain events.\n\nNE (1/8/01 9:34:10 AM)\n\tThanks for the clarification.  I still think it\u0027s strange that the two rt.jar\u0027s are equal, but I agree with your statement\n\tthat in general the model\u0027s idea of equality may not meet the needs of the viewers.\n\tIn general, I agree that it would be more flexible to allow equals and hashCode to be delegated to the content provider if needed.\n\tUsing wrapper objects is expensive, and can lead to confusion as to which object you\u0027re dealing with.\n\tIt just bothers me that viewers need to use equals and hashCode at all, but I don\u0027t see a way around this.\n\tOne option would be to use paths and compare based on the label text.  For example, in a tree viewer, it would ask the content\n\tprovider for the path for the second jar and get back:  String[] { \"JUnit2\", \"rt.jar\" }.  But feels less well defined than comparing \n\tthe elements themselves.  Paths are also more viewer-specific (i.e. what\u0027s the path for a table row?)\n\n\tDo you think it makes more sense to always delegate to the content provider, or make it optional?\n\tFor example, we could define an interface:\n\t\tinterface IHashCodeProvider\t{\n\t\t\tpublic int getHashCode(Object obj);\n\t\t\tpublic boolean equals(Object a, Object b);\n\t\t}\n\tThen we could either make IContentProvider extend IHashCodeProvider, and always call the two methods, or make it optional.\n\tIf the content provider didn\u0027t implement IHashCodeProvider, then we would use the equals and hashCode on the objects themselves.\n\tAlternatively, we could decouple them and have StructuredViewer.setHashCodeProvider(IHashCodeProvider), as we do for sorters,\n\tfilters and label providers.  This latter approach would seem to fit better with the current design.\n\nDB (08.01.2001 17:42:24)\n\tI like the idea of having a separate plugin which is also separate from IContentProvider since it should be a rare case\n\tredefining hashCode and equals.  So I only have implement the methods if I need to do so.\n\n\tOnly the name isn\u0027t perfect to me since the plugin does both hashCode and equals. But I am not able to come up with a \n\tbetter one.",
    "moved to \u0027active\u0027",
    "inactive",
    "PRODUCT VERSION:\n\tMini Test Pass\n\n"
  ],
  "commentCreationDates": [
    "2001-10-11T04:56:03+02:00",
    "2001-10-16T17:16:38+02:00",
    "2001-10-22T15:44:35+02:00",
    "2001-10-24T13:10:42+02:00"
  ],
  "traces": [
    {
      "exceptionType": "com.ibm.itp.common.AssertionFailedException",
      "message": "null argument;",
      "elements": [
        {
          "method": "com.ibm.itp.common.Assert.isNotNull",
          "source": "Assert.java, Compiled Code"
        },
        {
          "method": "com.ibm.itp.common.Assert.isNotNull",
          "source": "Assert.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.StructuredContentViewer.unmapElement",
          "source": "StructuredContentViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.AbstractTreeViewer.disassociate",
          "source": "AbstractTreeViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.AbstractTreeViewer.disassociateChildren",
          "source": "AbstractTreeViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.AbstractTreeViewer.disassociate",
          "source": "AbstractTreeViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.AbstractTreeViewer.updatePlus",
          "source": "AbstractTreeViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.AbstractTreeViewer.internalRefresh",
          "source": "AbstractTreeViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.AbstractTreeViewer.internalRefresh",
          "source": "AbstractTreeViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.StructuredContentViewer$2.run",
          "source": "StructuredContentViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.ContentViewer.preserveSelection",
          "source": "ContentViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.AbstractTreeViewer.preserveSelection",
          "source": "AbstractTreeViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.StructuredContentViewer.doDomainChanged",
          "source": "StructuredContentViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.AbstractTreeViewer.doDomainChanged",
          "source": "AbstractTreeViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.ContentViewer.runDomainChanged",
          "source": "ContentViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.ContentViewer.access$3",
          "source": "ContentViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.viewer.ContentViewer$3.run",
          "source": "ContentViewer.java, Compiled Code"
        },
        {
          "method": "com.ibm.swt.widgets.RunnableLock.run",
          "source": "RunnableLock.java, Compiled Code"
        },
        {
          "method": "com.ibm.swt.widgets.Display.runAsyncMessages",
          "source": "Display.java, Compiled Code"
        },
        {
          "method": "com.ibm.swt.widgets.Display.readAndDispatch",
          "source": "Display.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.parts.EventLoop.dispatchEventAndSleep",
          "source": "EventLoop.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.util.ModalContext.internalBlock",
          "source": "ModalContext.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.util.ModalContext.internalExecute",
          "source": "ModalContext.java:192"
        },
        {
          "method": "com.ibm.jface.util.ModalContext.execute",
          "source": "ModalContext.java:103"
        },
        {
          "method": "com.ibm.jface.util.ModalContext.execute",
          "source": "ModalContext.java:85"
        },
        {
          "method": "com.ibm.jface.parts.ProgressMonitorDialog.execute",
          "source": "ProgressMonitorDialog.java:258"
        },
        {
          "method": "com.ibm.itp.common.Operation.internalRun",
          "source": "Operation.java:315"
        },
        {
          "method": "com.ibm.itp.common.Operation.run",
          "source": "Operation.java:381"
        },
        {
          "method": "com.ibm.itp.ui.views.projectexplorer.ResourceViewer.doDelete",
          "source": "ResourceViewer.java:239"
        },
        {
          "method": "com.ibm.itp.ui.views.projectexplorer.DeleteResourceAction.actionPerformed",
          "source": "DeleteResourceAction.java:35"
        },
        {
          "method": "com.ibm.jface.ActionContributionItem.widgetSelected",
          "source": "ActionContributionItem.java:386"
        },
        {
          "method": "com.ibm.swt.widgets.TypedListener.handleEvent",
          "source": "TypedListener.java, Compiled Code"
        },
        {
          "method": "com.ibm.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java, Compiled Code"
        },
        {
          "method": "com.ibm.swt.widgets.Widget.notifyListener",
          "source": "Widget.java, Compiled Code"
        },
        {
          "method": "com.ibm.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java, Compiled Code"
        },
        {
          "method": "com.ibm.swt.widgets.Display.readAndDispatch",
          "source": "Display.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.parts.EventLoop.dispatchEventAndSleep",
          "source": "EventLoop.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.parts.EventLoop.internalRun",
          "source": "EventLoop.java, Compiled Code"
        },
        {
          "method": "com.ibm.jface.parts.EventLoop.run",
          "source": "EventLoop.java:49"
        },
        {
          "method": "com.ibm.itp.ui.desktop.Desktop.runEventLoop",
          "source": "Desktop.java:385"
        },
        {
          "method": "com.ibm.itp.ui.desktop.Desktop.run",
          "source": "Desktop.java:377"
        },
        {
          "method": "com.ibm.itp.app.Application.showUI",
          "source": "Application.java:538"
        },
        {
          "method": "com.ibm.itp.app.Application.run",
          "source": "Application.java:434"
        },
        {
          "method": "com.ibm.itp.app.Application.main",
          "source": "Application.java:212"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "3492",
      "date": "2001-10-11T04:56:03+02:00",
      "product": "JDT",
      "component": "UI",
      "severity": "normal"
    }
  ],
  "groupId": "3492",
  "bugId": "3492",
  "date": "2001-10-11T04:56:03+02:00",
  "product": "JDT",
  "component": "UI",
  "severity": "normal"
}