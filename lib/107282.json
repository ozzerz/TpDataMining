{
  "comments": [
    "3.1\nUnused import should not prevent compilation of the class.\nI get \u0027unresolved compilation problem\u0027. That sounds too radical. There\u0027s nothing\nthat prevents compiling the class.",
    "Adam,\n\nWould you have an example? The builds contain unused imports and they don\u0027t\nprevent the class from being compiled.",
    "ha, but i have the option set to error\n\nMy point is that _even then_ it should not prevent the compiler from producing a\nfully usable classfile. It does produce a classfile but you can\u0027t really run\nanything in it. \nThere\u0027s no _real_ problem with the code and I\u0027m sure the compiler can notice that. \n",
    "for an example try anything, like\n\nA.java\nimport java.util.List;//error here\npublic class A {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"hello\");\n\t}\n}\n\nyou get:\n\nException in thread \"main\" java.lang.Error: Unresolved compilation problem: \n\tat A.main(A.java:3)\n",
    "ok, I see. This is much clearer.\nThanks. So you mean we should filter out the warnings when generating problem\ntypes and problem methods.\nThat sounds fair, but this means the warnings won\u0027t be fixed :-).\nPhilippe, I will investigate this change.",
    "\u003eThat sounds fair, but this means the warnings won\u0027t be fixed :-).\nI think of warnings as a compile-time thing. I once I press \"run\" and click \"ok\nto run with errors in workspace\" it means I do want to run.\n\nthanks Olivier. This kind of problem does not happen often but when it does\nyou\u0027re  really suprised that the compiler seems to buffled by a triviality like\nthis.",
    "We can clearly filter out the warnings, but errors will still result in problem\nmethods.",
    "Let me rephrase the title to reflect the real problem.",
    "By \u0027errors\u0027 you mean only the \u0027Java Language Specification errors\u0027, right? \nAnd not \u0027JLS + whatever-preferences-you-have\u0027 errors.\n\nThat\u0027s fair. If I have bogus code in my method then it\u0027s OK to let it fail when\nthe method is called (OK to fail even on a branch than does not contain the\nproblem, for simplicity).",
    "By errors I mean whatever error is set in the compiler preferences. It is up to\nthe user to decide what should be considered as an error. An error means that\nthe code must be fixed.\nIf I set unused import as error, then it is fair to get a runtime error even if\nthis is not an error from the JLS point of view.\nI agree that warnings should cause runtime error to be thrown.",
    "re comment 9\nso how is my original problem going to be fixed?\nThe class will still fail on runtime because of the unused import. I think this\nis incorrect and this is exactly why I entered the report.\n\nI think compilation should create problem methods in classfiled only on\n\u0027mandatory i.e., JLS errors\u0027. On the optional (user specified) errors it should\njust go ahead and produce the bytecode as if nothing happened\u0027.",
    "Then this is not consistent with the user\u0027s settings. I thought that you had\nunused imports set as a warning. I misread your comment 2.\nI\u0027ll see what we can do with this.\n",
    "\u003eThen this is not consistent with the user\u0027s settings.\nThat\u0027s OK with me. The mandatory (JLS) errors form a separate category anyway\n(you can\u0027t change their severity) so I think it\u0027s ok to distingush them here too.\n",
    "The problem that we have right now is that the error prevents further analysis\non the code.\nFor example, the error can abort the type resolution of the unit and then no\ntypes in it have been resolved.\nWe would need to tweak the whole error management in the compiler in order to\nchange this behavior. Note that the batch compiler is not concerned with this\nsince it can only consider unused imports as warnings and not as error. This\nwould only impact the compiler within Eclipse.\nI will defer investigation till Philippe is back from vacations.\n\nPhilippe, any comment?",
    "Thanks Olivier.",
    "Adam,\n\nWhat you want to do simply means that you should set the unused imports as a\nwarning instead of an error. In this case, you could still see them in the\nproblem view and you could run your code.\nSaying that I think that any error on an import statement should not prevent\nfrom generating the .class file. Especially for unused import. That import\nclearly doesn\u0027t do anything. So in this case we should not trigger the problem\ntypes/methods mode and simply generate the code.\nNow we could imagine a better problem view that could allow you to \"sort\" or\n\"prioritize\" the problems (warnings or errors) to give a higher priority to the\none you really want to fix.\nHaving all warnings at the same level can prevent from focusing on specific ones.",
    "I noticed this problem in the following debugging scenario.\nDuring debugging I changed a bunch of code and built. Hotcode replace worked\nfine but I did not notice that an unused import got introduced.\nSo now, when I tried calling a method on the class I got the unfriendly and not\neasily understandable \u0027sorry, I can\u0027t run this class because you have an unused\nimport\u0027 error. It just looked too weird not to enter as a bug report :)\n\nNormally, I do want my unused imports as errors.",
    "I admit that getting problem method/type for unused imports is not ideal.\nI will investigate what needs to be changed to get a better control of the kind\nof errors that should not generate problem types/methods.",
    "Adam,\n\nI opened a more specific bug report for the unused imports case. See bug 107332.",
    "This is the old ZRH request for having extra compiler errors not alter classfile\ngeneration. I am against allowing errors to produce valid classfiles. If you\nonly want to get warned about an issue, then do not set it to ERROR, but WARNING.\n\nErrors are meant to be fatal. Introducing JLS error vs. optional error would be\nvery misleading.\n\nNow, I understand some users are raising some warnings as errors to make them\nmore proeminent, but I think this is an organizational problem. Why not fixing\nall warnings in the first place, then you can immediately see a new one. That\u0027s\nwhat we do in JDT/Core.\n\nIf some warnings are not very interesting, and you cannot fix them, then simply\ndisable them until you care again.\n\nThis whole debate could be improved if we introduced a 3rd severity category\n(which the platform supports: INFO), where INFO \u003c WARNING \u003c ERROR.\n",
    "\u003e Errors are meant to be fatal. Introducing JLS error vs. optional error would be\n\u003e very misleading.\nOn the other hand, I would expect a Java compiler to create working class files\nas long as the JLS is not violated. Otherwise, it does not compile Java(TM) any\nmore :-)\n\n\u003e This whole debate could be improved if we introduced a 3rd severity category\n\u003e (which the platform supports: INFO), where INFO \u003c WARNING \u003c ERROR.\nThat\u0027s bug 47340.",
    "I understand your claim Markus, but having fatal errors vs. ignorable errors\nwould be hard to understand. How would you expect users to tell the difference ?\n\nThen you would start working in a mode where you could ignore some errors, which\nwould easily make you miss real ones.\n\nNow the story is simple. Red X means must fix now, this is it. If you feel that\nunused imports are so bad, then simply fix them. I guess it takes less time than\nentering/annotating this defect... \n\n",
    "I think there is a difference between compile-time errors and runtime errors. On\ncompile time, I do want to see that import flagged as error. But as soon as I\npress Run and confirm I do want to run a project with errors (for whatever\nreason), I do want the bytecode to be as complete as possible. A triviality like\nan unused import should not prevent a compiler from generating valid code.\n\nThis is especially painful in cases when you *don\u0027t* see the \u0027do you want to run\nwith errors?\u0027 dialog - like in my original debug/hot swap scenario. See comment 16. ",
    "(In reply to comment #20)\n\u003e On the other hand, I would expect a Java compiler to create working class files\n\u003e as long as the JLS is not violated. Otherwise, it does not compile Java(TM) any\n\u003e more :-)\nMarkus, don\u0027t get confused between the compiler within Eclipse and the batch\ncompiler.\nThe batch compiler cannot report unused import as errors. It is only a warning.\nAnd also the whole idea of problem types/methods is specific to the Eclipse\nenvironment or the batch compiler with -processOnError option.\n",
    "By default, our compiler is sticking to the JLS. You can make it more sensitive,\nbut this has to be explicitly set by the user. You cannot blame the tool for\nrejecting what you told it to be an error.\n\nBasically, an error is just an error, which prevents running some portion of the\ncode (an import spans over the entire unit, which makes it not ignorable). \n\nBased on your arguments, I don\u0027t get why you are setting unused imports as\nerrors, given you want to ignore them. Maybe you should better select the\nproblems you want to reveal, or ask the tooling to better provide means to\ncategorize them.",
    "\u003eI don\u0027t get why you are setting unused imports as\n\u003eerrors, given you want to ignore them.\n\nI do not want to ingore them.\n\nBut when by accident you introduce them, like in my debug/hot swap scenario (see\ncomment 16), and the debugee fails because of an unresolved compile problem then\nyou start questioning if it is the right thing to do to make the classfile\nunusable because of a triviality like an unused import.\n\nI really do not see why the set of problem (i.e. made unusable by the inserted\nthrow-error bytecode) classes must be *exactly* the same set as the set of\nclasses that have compile errors. It should be just the subset for which it is\ntruly not possibly to generate code (like an unresolved reference, etc). \n\nPhilippe, if you really feel strongly about this, it\u0027s ok for me. It\u0027s not a\nsuper huge deal for me. \nAn not-understandible annoyance nonetheless.",
    "No problem. I am trying to understand the exact scenario. I would like to keep\nthe story simple. I feel concerned about introducing such an intermediate level\nof errors, which aren\u0027t truly errors.",
    "Philippe,\n\nProposed fix for bug 107814 gives some idea on how to filter such errors.",
    "I saw it, but it looks a bit of a hack as filtering one by one on a per ID basis\nwhich would end up being very error prone. Also, I still do not believe this\nmakes sense in the long term. How are we going to tell users that some errors\nare fine where others are fatal ? Our rule until now is simple and consistent:\nno error is fine, they are all fatal.\n\n",
    "I believe related bug is rather bug 107332.",
    "Also re: comment 22, I believe this is where we diverge. The compile time and\nruntime error sets are just the same. We let you run code with errors, but\nidentify some damage areas based on error locations. \nAn import spans over the entire unit, and thus is more involving than some error\nnested in some statement.\n\nBut again, don\u0027t tell unused imports are errors if you do not want to cause\ndamage to your classfiles. Again, why using ERROR for these problems ? Why isn\u0027t\nWARNING just fine ? My guess is that you have tons of warnings which you\ncannot/do not want to get rid off (since you accumulated so many), and then\nthere are a few you want to make stand out. The problem is that these are\ninterfering with some mechanisms as described here.\n\nMy recommendation is that you simply fix all your warnings, then you can notice\nall unused import at the very moment you introduce it. Working with a low\nproblem count is a good strategy, at least until we have better ways to\ncategorize problems than the simple problem view.\n\nAlso, I would rather favor introducing an INFO level, that you could use to\ndowngrade your numerous and less important warnings, which are only making noise.\n\nAm I totally wrong here ?",
    "Philippe: For me, your observation is correct except in one point. There are\ncertain style warnings that we\u0027d like to see flagged (as INFO?) but which are\nstill OK to commit to CVS. Therefore, we don\u0027t want to take the effort to\nworkaround/\"fix\" these warnings, but we still want to see them when editing the CU.\n\nAlthough I still think errors that don\u0027t prevent code generation should not lead\nto runtime errors, I\u0027d be a happy camper if bug 47340 was implemented.",
    "For these extra warnings, do you even care about them in the problem view ? I\nremember some old requests where some wanted more warnings in editor/reconcile\nthan when building (i.e. do not care about certain warnings until you edit them). ",
    "I already filter warnings from the Problems view today. If info severity was\navailable, I would just show errors and warnings in the Problems view and filter\ninfos.\n\nIt may be hard to understand for users why some problems only appear in the\neditor. And sometimes, I still want to see the infos in the problems view (e.g.\nto count occurrences of a certain problem to decide whether it should be\npromoted to warning or error). IMO, we should keep the story simple here, unless\nthere are significant performance reasons for not creating markers for some\nproblems.",
    "Agreed 100%. I am simply trying to see what you had in mind exactly. \u003cg\u003e",
    "Added compiler option so as to specify whether optional errors should be fatal\nor not. By default, an optional error is treated as fatal as a normal language\nerror (as defined by the language spec book), when disabling this option,\nclients will\nbe able to treat optional errors as severe warnings only, which will be rendered\nas errors, but no longer prevent from running the code. There is some work\nplanned on UI side so as to better distinguish amongst mandatory vs. optional\nerrors.\n\u003cpre\u003e\n* COMPILER / Treating Optional Error as Fatal\n*    When enabled, optional errors (i.e. optional problems which severity is set\nto \"error\") will be treated as standard\n*    compiler errors, yielding problem methods/types preventing from running\noffending code until the issue got resolved.\n*    When disabled, optional errors are only considered as warnings, still\ncarrying an error indication to make them more\n*    severe. Note that by default, errors are fatal, whether they are optional\nor not.\n*     - option id:        \n\"org.eclipse.jdt.core.compiler.problem.fatalOptionalError\"\n*     - possible values:   { \"enabled\", \"disabled\" }\n*     - default:           \"enabled\"\n\u003c/pre\u003e\t ",
    "Olivier - pls add some specific testcases.\n\nNote for UI: it shouldn\u0027t be surfaced as an option until the differenciation of\nmarker/annotation is made in the UI.",
    "To clarify: differenciation between mandatory and optional errors. Currently\nthere is no API for it.",
    "Marking as fixed. UI counterpart should have a PR for it in JDT/UI",
    "Added regression tests in\norg.eclipse.jdt.core.tests.compiler.regression.NonFatalErrorTest.test001/005.\nThis includes tests for bug 107332.",
    "*** Bug 107332 has been marked as a duplicate of this bug. ***",
    "I filed bug 113239 for the UI",
    "Verified for 3.2 M3 using build I20051025-0800+JDT/Core v_618a bu modifying the\njdt/core prefs in .settings.",
    "*** Bug 168104 has been marked as a duplicate of this bug. ***",
    "This is a great enhancement.  Many teams want to flag unused imports, local variables, etc., as errors, but it has a negative effect on hot-swapping.\n\nMy vote is to change the default of the new \"Treat configurable errors like fatal\" to false. Otherwise this improvement risks going undiscovered by most users."
  ],
  "commentCreationDates": [
    "2005-08-18T01:33:23+02:00",
    "2005-08-18T02:17:22+02:00",
    "2005-08-18T02:23:29+02:00",
    "2005-08-18T02:24:30+02:00",
    "2005-08-18T15:04:29+02:00",
    "2005-08-18T15:13:10+02:00",
    "2005-08-18T15:15:21+02:00",
    "2005-08-18T15:18:45+02:00",
    "2005-08-18T15:20:56+02:00",
    "2005-08-18T15:43:27+02:00",
    "2005-08-18T15:49:12+02:00",
    "2005-08-18T15:55:23+02:00",
    "2005-08-18T16:04:21+02:00",
    "2005-08-18T16:06:15+02:00",
    "2005-08-18T16:09:21+02:00",
    "2005-08-18T16:48:42+02:00",
    "2005-08-18T16:56:32+02:00",
    "2005-08-18T17:02:24+02:00",
    "2005-08-18T17:20:23+02:00",
    "2005-08-20T02:10:20+02:00",
    "2005-08-22T12:03:04+02:00",
    "2005-08-23T10:30:47+02:00",
    "2005-08-23T15:31:48+02:00",
    "2005-08-24T16:25:11+02:00",
    "2005-08-30T22:10:53+02:00",
    "2005-08-30T22:23:49+02:00",
    "2005-09-01T17:15:29+02:00",
    "2005-09-01T17:17:12+02:00",
    "2005-09-06T09:39:11+02:00",
    "2005-09-06T09:41:49+02:00",
    "2005-09-06T09:56:56+02:00",
    "2005-09-06T10:36:36+02:00",
    "2005-09-06T11:06:22+02:00",
    "2005-09-06T11:30:13+02:00",
    "2005-09-06T13:25:53+02:00",
    "2005-10-20T15:14:24+02:00",
    "2005-10-20T15:16:40+02:00",
    "2005-10-20T15:17:44+02:00",
    "2005-10-20T16:20:39+02:00",
    "2005-10-20T16:42:21+02:00",
    "2005-10-20T16:43:08+02:00",
    "2005-10-20T17:04:03+02:00",
    "2005-10-28T19:51:11+02:00",
    "2006-12-15T01:56:19+01:00",
    "2006-12-15T15:03:20+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.Error",
      "message": "Unresolved compilation problem:",
      "elements": [
        {
          "method": "A.main",
          "source": "A.java:3"
        }
      ],
      "number": 0,
      "commentIndex": 3,
      "bugId": "107282",
      "date": "2005-08-18T02:24:30+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "107282",
  "bugId": "107282",
  "date": "2005-08-18T01:33:23+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}