{
  "comments": [
    "Build: 3.0M7\n\nI launched a runtime workbench in debug mode on an existing workspace \ncontaining two Hello world plug-ins.\nWhen the runtime workbench appeared, I got the first stack pasted below in my \nlog complaining about background indexer crashing.\n\nIn the threads view of my host workbench, two threads paused, when I \npressed \u0027continue\u0027 on both of them.  The first thread dumped a stack to the \nconsole that is identical to the one I found in the log.  The second thread \ndumped an NPE.  It\u0027s the second stack pasted below.\n\nError Feb 13, 2004 21:06:32.281 Background Indexer Crash Recovery\njava.lang.ArrayIndexOutOfBoundsException: 16777425\nat org.eclipse.jdt.internal.core.index.impl.WordEntry.mapRefs\n(WordEntry.java:136)\nat org.eclipse.jdt.internal.core.index.impl.MergeFactory.mergeReferences\n(MergeFactory.java:180)\nat org.eclipse.jdt.internal.core.index.impl.MergeFactory.merge\n(MergeFactory.java:87)\nat org.eclipse.jdt.internal.core.index.impl.IndexImpl.merge(IndexImpl.java:221)\nat org.eclipse.jdt.internal.core.index.impl.IndexImpl.save(IndexImpl.java:315)\nat org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex\n(IndexManager.java:450)\nat org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute\n(AddJarFileToIndex.java:176)\nat org.eclipse.jdt.internal.core.search.processing.JobManager.run\n(JobManager.java:344)\nat java.lang.Thread.run(Thread.java:534)\n\n\n\njava.lang.NullPointerException\nat org.eclipse.jdt.internal.core.search.indexing.IndexManager.updateIndexState\n(IndexManager.java:616)\n\tat \norg.eclipse.jdt.internal.core.search.indexing.IndexManager.rebuildIndex\n(IndexManager.java:331)\n\tat org.eclipse.jdt.internal.core.search.indexing.IndexManager.getIndex\n(IndexManager.java:125)\n\tat org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes\n(PatternSearchJob.java:103)\n\tat org.eclipse.jdt.internal.core.search.PatternSearchJob.execute\n(PatternSearchJob.java:65)\n\tat \norg.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob\n(JobManager.java:261)\n\tat org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames\n(SearchEngine.java:825)\n\tat org.eclipse.jdt.internal.corext.util.AllTypesCache.search\n(AllTypesCache.java:440)\n\tat \norg.eclipse.jdt.internal.corext.util.AllTypesCache$TypeCacher.doSearchTypes\n(AllTypesCache.java:129)\n\tat org.eclipse.jdt.internal.corext.util.AllTypesCache$TypeCacher.run\n(AllTypesCache.java:98)",
    "This is the code for the method:\n\nprivate void updateIndexState(String indexName, Integer indexState) {\n\tgetIndexStates(); // ensure the states are initialized\n\tif (indexState !\u003d null) {\n\t\tif (indexState.equals(indexStates.get(indexName))) return;\n\t\tindexStates.put(indexName, indexState);\n\t} else {\n\t\tif (!indexStates.containsKey(indexName)) return;\n\t\tindexStates.removeKey(indexName);\n\t}\n\n\tBufferedWriter writer \u003d null;\n\ttry {\n\t\twriter \u003d new BufferedWriter(new FileWriter\n(savedIndexNamesFile));\n\t\tObject[] keys \u003d indexStates.keyTable;\n\n\u0027indexStates\u0027 cannot be null here since it wasn\u0027t null 5 lines above.\n\nLikely a VM problem.",
    "Unlikely to be VM-related.\n\nIt is possible for \u0027indexStates\u0027 to be null, because the if check is \nfor \u0027indexState\u0027 (i.e. singular).",
    "Look at the then AND else blocks, both access indexStates... it cannot be null \non a few lines later.",
    "Please indicate exactly which line from your snippet corresponds to the line \nthrowing the NPE, so I could try to figure out where the NPE could be coming \nfrom.  What I know is that I got an NPE and I have got the stack trace to \nprove it, so I\u0027m not sure that closing it without further investigation is a \ngood idea.",
    "Without further investigation? Did you even try to read thru the code in the \nstack trace?\n\n\nThe very first method called in updateIndexState is:\nprivate void updateIndexState(String indexName, Integer indexState) {\n\tgetIndexStates(); // ensure the states are initialized\n\nHere\u0027s the code for it:\n\nprivate SimpleLookupTable getIndexStates() {\n\tif (indexStates !\u003d null) return indexStates;\n\n\tthis.indexStates \u003d new SimpleLookupTable();\n\tchar[] savedIndexNames \u003d readIndexState();\n\tif (savedIndexNames.length \u003e 0) {\n\t\tchar[][] names \u003d CharOperation.splitOn(\u0027\\n\u0027, savedIndexNames);\n\t\tfor (int i \u003d 0, l \u003d names.length; i \u003c l; i++) {\n\t\t\tchar[] name \u003d names[i];\n\t\t\tif (name.length \u003e 0)\n\t\t\t\tthis.indexStates.put(new String(name), \nSAVED_STATE);\n\t\t}\n\t}\n\treturn this.indexStates;\n}\n\nSo how is indexStates null a few lines later?"
  ],
  "commentCreationDates": [
    "2004-02-14T02:23:34+01:00",
    "2004-02-17T19:18:02+01:00",
    "2004-02-17T22:05:56+01:00",
    "2004-02-18T16:33:21+01:00",
    "2004-02-18T17:36:11+01:00",
    "2004-02-18T18:08:17+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ArrayIndexOutOfBoundsException",
      "message": "16777425",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.core.index.impl.WordEntry.mapRefs",
          "source": "WordEntry.java:136"
        },
        {
          "method": "org.eclipse.jdt.internal.core.index.impl.MergeFactory.mergeReferences",
          "source": "MergeFactory.java:180"
        },
        {
          "method": "org.eclipse.jdt.internal.core.index.impl.MergeFactory.merge",
          "source": "MergeFactory.java:87"
        },
        {
          "method": "org.eclipse.jdt.internal.core.index.impl.IndexImpl.merge",
          "source": "IndexImpl.java:221"
        },
        {
          "method": "org.eclipse.jdt.internal.core.index.impl.IndexImpl.save",
          "source": "IndexImpl.java:315"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex",
          "source": "IndexManager.java:450"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute",
          "source": "AddJarFileToIndex.java:176"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.processing.JobManager.run",
          "source": "JobManager.java:344"
        },
        {
          "method": "java.lang.Thread.run",
          "source": "Thread.java:534"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "52038",
      "date": "2004-02-14T02:23:34+01:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.core.search.indexing.IndexManager.updateIndexState",
          "source": "IndexManager.java:616"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.indexing.IndexManager.rebuildIndex",
          "source": "IndexManager.java:331"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.indexing.IndexManager.getIndex",
          "source": "IndexManager.java:125"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes",
          "source": "PatternSearchJob.java:103"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.PatternSearchJob.execute",
          "source": "PatternSearchJob.java:65"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob",
          "source": "JobManager.java:261"
        },
        {
          "method": "org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames",
          "source": "SearchEngine.java:825"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.AllTypesCache.search",
          "source": "AllTypesCache.java:440"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.AllTypesCache$TypeCacher.doSearchTypes",
          "source": "AllTypesCache.java:129"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.AllTypesCache$TypeCacher.run",
          "source": "AllTypesCache.java:98"
        }
      ],
      "number": 1,
      "commentIndex": 0,
      "bugId": "52038",
      "date": "2004-02-14T02:23:34+01:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "52038",
  "bugId": "52038",
  "date": "2004-02-14T02:23:34+01:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}