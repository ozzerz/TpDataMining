{
  "comments": [
    "Build 20030218\n\nI put a conditional breakpoint in SWT.error(int) with the condition \"code \u003d\u003d\n44\" and debug a motif runtime-workbench launch config. In the target, I then\nfollow the steps described in Comment 10 of Bug 31312. When the breakpoint\nis hit, the following NPE occurs.\n\njava.lang.NullPointerException\n\tat org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.getTypeId(ASTInstructionCompiler.java:2782)\n\tat org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.visit(ASTInstructionCompiler.java:1781)\n\tat org.eclipse.jdt.core.dom.InfixExpression.accept0(InfixExpression.java:244)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:1353)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:1400)\n\tat org.eclipse.jdt.core.dom.ReturnStatement.accept0(ReturnStatement.java:74)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:1353)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:1423)\n\tat org.eclipse.jdt.core.dom.Block.accept0(Block.java:81)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:1353)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:1400)\n\tat org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:179)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:1353)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:1423)\n\tat org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:161)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:1353)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:1423)\n\tat org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:160)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:1353)\n\tat org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.createExpressionFromAST(ASTEvaluationEngine.java:219)\n\tat org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.getCompiledExpression(ASTEvaluationEngine.java:137)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.handleConditionalBreakpointEvent(JavaLineBreakpoint.java:449)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.handleBreakpointEvent(JavaLineBreakpoint.java:361)\n\tat org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.handleEvent(JavaBreakpoint.java:248)\n\tat org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:164)\n\tat org.eclipse.jdt.internal.debug.core.EventDispatcher.run(EventDispatcher.java:205)\n\tat java.lang.Thread.run(Thread.java:536)",
    "Also, I thought we added code to handle exceptions thrown from within the\nevaluation engine. However, when this NPE occurred the program was left\nsuspended but the debug view did not update.",
    "I believe the type binding was returned as null because of Bug 32300. However,\nthe API on expression.resolveTypeBinding() says that it can return null. Please\nhandle null.",
    "We should have to handle null. We asked the AST parser/compiler to resolve the\nbindings. If a binding cannot be resolved, an error will be reported and the\ncode of ASTInstructionCompiler will never be executed.",
    "hemmmm\n\nread \u0027We shouldn\u0027t have\u0027 intead of \u0027We should have\u0027",
    "/**\n * Resolves and returns the binding for the type of this expression.\n * \u003cp\u003e\n * Note that bindings are generally unavailable unless requested when the\n * AST is being built.\n * \u003c/p\u003e\n * \n * @return the binding for the type of this expression, or\n *    \u003ccode\u003enull\u003c/code\u003e if the type cannot be resolved\n */\t\npublic ITypeBinding resolveTypeBinding() {\n  return getAST().getBindingResolver().resolveExpressionType(this);\n}",
    "I\u0027m able to reproduce the problem today. I\u0027m investigating.",
    "We need to handle the NPE, but the \"root\" of the problem here is a PDE bug.\nThe org.eclipse.swt.motif project isn\u0027t a Java project, which prevents us from\ndoing evaluations.",
    "A test case to reproduce the bug:\n\n1. Create non-java project which contains a jar file bar.jar, which contains the\nfollowing compilation unit:\n\npublic class Bar {\n  public static boolean TRUE\u003d true;\n  public static void bar() {\n    System.out.println(\"test\"); // \u003c-- breakpoint here\n  }\n}\n\n2. Create a java project which contains the following compilation unit:\n\npublic class Foo {\n  public static void main(String[] args) {\n    Bar.bar();\n  }\n}\n\n3. Add bar.jar in the build path of the java project, as a workspace resource\n(\"add jar\", not \"add external jar\").\n\n4. Set the breakpoint in Bar, set \"Bar.TRUE\" as its condition.\n5. Launch Foo in debug mode.",
    "Fixed.\n\nWe were using the resource associated to the marker to determine the project.\nThis method return the project which contains the jar (which can be a non-java\nproject).\n\nSwitch to use the source locator system, this returns a java project which\ncontains the jar in its build path.",
    "Please verify (jared).",
    "I still get the exception if I use IBM 1.3.1, although the path to the\nexception is slightly different.\n\nThis time it\u0027s a timing issue. Launch.launch doesn\u0027t set the source locator\nfor the launch until *after* the delegate has been told to launch. If the\nbreakpoint is hit too quickly (I get it 100% of the time), we ask for the\nsource locator in the JDI Event Dispatch thread before it\u0027s been set.",
    "Darin, can you please take a look at the Launch.launch code? It looks like\nwe\u0027re trying to be smart and not set the source locator if the launch has been\ncancelled.",
    "A launch config can specify a source locator ID. If the launch delegate does \nnot create a source locator, the #launch() method will create a source locator \nof the type specified by the ID on the launch config (if any). \n\nThe launch() method could create the source locator first (before delegating to \nthe launch delegate). However, it assumes that attributes on the config will \nnot be modified (which seems fair) during the launch. The delegate could still \ncreate a source locator if it wanted to (but should do so before the VM is \nlaunched). I think our delegates make the source locator after the launch is \ncomplete.\n\nThus, I think we should change the #launch method to make the source locator \nbefore doing the actual launch. And, we should update our launch delegates to \ncreate source locators (where applicable) before the VM is launched.",
    "Fixed as described.",
    "Please verify, Jared.",
    "Verified."
  ],
  "commentCreationDates": [
    "2003-02-18T21:36:52+01:00",
    "2003-02-18T21:43:11+01:00",
    "2003-02-21T16:19:36+01:00",
    "2003-02-21T17:01:51+01:00",
    "2003-02-21T17:02:55+01:00",
    "2003-02-21T17:04:09+01:00",
    "2003-02-21T17:11:27+01:00",
    "2003-02-21T22:16:10+01:00",
    "2003-03-03T23:35:17+01:00",
    "2003-03-03T23:52:46+01:00",
    "2003-03-03T23:53:14+01:00",
    "2003-03-04T00:31:44+01:00",
    "2003-03-04T00:32:58+01:00",
    "2003-03-04T00:55:26+01:00",
    "2003-03-04T21:35:48+01:00",
    "2003-03-04T21:36:01+01:00",
    "2003-03-04T23:06:54+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.getTypeId",
          "source": "ASTInstructionCompiler.java:2782"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.visit",
          "source": "ASTInstructionCompiler.java:1781"
        },
        {
          "method": "org.eclipse.jdt.core.dom.InfixExpression.accept0",
          "source": "InfixExpression.java:244"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.accept",
          "source": "ASTNode.java:1353"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.acceptChild",
          "source": "ASTNode.java:1400"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ReturnStatement.accept0",
          "source": "ReturnStatement.java:74"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.accept",
          "source": "ASTNode.java:1353"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.acceptChildren",
          "source": "ASTNode.java:1423"
        },
        {
          "method": "org.eclipse.jdt.core.dom.Block.accept0",
          "source": "Block.java:81"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.accept",
          "source": "ASTNode.java:1353"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.acceptChild",
          "source": "ASTNode.java:1400"
        },
        {
          "method": "org.eclipse.jdt.core.dom.MethodDeclaration.accept0",
          "source": "MethodDeclaration.java:179"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.accept",
          "source": "ASTNode.java:1353"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.acceptChildren",
          "source": "ASTNode.java:1423"
        },
        {
          "method": "org.eclipse.jdt.core.dom.TypeDeclaration.accept0",
          "source": "TypeDeclaration.java:161"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.accept",
          "source": "ASTNode.java:1353"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.acceptChildren",
          "source": "ASTNode.java:1423"
        },
        {
          "method": "org.eclipse.jdt.core.dom.CompilationUnit.accept0",
          "source": "CompilationUnit.java:160"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTNode.accept",
          "source": "ASTNode.java:1353"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.createExpressionFromAST",
          "source": "ASTEvaluationEngine.java:219"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.getCompiledExpression",
          "source": "ASTEvaluationEngine.java:137"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.handleConditionalBreakpointEvent",
          "source": "JavaLineBreakpoint.java:449"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.handleBreakpointEvent",
          "source": "JavaLineBreakpoint.java:361"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.handleEvent",
          "source": "JavaBreakpoint.java:248"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch",
          "source": "EventDispatcher.java:164"
        },
        {
          "method": "org.eclipse.jdt.internal.debug.core.EventDispatcher.run",
          "source": "EventDispatcher.java:205"
        },
        {
          "method": "java.lang.Thread.run",
          "source": "Thread.java:536"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "32174",
      "date": "2003-02-18T21:36:52+01:00",
      "product": "JDT",
      "component": "Debug",
      "severity": "normal"
    }
  ],
  "groupId": "32174",
  "bugId": "32174",
  "date": "2003-02-18T21:36:52+01:00",
  "product": "JDT",
  "component": "Debug",
  "severity": "normal"
}