{
  "comments": [
    "Using 0514 build. \nJRE is \njava version \"1.4.2\"\nJ9 - VM for the Java(TM) platform (build 2.1)\nIBM J9SE VM (build 2.1, J2RE 1.4.2 IBM J9 build 20040422 (JIT enabled))\n\nWorks ok on Suns\u0027 JRE (1.4.2_03) but with IBM\u0027s its easy to exception from \niFile.getContentDescription(), I\u0027ll attach test case. \n\n\n\u003d \u003d \u003d \u003d \u003d\norg.eclipse.core.internal.resources.ResourceException(/com.ibm.encoding.\nresource.newtests/testfiles/xml/testUTF16.xml)[381]: sun.io.\nMalformedInputException\n\tat sun.io.ByteToCharUnicode.flush(ByteToCharUnicode.java:227)\n\tat sun.nio.cs.StreamDecoder$ConverterSD.flushInto(StreamDecoder.java:305)\n\tat sun.nio.cs.StreamDecoder$ConverterSD.implRead(StreamDecoder.java:329)\n\tat sun.nio.cs.StreamDecoder.read(StreamDecoder.java:222)\n\tat java.io.InputStreamReader.read(InputStreamReader.java:207)\n\tat org.apache.xerces.impl.XMLEntityScanner.load(Unknown Source)\n\tat org.apache.xerces.impl.XMLEntityScanner.skipSpaces(Unknown Source)\n\tat org.apache.xerces.impl.XMLDocumentScannerImpl$PrologDispatcher.\ndispatch(Unknown Source)\n\tat org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.\nscanDocument(Unknown Source)\n\tat org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n\tat org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n\tat org.apache.xerces.parsers.XMLParser.parse(Unknown Source)\n\tat org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source)\n\tat javax.xml.parsers.SAXParser.parse(Unknown Source)\n\tat org.eclipse.core.internal.content.XMLRootHandler.\nparseContents(XMLRootHandler.java:163)\n\tat org.eclipse.core.runtime.content.XMLRootElementContentDescriber.\ncheckCriteria(XMLRootElementContentDescriber.java:62)\n\tat org.eclipse.core.runtime.content.XMLRootElementContentDescriber.\ndescribe(XMLRootElementContentDescriber.java:87)\n\tat org.eclipse.core.internal.content.ContentType.describe(ContentType.java:\n164)\n\tat org.eclipse.core.internal.content.ContentTypeManager.\ninternalFindContentTypesFor(ContentTypeManager.java:295)\n\tat org.eclipse.core.internal.content.ContentTypeManager.\ngetDescriptionFor(ContentTypeManager.java:262)\n\tat org.eclipse.core.internal.resources.ContentDescriptionManager.\nreadDescription(ContentDescriptionManager.java:57)\n\tat org.eclipse.core.internal.resources.ContentDescriptionManager.\ngetDescriptionFor(ContentDescriptionManager.java:42)\n\tat org.eclipse.core.internal.resources.File.getContentDescription(File.\njava:239)\n\tat com.ibm.encoding.resource.tests.example.TestCodedReader.\ndoContentDescriptionTest(TestCodedReader.java:213)\n\tat com.ibm.encoding.resource.tests.example.TestCodedReader.\ntestFile123(TestCodedReader.java:206)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.\njava:84)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.\njava:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.\ninvoke(DelegatingMethodAccessorImpl.java:59)\n\tat java.lang.reflect.Method.invoke(Method.java:390)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.\nrunTests(RemoteTestRunner.java:422)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.\nrun(RemoteTestRunner.java:306)\n\tat org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.\nmain(RemotePluginTestRunner.java:30)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication$1.\nrun(UITestApplication.java:90)\n\tat org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)\n\tat org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:\n106)\n\tat org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:2702)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2394)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1353)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1324)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:\n243)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:141)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:90)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication.\nrun(UITestApplication.java:33)\n\tat org.eclipse.core.internal.runtime.PlatformActivator$1.\nrun(PlatformActivator.java:298)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:\n249)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:\n126)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.\njava:84)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.\njava:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.\ninvoke(DelegatingMethodAccessorImpl.java:59)\n\tat java.lang.reflect.Method.invoke(Method.java:390)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:269)\n\tat org.eclipse.core.launcher.Main.run(Main.java:722)\n\tat org.eclipse.core.launcher.Main.main(Main.java:706)",
    "Created an attachment (id\u003d10718)\njunit test to demonstrate above error\n",
    "David, it seems the mentioned file does not have a UTF-16 BOM. According to:\n\nhttp://www.w3.org/TR/2004/REC-xml-20040204/#charencoding\n\nit seems it should have. \n\nOf course, this does not invalidate the PR. I just thought I should mention.",
    "Created an attachment (id\u003d10738)\nhex values of test file\n\nI think it does -- testUTF16.xml in zip file? -- unless somethings getting\n\"lost in translation\". Of course, I think some one\u0027s code some where may leave\nthe input stream positioned after the BOM :) [that works pretty well, and is\nneeded, for UTF-8 BOMs, I\u0027ve always found the UTF-16 boms a little more\nproblematic, sometimes expected, sometimes not, as the different results for\ntwo VM\u0027s would seem to indicate]\n\nThe attached image show\u0027s what the hex values look like for the file I\u0027m\nlooking at ... FFFE, right?",
    "My fault... yes, the right one has the right BOM... I was trying with\n\"test-UTF-16.xml\" in testfiles\\genedFiles...\\xml. \n\nThe reason we were failing is that we want to let IOExceptions flow to the\ncaller, but sun.io.MalformedInputException is an I/O exception\n(CharConversionException). We will have to handle those (and let\nnon-encoding-related ones flow).",
    "Since we are reading the contents right in the beginning in the handling it to\ndescribers, any \"real\" I/O exceptions will happen right way. When calling\ndescribers, I/O exceptions will not be severe, so they are just logged (not thrown).\n\nFixed and released to HEAD as described above.",
    "Actually the problem itself still occurs...",
    "David, that file has an odd number of bytes. The IOException happens when trying\nto decode the last char. Is this intentional? The following example would cause\na CharConversionException to occur with IBM\u0027s JRE:\n\nimport java.io.*;\npublic class Simple {\n\tpublic static void main(String[] args) throws IOException {\n\t\tReader reader \u003d new InputStreamReader(new FileInputStream(args[0]), args[1]);\n\t\tint c;\n\t\twhile ((c \u003d reader.read()) !\u003d -1)\n\t\t\tSystem.out.println((char) c);\n\t}\n}",
    "No, it wasn\u0027t intentional. Well, at least I don\u0027t think so. I\u0027ll try and \nrecover its \"history\", but its just part of the whole set of files I\u0027ve \nroutinely tested for the past few years! (I should document my unit tests \nbetter).  I assume some previous version of Java wrote it that way. It does \nmake obvious, though, that the CharsetDecoder error defaults are different \nbetween the IBM and Sun VMs (and, we\u0027ve had trouble in the past where the \ndefaults change from one version to another). \n\nIf you change your example to use \"Replace\" on error then you get the same \nbehavior on both VMs. \n\n\t \tCharset charset \u003d Charset.forName(\"UTF-16\");\n\t \tCharsetDecoder charsetDecoder \u003d charset.newDecoder();\n\t \tcharsetDecoder.onMalformedInput(CodingErrorAction.REPLACE);\n\t\t Reader reader \u003d new InputStreamReader(new FileInputStream(args\n[0]), charsetDecoder);\n\t\t int c;\n\t\t while ((c \u003d reader.read()) !\u003d -1)\n\t\t \t\t System.out.println((char) c);\n}\n\nCan things be arranged so each \"content type handler\" set its own values for \nthis type of error handling? It seems the XMLRootHander would be best off \nignoring (replacing) them (since its looking for a \"positive match\"). But, in \nthe past, we\u0027ve enjoyed giving are editor users a choice when an error \noccurs ... e.g. \"malformed input detected do you want to continue or cancel?\". \nI\u0027m not sure how to do that with this new system. ",
    "Partial fix was to handle faulty describers so other describers still have a chance.\n\nAs the change you suggested, David, in core.runtime we have a requirement of\nrunning on J2SE subsets that do not include java.nio. To do what you suggested\nwould require doing some exercise with reflection.",
    "No java.nio!? How do those systems handle encoding/decoding? I thought java.nio \nwas a \"standard\" part of Java 1.4. So, if core.runtime has to run on a subset \nof standard Java, then some of this encoding/decoding function doesn\u0027t belong \nat that level, that\u0027d be my opinion, I mean. Even more concretely, in this \ncase, if your \"fix\" is just to disable that provider as \u0027faulty\u0027, then there \nwill be a bug open that object contributions depending on \nXMLRootElementContentDescriber would not work. (Or, do you mean it was just be \ndisabled for that one pass, for that one file, in which case, you\u0027d always need \nthat sort of fall back behaviour for that one time.). \n\nBTW, I think this \"invalid file\" was formed by checking a UTF-16 files with \nsingle EOL into CVS, and then when checked back out, an 2 coded EOL was added. \nOr some similar \"play\" with end-of-lines. I suspect this will be moderately \ncommon.\n\nMore severely, for me to maintain our products current level of encoding \nsupport/behavior, I will have to use java.nio (e.g. to check differenct \nof \"detected encoding\" and \"used encoding\" (to know when an alias is being \nused) and have control over how its set/initialized.  I as going to propose \nsome of these as fixes for core.runtime, but sounds like that would be a hard \ncase to sell. I don\u0027t mind leaving them in my own XML version of \nContentDescriber, as long as I can depend on it always being called. I assume I \nwould put its priority as \"high\" and a child of runtime.xml. Do you forsee any \nproblems with this approach?\n\nThanks in advance for any help or advice. ",
    "Agreed that the content type support is being more restricted than it should,\nbut right now we don\u0027t have many choices.\n\nRegardless the cirscumstances your file got into that state, you agree it is\ninvalid, right? \n\nRe: providing a personalized version of the XML content describer: you cannot\nreplace the default XML content provider. But the XML describer will hardly\nclassify any contents as invalid (currently it never does that), so you don\u0027t\nneed a new content type for XML. You need a more appropriate XML content\ndescriber to be used by your XML-based content types.",
    "No further action planned. We will log such exceptions only if in debug mode\n(added a debug option for content type), and faulty describers will just be\nskipped during that lookup."
  ],
  "commentCreationDates": [
    "2004-05-17T09:12:54+02:00",
    "2004-05-17T09:16:26+02:00",
    "2004-05-17T18:54:48+02:00",
    "2004-05-17T19:16:01+02:00",
    "2004-05-17T20:29:47+02:00",
    "2004-05-17T21:24:55+02:00",
    "2004-05-17T23:50:08+02:00",
    "2004-05-18T00:55:56+02:00",
    "2004-05-18T04:53:38+02:00",
    "2004-05-25T19:56:07+02:00",
    "2004-05-26T04:28:36+02:00",
    "2004-05-26T18:20:11+02:00",
    "2004-05-26T22:38:37+02:00"
  ],
  "traces": [
    {
      "exceptionType": "MalformedInputException",
      "elements": [
        {
          "method": "sun.io.ByteToCharUnicode.flush",
          "source": "ByteToCharUnicode.java:227"
        },
        {
          "method": "sun.nio.cs.StreamDecoder$ConverterSD.flushInto",
          "source": "StreamDecoder.java:305"
        },
        {
          "method": "sun.nio.cs.StreamDecoder$ConverterSD.implRead",
          "source": "StreamDecoder.java:329"
        },
        {
          "method": "sun.nio.cs.StreamDecoder.read",
          "source": "StreamDecoder.java:222"
        },
        {
          "method": "java.io.InputStreamReader.read",
          "source": "InputStreamReader.java:207"
        },
        {
          "method": "org.apache.xerces.impl.XMLEntityScanner.load",
          "source": "Unknown Source"
        },
        {
          "method": "org.apache.xerces.impl.XMLEntityScanner.skipSpaces",
          "source": "Unknown Source"
        },
        {
          "method": "org.apache.xerces.impl.XMLDocumentScannerImpl$PrologDispatcher.dispatch",
          "source": "Unknown Source"
        },
        {
          "method": "org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument",
          "source": "Unknown Source"
        },
        {
          "method": "org.apache.xerces.parsers.XML11Configuration.parse",
          "source": "Unknown Source"
        },
        {
          "method": "org.apache.xerces.parsers.XML11Configuration.parse",
          "source": "Unknown Source"
        },
        {
          "method": "org.apache.xerces.parsers.XMLParser.parse",
          "source": "Unknown Source"
        },
        {
          "method": "org.apache.xerces.parsers.AbstractSAXParser.parse",
          "source": "Unknown Source"
        },
        {
          "method": "javax.xml.parsers.SAXParser.parse",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.core.internal.content.XMLRootHandler.parseContents",
          "source": "XMLRootHandler.java:163"
        },
        {
          "method": "org.eclipse.core.runtime.content.XMLRootElementContentDescriber.checkCriteria",
          "source": "XMLRootElementContentDescriber.java:62"
        },
        {
          "method": "org.eclipse.core.runtime.content.XMLRootElementContentDescriber.describe",
          "source": "XMLRootElementContentDescriber.java:87"
        },
        {
          "method": "org.eclipse.core.internal.content.ContentType.describe",
          "source": "ContentType.java: 164"
        },
        {
          "method": "org.eclipse.core.internal.content.ContentTypeManager.internalFindContentTypesFor",
          "source": "ContentTypeManager.java:295"
        },
        {
          "method": "org.eclipse.core.internal.content.ContentTypeManager.getDescriptionFor",
          "source": "ContentTypeManager.java:262"
        },
        {
          "method": "org.eclipse.core.internal.resources.ContentDescriptionManager.readDescription",
          "source": "ContentDescriptionManager.java:57"
        },
        {
          "method": "org.eclipse.core.internal.resources.ContentDescriptionManager.getDescriptionFor",
          "source": "ContentDescriptionManager.java:42"
        },
        {
          "method": "org.eclipse.core.internal.resources.File.getContentDescription",
          "source": "File. java:239"
        },
        {
          "method": "com.ibm.encoding.resource.tests.example.TestCodedReader.doContentDescriptionTest",
          "source": "TestCodedReader.java:213"
        },
        {
          "method": "com.ibm.encoding.resource.tests.example.TestCodedReader.testFile123",
          "source": "TestCodedReader.java:206"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl. java:84"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl. java:57"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:59"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:390"
        },
        {
          "method": "junit.framework.TestCase.runTest",
          "source": "TestCase.java:154"
        },
        {
          "method": "junit.framework.TestCase.runBare",
          "source": "TestCase.java:127"
        },
        {
          "method": "junit.framework.TestResult$1.protect",
          "source": "TestResult.java:106"
        },
        {
          "method": "junit.framework.TestResult.runProtected",
          "source": "TestResult.java:124"
        },
        {
          "method": "junit.framework.TestResult.run",
          "source": "TestResult.java:109"
        },
        {
          "method": "junit.framework.TestCase.run",
          "source": "TestCase.java:118"
        },
        {
          "method": "junit.framework.TestSuite.runTest",
          "source": "TestSuite.java:208"
        },
        {
          "method": "junit.framework.TestSuite.run",
          "source": "TestSuite.java:203"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:422"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run",
          "source": "RemoteTestRunner.java:306"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main",
          "source": "RemotePluginTestRunner.java:30"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.UITestApplication$1.run",
          "source": "UITestApplication.java:90"
        },
        {
          "method": "org.eclipse.swt.widgets.RunnableLock.run",
          "source": "RunnableLock.java:35"
        },
        {
          "method": "org.eclipse.swt.widgets.Synchronizer.runAsyncMessages",
          "source": "Synchronizer.java: 106"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runAsyncMessages",
          "source": "Display.java:2702"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:2394"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1353"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1324"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java: 243"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:141"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:90"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.UITestApplication.run",
          "source": "UITestApplication.java:33"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:298"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java: 249"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java: 126"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl. java:84"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl. java:57"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:59"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:390"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:269"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:722"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:706"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "62443",
      "date": "2004-05-17T09:12:54+02:00",
      "product": "Platform",
      "component": "Resources",
      "severity": "normal"
    }
  ],
  "groupId": "62443",
  "bugId": "62443",
  "date": "2004-05-17T09:12:54+02:00",
  "product": "Platform",
  "component": "Resources",
  "severity": "normal"
}