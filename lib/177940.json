{
  "comments": [
    "Build ID: I20070222-0951\n\nSteps To Reproduce:\n1. Create a CDT project\n2. Modify scanner discovery settings (selected profile, profile specific settings)\n3. Run build to create scanner discovery data\n4. The created scanner info data is stored in \u003cworkspace\u003e\\.metadata\\.plugins\\org.eclipse.cdt.make.core, the project settings are also stored eith the workspace--all these settings should be stored directly below the project directory.\n\n\n\nMore information:\nThis is important for sharing the settings and generated data in a team.",
    "Could you give some more detailed description for the bug, i.e. could you list the settings that you think should be stored within the project?\n\nThanks,\nMikhail",
    "Hi!\n\nHere the affected classes:\n\nDiscoveryTab:\nStore all project property settings with the project (selected profile id, report enabled, automate scanner discovery, report path detection problem, enable build output scanner discovery, etc.)\n\nDiscoveredScannerInfoStore:\nUse project location instead of MakeCorePlugin.getWorkingDirectory() for reading and writing generated scanner info data.\n\nThe idea is that these settings should be available with the project such that another team member using the project initally has everything set up correctly. The discovered scanner info should be available to all team members (no need for every team member to run the scanner discovery after fetching the project), and it should not be necessary for every team member to set up discovery options.\n\nI know that such changes are subject for discussion.\n",
    "(In reply to comment #2)\n\n\u003e DiscoveryTab:\n\u003e Store all project property settings with the project (selected profile id,\n\u003e report enabled, automate scanner discovery, report path detection problem,\n\u003e enable build output scanner discovery, etc.)\nIt should be set within the project now.\n\n\u003e DiscoveredScannerInfoStore:\n\u003e Use project location instead of MakeCorePlugin.getWorkingDirectory() for\n\u003e reading and writing generated scanner info data.\nThe Discovered scanner information is usually differ for different machines, e.g. you could have standard headers recide in different directories on different machines. This is why they should not be shared and should be recalculated for different hosts.\n\nMikhail",
    "Hi Mikhail!\n\nWow, you are really fast ;-)\n\nRegarding discovery scanner info. I see that system includes or other compiler internal settings are specific to a user or workspace. However, all other includes and symbols are project specific. Maybe absolute include paths could be converted to project relative include paths when serializing or deserializing the paths--just an idea.\n",
    "(In reply to comment #4)\n\u003e Wow, you are really fast ;-)\nNot that fast :) I didn\u0027t do any changes. The discover settings were always stored within the project directory. Let me know if this does not work for you.\n\n\u003e Regarding discovery scanner info. I see that system includes or other compiler\n\u003e internal settings are specific to a user or workspace. However, all other\n\u003e includes and symbols are project specific. Maybe absolute include paths could\n\u003e be converted to project relative include paths when serializing or\n\u003e deserializing the paths--just an idea.\nThe discovered info settings were always stored outside of the project. Do you have any special reason for storing them within the project?\n\nMikhail\n",
    "I just realized that the discovery properties are really stored in the .cproject file, but only if it is a CDT project created by a CDT project creation wizard. The settings are not stored there for projects with default settings as created automatically via the resource listener (see backtrace below) or by calling CCorePlugin.getDefault().getCDescriptorManager().runDescriptorOperation(project, op, monitor);\n\nThis seems again to end up in the problem I have with the default settings / backward compatibility stuff.\n\nRegarding discovered scanner info, I assume that the include paths and symbols are not stored anywhere in the project folder, right? I thought it would be useful if every team member initially got the discovered data generated by the team member who created the project. As far as I have seen the discovered data is stored with the .sc file in the .metadata\\.plugins\\org.eclipse.cdt.make.core folder, but manually added paths are stored in the .cproject file in the project folder.\n\nI mean, if someone adds an absolute path via the include paths and symbols property page, then other users may have the same troubles as with discovered paths. Therefore all project specific paths could be stored under the project folder (in whatever file). But maybe I missed something.\n\n\nCProject.\u003cinit\u003e(ICElement, IProject) line: 63\t\nCModel.getCProject(IResource) line: 78\t\nCModelManager.create(IProject) line: 245\t\nCModelManager.create(IResource, ICProject) line: 229\t\nDeltaProcessor.createElement(IResource) line: 93\t\nDeltaProcessor.traverseDelta(ICElement, IResourceDelta) line: 459\t\nDeltaProcessor.processResourceDelta(IResourceDelta) line: 440\t\nCModelManager.resourceChanged(IResourceChangeEvent) line: 775\t\nNotificationManager$2.run() line: 282\t\nSafeRunner.run(ISafeRunnable) line: 37\t\nNotificationManager.notify(ResourceChangeListenerList$ListenerEntry[], IResourceChangeEvent, boolean) line: 276\t\nNotificationManager.broadcastChanges(ElementTree, ResourceChangeEvent, boolean) line: 148\t\nWorkspace.broadcastPostChange() line: 312\t\nWorkspace.endOperation(ISchedulingRule, boolean, IProgressMonitor) line: 1019\t\nWorkspace.run(IWorkspaceRunnable, ISchedulingRule, int, IProgressMonitor) line: 1807\t\nNotificationManager$NotifyJob.run(IProgressMonitor) line: 39\t\nWorker.run() line: 58\t\n",
    "(In reply to comment #6)\n \nCould you attach a stack-trace of the project creation that fails?\nI don\u0027t see that the project is being created from the stack trace you\u0027ve attached.\n\nThanks,\nMikhail\n",
    "Created an attachment (id\u003d61391)\nStacktrace for creating a CProject instance\n\nWRProjectModel.addPathEntry is implemented as follows. This creates indirectly a CProject instance.\n\npublic void addPathEntry(IProject project, IPathEntry entry) throws CoreException {\n  IPathEntryStore store \u003d CoreModel.getPathEntryStore(project);\n  if(store !\u003d null) {\n    IPathEntry[] entries \u003d store.getRawPathEntries();\n    List entryList \u003d new ArrayList(Arrays.asList(entries));\n    if (!entryList.contains(entry)) {\n      entryList.add(entry);\n      store.setRawPathEntries((IPathEntry[])entryList.toArray(new IPathEntry[entryList.size()]));\n    }\n  }\n}\n",
    "Thanks, Gerhard,\n\nI guess the source of the problem you are seeing is that you are creating the project in some \"non-standard\" way. NOTE: the CProject instance creation is not itsels a project creation. I can not reproduce the problem unless I understand the project creation flow you are implementing.\n\nCould you please describe the logic of the project creation you are implementing, i.e. what goes after what, or some test-case, etc.\n\nThanks,\nMikhail",
    "With the attached stacktrace, the path entry is written to the .cproject file correctly. However, when I add a path container after the proejct has been created, then it is not persisted.\n\nSee stacktrace below (called after project creation, for another project type):\n\nThread [Worker-22] (Suspended (breakpoint at line 272 in SAPropsAnalysis))\t\n\tSAPropsAnalysis.saveCDTBuildInfo(IProject) line: 272\t\n\tSAPropsAnalysis.configureNewProject(IProject) line: 187\t\n\tSAPropsAnalysis.read(IProject) line: 97\t\n\tSAContentManager.openProject(IProject) line: 11\t\n\tSAResourceChangeListener.visit(IResourceDelta) line: 113\t\n\tResourceDelta.accept(IResourceDeltaVisitor, int) line: 67\t\n\tResourceDelta.accept(IResourceDeltaVisitor, int) line: 76\t\n\tResourceDelta.accept(IResourceDeltaVisitor) line: 48\t\n\tSAResourceChangeListener.resourceChanged(IResourceChangeEvent) line: 81\t\n\tNotificationManager$2.run() line: 282\t\n\tSafeRunner.run(ISafeRunnable) line: 37\t\n\tNotificationManager.notify(ResourceChangeListenerList$ListenerEntry[], IResourceChangeEvent, boolean) line: 276\t\n\tNotificationManager.broadcastChanges(ElementTree, ResourceChangeEvent, boolean) line: 148\t\n\tWorkspace.broadcastBuildEvent(Object, int, int) line: 296\t\n\tAutoBuildJob.doBuild(IProgressMonitor) line: 161\t\n\tAutoBuildJob.run(IProgressMonitor) line: 224\t\n\tWorker.run() line: 58\t\n\nSAPropsAnalysis.saveCDTBuildInfo actually adds the DiscoveryPathContainer, exactly as in ScannerConfigNature.initializeDiscovery.\n\nMaybew we do not initialize the CDT project correctly. In fact, we are\n- set the c and cc natures (CProjectNature.C_NATURE_ID, CProjectNature.CC_NATURE_ID)\n- we register binary parsers (PE, ELF parser)\n- calling CoreModel.getRawPathEntries to get the raw path entries\n- add the discovery container (with id org.eclipse.cdt.make.core.DISCOVERED_SCANNER_INFO), if missing (and then save it using setRawPathEntries)\n- there is an extension for the scanner discovery for our own discovery profile,\n\n   \u003cextension\n         id\u003d\"WRStandardMakePerFileProfile\"\n         name\u003d\"%perFileScannerInfoProfileExtensionName\"\n         point\u003d\"org.eclipse.cdt.make.core.ScannerConfigurationDiscoveryProfile\"\u003e\n      \u003cscannerInfoCollector\n            class\u003d\"org.eclipse.cdt.make.internal.core.scannerconfig2.PerFileSICollector\"\n            scope\u003d\"file\"/\u003e\n      \u003cbuildOutputProvider\u003e\n         \u003copen/\u003e\n         \u003cscannerInfoConsoleParser class\u003d\"org.eclipse.cdt.make.internal.core.scannerconfig.gnu.GCCPerFileBOPConsoleParser\" compilerCommands\u003d\"gcc,dcc,cpp,c++,cc\"/\u003e\n      \u003c/buildOutputProvider\u003e\n      \u003cscannerInfoProvider providerId\u003d\"compilerBuiltinProvider\"\u003e\n         \u003crun\n               class\u003d\"com.windriver.ide.staticanalysis.core.scannerdiscovery.SACompilerBuiltinProvider\"/\u003e\n         \u003cscannerInfoConsoleParser class\u003d\"com.windriver.ide.staticanalysis.core.scannerdiscovery.SACompilerBuiltinConsoleParser\" compilerCommands\u003d\"gcc,dcc,cpp,c++,cc\"/\u003e\n      \u003c/scannerInfoProvider\u003e\n   \u003c/extension\u003e\n\n\nThat\u0027s actually all we do. I actually do not know, if we miss something to initialize.",
    "(In reply to comment #10)\n\n\u003e Maybew we do not initialize the CDT project correctly. In fact, we are\n\u003e - set the c and cc natures (CProjectNature.C_NATURE_ID,\n\u003e CProjectNature.CC_NATURE_ID)\n\u003e - we register binary parsers (PE, ELF parser)\n\u003e - calling CoreModel.getRawPathEntries to get the raw path entries\n\u003e - add the discovery container (with id\n\u003e org.eclipse.cdt.make.core.DISCOVERED_SCANNER_INFO), if missing (and then save\n\u003e it using setRawPathEntries)\n\u003e - there is an extension for the scanner discovery for our own discovery\n\u003e profile,\nThere might be some cuncurrency problems here. Are you running this as a batch operation (via IWorkspace.run() )?\n\nMikhail",
    "One more thing to note: \n\u003e Build ID: I20070222-0951\nIs it the CDT build ID that you are mentioning?\nIf so, could you try the latest build or the sources from HEAD. There have been done a lot of changes and fixes to the CDT since 02.22\n\nThanks,\nMikhail\n",
    "(In reply to comment #12)\n\u003e One more thing to note: \n\u003e \u003e Build ID: I20070222-0951\n\u003e Is it the CDT build ID that you are mentioning?\nSorry, I see now that this is an Eclipse Build ID rather than a CDT Build ID. In any way please use one of the latest CDT Builds or the sources from HEAD since there are many bug-fixes made in the recent time.\n\nMikhail\n",
    "Hi!\n\nThe build ID ist that of Eclipse. I am always using latest HEAD version of CDT.\n\nThe natures are set immediately after our project creation wizard has closed. The new path entry is added when a resource change is notified by the workspace.\n\nI am assembling a test case which will also be useful for the other issues I reported. I think this makes it easier to explain what happens.\n",
    "(In reply to comment #14)\n\u003e I am assembling a test case which will also be useful for the other issues I\n\u003e reported. I think this makes it easier to explain what happens.\nThank you Gerhard! \n\nI\u0027m sure this will definitely help!\n\nThanks,\nMikhail",
    "Hi Mikhail!\n\nDoes CPathEntryTest run sucessfully for you? I was writing additional test cases for this class when I realized they do not even run in their original form. For instance in testCPathEntries the last assertion fails.\n\nI just updated to the latest HEAD version (as of 2007-03-22, 21:00:00). The problem still occurs. It seems that this is exactly the same problem that I have with our projects.\n\njunit.framework.AssertionFailedError: Expecting 5 pathentries\n\tat junit.framework.Assert.fail(Assert.java:47)\n\tat junit.framework.Assert.assertTrue(Assert.java:20)\n\tat org.eclipse.cdt.core.model.tests.CPathEntryTest.testCPathEntries(CPathEntryTest.java:157)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat junit.framework.TestCase.runTest(TestCase.java:164)\n\tat junit.framework.TestCase.runBare(TestCase.java:130)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:120)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:230)\n\tat junit.framework.TestSuite.run(TestSuite.java:225)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:58)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication$1.run(UITestApplication.java:122)\n\tat org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)\n\tat org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:123)\n\tat org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3467)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3107)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2264)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2228)\n\tat org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2103)\n\tat org.eclipse.ui.internal.Workbench$4.run(Workbench.java:457)\n\tat org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:289)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:452)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)\n\tat org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:101)\n\tat org.eclipse.pde.internal.junit.runtime.UITestApplication.start(UITestApplication.java:52)\n\tat org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:146)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:106)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:76)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:169)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:476)\n\tat org.eclipse.equinox.launcher.Main.basicRun(Main.java:416)\n\tat org.eclipse.equinox.launcher.Main.run(Main.java:1124)\n\tat org.eclipse.equinox.launcher.Main.main(Main.java:1099)\n\n",
    "Hi Gerhard,\n\nThats a great great point! I have committed a one line fix to the small issue I found with the ICDescriptor persistance mechanism.\n\nThe path entry test are passing for me now!\n\nPlease update and let me know whether the fix solves your problem.\n\nThanks,\nMikhail",
    "(In reply to comment #17)\nHi Gerhard,\n\nAre you still seeing the problem with settings persistance or is it now works fine for you?\n\nThanks,\nMikhail",
    "Hi!\n\nThanks. The fix did change something. Now the container is written correctly to the .cproject file.\n\nThe \u003cproject name\u003e.sc file for the project exists and contains discovered paths, and a path container node is in the .cproject file. The content of storage module \"scannerConfiguration\", such as selected profile and other scanner discovery settings, is not persisted, and thus the discovered paths are not recovered after reopening the project. Actually, CDT uses the wrong scanner discovery settings after reopening the project.\n\nThe create .cproject file:\n\n\u003c?xml version\u003d\"1.0\" encoding\u003d\"UTF-8\"?\u003e\n\u003c?fileVersion 4.0.0?\u003e\n\n\u003ccproject\u003e\n\u003cstorageModule moduleId\u003d\"org.eclipse.cdt.core.settings\"\u003e\n\u003ccconfiguration id\u003d\"org.eclipse.cdt.core.default.config.860343088\"\u003e\n\u003cstorageModule buildSystemId\u003d\"org.eclipse.cdt.core.defaultConfigDataProvider\" id\u003d\"org.eclipse.cdt.core.default.config.860343088\" moduleId\u003d\"org.eclipse.cdt.core.settings\" name\u003d\"Configuration\"\u003e\n\u003cexternalSettings/\u003e\n\u003cextensions\u003e\n\u003cextension id\u003d\"org.eclipse.cdt.core.PE\" point\u003d\"org.eclipse.cdt.core.BinaryParser\"/\u003e\n\u003cextension id\u003d\"org.eclipse.cdt.core.ELF\" point\u003d\"org.eclipse.cdt.core.BinaryParser\"/\u003e\n\u003c/extensions\u003e\n\u003c/storageModule\u003e\n\u003cstorageModule moduleId\u003d\"scannerConfiguration\"/\u003e\n\u003cstorageModule moduleId\u003d\"org.eclipse.cdt.core.pathentry\"\u003e\n\u003cpathentry kind\u003d\"con\" path\u003d\"org.eclipse.cdt.make.core.DISCOVERED_SCANNER_INFO\"/\u003e\n\u003c/storageModule\u003e\n\u003c/cconfiguration\u003e\n\u003c/storageModule\u003e\n\u003c/cproject\u003e\n\nAs opposed to that, for all CDT projects all profiles and settings are stored in the scannerConfiguration storage module section of .cproject:\n\n\u003cstorageModule moduleId\u003d\"scannerConfiguration\"\u003e\n\u003cautodiscovery enabled\u003d\"true\" problemReportingEnabled\u003d\"true\" selectedProfileId\u003d\"org.eclipse.cdt.make.core.GCCStandardMakePerProjectProfile\"/\u003e\n\u003cprofile id\u003d\"com.windriver.ide.staticanalysis.core.WRStandardMakePerFileProfile\"\u003e\n\u003cbuildOutputProvider\u003e\n\u003copenAction enabled\u003d\"true\" filePath\u003d\"\"/\u003e\n\u003cparser enabled\u003d\"true\"/\u003e\n\u003c/buildOutputProvider\u003e\n\u003cscannerInfoProvider id\u003d\"compilerBuiltinProvider\"\u003e\n\u003crunAction arguments\u003d\"\" command\u003d\"\" useDefault\u003d\"true\"/\u003e\n\u003cparser enabled\u003d\"true\"/\u003e\n\u003c/scannerInfoProvider\u003e\n\u003c/profile\u003e\n...\n\nI think I need to write a test case for that.\n\n\n",
    "(In reply to comment #19)\nHi Gerhard,\n\n\u003e I think I need to write a test case for that.\nYes, the set-case would definitely help. It would be good if you could provide it as soon as possible in case you need this bug to be fixed for the M6.\n\nThanks,\nMikhail\n",
    "Created an attachment (id\u003d62070)\nScanner discovery test case for default project setup\n\nThis is a test case for the way we are using CDT (default project setup, no build configuration). The CCommandDSC is needed for resolving discovered command settings.",
    "(In reply to comment #21)\nI\u0027ve got all three ScannerConfigDiscoveryTests passing for me with the latest sources from HEAD.\nHow should I run a tests to see the issue?\nI\u0027ve noticed there is a commented project.close() project.open() in the testGetCCompilerBuiltinsExt. Should I uncomment it?\n\nMikhail",
    "Hi!\n\nYes, actually the project close and reopen should be uncommented. I realized that they were commented right after I sent the patch, but I was in a conference call then and I had no chance to chenge it. (I just commented the lines in order to check that the test runs basically)\n\nPlease uncomment those two line.\n",
    "Of course, you can give the test case a reasonable name, if you like.",
    "Thanks, Gerhard!\n\nI\u0027ve fixed the problem with the scanner info setting serialization now.\nThe test now passes.\n\nPlease update and let me know whether the serialization works correctly for you now.\n\nMikhail\n\nP.S. NOTE FYI: please double check your scanner info settings initialization! I had to add some checks for null in data serialization in order to avoid NPEs caused by that several fields in the Scanner Config Info2 settings were null. I also saw the same failures of your test when using the CDT prior the New Project Model check-in and it seems that the settings logic does not assume that some fields can be null.",
    "Thanks a lot. It seems to solve this issue. Could you please check the test case into CVS?\n\nHow can I find NPEs? I do not see/did not see any NPEs. Do I have to enable tracing or anything else?",
    "(In reply to comment #26)\n\u003e Thanks a lot. It seems to solve this issue. Could you please check the test\n\u003e case into CVS?\nI can do this. Can I skip the CCommandDSC command changes you\u0027ve made for now?\n\n\u003e How can I find NPEs? I do not see/did not see any NPEs. Do I have to enable\n\u003e tracing or anything else?\nI\u0027ve committed several checks for null in the ScannerConfigInfoFactory2 (see the diff for the two latest ScannerConfigInfoFactory2.java versions for the list of null ckecks Ive added), so you won\u0027t see them and the serialization seems to work fine for your code now.\nThe only thing I\u0027m warried about is that since the checks were not there initially it might be expected by some other functionality that those ScannerConfigInfoFactory2 settings can not be null.\n\nMikhail",
    "As I can see the only thing left to be done for this bug is the serialization of some discovered scanner info settings within the project.\nThis definitely will not be done for the 4.0 since it requires changes in the discovery mechanism architecture.\nI am also not sure we need to do this at all (see my Comment# 3 for detail).\n\nI\u0027ll re-target the bug to the future and assign to the default inbox for the future discussions for now.\n\nThanks,\nMikhail",
    "Updating summary to more reflect the bug intent..",
    "Future means you commit to fix it in the Future. Inboxes can\u0027t make committments. Moving to \u0027--\u0027."
  ],
  "commentCreationDates": [
    "2007-03-18T17:21:43+01:00",
    "2007-03-19T09:05:47+01:00",
    "2007-03-19T15:18:26+01:00",
    "2007-03-19T15:29:35+01:00",
    "2007-03-19T16:05:16+01:00",
    "2007-03-19T16:20:30+01:00",
    "2007-03-19T16:55:00+01:00",
    "2007-03-19T17:30:26+01:00",
    "2007-03-20T16:00:49+01:00",
    "2007-03-20T16:20:32+01:00",
    "2007-03-20T16:38:40+01:00",
    "2007-03-20T17:14:17+01:00",
    "2007-03-20T17:52:29+01:00",
    "2007-03-21T10:05:06+01:00",
    "2007-03-21T10:35:37+01:00",
    "2007-03-21T10:41:50+01:00",
    "2007-03-22T21:36:40+01:00",
    "2007-03-23T09:53:29+01:00",
    "2007-03-26T12:13:56+02:00",
    "2007-03-26T17:26:17+02:00",
    "2007-03-26T17:34:13+02:00",
    "2007-03-27T12:59:08+02:00",
    "2007-03-27T13:27:19+02:00",
    "2007-03-27T14:27:26+02:00",
    "2007-03-27T14:28:52+02:00",
    "2007-03-27T15:38:09+02:00",
    "2007-03-27T16:26:22+02:00",
    "2007-03-27T16:37:44+02:00",
    "2007-03-27T16:46:24+02:00",
    "2007-03-27T16:51:26+02:00",
    "2007-08-21T17:00:39+02:00"
  ],
  "traces": [
    {
      "exceptionType": "junit.framework.AssertionFailedError",
      "message": "Expecting 5 pathentries",
      "elements": [
        {
          "method": "junit.framework.Assert.fail",
          "source": "Assert.java:47"
        },
        {
          "method": "junit.framework.Assert.assertTrue",
          "source": "Assert.java:20"
        },
        {
          "method": "org.eclipse.cdt.core.model.tests.CPathEntryTest.testCPathEntries",
          "source": "CPathEntryTest.java:157"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:585"
        },
        {
          "method": "junit.framework.TestCase.runTest",
          "source": "TestCase.java:164"
        },
        {
          "method": "junit.framework.TestCase.runBare",
          "source": "TestCase.java:130"
        },
        {
          "method": "junit.framework.TestResult$1.protect",
          "source": "TestResult.java:106"
        },
        {
          "method": "junit.framework.TestResult.runProtected",
          "source": "TestResult.java:124"
        },
        {
          "method": "junit.framework.TestResult.run",
          "source": "TestResult.java:109"
        },
        {
          "method": "junit.framework.TestCase.run",
          "source": "TestCase.java:120"
        },
        {
          "method": "junit.framework.TestSuite.runTest",
          "source": "TestSuite.java:230"
        },
        {
          "method": "junit.framework.TestSuite.run",
          "source": "TestSuite.java:225"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run",
          "source": "JUnit3TestReference.java:130"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.TestExecution.run",
          "source": "TestExecution.java:38"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:460"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests",
          "source": "RemoteTestRunner.java:673"
        },
        {
          "method": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run",
          "source": "RemoteTestRunner.java:386"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main",
          "source": "RemotePluginTestRunner.java:58"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.UITestApplication$1.run",
          "source": "UITestApplication.java:122"
        },
        {
          "method": "org.eclipse.swt.widgets.RunnableLock.run",
          "source": "RunnableLock.java:35"
        },
        {
          "method": "org.eclipse.swt.widgets.Synchronizer.runAsyncMessages",
          "source": "Synchronizer.java:123"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runAsyncMessages",
          "source": "Display.java:3467"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:3107"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:2264"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:2228"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.access$4",
          "source": "Workbench.java:2103"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench$4.run",
          "source": "Workbench.java:457"
        },
        {
          "method": "org.eclipse.core.databinding.observable.Realm.runWithDefault",
          "source": "Realm.java:289"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:452"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:149"
        },
        {
          "method": "org.eclipse.ui.internal.ide.application.IDEApplication.start",
          "source": "IDEApplication.java:101"
        },
        {
          "method": "org.eclipse.pde.internal.junit.runtime.UITestApplication.start",
          "source": "UITestApplication.java:52"
        },
        {
          "method": "org.eclipse.equinox.internal.app.EclipseAppHandle.run",
          "source": "EclipseAppHandle.java:146"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication",
          "source": "EclipseAppLauncher.java:106"
        },
        {
          "method": "org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start",
          "source": "EclipseAppLauncher.java:76"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:354"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:169"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:585"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.invokeFramework",
          "source": "Main.java:476"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.basicRun",
          "source": "Main.java:416"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.run",
          "source": "Main.java:1124"
        },
        {
          "method": "org.eclipse.equinox.launcher.Main.main",
          "source": "Main.java:1099"
        }
      ],
      "number": 0,
      "commentIndex": 16,
      "bugId": "177940",
      "date": "2007-03-22T21:36:40+01:00",
      "product": "CDT",
      "component": "cdt-core",
      "severity": "normal"
    }
  ],
  "groupId": "177940",
  "bugId": "177940",
  "date": "2007-03-18T17:21:43+01:00",
  "product": "CDT",
  "component": "cdt-core",
  "severity": "normal"
}