{
  "comments": [
    "Here is the test case:\n[public class T {\n\npublic void save() {\n        int a \u003d 3;\n        try {\n            Object warnings \u003d null;\n            try {\n                Object contexts \u003d null;\n                try {\n                    System.out.println(warnings);\n\t\t\t\t\treturn;\n                } catch (NullPointerException npe) {\n\t\t\t\t\tSystem.out.println(contexts);\n                    return;\n                }\n            } catch (Exception e) {\n                return;\n            }\n        } finally {\n            int b \u003d 4;\n            System.out.println(\"#save -\u003e \" + b + a);\n        }\n    }\n}]\n\n\tIf you compile this code using the Eclipse compiler and then run it using this VM:\njava version \"1.3.0\"\nJava(TM) 2 Runtime Environment, Standard Edition (build 1.3.0)\nClassic VM (build 1.3.0, J2RE 1.3.0 IBM build cn130-20000622 (JIT enabled: jitc))\n\n\tYou will get this error in the console:\njava.lang.VerifyError: (class: T, method: save signature: ()V) Localvariable 4 contains wrong type\n        at java.lang.Class.forName1(Native Method)\n        at java.lang.Class.forName(Class.java:134)\n        at Test.main(Test.java:5)\n\nIf you change the code with:\n[public class T {\n\npublic void save() {\n        int a \u003d 3;\n        try {\n            Object warnings \u003d null;\n            try {\n                Object contexts \u003d null;\n\t\t\t\tSystem.out.println(contexts);\n                try {\n                    System.out.println(warnings);\n\t\t\t\t\treturn;\n                } catch (NullPointerException npe) {\n                    return;\n                }\n            } catch (Exception e) {\n                return;\n            }\n        } finally {\n            int b \u003d 4;\n            System.out.println(\"#save -\u003e \" + b + a);\n        }\n    }\n}]\n\n\tThe only difference is the location of the line: System.out.println(contexts); then you don\u0027t have a problem anymore.\n\n\tThe bytecodes generated in the first case are:\n\nMethod void save()\n   0 iconst_3\n   1 istore_1\n   2 aconst_null\n   3 astore_3\n   4 aconst_null\n   5 astore 4\n   7 getstatic #20 \u003cField java.io.PrintStream out\u003e\n  10 aload_3\n  11 invokevirtual #26 \u003cMethod void println(java.lang.Object)\u003e\n  14 jsr 44\n  17 return\n  18 astore 5\n  20 getstatic #20 \u003cField java.io.PrintStream out\u003e\n  23 aload 4\n  25 invokevirtual #26 \u003cMethod void println(java.lang.Object)\u003e\n  28 jsr 44\n  31 return\n  32 astore 4\n  34 jsr 44\n  37 return\n  38 astore_3\n  39 jsr 44\n  42 aload_3\n  43 athrow\n  44 astore_2\n  45 iconst_4\n  46 istore 4\n  48 getstatic #20 \u003cField java.io.PrintStream out\u003e\n  51 new #28 \u003cClass java.lang.StringBuffer\u003e\n  54 dup\n  55 ldc #30 \u003cString \"#save -\u003e \"\u003e\n  57 invokespecial #33 \u003cMethod java.lang.StringBuffer(java.lang.String)\u003e\n  60 iload 4\n  62 invokevirtual #37 \u003cMethod java.lang.StringBuffer append(int)\u003e\n  65 iload_1\n  66 invokevirtual #37 \u003cMethod java.lang.StringBuffer append(int)\u003e\n  69 invokevirtual #41 \u003cMethod java.lang.String toString()\u003e\n  72 invokevirtual #43 \u003cMethod void println(java.lang.String)\u003e\n  75 ret 2\nException table:\n   from   to  target type\n     7    18    18   \u003cClass java.lang.NullPointerException\u003e\n     4    32    32   \u003cClass java.lang.Exception\u003e\n     2    38    38   any\n\nIn the second case we got:\nMethod void save()\n   0 iconst_3\n   1 istore_1\n   2 aconst_null\n   3 astore_3\n   4 aconst_null\n   5 astore 4\n   7 getstatic #20 \u003cField java.io.PrintStream out\u003e\n  10 aload 4\n  12 invokevirtual #26 \u003cMethod void println(java.lang.Object)\u003e\n  15 getstatic #20 \u003cField java.io.PrintStream out\u003e\n  18 aload_3\n  19 invokevirtual #26 \u003cMethod void println(java.lang.Object)\u003e\n  22 jsr 44\n  25 return\n  26 astore 5\n  28 jsr 44\n  31 return\n  32 astore 4\n  34 jsr 44\n  37 return\n  38 astore_3\n  39 jsr 44\n  42 aload_3\n  43 athrow\n  44 astore_2\n  45 iconst_4\n  46 istore 4\n  48 getstatic #20 \u003cField java.io.PrintStream out\u003e\n  51 new #28 \u003cClass java.lang.StringBuffer\u003e\n  54 dup\n  55 ldc #30 \u003cString \"#save -\u003e \"\u003e\n  57 invokespecial #33 \u003cMethod java.lang.StringBuffer(java.lang.String)\u003e\n  60 iload 4\n  62 invokevirtual #37 \u003cMethod java.lang.StringBuffer append(int)\u003e\n  65 iload_1\n  66 invokevirtual #37 \u003cMethod java.lang.StringBuffer append(int)\u003e\n  69 invokevirtual #41 \u003cMethod java.lang.String toString()\u003e\n  72 invokevirtual #43 \u003cMethod void println(java.lang.String)\u003e\n  75 ret 2\nException table:\n   from   to  target type\n    15    26    26   \u003cClass java.lang.NullPointerException\u003e\n     4    32    32   \u003cClass java.lang.Exception\u003e\n     2    38    38   any\n\n\n\tThe only difference I found relevant is that in the first case there is a aload4 bytecode after a jsr. In the second case the local 4 is never used outside the subroutine \n\tafter the first jsr call at 22. That seems to be the problem. After the first jsr call at 14 in the failing case, there is a load of the local 4. The reason seems to be that the local array used\n\tin the subroutine is reused when the subroutine returns. Then the slot 4 is already used by a local of a different type (an int in the subroutine).\n\n\tThe Sun VM 1.2.2 (java version \"1.2.2\" Classic VM (build JDK-1.2.2-001, native threads, symcjit)) has the same VerifyError.\n\nNOTES:\n\nOT (15/05/2001 3:25:12 PM)\n\tOne way to fix it would be to use a different slot for the local inside the subroutine.\n\tjavac 1.2.2 produces the following bytecodes for the first case:\n\nMethod void save()\n   0 iconst_3\n   1 istore_1\n   2 aconst_null\n   3 astore 4\n   5 aconst_null\n   6 astore 5\n   8 getstatic #12 \u003cField java.io.PrintStream out\u003e\n  11 aload 4\n  13 invokevirtual #13 \u003cMethod void println(java.lang.Object)\u003e\n  16 jsr 44\n  19 return\n  20 pop\n  21 getstatic #12 \u003cField java.io.PrintStream out\u003e\n  24 aload 5\n  26 invokevirtual #13 \u003cMethod void println(java.lang.Object)\u003e\n  29 jsr 44\n  32 return\n  33 pop\n  34 jsr 44\n  37 return\n  38 astore_2\n  39 jsr 44\n  42 aload_2\n  43 athrow\n  44 astore_3\n  45 iconst_4\n  46 istore 4\n  48 getstatic #12 \u003cField java.io.PrintStream out\u003e\n  51 new #7 \u003cClass java.lang.StringBuffer\u003e\n  54 dup\n  55 ldc #1 \u003cString \"#save -\u003e \"\u003e\n  57 invokespecial #10 \u003cMethod java.lang.StringBuffer(java.lang.String)\u003e\n  60 iload 4\n  62 invokevirtual #11 \u003cMethod java.lang.StringBuffer append(int)\u003e\n  65 iload_1\n  66 invokevirtual #11 \u003cMethod java.lang.StringBuffer append(int)\u003e\n  69 invokevirtual #15 \u003cMethod java.lang.String toString()\u003e\n  72 invokevirtual #14 \u003cMethod void println(java.lang.String)\u003e\n  75 ret 3\nException table:\n   from   to  target type\n     8    20    20   \u003cClass java.lang.NullPointerException\u003e\n     5    33    33   \u003cClass java.lang.Exception\u003e\n     2    38    38   any\n\nYou can notice that the local used inside the subroutine is not the same than the one used for the contexts variable (local 5). But if I change the code to be:\npublic class T {\n\npublic void save() {\n        int a \u003d 3;\n        try {\n            Object warnings \u003d null;\n            try {\n                Object contexts \u003d null;\n                try {\n                    System.out.println(warnings);\n\t\t\t\t\treturn;\n                } catch (NullPointerException npe) {\n\t\t\t\t\tSystem.out.println(contexts);\n                    System.out.println(warnings);\n                    return;\n                }\n            } catch (Exception e) {\n                return;\n            }\n        } finally {\n            int b \u003d 4;\n            System.out.println(\"#save -\u003e \" + b + a);\n        }\n    }\n}\n\n\tThen they produce:\nMethod void save()\n   0 iconst_3\n   1 istore_1\n   2 aconst_null\n   3 astore 4\n   5 aconst_null\n   6 astore 5\n   8 getstatic #12 \u003cField java.io.PrintStream out\u003e\n  11 aload 4\n  13 invokevirtual #13 \u003cMethod void println(java.lang.Object)\u003e\n  16 jsr 52\n  19 return\n  20 pop\n  21 getstatic #12 \u003cField java.io.PrintStream out\u003e\n  24 aload 5\n  26 invokevirtual #13 \u003cMethod void println(java.lang.Object)\u003e\n  29 getstatic #12 \u003cField java.io.PrintStream out\u003e\n  32 aload 4\n  34 invokevirtual #13 \u003cMethod void println(java.lang.Object)\u003e\n  37 jsr 52\n  40 return\n  41 pop\n  42 jsr 52\n  45 return\n  46 astore_2\n  47 jsr 52\n  50 aload_2\n  51 athrow\n  52 astore_3\n  53 iconst_4\n  54 istore 4\n  56 getstatic #12 \u003cField java.io.PrintStream out\u003e\n  59 new #7 \u003cClass java.lang.StringBuffer\u003e\n  62 dup\n  63 ldc #1 \u003cString \"#save -\u003e \"\u003e\n  65 invokespecial #10 \u003cMethod java.lang.StringBuffer(java.lang.String)\u003e\n  68 iload 4\n  70 invokevirtual #11 \u003cMethod java.lang.StringBuffer append(int)\u003e\n  73 iload_1\n  74 invokevirtual #11 \u003cMethod java.lang.StringBuffer append(int)\u003e\n  77 invokevirtual #15 \u003cMethod java.lang.String toString()\u003e\n  80 invokevirtual #14 \u003cMethod void println(java.lang.String)\u003e\n  83 ret 3\nException table:\n   from   to  target type\n     8    20    20   \u003cClass java.lang.NullPointerException\u003e\n     5    41    41   \u003cClass java.lang.Exception\u003e\n     2    46    46   any\n\n\tSo they have the same bug, aload 5 is done after the jsr call at 16.\n\tJavac (1.3) fixes the problem. They don\u0027t use the same local at all.\n\nMethod void save()\n   0 iconst_3\n   1 istore_1\n   2 aconst_null\n   3 astore_2\n   4 aconst_null\n   5 astore_3\n   6 getstatic #2 \u003cField java.io.PrintStream out\u003e\n   9 aload_2\n  10 invokevirtual #3 \u003cMethod void println(java.lang.Object)\u003e\n  13 jsr 50\n  16 return\n  17 astore 4\n  19 getstatic #2 \u003cField java.io.PrintStream out\u003e\n  22 aload_3\n  23 invokevirtual #3 \u003cMethod void println(java.lang.Object)\u003e\n  26 getstatic #2 \u003cField java.io.PrintStream out\u003e\n  29 aload_2\n  30 invokevirtual #3 \u003cMethod void println(java.lang.Object)\u003e\n  33 jsr 50\n  36 return\n  37 astore_3\n  38 jsr 50\n  41 return\n  42 astore 5\n  44 jsr 50\n  47 aload 5\n  49 athrow\n  50 astore 6\n  52 iconst_4\n  53 istore 7\n  55 getstatic #2 \u003cField java.io.PrintStream out\u003e\n  58 new #6 \u003cClass java.lang.StringBuffer\u003e\n  61 dup\n  62 invokespecial #7 \u003cMethod java.lang.StringBuffer()\u003e\n  65 ldc #8 \u003cString \"#save -\u003e \"\u003e\n  67 invokevirtual #9 \u003cMethod java.lang.StringBuffer append(java.lang.String)\u003e\n  70 iload 7\n  72 invokevirtual #10 \u003cMethod java.lang.StringBuffer append(int)\u003e\n  75 iload_1\n  76 invokevirtual #10 \u003cMethod java.lang.StringBuffer append(int)\u003e\n  79 invokevirtual #11 \u003cMethod java.lang.String toString()\u003e\n  82 invokevirtual #12 \u003cMethod void println(java.lang.String)\u003e\n  85 ret 6\nException table:\n   from   to  target type\n     6    17    17   \u003cClass java.lang.NullPointerException\u003e\n     4    37    37   \u003cClass java.lang.Exception\u003e\n     2    42    42   any\n\n\tThe local used in the subroutine is in the slot 7 which is not used for the first locals contexts and warnings.\n\nOT (15/05/2001 4:24:10 PM)\n\tI am not sure this is a bug in the code gen. I think it is a bug in the bytecode verifier, but like this is a bug in one of the Sun VM, we need to find a workaround.\n\tThe easiest way seems to do like in the javac 1.3 compiler: never reuse a slot for a local inside a subroutine.",
    "Finally block scope is now nested under the try block scope. Note that it does \nnot seem the catch blocks need the same. Added regression tests.\nFixed in 204.",
    "This fix was actually not good, and caused 4943 and 4919.\nNew fix is actually to specifically shift return addresses when assigning \npositions to local variables in scopes.\n\nReturn addresses are assigned positions at the end of the method.\n\nFix in build \u003e 204. Issued a patch204 for jdtcore.",
    "Fixed now",
    "PRODUCT VERSION:\n\t106\n\n"
  ],
  "commentCreationDates": [
    "2001-10-11T04:52:14+02:00",
    "2001-10-12T12:37:03+02:00",
    "2001-10-16T13:37:33+02:00",
    "2001-10-22T19:40:39+02:00",
    "2001-10-24T05:53:22+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.VerifyError",
      "message": "(class: T, method: save signature: ()V) Localvariable 4 contains wrong type",
      "elements": [
        {
          "method": "java.lang.Class.forName1",
          "source": "Native Method"
        },
        {
          "method": "java.lang.Class.forName",
          "source": "Class.java:134"
        },
        {
          "method": "Test.main",
          "source": "Test.java:5"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "3264",
      "date": "2001-10-11T04:52:14+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "3264",
  "bugId": "3264",
  "date": "2001-10-11T04:52:14+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}