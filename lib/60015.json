{
  "comments": [
    "(This is an incomplete bug report -- sorry no time not to further isolate.)\n\nRunning AJDT 1.1.6, I get dozens of these warnings:\n\n----------\nWarning does not match because declaring type is java.lang.Object, if match\ndesired use target(st.ata.mc.exim.DatastoreReader)\n[Xlint:unmatchedSuperTypeInCall] Blah.aj project/src/package/dir line 22\n----------\n\nfor something like this code:\n\n----------\nimport pack.Interface;\n...\npointcut dsrCall() : call(* Interface.*(..)); // WARNING HERE\n...\n----------\n\nEach warning points to the pointcut (not the join point shadow).\n\nNPE running from the command-line with the latest tree (will attach).",
    "Created an attachment (id\u003d9980)\nCommand and NPE trace\n\nNPE running from the command-line with the current tree.",
    "Created an attachment (id\u003d9981)\ninitial attempt to reproduce\n\n.zip file with initial test case attempt that does not reproduce the bug but\ndoes reflect the basic structure of the code I\u0027m using (and can\u0027t submit).",
    "P2 for investigation as NPE",
    "Great!\nI put this line in bug 59596:\n\"I give up!  I can\u0027t create a minimal library equivalent to rt.jar that \n contains an unresolvable member - so I can\u0027t create a testcase in CVS\"\n\nIt turns out that any kind of lint warning would do for showing up the NPE \ncovered in bug 59596.  In this bug report Wes has shown another way to \ndemonstrate the same NPE, and I\u0027ve played about a bit with his code to create \na testcase.  The NPE is due to the same thing as in 59596 - we attempt to make \na source context when we don\u0027t have a compilation unit.  The source context we \nare trying to make is the one that gives us information like:\n\npublic static void main(Bananas[] args) {\n                        ^^^^^^^\n\nwhich highlights the area of the source at fault.\n\nThis means the fix for the 59596 NPE that I checked in yesterday covers this \nbug too.  The important requirement for surfacing this bug is that you are \nattempting to create a source context for something that came in as binary.  \nIn the case here we are attempting to attach a lint warning.\n\nI\u0027m going to attach the zip of my testcase setup.  The key difference between \nwhat Wes attached and what I have attached is that I\u0027ve moved the \nUnmatchedCallSupertype code so that it comes in as binary when we compile the \naspect.  (Incremental compilation is the other way it could come into the \nsystem in binary form, on the 2nd compile).  \nOh and I added the line:\n\n System.err.println(this.toString());\n\nto UnmatchedCallSupertype - this is what will cause the lint warning to \ntrigger.  Because toString() is declared on java.lang.Object but inherited by \ninterface ILib - this means a pointcut call(* ILib.*(..)) will warn you \nbecause toString() calls won\u0027t be matched even though you have said \u0027*\u0027 for \nthe method name.  Am I making sense?  I think thats whats happening.\n\nIf you unzip the attached zip and run:\n\najc -d out src\\*.java\n\najc -inpath out A.java\n\nYou get (with 1.2rc1):\n\njava.lang.NullPointerException\n        at \norg.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext\n(EclipseAdapterUtils.java:50)\n        at \norg.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation\n(EclipseAdapterUtils.java:120)\n        at \norg.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage\n(EclipseAdapterUtils.java:129)\n\nI\u0027ll attach the zip then follow up with more explanation ...\n",
    "Created an attachment (id\u003d9996)\nTestcase zip, shows NPE.\n",
    "But ... that is not quite the end of the story.\n\nWith the latest from HEAD which fixes the NPE, I can run that code from \n60015.zip and get:\n\nC:\\temp\\wes\\bugs2\\unmatchedCallSupertype\\A.java:6 warning does not match \nbecause declaring type is java.lang.Object, if match desired use target\n(lib.ILib) [Xlint:unmatchedSuperTypeInCall]\n(no source information available)\n\t\nsee also: UnmatchedCallSupertype.java:11\nsee also: C:\\temp\\wes\\bugs2\n\\unmatchedCallSupertype\\out\\UnmatchedCallSupertype.class\n1 warning\n\nThis is giving us all the information we need, but as Wes has noticed, AJDT is \nonly paying attention to the first source location (the pointcut definition).  \nThe new AJDT will need to support the notion of multiple locations for \nmessages.\n\nThe real problem though is if I compile all the source together:\n\najc A.java src\\*.java\n\nbecause that gives an entirely different message:\n\nC:\\temp\\wes\\bugs2\\unmatchedCallSupertype\\src\\UnmatchedCallSupertype.java:6 \nwarning does not match because declaring type is java.lang.Object, if match \ndesired use target(lib.ILib) [Xlint:unmatchedSuperTypeInCall]\npublic static void main(String[] args) {\n^^^^^^^^^^^^^^^^\n\t\n\tsee also: C:\\temp\\wes\\bugs2\n\\unmatchedCallSupertype\\src\\UnmatchedCallSupertype.java:11\n\n1 warning\n\nThe first location is wrong.  It points at line 6 of UnmatchedCallSupertype.  \nWhat it should say is line 6 of A.java (to match the other variant of the \nmessage).  And because that location is wrong, when it prints the source \ncontext out, it says:\n\npublic static void main(String[] args) {\n^^^^^^^^^^^^^^^^\n\nwhich is nonsense, line 6 of UnmatchedCallSupertype is nothing to do with the \npointcut or the shadow.  This is messy.  It is relatively straightforward to \nadjust the filename used in the 2nd message to be correct (A.java) but because \nthe error arose whilst processing shadows in UnmatchedCallSupertype then when \nthe logic goes looking through the compilation unit for the source context, it \nstill looks at line 6 in UnmatchedCallSupertype which is wrong.  We could swap \nthe locations, so the first argument of this lint warning is the shadow that \ndoesn\u0027t get matched.  But then I\u0027m not sure if the message still makes perfect \nsense.  let me try it...",
    "With the switch in locations, here is the output when doing an \u0027all source\u0027 \nbuild:\n\nC:\\temp\\wes\\bugs2\\unmatchedCallSupertype\\src\\UnmatchedCallSupertype.java:11 \nwarning does not match because declaring type is java.lang.Object, if match \ndesired use target(lib.ILib) [Xlint:unmatchedSuperTypeInCall]\nSystem.err.println(this.toString());\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\t\n\tsee also: C:\\temp\\wes\\bugs2\\unmatchedCallSupertype\\A.java:6\n\n(with a lovely correct source context, although maybe it could have just \nunderlined toString())\n\nAnd here is the output doing a \u0027binary input\u0027 build:\n\nUnmatchedCallSupertype.java:11 warning does not match because declaring type \nis java.lang.Object, if match desired use target(lib.ILib) \n[Xlint:unmatchedSuperTypeInCall]\n(no source information available)\n\t\n\tsee also: C:\\temp\\wes\\bugs2\\unmatchedCallSupertype\\A.java:6\n\tsee also: C:\\temp\\wes\\bugs2\n\\unmatchedCallSupertype\\out\\UnmatchedCallSupertype.class\n\nComments?  I\u0027ll attach the patch to create this alternative behavior.\n\nAt the time we create the lint warning we also have the actual shadow \nsignature, in this case:\n\n  method-call(java.lang.String java.lang.Object.toString())\n\nI wonder if something can be done with that to improve the message because \nfrom all the information above (including the source context), it would still \ntake some thinking to work out which shadow on that line wouldn\u0027t match.\n\nDoes anyone think I write too much in these bug reports?\n",
    "Created an attachment (id\u003d9997)\nPatch for the weaver that reverses source locations.\n",
    "(1) IMHO you don\u0027t write too much.  It\u0027s *very* helpful to understand and\nencouraging to see things dealt with in their messy complexity, and it raises\nthe bar for communications.\n\n(2) I am not sure I agree with the xlint message in this context. \n\n   warning does not match because declaring type \n   is java.lang.Object, if match desired use target(lib.ILib)\n\nIt sounds like we\u0027re saying that using the declaring type is\nrequired, when AFAIK it is not.\n\nI assume that (i.e., I thought it used to be that)\n\n  call(* Foo.*(..))\n\n(where Foo is defined) would result in picking out any call where the\ncompile-time type of the reference is a subtype of Foo, regardless of the\ndeclaring type of the method -- e.g.,\n\n  Foo foo \u003d null;\n  foo.toString();  // here, though toString declared by Object\n\ni.e., while the careful programmer can specify the declaring type, s/he might\nwant to specify a subtype and limit the calls accordingly.  (There is no\nrequirement to use the declaring type.  This was the suggested workaround before\nJava 1.4 compilers because earlier compilers were setting up the call site with\nthe declaring type of the method rather than the compile-time type of the\nreference.)\n\nWhich means that given\n\n  class Bar { void bar(){}}\n  class Foo extends Bar { void foo() {}}\n\n, the pointcut\n\n    call(* Foo.bar())\n\nwill not match the shadows\n\n   new Bar().bar()\n   ((Bar)(new Foo()).bar()\n\n, though\n\n    call(* Bar.bar())\n\nwould match the shadow\n\n   new Foo().bar()\n\n. \n\nThe problem with the type in call(* type.*()) is that people think it refers to\nthe object being pointed at, not the reference doing the pointing.  Which is why\n(I think?) we have an xlint warning for this:\n\n    call(* Bar.foo())\n    call(* Bar.unmatched())\n\nWhere the member is not defined on the reference type, this will never match,\neven though it could match if you did this (for some subtype of Bar):\n\n   target(Bar) \u0026\u0026 call(* foo())\n\nSo in the test case (2004-04-27 04:48), where lib.ILib is in fact defined on the\nclasspath and properly imported by the aspect, I see no reason to issue this\nwarning for any join point, and the before advice on call(* ILib.*(..)) in\nA.java should apply to this Client.java shadow:\n\n  new Lib().run();\n\n(And btw, I agree that the compile-time type of the reference is not the kind of\nthing that should matter to a programmer when writing aspects.  A small change\n(e.g., a perfectly safe cast) could result in the pointcut not matching any\nmore.  Nonetheless, I believe that\u0027s what the semantics say, and coupled with\ncast join points it could be quite useful.)\n\nSo back to when the warning (bug 41952) should be issued: it seems applicable\nwhen there is a literal method signature definitely matched and that method is\ndefined by a supertype.  Then either (a) at the specific method call join points\nwhere there is a reference with the compile-time type of a supertype causing the\npointcut not to match, the warning would be issued that the advice/pointcut is\nnot matching because of the specified type, and suggesting target instead; or\n(b) (once at the pointcut definition only) there should be a warning that it\nwon\u0027t pick out references even to that type if they have a compile-time type of\nsome supertype which is itself a subtype of the declaring type.  I personally\nprefer (b).",
    "What I\u0027ve just checked solves the basic annoyance of producing the warning for\nsomething like toString() that is inherited from Object when you have clearly\nspecified an interface.\n\nThis program used to produce the warning on the indicated line:\n  public void run();\n}\n\naspect P implements I {\n  public void run() { }\n\n  public static void main(String[]argv) {\n    aspectOf().run();\n    aspectOf().toString();  // XLINT WARNING HERE\n  }\n  before(): call(* I.*(..)) {}\n}\n\nBut with the fix, it doesnt.\n\nAJDTs ability to cope with messages that have multiple source locations\n(discussed in this bug) is being dealt with under bug 71059 and will be in AJDT\n1.1.12.  That makes me feel more comfortable about the fact that we are still\nproducing messages with locations that could be considered to be *the wrong way\nround*.",
    "Hi Wes,\n\nAre you ok if we close this bug now - I\u0027ve done as much as I currently plan to\ndo.  The original unhelpful warning no longer comes out.  You can download the\nmost recent development driver to test it out.\n\nthanks,\nAndy.",
    "Silence is consent!",
    "Fix released as part of AspectJ 1.2.1"
  ],
  "commentCreationDates": [
    "2004-04-26T22:49:10+02:00",
    "2004-04-26T22:50:30+02:00",
    "2004-04-26T22:51:56+02:00",
    "2004-04-26T22:52:49+02:00",
    "2004-04-27T10:42:51+02:00",
    "2004-04-27T10:48:06+02:00",
    "2004-04-27T11:25:55+02:00",
    "2004-04-27T11:46:46+02:00",
    "2004-04-27T12:05:32+02:00",
    "2004-04-27T14:14:18+02:00",
    "2004-08-03T17:06:37+02:00",
    "2004-08-11T15:36:58+02:00",
    "2004-08-11T18:40:40+02:00",
    "2004-10-21T10:31:44+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext",
          "source": "EclipseAdapterUtils.java:50"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation",
          "source": "EclipseAdapterUtils.java:120"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage",
          "source": "EclipseAdapterUtils.java:129"
        }
      ],
      "number": 0,
      "commentIndex": 4,
      "bugId": "60015",
      "date": "2004-04-27T10:42:51+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "60015",
  "bugId": "60015",
  "date": "2004-04-26T22:49:10+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}