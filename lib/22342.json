{
  "comments": [
    "Instantiating a javax.naming.InitialContext from a plugin causes the following \nexception:\n\njavax.naming.NoInitialContextException:\n    Cannot instantiate class: org.jnp.interfaces.NamingContextFactory.\n    Root exception is java.lang.ClassNotFoundException: \norg.jnp.interfaces.NamingContextFactory at java.net.URLClassLoader$1.run\n(URLClassLoader.java:198)\n\nThe missing class, org.jnp.interfaces.NamingContextFactory, is the JBoss \nsupplied ContextFactory. The jar file that supplies it is in the project and \nthe jar file is specfied as a requried runtime library in plugin.xml. To test \nthis I have instantiated a new class of this type directly in the same code \nthat attempts to create the IntitialContext and it is created okay.\n\nI also tested putting the jar file directly into $JAVA_HOME/jre/lib/ext and the \nInitialContext is then created okay. This ,however, is not a work around since \nit then starts to pull on a very long piece of string; a road to madness.\n\nI suspect that the cause of the problem lies in the fact that the \nIntitialContext is loaded initially into the System classloader, but that the \nJBoss classes required for it to load in my code are not visible to it from its \nclasspath.\n\nI have tested this on both W2K and Linux GTK2.\n\nJoel",
    "Created an attachment (id\u003d1830)\nTest case plugin to demonstrate the problem\n",
    "I have explored the problem and have come to the conclusion that it is caused \nby the fact that the InitialContext class is being loaded by the System class \nloader. Therefore when my plugin requests an InitialContext and the jndi \nproperties points to a class that is not in the classpath of the System loader \na ClassNoFound exception occurs.\n\nI have found a work around in my situation by using the Factory that would \nnormally be designated in the jndi properties directly in the code to \ninstatiate a factory. I then use this factory to boot strap the context.\n\nI have lowered the severity to normal since I have a working solution. I fact, \ndepending on ones point of view, this may not be even considered a bug. It \ndoes, however break *any* code that depends on using a property to designate \nits runtime type. Since this is a widely used programming model, it is \nproblematic that Eclipse throws a surprise into the works. At very least I \nwould like to see the behaviour documented, possibly an FAQ on this would be \nappropriate. If possible I think a solution that allows a plugin to \nspecifically request that a class that is already loaded in one of the parent \nloaders be reloaded into the context class loader. While this is not \ntransparent, it has the benefit of being safe.\n\nThanks,\nJoel",
    "It is specified Java behaviour that if class A tries to reference class B, the\nclass loader that loaded A will be used to load B.  Eclipse by design has a\nsegmented namespace, where each plugin has its own class loader.  The system\nclass path contains only the bootstrap jar (startup.jar).  Thus the system class\nloader is not able to see classes contained in the class paths of individual\nplugins.\n"
  ],
  "commentCreationDates": [
    "2002-08-11T22:33:58+02:00",
    "2002-08-12T12:42:17+02:00",
    "2002-08-14T20:18:46+02:00",
    "2005-01-04T22:17:31+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ClassNotFoundException",
      "message": "org.jnp.interfaces.NamingContextFactory",
      "elements": [
        {
          "method": "java.net.URLClassLoader$1.run",
          "source": "URLClassLoader.java:198"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "22342",
      "date": "2002-08-11T22:33:58+02:00",
      "product": "Platform",
      "component": "Resources",
      "severity": "normal"
    }
  ],
  "groupId": "22342",
  "bugId": "22342",
  "date": "2002-08-11T22:33:58+02:00",
  "product": "Platform",
  "component": "Resources",
  "severity": "normal"
}