{
  "comments": [
    "ValidatorDelegatesRegistry.getInstance() is not thread safe, which can lead to the following problem marker being attached to a new Dynamic Web Project.\n\nSeverity and Description\tPath\tResource\tLocation\tCreation Time\tId\nThe validator XML Schema Validator is a delegating validator but no delegate can found for it.\t\tTestWebApp\tUnknown\t1156951456253\t197\n\nAlso a \"strange\" (i.e. it has no message!?) entry appears in the Error Log.\n\nThis is fairly reproducible for me using current (08/30/2006) WTP source by creating a new Dynamic Web Project is a freshly started Eclipse session, i.e. getInstance() has yet to be called.  The problem behavior can be forced in a development environment by placing breakpoints at the following two lines in ValidatorDelegatesRegistry.getInstance():\n\nLine 47:  ValidatorDelegatesRegistryReader reader \u003d new...;\nLine 51:  return instance;\n\nStart the Eclipse application in debug and create a new Dynamic Web Project.  Both breakpoints should be hit on different threads.  Resume the thread at the \"return\" breakpoint, allowing it to proceed with an uninitialized instance, which leads to the problem and the error.  Then allow the other thread to resume.\n\nInitializing the ValidatorDelegatesRegistryReader with a local instance, and then setting the static instance after it is initialized works for me.  The registry gets read twice, but that\u0027s better that the current behavior.  I don\u0027t know what the deadlock risk would be if getInstance() was synchronized.\n\nI\u0027m leaving the Severity at \"normal\" because I don\u0027t see any ill effects beyond the annoying problem marker, but it could be upped because it\u0027s a \"quality\" issue.  Restarting Eclipse, closing and re-opening the project, and running validation won\u0027t get rid of the problem marker.  Cleaning the project is the only way I\u0027ve found so far to get the problem marker to go away.  Perhaps this would be sufficient justification to fix in WTP 1.5.1.",
    "Though I didn\u0027t see any ill effects during testing, a more in depth examination of the code reveals that the thread unsafe behavior extends to thread unsafe gets and puts on a HashMap, i.e. ValidatorDelegatesRegistry.delegatesByTarget.  The Javadoc for HashMap states that a HashMap *must* be externally synchronized if at least one of multiple threads can modify the HashMap.\n\nI have seen the effect of this kind of misuse with Sun\u0027s implementation of HashMap in Tomcat 5.0.x\u0027s session handling.  The get() can incorrectly return null if a put() is modifying the HashMap at the same time as the get().  Or worse, if the put() performs a resize of the HashMap, the get() can enter a tight endless loop effectively freezing the JVM.  This would require additional plug-ins contributing validationDelegates, but this isn\u0027t something WTP can control.  Runtimes other than Sun\u0027s may have different undesirable behavior.  Given this, I\u0027m raising the severity to \"critical\".  Please reconsider for WTP 1.5.1.",
    "Thanks for tracking this down Larry - it all makes more sense now. I also think we should try to get this fixed for 1.5.1  \n\nAs I wrote the initial contribution for this functionality I am willing to put some time into this. I am looking forward to any suggestions on how to safely fix this this late in 1.5.1.",
    "Created an attachment (id\u003d50593)\nPossible patch to avoid thread unsafe access to HashMap\n\nHere is my idea of a patch.  Since what is being loaded is fixed, i.e. is Eclipse registry data, reading it mulitple times and instantiating multiple initial instances shouldn\u0027t be a problem since the returned HashMaps would be identical.  Last concurrent access wins and its instance gets kept for future use.  Not returning one that might still be undergoing initialization should avoid the bug.",
    "Valentin, any idea how often the \u0027getInstance()\u0027 would be called when say a project of XML Schemas is validated? ",
    "Created an attachment (id\u003d50602)\nanother possible patch for thread safe singleton\n\nThere\u0027s a common pattern recommended for thread safe singletons, that looks like code in this patch. Basically, you define another class that constructs the instance of the singleton, and that\u0027s assiged to a static variable, so .... the theory goes ... all is done during class loading and static initialization, and -- according to VM spec\u0027s -- during that phase one one thread can access it.\n\nWhile some complain this isn\u0027t lazy enough, that the singleton is created when the class is first loaded, the reality is, the counter argument goes, the class isn\u0027t loaded until used, and when used, the first thing anyone does is get the singleton ... so, its lazy enough, I\u0027ve read. \n\nAs for the rest ... all those unsafe HashMaps! :) ... right off, I suspect all those should be replaced by a SynchronoizedMap (see Collections.synchronizedMap and read its JavaDoc carefully ... you still need to \"synch\" on that instance). \n\nSo, I _think_ this proposed patch is a tiny bit safer than Larry\u0027s (sorry Larry :) but I\u0027m just putting it up there for comment. A google on \"java thread safe singletons\" would likely be an interesting read for all interested in this bug. \n\n",
    "Thanks David. Is it known whether this getInstance() could be called from some plug-in\u0027s startup code?  Not knowing, I was trying to avoid adding any synchronization in my patch for fear of introducing a potential deadlock (forgot to mention it\u0027s just a \"quick fix\" for 1.5.1).  After some of the other deadlock issues, I seem to be getting paranoid about this.:)  Perhaps someone more familiar with the code could comment on whether this risk is real or not.  As you point out, something better should be used for fixing WTP 2.0, if not 1.5.1.",
    "After further thought, I can\u0027t say for sure that there isn\u0027t deadlock potential in having multiple threads read the same registry entries.  Objects being instantiated could involve class loader locks, so my patch may be less safe  than David\u0027s, though it doesn\u0027t add any new synchronization directly.  I believe I\u0027ll take two aspirin and think about it in the morning.:)",
    "(In reply to comment #6)\n\u003e Thanks David. Is it known whether this getInstance() could be called from some\n\u003e plug-in\u0027s startup code?  \n\nThis is a good question and I was assuming not. Of course, either fix would be a problem if so, since nothing in startup code should call (directly or indirectly) \n\"create executable extension\". So, at a minimum, that should be check and documented in the \"getInstance\" method. \n\n\n",
    "A couple of other thoughts ... Larry, you marked this as \"critical\"? \nIs it really \"crashes, loss of data, severe memory leak\"? \nSeems more \"normal\" to me ... though guess some could argue \"major\". \n\nAlso see bug 158073. If, as in my patch, there is a possibility of exceptions being thrown during class loading/construction, then I think its all the more important to catch and log exceptions. I don\u0027t recall specifics, but I seem to recall that if that is not done, then an exception can be \"seen\" as simply a \"failure to load class\", which is often logged as \"class not found\" and it can be very hard to locate the source of the problem, if meaningful exceptions not logged. \n\n",
    "Hi David,\n\nTo be clear, the only reason I chose \"critical\" over \"major\" is that behavior of unsynchronized access to a HashMap under modification is undefined.  For the Sun JRE, this appears to cause an erroneous null to be returned by get(), which doesn\u0027t seem likely to lead to a \"critical\" malfunction.  However, I was reluctant to assume the same for other JDK\u0027s I\u0027m not familiar with.  That aspect of the issue could be addressed by using a synchronized Map, as you suggest.  Unfortunately, it wouldn\u0027t fix the behavioral aspect of the erroneous error that can get added to the project when the delegatesByTarget Map is used while it is being populated.  So far this is the only side effect I\u0027ve seen, but there could be others.\n\nI would rate the behavioral aspect of this issue as \"major\" due to the impact on the perceived quality of Web Tools.  For the side effect I\u0027ve seen, it\u0027s a bizarre error that happens intermittently, potentially once per Eclipse session.  Also, it requires a specific workaround (i.e. clean the project) to fix.  Closing and reopening the project doesn\u0027t fix it.  Restarting Eclipse also doesn\u0027t fix it and makes it possible for it to happen again.\n\nI don\u0027t recall seeing this error on my home system, but yesterday on my system at work I did a brief test where it happened 3 out of 4 times.  The error has only been raised once on the Web Tools newsgroup and Google is only showing one additional hit, last I checked.  It\u0027s hard to say how many would be impacted, but here at SAS, it appears we have the right type of system to encounter this (3.2GHZ CPU, 2GMem, WindowsXP) as both people assigned to test our plug-ins are also seeing this error.\n\nI don\u0027t have problem with not fixing the behavior in 1.5.1 if we can\u0027t find a patch we are comfortable about being safe.  If we can\u0027t find a way to protect the initialization of the delegatesByTarget Map with synchronization, then I be in favor of going with your suggestion to use a synchronized Map in 1.5.1 and try to fix the behavior in 1.5.2.",
    "Thanks for clarifying, Larry. It sounds like from your description then this should be changed to \"major\". And, my own view, is the unschronized map undefined behavior is not so scary as providing a \"half fix\" at this late date for 151. I think that _maight_ have some side effect that\u0027s not easy to predict and might make some other, even worse problem pop up. My suggestion would be to change to \u0027major\u0027, prepare a patch for the singleton safety, and a patch to log errors during initialization (bug 158073) and then also add synchronized maps and confirm none of this is called during plugin \u0027start\u0027 mehods and then provide all this real quick in the 1.5.2 stream so it can be tested for a number of weeks before formally releasing it. I\u0027m just paranoid of regressions when it comes to fixing thread issues \"at the last minute\". But, I agree, this area needs some quick attention. \n",
    "Changing to \"major\".  I don\u0027t think using a synchronized Map would carry any risk as the synchronization is all internal to the Map.  The timing between threads could be altered, but that timing can already occur, though randomly.  However, the code has been this way since 1.5 and we haven\u0027t seen this cause big problems, so it\u0027s probably a minor issue in the overall scheme.",
    "This is a rather long post, but please read as I am proposing an alternative fix at the end.\n\nFirst, thanks all for your valuable insight. A little bit of historical perspective: previously the validation framework invoked the validators synchronously, and later offered validators run as jobs. The delegating validator mechanism was implemented initially using IValidator and later were converted to implement IValidatorJob. This conversion did not take into account properly the multithreading issues introduced by running validators as jobs.\n\nI am going to try to answer some of the questions asked in previous posts.\n\n\u003e Larry: Also a \"strange\" (i.e. it has no message!?) entry appears in the Error Log.\n\nIt appears something fishy is going on here. If I follow your steps to force the error to happen I see the funny error in the log. If I then re-start Eclipse and check the log, the error log entry has a nice error message detailing what went wrong.\n\n*** ERROR ***: Thu Sep 21 10:32:32 EDT 2006    org.eclipse.wst.validation.internal.core.ValidationException: The validator XML Schema Validator is a delegating validator but no delegate can found for it.\nat org.eclipse.wst.validation.internal.delegates.DelegatingValidator.validateInJob(DelegatingValidator.java:231)\nat org.eclipse.wst.validation.internal.operations.ValidatorJob.run(ValidatorJob.java:70)\nat org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)\n\n\u003e Larry: Is it known whether this getInstance() could be called from some plug-in\u0027s startup code? \n\nI think it\u0027s highly unlikely getInstance is going to be called from another plug-in\u0027s startup code. The class is in an internal package and designed for the use of the validation framework only. Inside the validation framework core and UI this method is called here:\n\norg.eclipse.wst.validation.internal - validate - org.eclipse.wst.validation\n\tValidationConfiguration\n\t\tgetDelegateDescriptor(ValidatorMetaData)\n\tValidatorMetaData\n\t\tisDelegating()\n\t\tsetDefaultDelegates(ValidatorMetaData[]) (2 matches)\n\norg.eclipse.wst.validation.internal.ui - validateui - org.eclipse.wst.validation.ui\n\tDelegatingValidatorPreferencesDialog\n\t\tcreateDialogArea(Composite)\n\tDelegatesContentProvider\n\t\tgetElements(Object)\n\n\u003eCraig: any idea how often the \u0027getInstance()\u0027 would be called when say a\nproject of XML Schemas is validated? \n\nHere are the stack traces of the two threads accessing getInstance concurrently:\n\nThread [Worker-4] (Suspended (breakpoint at line 47 in ValidatorDelegatesRegistry))\t\n\tValidatorDelegatesRegistry.getInstance() line: 47\t\n\tGlobalConfiguration(ValidationConfiguration).getDelegateDescriptor(ValidatorMetaData) line: 1071\t\n\tProjectConfiguration.getDelegateDescriptor(ValidatorMetaData) line: 620\t\n\tWSDLDelegatingValidator(DelegatingValidator).validateInJob(IValidationContext, IReporter) line: 221\t\n\tValidatorJob.run(IProgressMonitor) line: 70\t\n\tWorker.run() line: 58\t\n\nThread [Worker-9] (Suspended (breakpoint at line 51 in ValidatorDelegatesRegistry))\t\n\tValidatorDelegatesRegistry.getInstance() line: 51\t\n\tGlobalConfiguration(ValidationConfiguration).getDelegateDescriptor(ValidatorMetaData) line: 1071\t\n\tProjectConfiguration.getDelegateDescriptor(ValidatorMetaData) line: 620\t\n\tXSDDelegatingValidator(DelegatingValidator).validateInJob(IValidationContext, IReporter) line: 221\t\n\tValidatorJob.run(IProgressMonitor) line: 70\t\n\tWorker.run() line: 58\t\n\nThe WSDL and XSD validator  (the only delegating validators we have so far) are racing to get their delegate from the registry.\n\n\nNow, based on my understanding of how the validation framework and the delegates work, and the fact that no piece of code other than the validation framework should deal with the delegates registry, I believe a simple and safe fix could be to try to load the delegates registry around the same time the validation framework is initializing its registry. In other words an early call to ValidatorDelegatesRegistry.getInstance() might do the trick, at least for 1.5.1. This call should happen before any validator is run. I\u0027ll try to locate where we could make this call.",
    "*** Bug 159053 has been marked as a duplicate of this bug. ***",
    "I agree with Valentin assessment that we should try to load the delegates registry around the same time the validation framework is initializing its registry.",
    "Created an attachment (id\u003d54684)\nProposed fix for 1.5.3\n\nLarry, David thanks for the valuable suggestions on properly synchronizing this code. However, IMHO, for 1.5.3 - and maybe even for the longer term - we could probably employ a simpler, hopefully \"safe enough\" solution.\n\nThe attached patch attempts to fix the issue by making the minimum amount of changes. It is based on the premise that the delegates registry is really a static data structure and it should be initialized only once: at the same time the validators registry is being initialized. This will take the delegates registry initialization out of the multithreading execution path (validator jobs).The fix also modifies the delegate validator descriptor to not cache the delegate instance, further minimizing the possibility of multithreading issues. This is in line with the validation framework approach which seems to create a validator instance every time a validator is invoked.\n\nI am trying to track down a dual core or dual CPU test machine so I can test this fix appropriately as I was not able to reproduce this issue on my work system unless I used the breakpoint approach. Until then Larry, since you\u0027ve reported that the scenario is easily reproducible on your system, I\u0027d appreciate it if you could please try out the patch and let me know if it fixes the problem. Any feedback from the other people \"listening in\" is appreciated. Hopefully this patch is acceptable and we will have enough time until we release 1.5.3 to test it well.",
    "From a practical standpoint, the 1.5.2 patch works for me.  Both ValidatorDelegatesRegistry.getInstance() and ValidationRegistryReader.getReader() tend to get synchronized behind the following static in ConfigurationConstants:\n\n    static ValidatorMetaData[] DEFAULT_ENABLED_VALIDATORS \u003d ValidationRegistryReader.getReader().getValidatorMetaDataArrayEnabledByDefault();\n\nConfigurationManager.getManager() isn\u0027t thread safe, but I\u0027m not seeing it hit on multiple threads in the project creation use case, nor others that I\u0027ve tried.  getManager()\u0027s window may be small enough to not be worth worrying about.\n\nI would say the patch would successfully avoid the Dynamic Web Application creation problem in WTP 1.5.3.  I haven\u0027t found any other use case that would exhibit a problem either.\n\n",
    "Oops, I should have said the 1.5.3 patch.",
    "Neeraj, I am reassigning to you as I can\u0027t commit code to your component. Please verify the patch and commit if all is OK. I\u0027d like us to put this fix in early to give it wide testing exposure before we release 1.5.3.",
    "Hi Chuck, as per our conversation, since Neeraj will be away for a little while, please assign to someone else in your team to review and commit this fix.",
    "Dropping to build",
    "I\u0027m no longer seeing this problem.",
    "closing"
  ],
  "commentCreationDates": [
    "2006-08-30T18:12:50+02:00",
    "2006-08-31T00:27:50+02:00",
    "2006-09-20T21:33:50+02:00",
    "2006-09-20T21:59:12+02:00",
    "2006-09-20T22:33:42+02:00",
    "2006-09-21T00:04:29+02:00",
    "2006-09-21T00:44:52+02:00",
    "2006-09-21T01:31:01+02:00",
    "2006-09-21T03:45:35+02:00",
    "2006-09-21T05:09:29+02:00",
    "2006-09-21T14:32:09+02:00",
    "2006-09-21T15:28:34+02:00",
    "2006-09-21T15:50:31+02:00",
    "2006-09-21T16:51:37+02:00",
    "2006-10-01T23:28:21+02:00",
    "2006-10-24T22:19:55+02:00",
    "2006-11-29T02:58:32+01:00",
    "2006-11-30T18:07:43+01:00",
    "2006-11-30T18:08:44+01:00",
    "2006-12-01T03:20:21+01:00",
    "2006-12-11T16:14:02+01:00",
    "2006-12-13T20:35:31+01:00",
    "2007-01-11T18:52:07+01:00",
    "2007-01-18T02:09:22+01:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.wst.validation.internal.core.ValidationException",
      "message": "The validator XML Schema Validator is a delegating validator but no delegate can found for it.",
      "elements": [
        {
          "method": "org.eclipse.wst.validation.internal.delegates.DelegatingValidator.validateInJob",
          "source": "DelegatingValidator.java:231"
        },
        {
          "method": "org.eclipse.wst.validation.internal.operations.ValidatorJob.run",
          "source": "ValidatorJob.java:70"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 0,
      "commentIndex": 13,
      "bugId": "155706",
      "date": "2006-09-21T16:51:37+02:00",
      "product": "Web Tools",
      "component": "wst.validation",
      "severity": "major"
    }
  ],
  "groupId": "155706",
  "bugId": "155706",
  "date": "2006-08-30T18:12:50+02:00",
  "product": "Web Tools",
  "component": "wst.validation",
  "severity": "major"
}