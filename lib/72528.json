{
  "comments": [
    "I have an aspect that captures around() a pcd and returns an Object[], though\nthe actual methods being instrumented might return any valid POJO array, i\nunderstand that AspectJ will take care of casting at assignment.\n\nI expected the following code to work properly, but at runtime i get a\njava.lang.VerifyError as shown below:\n\nF:\\wd\\Hello\u003eajbrowser HelloWorld.lst\njava.lang.VerifyError: (class: de/rohith/PrinterWorld, method: returnArrayWithCl\noning signature: ()[Ljava/lang/Integer;) Incompatible argument to function\n        at de.rohith.HelloWorld.main(HelloWorld.java:18)\nException in thread \"main\"\n\nI suspect the compiler fails to notice the return types of the methods being\ncaught at compile time.\n\nI have tested this code with both ajbrowser as well as AJDT, both result in the\nsame error output.\n\n-----------HelloWorldAspect.java---------------\npackage de.rohith;\n\nimport java.lang.Object;\n\npublic aspect HelloWorldAspect {\n    \n\tprivate int callDepth \u003d -1;\n\n    public HelloWorldAspect() {\n    }\n    \n    pointcut hello(): !within(HelloWorldAspect);\n    \n    pointcut method(): execution(public (*[]) de..*(..));\n    \n    pointcut cloning(): call(* java.lang.Object.clone());\n\n    declare warning: method() \u0026\u0026 hello(): \"*[] returning method called\" ;\n    \n    Object[] around(): cflow(method()) \u0026\u0026 cloning() \u0026\u0026 hello() {\n    \tprint(\"\", thisEnclosingJoinPointStaticPart);\n    \tObject[] ret \u003d proceed(); \n    \treturn (Object[])ret.clone();\n    }\n\n    private void print(String prefix, Object message) {\n        for (int i \u003d 0, spaces \u003d callDepth * 2; i \u003c spaces; i++) {\n            System.out.print(\" \");\n        }\n        System.out.println(prefix + message);\n    }\n\n}\n\n\n-----------PrinterWorld.java------------\npackage de.rohith;\npublic class PrinterWorld {\n\tprivate Integer[] intArray \u003d new Integer[2];\n\tpublic PrinterWorld() {\n\t\t\n\t}\n    public void print() {\n        System.out.println(\"Hello World!\"); \n    }\n    \n    public Integer returnInt() {\n    \treturn new Integer(3);\n    }\n    \n    public Integer[] returnArrayWithCloning() {\n    \tfor (int i \u003d 0; i \u003c intArray.length; i++) {\n\t\t\tintArray[i] \u003d new Integer(i++);\n\t\t}\n    \treturn (Integer[])intArray.clone();\n    }\n    \n    public Integer[] returnArrayWithoutCloning() {\n    \treturn intArray;\n    }\n}\n\n-----------HelloWorld.java------------\npackage de.rohith;\n\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n        PrinterWorld p \u003d new PrinterWorld();\n        p.print(); \n        Integer i \u003d p.returnInt();\n        Integer[] intArray \u003d p.returnArrayWithCloning();\n        Integer[] array2 \u003d p.returnArrayWithoutCloning();\n    }\n}",
    "Created an attachment (id\u003d14155)\nContains all the classes to reproduce this bug\n",
    "This is almost certainly related to the bug in the handling of [] in type \npatterns, as reported in bug 72531. Any verify error is serious and we will fix \nthis in the 1.2.1 release. I\u0027ll post to this bug report as soon as a fix is \navailable for download from the AspectJ download page.",
    "This turns out to be a really interesting bug. The problem is that in \n\u0027marshalling\u0027 the parameters to call the around body, ajc gets confused and \nthinks that the target of the call (the intArray) is a Foo, and generates a line \nof code of the form:\n\nFoo foo \u003d intArray;\n\nthis is what causes the verify error.\n\nThis is all wrapped up in the special treatment of array types and of the clone \nmethod. Note that clone() is redefined for an array type, to be public (you \ncan\u0027t just call clone on an arbitrary Object), and to return a shallow copy of \nthe array. But where does this special redefinition of the clone() method happen \n(in which type??). It\u0027s this unique combination of factors - a redefined method \non a \u0027special\u0027 type that is causing the confusion. I\u0027m off to spend some time \nreading in the JVM and JLS specs to see what they have to say on the topic \nbefore deciding on the right fix.... ",
    "JSL 10.7.....",
    "this is not the first time those magical JLS 10.7 array members cause trouble.\nWe\u0027re already special casing the length field somewhere (actually, it\u0027s \nmore special since it is represented in bytecode by the ARRAYLENGTH bytecode\nand not by a field at all).  \n",
    "related to Bug 67665 ",
    "I understand from JLS 10.7 that it is unclear what type represents an array type\nat runtime, but if this bug is related to Bug 67665 then i think the basic\nassumption that AspectJ supports all the Java types fails. According to JLS\n10.1, an array is a Java type. Another reason i would assume that arrays are\nsupported as types is in \"AspectJ 1.1 quick refernce\" among TypePat it clearly\nmentions that it accepts an array type.",
    "when I said it was related to Bug 67665, I meant that I raised\n_implementation_ issues of treatment of \n.length and .clone() there, and that there are some cleanup issues with\narray syntax there as well.  \n\nI don\u0027t think 10.7 is at all unclear about what types represent at runtime.\nArray types are types.  They have some methods and one field.  We need to \ncapture calls to those methods (and accesses and assignments to that field)\nas join points.  Nobody is talking about language changes here.  We\u0027re\ntalking about fixing a bug, and I noted that array treatment in general\nis a place where we\u0027ve had bugs before.",
    "Ok - fix checked in.  What I\u0027ve done is what we thought we\u0027d have to do.  When\nwe grab the target for a method-call shadow and we recognize it as being one of\nthese nasty clone calls on Object, I have a quick look before the shadow to see\nwhat the \u0027thing\u0027 is on the stack.  There are a number of possibilities (that I\nhave captured in the testcase), basically we might encounter:\n\n- a load instruction, in which case we ask the instruction what type it is\nworking with (querying the local variable tag) and this helps us work out that\nit is an array.\n\n- a field access instruction, in which case we ask the field what type it is.\n\n- a anewarray instruction, in which case we *know* its an array (although why\nanyone would write \u0027(Integer[])new Integer[5].clone()\u0027 I dont know!)\n\n- a multianewarray instruction, in which case *know* its an array.\n\nI\u0027ve put a lot of guards in so that we don\u0027t do this extra processing unless it\nmeets the criteria of being this nasty case.  It will also blow up if it\nencounters an instruction other than those expected when trying to determine the\nreal type of the target - if we didn\u0027t blow up then we would fail later at\nverify time.\n\nits a bit messy but I think it is quite a robust solution.",
    "I can\u0027t look at the code right now, but two reactions to the solution description:\n\n* the localVariable tag won\u0027t work at all if someone has stripped off debugging\ninformation.  Whatever solution we have should perhaps work better if we have\ndebugging info, but better not generate a bad classfile if we don\u0027t.\n\n* even if we\u0027re lucky enough to have debugging information, ?: can surprise you\n\n  ((testA ? exp0 : exp1) (testB ? exp2 : exp3) (testC ? exp4 : exp5)).clone()\n",
    "Hi Erik.  \nYes, I hadn\u0027t thought about them stripping that debug info off.  \nI just couldn\u0027t think of a nicer solution to this problem (unless we say\ncompiler restriction).  I believe that at least now we will fail at compile time\nrather than runtime.  Did you have a nicer fix in mind for this?  My first go\nwas to try and generate the code that looked like this:\n\npublic static final Object clone_aroundBody0(X x, Object y) {\n  if (y instanceof Object[]) {\n    return ((Object[])y).clone();\n  } else {\n    return y.clone();\n  }\n}\n\nbut that still fails verification because \u0027return y.clone()\u0027 exists in the bytecode.\n\nI then thought well - is the only time we will ever try and create a method like\nthis:\n\npublic static final Object clone_aroundBody0(Object y) {\n  return y.clone();\n}\n\nwhen the clone was originally on an array type.  If its true then in this case\nwe could always produce:\n\npublic static final Object[] clone_aroundBody0(Object[] y) {\n  return (Object[])y.clone();\n}\n\nbut I wasnt sure if that was one assumption too far?",
    "Yeah, I see your point.  The proposed solution we had was worse, too, since\n\n  ((Object) new int[3]) instanceof Object[]\n\nis false.  I\u0027m still worried about the fragility of this solution without\ndebugging info, but there it is.\n\nThis is exactly the case where a separate set of people working on the AspectJ\nsemantics might come up with a better solution that we could then steal if the\ncurrent one turns out to be too fragile in practice *grin*.\n\nWe should probably close this as fixed.\n",
    "I\u0027m going on holiday at the weekend for two weeks and want to write down my last\nminute thoughts on this bug so I don\u0027t forget them whilst I\u0027m in the Maldives. \nI may not get to finishing this bug off before I go.\n\nThe oxford guys didn\u0027t seem to think a 1.4 compiler should still be producing\nthe \u0027Object.clone()\u0027 bytecode, they seemed to think the one they are using is\nproducing the right \u0027\u003carraytype\u003e.clone()\u0027 bytecode.  I need to check if this is\nreally the case.  It could be a bug in the Eclipse compiler so I need to check\nit on SUN and IBM 1.4 compilers. (And check the polyglot compiler they use?)\n\nI do think my current solution will fail at compile time if we can\u0027t determine\nthe actual type on which clone() is called - but if there is no debug\ninformation I don\u0027t think it will fail in a nice way - it will fail with an NPE\nas I\u0027m assuming the local variable tag is found.  It should gracefully fail if\nthe tag is missing.\n",
    "not useful targetting 1.2.1",
    "not planning to do any more with this for now... basic verifyerror was fixed long ago."
  ],
  "commentCreationDates": [
    "2004-08-24T20:21:34+02:00",
    "2004-08-24T20:29:09+02:00",
    "2004-08-24T21:49:57+02:00",
    "2004-08-25T19:15:16+02:00",
    "2004-08-25T19:22:44+02:00",
    "2004-08-25T19:28:50+02:00",
    "2004-08-25T19:34:25+02:00",
    "2004-08-26T12:06:22+02:00",
    "2004-08-26T16:24:02+02:00",
    "2004-09-03T15:51:14+02:00",
    "2004-09-03T17:41:46+02:00",
    "2004-09-03T18:24:57+02:00",
    "2004-09-09T17:26:45+02:00",
    "2004-09-09T18:31:02+02:00",
    "2006-02-15T08:52:10+01:00",
    "2006-05-30T14:49:20+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.VerifyError",
      "message": "(class: de/rohith/PrinterWorld, method: returnArrayWithCl oning signature: ()[Ljava/lang/Integer;) Incompatible argument to function",
      "elements": [
        {
          "method": "de.rohith.HelloWorld.main",
          "source": "HelloWorld.java:18"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "72528",
      "date": "2004-08-24T20:21:34+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "72528",
  "bugId": "72528",
  "date": "2004-08-24T20:21:34+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}