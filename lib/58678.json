{
  "comments": [
    "I20040413\n\nRefactoring needs the ability to own a scheduling rule for an extended duration,\nbut be free to use that rule in multiple threads (UI thread, ModalContext\nthread). Essentially, it needs a scheduling rule that will prevent other\nbackground jobs from running, but will not prevent attempts to beginRule in any\nthreads.\n\nAlternatively, this could be solved by introducing the ability to turn off\n(queue but not execute) background jobs completely for a defined period of time.",
    "Dirk, I have released new API methods on IJobManager: suspend() will halt the\nexecution of all background jobs, and resume() will allow them to start again. \nThis does not affect jobs that are running at the time suspend() is called.  It\nwould need to be followed by a call to join to ensure that nothing is running:\n\nIJobManager jobMan \u003d Platform.getJobManager();\njobMan.suspend();\njobMan.join(null, progressMonitor);\n\n ... do the refactoring\n\njobMan.resume();\n\nTry this out and let me know if it works for you.  We are also considering using\nthis during platform startup to avoid background jobs from running before the UI\nhas appeared.",
    "MVM, I will attach a patch I made to IDE that makes use of this suspend/resume\nmechanism during startup.  It didn\u0027t have a significant performance impact for a\nnormal start, but it will help the cases where builds and other long operations\nare running during startup.  Unfortunately, many of the JDT background functions\n(search indexing, type caching), do not use the job manager so this will not\nhelp for those cases.",
    "Created an attachment (id\u003d9904)\nPatch to project org.eclipse.ui.ide\n\nThis suspends jobs until the workbench windows have been created.",
    "Type caching is triggered after Eclipse is fully running by syncing the all \ntypes cache with the event loop. John, have you seen cases where the case has \nbeen built before Eclipse was up and running ?",
    "and of course thanks for the new API.",
    "Dirk, I haven\u0027t seen that happening. I was just pointing out that suspend/resume\nonly works on background operations that use jobs.",
    "John,\n\nI tried the new API and have some questions: I was hoping that when I pass in \nthe null progress monitor (or null) I will get the same blocking dialog as I \ndo get if I call beginRule(...). But what happens is that the UI remains \ntotally active (I can even start another action) and no dialog appears.\n\nAnother think I notices is that the join method throws an \nInterruptedException. For me it is not clear when this happens since I never \ninterrupted the main thread ?",
    "Now I ended up in a situation where the join never finished. The last \nremaining job in the list which didn\u0027t go away was [0]\u003d \nImplicitJobs$ThreadJob  (id\u003d837848)\n\tacquireRule\u003d true\n\tflags\u003d 260\n\tjobNumber\u003d 13\n\tlastPush\u003d null\n\tlisteners\u003d null\n\tmonitor\u003d ProgressManager$JobMonitor  (id\u003d837852)\n\tname\u003d \"Implicit job\"\n\tnext\u003d null\n\tprevious\u003d null\n\tpriority\u003d 10\n\tproperties\u003d null\n\tqueued\u003d true\n\trealJob\u003d null\n\tresult\u003d Status  (id\u003d837860)\n\truleStack\u003d ISchedulingRule[2]  (id\u003d837864)\n\trunning\u003d true\n\tschedulingRule\u003d WorkspaceRoot  (id\u003d837868)\n\tstartTime\u003d -1\n\tthis$0\u003d ImplicitJobs  (id\u003d837784)\n\tthread\u003d Thread  (id\u003d837012)\n\ttop\u003d 0\n",
    "Re: comment #7 - I don\u0027t follow you, when you say, \"I pass in \nthe null progress monitor\", what API are you talking about? The join call?\n\nRe: InterruptedException - this is just a general pratice with blocking methods\nin Java.  Allowing interruption gives you a way to break out of the join call\nfrom another thread. If you don\u0027t want to respond to interruption, you can catch\nthe exception and join again:\n\nboolean repeat \u003d true;\nwhile (repeat) {\n\trepeat \u003d false;\n\ttry {\n\t\tjoin(...)\n\t} catch (InterruptedException e) {\n\t\t//ignore and loop\n\t\trepeat \u003d true;\n\t}\n}\n",
    "Dirk, I have realized a general problem with the suspend/resume API.  If threads\nblock while trying to acquire scheduling rules on resources outside of jobs\n(i.e., if they modify the workspace in the UI thread or a ModalContextThread),\nthis is handled by creating a fake (\"implicit\") job for that thread, and then\nblocking until the job starts. Of course if the job manager is suspended those\njobs will currently never start.  I am working on trying to make this work right\nnow.\n\nI think we should be prepared for the possibility of having to declare failure\non this API for 3.0. It is very late in the game to be playing with such a\npowerful new API.",
    "Dirk, I have fixed the problem with implicit jobs being created while the job\nmanager is suspended. These jobs will now always execute, even when the job\nmanager is suspended. You should load the latest runtime from HEAD and play\nagainst that (this may require loading the latest workbench as well).  I haven\u0027t\nyet gotten around to the other issue we discussed (blocked dialog during join,\ncalling suspend in a thread that is inside a beginRule/endRule pair).",
    "Dirk, I have made changes to IJobManager.join that will now cause it to open the\n\"blocked operation\" dialog during the join if you pass a null progress monitor.\nI have also added examples of IJobManager.join and suspend/resume to the\norg.eclipse.ui.examples.job project, if you want to play around with it to see\nhow it looks.",
    "John, I tested it, but it doesn\u0027t work. I think the reason is that I try to \njoin for all job families (I pass in null). This results in the fact that the \nUI job scheduled by BlockedJobsDialog will never run hence now progress \nmonitor will be shown. ",
    "I will investigate if I can workaround this problem.",
    "I am now able to pop-up the dialog, but it doesn\u0027t update progress since the \njob updating the progress monitor isn\u0027t running anymore. John, I think I \nsomehow need more control over which jobs get suspended. I will call you to \ndiscuss the issue.",
    "I have released new API: IJobManager#suspend(ISchedulingRule, IProgressMonitor)\nand #resume(ISchedulingRule). Rather than globally suspending all jobs, you now\nmust specify what scheduling rules you want to suspend. This will allow UI jobs\nand other updates to run. I have deprecated the old suspend/resume (and hope to\ndelete after this week\u0027s builds).",
    "UI should migrate to new suspend/resume methods, and use IWorkspaceRoot as the\nscheduling rule. This will still prevent builds and refreshes from happening\nduring startup, but will allow UI jobs to run.",
    "John, I tested the new API but it produces an exception. Here is what I do:\n\ntry {\n   manager.suspend(ResourcesPlugin.getWorkspace().getRoot(), null);\n   // do the actual operation. This one executes a runnable via\n   // IWorkspace.run(....);\n} finally {\n  manager.resume(ResourcesPlugin.getWorkspace().getRoot());\n}\n\nThe code above is executed in the UI thread, the runnable passed to \nIWorkspace.run is executed in the modal context thread. The exception is:\n\t\t\t\nCaused by: java.lang.IllegalArgumentException: endRule without matching \nbeginRule: R/\n\tat java.lang.Throwable.\u003cinit\u003e(Throwable.java)\n\tat java.lang.Throwable.\u003cinit\u003e(Throwable.java)\n\tat org.eclipse.core.internal.runtime.Assert.isLegal(Assert.java)\n\tat org.eclipse.core.internal.jobs.ImplicitJobs.end\n(ImplicitJobs.java:107)\n\tat org.eclipse.core.internal.jobs.JobManager.endRule\n(JobManager.java:430)\n\tat org.eclipse.core.internal.resources.WorkManager.checkOut\n(WorkManager.java:119)\n\tat org.eclipse.core.internal.resources.Workspace.endOperation\n(Workspace.java:896)\n\tat org.eclipse.core.internal.resources.Workspace.run\n(Workspace.java:1665)\n\tat org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run\n(WorkbenchRunnableAdapter.java:52)\n\tat org.eclipse.jface.operation.ModalContext$ModalContextThread.run\n(ModalContext.java:101)",
    "Dirk, I believe I have fixed this. Please try again. I now handle the case where\nbeginRule/endRule overlaps arbitrarily with suspend/resume, such as:\n\nUI Thread: suspend(root)\nUI Thread: begin(root)\nMarker view update: begin(root)\nUI Thread: end(root)\nUI Thread: resume(root)\nMarker view update: end(root)\n\nI had previously documented this as a limitation of the API, but since the user\nof suspend/resume has no control over activity in other threads, this wasn\u0027t a\nrealistic limitation.",
    "John, I tested it and I still see a deadlock. Here is what I do:\n\nUI thread: suspend(workspace)\nModal context: run operation taking workspace lock \u003c\u003d\u003d work fine\nUI thread: run operation taking workspace lock \u003c\u003d\u003d dead locks\n\nHere are the variable I have in the debugger.\n\nthis\u003d ThreadJob  (id\u003d836204)\n\tacquireRule\u003d true\n\tflags\u003d 256\n\tjobNumber\u003d 23\n\tlastPush\u003d null\n\tlisteners\u003d null\n\tmanager (ThreadJob)\u003d JobManager  (id\u003d836212)\n\tmonitor\u003d null\n\tname\u003d \"Implicit Job\"\n\tnext\u003d null\n\tprevious\u003d null\n\tpriority\u003d 10\n\tproperties\u003d null\n\trealJob\u003d null\n\tresult\u003d null\n\truleStack\u003d ISchedulingRule[2]  (id\u003d836376)\n\trunning\u003d false\n\tschedulingRule\u003d WorkManager$NotifyRule  (id\u003d836380)\n\tstartTime\u003d 0\n\tthread\u003d Thread  (id\u003d836116)\n\ttop\u003d 0\nmonitor\u003d EventLoopProgressMonitor  (id\u003d836344)\nblockingJob\u003d ThreadJob  (id\u003d836348)\n\tacquireRule\u003d true\n\tflags\u003d 260\n\tjobNumber\u003d 8\n\tlastPush\u003d null\n\tlisteners\u003d null\n\tmanager (ThreadJob)\u003d JobManager  (id\u003d836212)\n\tmonitor\u003d NullProgressMonitor  (id\u003d836396)\n\tname\u003d \"Implicit Job\"\n\tnext\u003d null\n\tprevious\u003d null\n\tpriority\u003d 10\n\tproperties\u003d null\n\trealJob\u003d null\n\tresult\u003d Status  (id\u003d836400)\n\truleStack\u003d ISchedulingRule[4]  (id\u003d836404)\n\trunning\u003d true\n\tschedulingRule\u003d WorkspaceRoot  (id\u003d836408)\n\tstartTime\u003d -1\n\tthread\u003d Thread  (id\u003d836116)\n\ttop\u003d 2",
    "Can you attach stack traces when it is deadlocked?",
    "John, here are the stack traces. What I noticed is that the progress view \nshows a Job \"Building Workspace Waiting\".\n\norg.eclipse.core.launcher.Main at localhost:2920\n\tThread [main] (Suspended)\n\t\tThreadJob(Object).wait(long, int) line: not available [native \nmethod]\n\t\tThreadJob(Object).wait(long) line: 223\n\t\tThreadJob.joinRun(IProgressMonitor) line: 159\n\t\tImplicitJobs.begin(ISchedulingRule, IProgressMonitor, boolean) \nline: 89\n\t\tJobManager.beginRule(ISchedulingRule, IProgressMonitor) line: \n167\n\t\tWorkManager.checkIn(ISchedulingRule, IProgressMonitor) line: 95\n\t\tWorkspace.prepareOperation(ISchedulingRule, IProgressMonitor) \nline: 1611\n\t\tWorkspace.checkpoint(boolean) line: 205\n\t\tPerformChangeOperation$1.run(IProgressMonitor) line: 215\n\t\tWorkspace.run(IWorkspaceRunnable, ISchedulingRule, int, \nIProgressMonitor) line: 1656\n\t\tWorkspace.run(IWorkspaceRunnable, IProgressMonitor) line: 1676\n\t\tPerformChangeOperation.executeChange(IProgressMonitor) line: \n264\n\t\tPerformChangeOperation.run(IProgressMonitor) line: 182\n\t\tWorkspace.run(IWorkspaceRunnable, ISchedulingRule, int, \nIProgressMonitor) line: 1656\n\t\tWorkbenchRunnableAdapter.run(IProgressMonitor) line: 52\n\t\tModalContext.runInCurrentThread(IRunnableWithProgress, \nIProgressMonitor) line: 302\n\t\tModalContext.run(IRunnableWithProgress, boolean, \nIProgressMonitor, Display) line: 252\n\t\tRefactoringWizardDialog2.run(boolean, boolean, \nIRunnableWithProgress) line: 278\n\t\tRenameTypeWizard(RefactoringWizard).internalPerformFinish\n(InternalAPI, PerformChangeOperation) line: 525\n\t\tRenameRefactoringWizard$1(UserInputWizardPage).performFinish() \nline: 151\n\t\tRenameTypeWizard(RefactoringWizard).performFinish() line: 591\n\t\tRefactoringWizardDialog2.okPressed() line: 402\n\t\tRefactoringWizardDialog2(Dialog).buttonPressed(int) line: 351\n\t\tDialog$2.widgetSelected(SelectionEvent) line: 491\n\t\tTypedListener.handleEvent(Event) line: 89\n\t\tEventTable.sendEvent(Event) line: 82\n\t\tButton(Widget).sendEvent(Event) line: 796\n\t\tDisplay.runDeferredEvents() line: 2594\n\t\tDisplay.readAndDispatch() line: 2272\n\t\tRefactoringWizardDialog2(Window).runEventLoop(Shell) line: 668\n\t\tRefactoringWizardDialog2(Window).open() line: 648\n\t\tRefactoringWizardOpenOperation.run(Shell, String) line: 121\n\t\tRefactoringStarter.activate(Refactoring, RefactoringWizard, \nShell, String, boolean) line: 40\n\t\tRenameUserInterfaceStarter(UserInterfaceStarter).activate\n(Refactoring, Shell, boolean) line: 54\n\t\tRenameUserInterfaceStarter.activate(Refactoring, Shell, \nboolean) line: 113\n\t\tRenameSupport.openDialog(Shell) line: 108\n\t\tRenameJavaElementAction.run(IJavaElement, RenameSupport) line: \n175\n\t\tRenameJavaElementAction.run(ITextSelection) line: 128\n\t\tRenameAction.run(ITextSelection) line: 127\n\t\tRenameAction(SelectionDispatchAction).dispatchRun(ISelection) \nline: 216\n\t\tRenameAction(SelectionDispatchAction).run() line: 188\n\t\tRenameAction(Action).runWithEvent(Event) line: 881\n\t\tActionContributionItem.handleWidgetSelection(Event, boolean) \nline: 612\n\t\tActionContributionItem.access$2(ActionContributionItem, Event, \nboolean) line: 563\n\t\tActionContributionItem$6.handleEvent(Event) line: 482\n\t\tEventTable.sendEvent(Event) line: 82\n\t\tMenuItem(Widget).sendEvent(Event) line: 796\n\t\tDisplay.runDeferredEvents() line: 2594\n\t\tDisplay.readAndDispatch() line: 2272\n\t\tWorkbench.runEventLoop(Window$IExceptionHandler, Display) \nline: 1353\n\t\tWorkbench.runUI() line: 1324\n\t\tWorkbench.createAndRunWorkbench(Display, WorkbenchAdvisor) \nline: 243\n\t\tPlatformUI.createAndRunWorkbench(Display, WorkbenchAdvisor) \nline: 140\n\t\tIDEApplication.run(Object) line: 90\n\t\tPlatformActivator$1.run(Object) line: 283\n\t\tEclipseStarter.run(Object) line: 242\n\t\tEclipseStarter.run(String[], Runnable) line: 119\n\t\tNativeMethodAccessorImpl.invoke0(Method, Object, Object[]) \nline: not available [native method]\n\t\tNativeMethodAccessorImpl.invoke(Object, Object[]) line: 79\n\t\tDelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 41\n\t\tMethod.invoke(Object, Object[]) line: 386\n\t\tMain.basicRun(String[]) line: 269\n\t\tMain.run(String[]) line: 700\n\t\tMain.main(String[]) line: 684\n\tThread [Framework Event Dispatcher] (Suspended)\n\t\tEventThread(Object).wait(long, int) line: not available \n[native method]\n\t\tEventThread(Object).wait() line: 193\n\t\tEventThread.getNextEvent() line: 149\n\t\tEventThread.run() line: 107\n\tThread [OSGi Console] (Suspended)\n\t\tObject.wait(long, int) line: not available [native method]\n\t\tObject.wait(long) line: 223\n\t\tFrameworkConsole.console() line: 258\n\t\tFrameworkConsole.console(String[]) line: 231\n\t\tFrameworkConsole.run() line: 206\n\t\tThread.run() line: 806\n\tThread [Start Level Event Dispatcher] (Suspended)\n\t\tEventThread(Object).wait(long, int) line: not available \n[native method]\n\t\tEventThread(Object).wait() line: 193\n\t\tEventThread.getNextEvent() line: 149\n\t\tEventThread.run() line: 107\n\tThread [Java indexing] (Suspended)\n\t\tIndexManager(Object).wait(long, int) line: not available \n[native method]\n\t\tIndexManager(Object).wait() line: 193\n\t\tIndexManager(JobManager).run() line: 323\n\t\tThread.run() line: 806\n\tThread [Worker-0] (Suspended)\n\t\tWorkerPool(Object).wait(long, int) line: not available [native \nmethod]\n\t\tWorkerPool(Object).wait(long) line: 223\n\t\tWorkerPool.sleep(long) line: 209\n\t\tWorkerPool.startJob(Worker) line: 236\n\t\tWorker.run() line: 59\n\tThread [Worker-1] (Suspended)\n\t\tWorkerPool(Object).wait(long, int) line: not available [native \nmethod]\n\t\tWorkerPool(Object).wait(long) line: 223\n\t\tWorkerPool.sleep(long) line: 209\n\t\tWorkerPool.startJob(Worker) line: 236\n\t\tWorker.run() line: 59\n\tThread [Worker-2] (Suspended)\n\t\tWorkerPool(Object).wait(long, int) line: not available [native \nmethod]\n\t\tWorkerPool(Object).wait(long) line: 223\n\t\tWorkerPool.sleep(long) line: 209\n\t\tWorkerPool.startJob(Worker) line: 236\n\t\tWorker.run() line: 59\n\tThread [Worker-3] (Suspended)\n\t\tWorkerPool(Object).wait(long, int) line: not available [native \nmethod]\n\t\tWorkerPool(Object).wait(long) line: 223\n\t\tWorkerPool.sleep(long) line: 209\n\t\tWorkerPool.startJob(Worker) line: 236\n\t\tWorker.run() line: 59\n\tThread [org.eclipse.jdt.internal.ui.text.JavaReconciler] (Suspended)\n\t\tDirtyRegionQueue(Object).wait(long, int) line: not available \n[native method]\n\t\tDirtyRegionQueue(Object).wait(long) line: 223\n\t\tAbstractReconciler$BackgroundThread.run() line: 161\n",
    "Dirk, I think I have discovered the problem. If you try to acquire a rule that\nis *contained* by the suspended rule, it would not allow you to obtain it. I.e.,\nif you suspend IWorkspaceRoot, I would not allow you to acquire any resource\nbelow the root.  I have released a fix to HEAD, so please try it. The\nsuspend/resume rule code is getting more and more complex!",
    "Dirk, how is this working for you now?",
    "John, I tested it and it looks OK so far. I will integrate the API at othe \nplaces as well tomorrow and will let you know if I discovered additional \nissues.",
    "John, in some case I now get a NPE when using the new suspend/resume API \ntogether with normal runnables. The stack trace of the NPE is:\n\nThread [Worker-1] (Suspended (exception NullPointerException))\n\tWorkspaceRoot(Resource).contains(ISchedulingRule) line: 440\n\tImplicitJobs.findThreadJob(Thread, ISchedulingRule) line: 116\n\tImplicitJobs.begin(ISchedulingRule, IProgressMonitor, boolean) line: 56\n\tJobManager.beginRule(ISchedulingRule, IProgressMonitor) line: 167\n\tWorkManager.checkIn(ISchedulingRule, IProgressMonitor) line: 95\n\tWorkspace.prepareOperation(ISchedulingRule, IProgressMonitor) line: \n1629\n\tWorkspace.run(IWorkspaceRunnable, ISchedulingRule, int, \nIProgressMonitor) line: 1669\n\tNotificationManager$NotifyJob.run(IProgressMonitor) line: 38\n\tWorker.run() line: 66\n\n",
    "Fixed.",
    "This should have been marked fixed awhile ago. The requested API was delivered\nin M9."
  ],
  "commentCreationDates": [
    "2004-04-15T17:55:44+02:00",
    "2004-04-23T20:18:07+02:00",
    "2004-04-23T20:20:00+02:00",
    "2004-04-23T20:20:41+02:00",
    "2004-04-26T00:06:21+02:00",
    "2004-04-26T00:06:40+02:00",
    "2004-04-26T16:34:50+02:00",
    "2004-04-28T13:09:35+02:00",
    "2004-04-28T14:09:14+02:00",
    "2004-04-28T16:40:57+02:00",
    "2004-04-28T16:50:17+02:00",
    "2004-04-28T23:35:08+02:00",
    "2004-04-30T22:40:22+02:00",
    "2004-05-03T14:48:04+02:00",
    "2004-05-03T14:48:27+02:00",
    "2004-05-03T15:11:13+02:00",
    "2004-05-04T01:31:41+02:00",
    "2004-05-04T01:47:58+02:00",
    "2004-05-04T16:39:25+02:00",
    "2004-05-05T21:06:59+02:00",
    "2004-05-06T14:46:11+02:00",
    "2004-05-06T18:36:58+02:00",
    "2004-05-06T19:26:59+02:00",
    "2004-05-08T00:23:55+02:00",
    "2004-05-11T00:06:43+02:00",
    "2004-05-11T00:11:48+02:00",
    "2004-05-11T14:36:24+02:00",
    "2004-05-11T17:22:22+02:00",
    "2004-05-31T22:52:19+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.IllegalArgumentException",
      "message": "endRule without matching  beginRule: R/",
      "elements": [
        {
          "method": "java.lang.Throwable.\u003cinit\u003e",
          "source": "Throwable.java"
        },
        {
          "method": "java.lang.Throwable.\u003cinit\u003e",
          "source": "Throwable.java"
        },
        {
          "method": "org.eclipse.core.internal.runtime.Assert.isLegal",
          "source": "Assert.java"
        },
        {
          "method": "org.eclipse.core.internal.jobs.ImplicitJobs.end",
          "source": "ImplicitJobs.java:107"
        },
        {
          "method": "org.eclipse.core.internal.jobs.JobManager.endRule",
          "source": "JobManager.java:430"
        },
        {
          "method": "org.eclipse.core.internal.resources.WorkManager.checkOut",
          "source": "WorkManager.java:119"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.endOperation",
          "source": "Workspace.java:896"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.run",
          "source": "Workspace.java:1665"
        },
        {
          "method": "org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run",
          "source": "WorkbenchRunnableAdapter.java:52"
        },
        {
          "method": "org.eclipse.jface.operation.ModalContext$ModalContextThread.run",
          "source": "ModalContext.java:101"
        }
      ],
      "number": 0,
      "commentIndex": 18,
      "bugId": "58678",
      "date": "2004-05-04T16:39:25+02:00",
      "product": "Platform",
      "component": "Resources",
      "severity": "normal"
    }
  ],
  "groupId": "58678",
  "bugId": "58678",
  "date": "2004-04-15T17:55:44+02:00",
  "product": "Platform",
  "component": "Resources",
  "severity": "normal"
}