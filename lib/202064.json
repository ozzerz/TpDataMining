{
  "comments": [
    "You know ... that you did allowed to the the following test.\n\nI created a LoadChunkRevisionRequest\nIt takes in parameters a list of CDOID.\nIt return a list of CDORevisionImpl.\n\nAfter we receive the list of CDOID from LoadChunkRequest I call\nLoadChunkRevisionRequest with the return list from LoadChunkRequest.\n\nI can go up to 5800 objects/ sec with that!! I was amazed!!!\n\nTest with referenceChunk at \n\n200- 5861 objects/sec\n300- 5827 objects / sec\n500 - 5727 objects / sec\n1000 - 5147 object/sec\n2000 - 4231 objects / sec \n\nPerformance should go faster as I increased referenceChunk .... Why we do not\nsee that ?.. Easy.. the first chunk of the collection we fetch... it is a list\nof CDOID. So it will not call LoadChunkRevision... More the refenceChunk is big\nmore we will fetch object sequentially for the first part...\nIf I change that (harcoded in the code to not fetch CDOID the first part).. I\ncan go up to 7500 objects / sec.. We should even go faster if instead of CDOID\nwe fetch directly the object.. (didn`t try it)\n\nAnyway we should take advantage of that.. don`t you think ? We can even have a\nthread that will fetch object by chunk...to provide objects to the main\nthread.. (to not block it) all the time. We can call it... SmartReadAhead\nThread !\n\n\nIn brief, if we can detect when we should load objects by chunk (like when we\niterate through collection) we can win big time!!!\n\nLet me know what you think !",
    "\nI created as a small prototype (and to see if it could be benefic), the SmartReadAdhead.\n\nBasically, I have one attribute SmartReadAhead per CDOViewImpl.\nEach time, the CDOStore.get is called I notify the smartreadahead before the call and after the call.\n\nThe goal here is to determine the difference between a end-user trigger.. and a process trigger. Normally, the process will trigger more event per seconds than the user. \n\nIf I show you this... you will probaly know where the user interact with the UI.\n\nX \u003d time \n\nREADBEFORE X+12\nREADAFTER X+12\n\nREADBEFORE X+12 \nREADAFTER X+15  \n\nREADBEFORE X+15\nREADAFTER X+16\n\n\u003c\u003c USER INTERACT HERE\n\nREADBEFORE X+25\nREADAFTER X+26\n\n\nIn the Before notification I calculate the time between .. the last readafter.\n\nIn this case... I will add a CDOFetchRule in the smartReadAhead.\nCDOFetchRule wll be sent to the server the next time I read something.\n\n\nMy test case is the following :\n\nI have a collection of PurchaseOrder. Each of them have an attribut Supplier and Order.\nMy process access my Supplier all the time. Doesn`t access Order.\n\nIn this case, my access from PurchaseOrder and Supplier will be detected... and will be added to the proxy rule.\n\nWithout the SmartReadAhead.. I was doing 1450 objects / secs\nAfter... 8080 objects/secs. I will try it at work tomorrow... But this simple rule seem to be very efficient and make sense as well.\n\n\n\nI only listen to event that have this property\n\nisReference and !isMany\n\nbecause we have already the mechanism to load in chunk for them...\n\nWhere do you think will be the best place to be able to hook up our stuff..\nLegacy wrapper doesn`t use CDOStore right ? But I think my feature will only be usable to them.. since the hook... is easier to do.\n\nComments?\n\n",
    "Generally we don\u0027t need to look at CDOLegacyImpl for new optimizations first.\nIf at all there are optimizations possible I\u0027ll investigate later.\n\nI\u0027d like to look at your patch before I can see if it\u0027s good.\nAt least the resulting numbers look good ;-)\n\nOriginally I had a completely asynchronous solution in mind, but let\u0027s see...",
    "(In reply to comment #2)\n\u003e Generally we don\u0027t need to look at CDOLegacyImpl for new optimizations first.\n\u003e If at all there are optimizations possible I\u0027ll investigate later.\n\u003e I\u0027d like to look at your patch before I can see if it\u0027s good.\n\u003e At least the resulting numbers look good ;-)\n\u003e Originally I had a completely asynchronous solution in mind, but let\u0027s see...\n\nI had also Asynchronously in mind...but since it is costly to do one fetch... I presume it will be more efficient to fetch objects in chunk... if possible.\n\n\nThis feature do not exclude the asyncrhonous one....\n",
    "Created an attachment (id\u003d77860)\nAnalyzer-Beta1\n\n\nHere the first version of my analyzer.\n\nThis analyzer can detect path that you would used base on time. At runtime.. it will create Cluster of feature to be fetch at the same time.\n\nThis analyzer is running in the same thread.\n\nCDOFeatureAnalyzer will find pattern. If it detect one it will add it to make it available to the rulemanager. \n\nRight now, it is working well for our model. \n\nWe have one analyzer per CDOView.\nCDORevisionmanagerImpl have a IFetchRuleManager.\n\nEach time you are doing a loadRevisionRequest it will ask the IFetchRuleManager rules for a id`s. In my case, I delegate that call to my current Analyzer.\n\nThe next things to do is the following :  we can detect the sequence of cluster of feature that we access.... and fetch them in another thread.(asynchronously). \nI don`t believe it will be benefits to do that strategy (readahead) objects/objects... It will go so fast.... that it is not worth it .... but by group!!! Oh yes.\n\nTo use it.. for now I create a \nCDORevisionManagerImpl.setFetchRuleManager(new CDOFeeatureRuleManager())\nand for each VIEW and setup to \nCDOViewImpl.setFetchFeatureAnalyzer(new CDOFeatureAnalyzer());\n\nNow I will work.. with the other thread to detect the sequence of cluster of fetchRule access.... and load objects in advance based on statistics...\n\nThat patch contains also 2 fixes.\n\nCDOStore.lookupAhead\nBEFORE\n      int toIndex \u003d Math.min(index + chunkSize - 1, list.size());\n      Set\u003cCDOID\u003e notRegistered \u003d new HashSet\u003cCDOID\u003e();\n      for (int i \u003d fromIndex; i \u003c\u003d toIndex; i++)\n\nAFTER (I changed 2 things)\n\u003e\u003e      int toIndex \u003d Math.min(index + chunkSize, list.size());\n        Set\u003cCDOID\u003e notRegistered \u003d new HashSet\u003cCDOID\u003e();\n\u003e\u003e      for (int i \u003d fromIndex; i \u003c toIndex; i++)\n\n\nAnother problem was in the client side\nCDORevisionResolver.TimeLine\n   @Override\n    public synchronized boolean add(CDORevisionImpl revision)\n    {\n      int version \u003d revision.getVersion();\n      ListIterator\u003cCDORevisionImpl\u003e it \u003d super.listIterator(0);\n      while (it.hasNext())\n      {\n        CDORevisionImpl r \u003d it.next();\n        int v \u003d r.getVersion();\n        if (v \u003d\u003d version)\n        {\n          // Could have more than 1 version of the same objects...\n\u003c\u003c\u003c\u003c\u003c          return false;\n\nBefore we were throwing exception. The LoadChunk that we did ... can introduce a problem.. (only in the client side)\n\nOn the server side.. maybe it make sense but not in the client side.\n\nThese 2 problems are not to fix something that I introduce with that patch... It is to fix things that was introduce with the load in chunk.\n\nLet me know what you think.\n\n   ",
    "Created an attachment (id\u003d77861)\nOops.. BETA 2\n\nForgot to recreate my patch before sending it.",
    "Refactored a bit an committed to CVS.\nHere some questions/comments:\n\nIs NOOPFetchRuleManager.getFetchRules(CDOID) a relict?\nIt\u0027s not part of the interface and it\u0027s not being called from anywhere.\n---\n\nCDOStore.get() calls preTraverseFeature() and postTraverseFeature().\nWouldn\u0027t it be better to pass \"revision\" instead of \"cdoObject.cdoRevision()\"?\nI\u0027m not very sure, but especially in the first case cdoObject.cdoRevision() could return null.\nThis is why getRevisionForReading(cdoObject) is called. But that can already lead to loading...\n---\n\nHave changed your fix to loadAhead once more. Want to express that toIndex is a reachable index\nin contrast to a size. The same idiom like in LoadChunkRequest/Indication. Is it ok?\n---\n\nWhy is the default for loadRevisionCollectionChunkSize \u003d 1?\nIt should be turned off by default.\n---\n\nIn LoadRevisionRequest.requesting() you forgot to ask \"fetchSize \u003e 0\" which could lead\nto signalling sequence error if fetchSize \u003d\u003d 0.\n---\n\nI believe there\u0027s something wrong with the following code but I wasn\u0027t able to see what it should be:\n        CDOFetchRule fetchRule \u003d new CDOFetchRule(in, getPackageManager());\n        for (CDOFeature feature : fetchRule.getFeatures())\n        {\n          fetchRules.put(fetchRule.getCDOClass(), fetchRule);\n        }\n\"feature\" is never used (warning) and the put() seems to multiply put the same thing...\n---\n\nIn LoadRevisionIndication.collectRevisionsByRule() there seems to be missing a check in isMany:\n\tif (!id.isNull() \u0026\u0026 !containedRevisions.containsKey(id))\n---\n\t\nWhat  is this good for:\n\tint newReferenceChunk \u003d Math.max(referenceChunk, 1000);\n---\n\t\nDidn\u0027t you say there\u0027s a Thread somewhere? Where is it?",
    "(In reply to comment #6)\n\u003e Refactored a bit an committed to CVS.\n\u003e Here some questions/comments:\n\u003e Is NOOPFetchRuleManager.getFetchRules(CDOID) a relict?\n\u003e It\u0027s not part of the interface and it\u0027s not being called from anywhere.\n\u003e ---\n\u003e CDOStore.get() calls preTraverseFeature() and postTraverseFeature().\n\u003e Wouldn\u0027t it be better to pass \"revision\" instead of \"cdoObject.cdoRevision()\"?\n\u003e I\u0027m not very sure, but especially in the first case cdoObject.cdoRevision()\n\u003e could return null.\n\u003e This is why getRevisionForReading(cdoObject) is called. But that can already\n\u003e lead to loading...\n\nI thought at this point it was sure that we have a revision. I don`t want to cause any fetching....\n\n\u003e ---\n\u003e Have changed your fix to loadAhead once more. Want to express that toIndex is a\n\u003e reachable index\n\u003e in contrast to a size. The same idiom like in LoadChunkRequest/Indication. Is\n\u003e it ok?\nSure!! \n\n\u003e ---\n\u003e Why is the default for loadRevisionCollectionChunkSize \u003d 1?\n\u003e It should be turned off by default.\n\nloadRevisionCollectionChunkSize  \u003c\u003d 1 .. means desactivate\n\n\n\u003e ---\n\u003e In LoadRevisionRequest.requesting() you forgot to ask \"fetchSize \u003e 0\" which\n\u003e could lead\n\u003e to signalling sequence error if fetchSize \u003d\u003d 0.\n\nYou are right !!\n\n\u003e ---\n\u003e I believe there\u0027s something wrong with the following code but I wasn\u0027t able to\n\u003e see what it should be:\n\u003e         CDOFetchRule fetchRule \u003d new CDOFetchRule(in, getPackageManager());\n\u003e         for (CDOFeature feature : fetchRule.getFeatures())\n\u003e         {\n\u003e           fetchRules.put(fetchRule.getCDOClass(), fetchRule);\n\u003e         }\n\u003e \"feature\" is never used (warning) and the put() seems to multiply put the same\n\u003e thing...\n\nI change my code last minutes.. should be only \nfetchRules.put(fetchRule.getCDOClass(), fetchRule);\n\n\n\u003e ---\n\u003e In LoadRevisionIndication.collectRevisionsByRule() there seems to be missing a\n\u003e check in isMany:\n\u003e         if (!id.isNull() \u0026\u0026 !containedRevisions.containsKey(id))\nyeah.\n\u003e ---\n\u003e What  is this good for:\n\u003e         int newReferenceChunk \u003d Math.max(referenceChunk, 1000);\n\nI wasn`t sure If i want to configure that as well.\nBut detecting that I need to fetch a collection... i want to be sure that the user set referenceChunk.. so it could benefit from the chunking read\n\n\u003e ---\n\u003e Didn\u0027t you say there\u0027s a Thread somewhere? Where is it?\nThis will be later. It is coming. What I was saying... is the next step will be the asynchronous call.. The API will not change for that since it will use IFeatureAnalyzer and the IFetchRuleManager and the CDORevisionManagerImpl.\n\nThe version we have right now only detect cluster of objects based on time ... I need to work to detect cluster based on time \u0026 it needs to be connected...\n\nfor that only one things should change it is (for now)\n\nIFeatureAnalyzer.preTraverseFeature(CDORevision cdoRevision, CDOFeature cdoFeature, int index, Object result);\n\n",
    "(In reply to comment #7)\n\u003e (In reply to comment #6)\n\u003e \u003e Refactored a bit an committed to CVS.\n\u003e \u003e Here some questions/comments:\n\u003e \u003e Is NOOPFetchRuleManager.getFetchRules(CDOID) a relict?\n\u003e \u003e It\u0027s not part of the interface and it\u0027s not being called from anywhere.\n\u003e \u003e ---\n\u003e \u003e CDOStore.get() calls preTraverseFeature() and postTraverseFeature().\n\u003e \u003e Wouldn\u0027t it be better to pass \"revision\" instead of \"cdoObject.cdoRevision()\"?\n\u003e \u003e I\u0027m not very sure, but especially in the first case cdoObject.cdoRevision()\n\u003e \u003e could return null.\n\u003e \u003e This is why getRevisionForReading(cdoObject) is called. But that can already\n\u003e \u003e lead to loading...\n\u003e I thought at this point it was sure that we have a revision. I don`t want to\n\u003e cause any fetching....\n\u003e \u003e ---\n\u003e \u003e Have changed your fix to loadAhead once more. Want to express that toIndex is a\n\u003e \u003e reachable index\n\u003e \u003e in contrast to a size. The same idiom like in LoadChunkRequest/Indication. Is\n\u003e \u003e it ok?\n\u003e Sure!! \n\u003e \u003e ---\n\u003e \u003e Why is the default for loadRevisionCollectionChunkSize \u003d 1?\n\u003e \u003e It should be turned off by default.\n\u003e loadRevisionCollectionChunkSize  \u003c\u003d 1 .. means desactivate\n\u003e \u003e ---\n\u003e \u003e In LoadRevisionRequest.requesting() you forgot to ask \"fetchSize \u003e 0\" which\n\u003e \u003e could lead\n\u003e \u003e to signalling sequence error if fetchSize \u003d\u003d 0.\n\u003e You are right !!\n\u003e \u003e ---\n\u003e \u003e I believe there\u0027s something wrong with the following code but I wasn\u0027t able to\n\u003e \u003e see what it should be:\n\u003e \u003e         CDOFetchRule fetchRule \u003d new CDOFetchRule(in, getPackageManager());\n\u003e \u003e         for (CDOFeature feature : fetchRule.getFeatures())\n\u003e \u003e         {\n\u003e \u003e           fetchRules.put(fetchRule.getCDOClass(), fetchRule);\n\u003e \u003e         }\n\u003e \u003e \"feature\" is never used (warning) and the put() seems to multiply put the same\n\u003e \u003e thing...\n\u003e I change my code last minutes.. should be only \n\u003e fetchRules.put(fetchRule.getCDOClass(), fetchRule);\n\u003e \u003e ---\n\u003e \u003e In LoadRevisionIndication.collectRevisionsByRule() there seems to be missing a\n\u003e \u003e check in isMany:\n\u003e \u003e         if (!id.isNull() \u0026\u0026 !containedRevisions.containsKey(id))\n\u003e yeah.\n\u003e \u003e ---\n\u003e \u003e What  is this good for:\n\u003e \u003e         int newReferenceChunk \u003d Math.max(referenceChunk, 1000);\n\u003e I wasn`t sure If i want to configure that as well.\n\u003e But detecting that I need to fetch a collection... i want to be sure that the\n\u003e user set referenceChunk.. so it could benefit from the chunking read\n\u003e \u003e ---\n\u003e \u003e Didn\u0027t you say there\u0027s a Thread somewhere? Where is it?\n\u003e This will be later. It is coming. What I was saying... is the next step will be\n\u003e the asynchronous call.. The API will not change for that since it will use\n\u003e IFeatureAnalyzer and the IFetchRuleManager and the CDORevisionManagerImpl.\n\u003e The version we have right now only detect cluster of objects based on time ...\n\u003e I need to work to detect cluster based on time \u0026 it needs to be connected...\n\u003e for that only one things should change it is (for now)\n\u003e IFeatureAnalyzer.preTraverseFeature(CDORevision cdoRevision, CDOFeature\n\u003e cdoFeature, int index, Object result);\n\n\nI`m refactoring and moving everything except(CDOFetchRule) into project:\norg.eclipse.emf.cdo since only the client should have these classes.\n",
    " (In reply to comment #7)\n\u003e \u003e CDOStore.get() calls preTraverseFeature() and postTraverseFeature().\n\u003e \u003e Wouldn\u0027t it be better to pass \"revision\" instead of \"cdoObject.cdoRevision()\"?\n\u003e \u003e I\u0027m not very sure, but especially in the first case cdoObject.cdoRevision()\n\u003e \u003e could return null.\n\u003e \u003e This is why getRevisionForReading(cdoObject) is called. But that can already\n\u003e \u003e lead to loading...\n\u003e \n\u003e I thought at this point it was sure that we have a revision. I don`t want to\n\u003e cause any fetching....\n\nI will have to investigate this later.\nMaybe we need a getRevisionForReading(cdoObject, loadOnDemand)...\nIs it possible to pass the InternalCDOObject into preTraverseFeature()\ninstead of its CDORevision? That would be much simpler and maybe even\nmore correct, since the revision per object can/will change over time.\nI\u0027m not sure about what you need in CDOFeatureAnalyzer.\n\n\u003e \u003e Why is the default for loadRevisionCollectionChunkSize \u003d 1?\n\u003e \u003e It should be turned off by default.\n\u003e \n\u003e loadRevisionCollectionChunkSize  \u003c\u003d 1 .. means desactivate\nThat seems a bit strange. I\u0027d expect deactivated to be either\nloadRevisionCollectionChunkSize  \u003d\u003d 0 or \nloadRevisionCollectionChunkSize  \u003d\u003d 1 but not both.\nWhat are the exact semantics of a \"loadRevisionCollectionChunk\"? \n\n\u003e \u003e What  is this good for:\n\u003e \u003e         int newReferenceChunk \u003d Math.max(referenceChunk, 1000);\n\u003e \n\u003e I wasn`t sure If i want to configure that as well.\n\u003e But detecting that I need to fetch a collection... i want to be sure that the\n\u003e user set referenceChunk.. so it could benefit from the chunking read\n\nI think we need to provide something more obvious/configurable.\nCan you please post a proposal?\n",
    "(In reply to comment #9)\n\u003e  (In reply to comment #7)\n\u003e \u003e \u003e CDOStore.get() calls preTraverseFeature() and postTraverseFeature().\n\u003e \u003e \u003e Wouldn\u0027t it be better to pass \"revision\" instead of \"cdoObject.cdoRevision()\"?\n\u003e \u003e \u003e I\u0027m not very sure, but especially in the first case cdoObject.cdoRevision()\n\u003e \u003e \u003e could return null.\n\u003e \u003e \u003e This is why getRevisionForReading(cdoObject) is called. But that can already\n\u003e \u003e \u003e lead to loading...\n\u003e \u003e \n\u003e \u003e I thought at this point it was sure that we have a revision. I don`t want to\n\u003e \u003e cause any fetching....\n\u003e I will have to investigate this later.\n\u003e Maybe we need a getRevisionForReading(cdoObject, loadOnDemand)...\n\u003e Is it possible to pass the InternalCDOObject into preTraverseFeature()\n\u003e instead of its CDORevision? That would be much simpler and maybe even\n\u003e more correct, since the revision per object can/will change over time.\n\u003e I\u0027m not sure about what you need in CDOFeatureAnalyzer.\n\nI can use the InternalCDOObject. I will modify it.\n\n\u003e \u003e \u003e Why is the default for loadRevisionCollectionChunkSize \u003d 1?\n\u003e \u003e \u003e It should be turned off by default.\n\u003e \u003e \n\u003e \u003e loadRevisionCollectionChunkSize  \u003c\u003d 1 .. means desactivate\n\u003e That seems a bit strange. I\u0027d expect deactivated to be either\n\u003e loadRevisionCollectionChunkSize  \u003d\u003d 0 or \n\u003e loadRevisionCollectionChunkSize  \u003d\u003d 1 but not both.\n\u003e What are the exact semantics of a \"loadRevisionCollectionChunk\"? \n\nbecause usually to be activated.. you need to load at least 2 objects at the time... but we can put it at zero.. it is clearer.\nloadRevisionCollectionChunk\n\nFor collection it will load at the same time the next X objects\nif it is 1... it is the same things as loading 1 objects.. ut maybe not in all cases.\n\n\u003e \u003e \u003e What  is this good for:\n\u003e \u003e \u003e         int newReferenceChunk \u003d Math.max(referenceChunk, 1000);\n\u003e \u003e \n\u003e \u003e I wasn`t sure If i want to configure that as well.\n\u003e \u003e But detecting that I need to fetch a collection... i want to be sure that the\n\u003e \u003e user set referenceChunk.. so it could benefit from the chunking read\n\u003e I think we need to provide something more obvious/configurable.\n\u003e Can you please post a proposal?\nOk, I will use the referenceChunk.. if the user didn\u0027t set it.. it will not benefits from it.\nFor now .. I will use reference Chunk and do some benchmark... \n\n\n\n",
    "(In reply to comment #9)\n\u003e  (In reply to comment #7)\n\u003e \u003e \u003e CDOStore.get() calls preTraverseFeature() and postTraverseFeature().\n\u003e \u003e \u003e Wouldn\u0027t it be better to pass \"revision\" instead of \"cdoObject.cdoRevision()\"?\n\u003e \u003e \u003e I\u0027m not very sure, but especially in the first case cdoObject.cdoRevision()\n\u003e \u003e \u003e could return null.\n\u003e \u003e \u003e This is why getRevisionForReading(cdoObject) is called. But that can already\n\u003e \u003e \u003e lead to loading...\n\u003e \u003e \n\u003e \u003e I thought at this point it was sure that we have a revision. I don`t want to\n\u003e \u003e cause any fetching....\n\u003e I will have to investigate this later.\n\u003e Maybe we need a getRevisionForReading(cdoObject, loadOnDemand)...\n\u003e Is it possible to pass the InternalCDOObject into preTraverseFeature()\n\u003e instead of its CDORevision? That would be much simpler and maybe even\n\u003e more correct, since the revision per object can/will change over time.\n\u003e I\u0027m not sure about what you need in CDOFeatureAnalyzer.\n\u003e \u003e \u003e Why is the default for loadRevisionCollectionChunkSize \u003d 1?\n\u003e \u003e \u003e It should be turned off by default.\n\u003e \u003e \n\u003e \u003e loadRevisionCollectionChunkSize  \u003c\u003d 1 .. means desactivate\n\u003e That seems a bit strange. I\u0027d expect deactivated to be either\n\u003e loadRevisionCollectionChunkSize  \u003d\u003d 0 or \n\u003e loadRevisionCollectionChunkSize  \u003d\u003d 1 but not both.\n\u003e What are the exact semantics of a \"loadRevisionCollectionChunk\"? \n\u003e \u003e \u003e What  is this good for:\n\u003e \u003e \u003e         int newReferenceChunk \u003d Math.max(referenceChunk, 1000);\n\u003e \u003e \n\u003e \u003e I wasn`t sure If i want to configure that as well.\n\u003e \u003e But detecting that I need to fetch a collection... i want to be sure that the\n\u003e \u003e user set referenceChunk.. so it could benefit from the chunking read\n\u003e I think we need to provide something more obvious/configurable.\n\u003e Can you please post a proposal?\n\nI was a bit suprised that you checked in my code. I just wanted to know if the design was good... and to let you understand my design and my strategy to detect proxy...\n\nWith the GraphConnectedSpace that I\u0027m doing .. it will be more accurate for processing business.\n\nSimon",
    "Oh, sorry. I thought it was meant as a contribution. Is it a problem?\nThe main reason was that I often need hours to review/understand your patches.\nAs you might have noticed I spend notable effort to convert it to my own coding style so that the whole code base forms a homogeneous piece of technology.\nI hope you\u0027re not angry about that. You know each programmer has his own principles and idioms and that makes it easier for me to maintain it in the future.\n\nI guess one of your next patches will show what GraphConnectedSpace is ;-)\n\nBTW. I\u0027m going to visit some friends over the weekend. I won\u0027t be able to respond before Sunday. Enjoy...",
    "(In reply to comment #12)\n\u003e Oh, sorry. I thought it was meant as a contribution. Is it a problem?\nNo no.. I want to contribute... only it is not bullet proof.\n\n\u003e The main reason was that I often need hours to review/understand your patches.\n\u003e As you might have noticed I spend notable effort to convert it to my own coding\n\u003e style so that the whole code base forms a homogeneous piece of technology.\n\nCan you send me your coding style (in eclipse).. so at least we should have the same looking code ?\n\n\u003e I hope you\u0027re not angry about that. You know each programmer has his own\n\u003e principles and idioms and that makes it easier for me to maintain it in the\n\u003e future.\n No!!Needs me more than that to be angry!!\n\n\u003e I guess one of your next patches will show what GraphConnectedSpace is ;-)\n\u003e BTW. I\u0027m going to visit some friends over the weekend. I won\u0027t be able to\n\u003e respond before Sunday. Enjoy...\n\nHave a nice week-end !!\n\n",
    "I did some test with the new analyzer. (loading a model that contains 40000 objects)\n\nHere some results:\n\nWithout DynamicFetchRule\n1250 request to the server\n3590 objects / sec\n\nWith DynamicFetchRule\n63 request to the server (20 times less request)\n4769 objects / sec (33 % faster)\n\n(Don`t forget my computer is slow.. usually the throughput is faster and I run my CD player at the time !!)\n\nBoth of them are using LoadChunkCollection(100); \n\nIn a network with high latency... the difference will be bigger between them.\n1250 requests in a network with high latency will be affected more than doing 63 requests.\n\nTo simulate the latency. I added a Thread.currentThread.sleep(20) in the beginning of the LoadRevisionIndication.responding.\n\n1090 objects / sec (Without DynamicFetchRule) Degradation \u003d 329 % \n3750 objects / sec (With DynamicFetchRule) Degradation \u003d 127 %  \n\nNow \u003cWith DynamicFetchRule\u003e is 244 % faster than the \u003cWithout DynamicFetchRule\u003e instead of 33 %\n\nThe performance degradation is important for the \u003cWith DynamicFetchRule\u003e\n\nI will try to build a test case where it is not good to use DynamicFetchRule... to see the impact. (Accessing objects without pattern).\nI don`t think the performance that important.. but we will see.\n\n\n\n",
    "Created an attachment (id\u003d77950)\nNew version - Detect different rules for different graph of instances at the same time\n\nThis algorithm is able to detect group of instances use together. \nIn this case we could have different rules on different part of the model calculate at the same time.\n\nYou can review me and check-in the code.\n\nFor my models I tested... it was really fantastic\nI have a graph with different structure. The depth is 4 ... and I used different path to access my data.\nIt can detect my pattern and will fetch in one shot the 4 depth I used all the time.\n\nFetch 120 000 objects :\n(I removed Session.provideCDOID... otherwise I cannot go more than 6000 objects/sec)\n\nWithout DynamicRule\n3715 request to the server\n8302 objects/sec\n\nWith DynamicRule\n141 request to the server\n11890 objects/sec (I went over  12000 objects/sec ... but after it went down a little bit)\n\nAdd the latency in there!!! and the \u003cWithout DynamicRule\u003e will go down big time.\n\nThanks",
    "The results are very impressive!!! Good work ;-)\nI must admit that I did not test it, yet, since I\u0027m fighting other fires at the moment (provide proper features and automatic builds with Nick).\n\nSome comments to CDOReadAhead:\n1. Have the feeling that QueueWorker would be a good superclass.\n2. If not, IWorkSerializer.dispose() should be called somewhere.\n3. Have renamed \"session\" to \"view\".\n4. Is nested class Test still needed?\n5. Could you please provide a test case? Also important as an illustration...\n\nCommitted to CVS.",
    "Should we add a feature to control the maximum recursion depth of Session.collectContainedRevisions()?",
    "(In reply to comment #16)\n\u003e The results are very impressive!!! Good work ;-)\n\u003e I must admit that I did not test it, yet, since I\u0027m fighting other fires at the\n\u003e moment (provide proper features and automatic builds with Nick).\n\u003e Some comments to CDOReadAhead:\n\u003e 1. Have the feeling that QueueWorker would be a good superclass.\n\u003e 2. If not, IWorkSerializer.dispose() should be called somewhere.\n\u003e 3. Have renamed \"session\" to \"view\".\n\u003e 4. Is nested class Test still needed?\n\u003e 5. Could you please provide a test case? Also important as an illustration...\n\nOOps.. CDOReadAhead was not meant to be send in the patch. It is the part where a thread will fetch objects in another thread.. I did a quick test.. without good result..\n\nYou can remove it from now. I will send you the patch to remove it.\n\n\u003e Committed to CVS.\n\n",
    "Created an attachment (id\u003d77969)\nRemove CDOReadAhead\n\nRemove CDOReadAhead from the repository (Test file)",
    " (In reply to comment #19)\n\u003e Remove CDOReadAhead from the repository (Test file)\n\nDone.",
    "Created an attachment (id\u003d78135)\nUpdate \n\nI have 2 kind of analyzer... one for processing intensive.. the other through UI interaction.\n\n\nI was starting to do my test cases when I had a problem.\n\nCompany company \u003d Model1Factory.eINSTANCE.createCompany();\nPurchaseOrder purchaseOrder \u003d Model1Factory.eINSTANCE.createPurchaseOrder();\ncompany.getPurchaseOrders().add(purchaseOrder);\npurchaseOrder.setSupplier(supplier);\n\n\nI get the following\n\norg.eclipse.net4j.util.ImplementationError: Unable to provideCDOID: org.eclipse.emf.cdo.tests.model1.impl.SupplierImpl\n\tat org.eclipse.emf.internal.cdo.CDOViewImpl.provideCDOID(CDOViewImpl.java:402)\n\tat org.eclipse.emf.cdo.internal.protocol.revision.CDORevisionImpl.writeValues(CDORevisionImpl.java:691)\n\tat org.eclipse.emf.cdo.internal.protocol.revision.CDORevisionImpl.write(CDORevisionImpl.java:137)\n\tat org.eclipse.emf.internal.cdo.protocol.CommitTransactionRequest.writeRevisions(CommitTransactionRequest.java:123)\n\tat org.eclipse.emf.internal.cdo.protocol.CommitTransactionRequest.writeNewObjects(CommitTransactionRequest.java:102)\n\tat org.eclipse.emf.internal.cdo.protocol.CommitTransactionRequest.requesting(CommitTransactionRequest.java:64)\n\tat org.eclipse.net4j.signal.RequestWithConfirmation.execute(RequestWithConfirmation.java:48)\n\tat org.eclipse.net4j.signal.Signal.runSync(Signal.java:130)\n\nI don`t think I will look at it tonight.. but I believe it should persist the dangling reference.. right?",
    "Could you provide the whole test case code?\nPurchaseOrder.supplier is a non-containment reference and it seems that the supplier instance is not properly attached to the view.\nIn this case an exception must occur. Maybe I should turn it into a DanglingReferenceException exends IllegalStateException\n(instead of an ImplementationError).",
    "(In reply to comment #22)\n\u003e Could you provide the whole test case code?\n\u003e PurchaseOrder.supplier is a non-containment reference and it seems that the\n\u003e supplier instance is not properly attached to the view.\n\u003e In this case an exception must occur. Maybe I should turn it into a\n\u003e DanglingReferenceException exends IllegalStateException\n\u003e (instead of an ImplementationError).\n\nYou had the whole test case code.. I was started and what you had.\n\nSo we need to persist each objects ... I thought it was suppose to be made persistent in the case of a transient objects. Otherwise it added a reference.\n\nI know hibernate does persistence automatically .. and it is easier much eaisier.. \nObjectivity database also ... does it that way.\n\nDo we not do it by choice .. or we follow a spec ?",
    "CDO tries to follow the EMF spec/semantics as neat as possible/appropriate.\nIn this case it is the spec of containment within a ResourceSet (CDOView).\nI don\u0027t think that any existing persistent backend, including RDBs, have this concept.\n\nYour EMF test code would not be legal with an XMLResourceImpl, too.\nYou can\u0027t persist Ecore model instances with cross references to objects that are not contained in the same ResourceSet.",
    "(In reply to comment #24)\n\u003e CDO tries to follow the EMF spec/semantics as neat as possible/appropriate.\n\u003e In this case it is the spec of containment within a ResourceSet (CDOView).\n\u003e I don\u0027t think that any existing persistent backend, including RDBs, have this\n\u003e concept.\n\u003e Your EMF test code would not be legal with an XMLResourceImpl, too.\n\u003e You can\u0027t persist Ecore model instances with cross references to objects that\n\u003e are not contained in the same ResourceSet.\n\n\nI don\u0027t know why you think that any existing persistent backend   don\u0027t have this concept.. but they do.\n\nHere the link\nhttp://docs.huihoo.com/framework/hibernate/hibernate-reference-2.1.7/manipulatingdata.html\n\n9.9. you have the flag \ncascade\u003d\"save-update\" (to delete you need to do it manually)\n\nIn teneo you use the same things!!\n\n\nDo you mean in EMF or in general.. because I know well Objectivity and they do as well (don\u0027t use EMF) ?\n\nThis make sense as well. You want to keep the integrity of your graph. You have a dangling reference... what do you do ? The only possibilty is to persist it ?\nWhat else can the consumer would like to do ?\n\n\n",
    "I mean especially the ResourceSet and the Resource.\nIn any case I withdraw my statement about persistence backends because I don\u0027t know many of them and it seems irrelevant for this discussion.\n\nWhat seems important is that EMF can\u0027t serialize a Resource with dangling references. Or am I wrong?",
    "(In reply to comment #26)\n\u003e I mean especially the ResourceSet and the Resource.\n\u003e In any case I withdraw my statement about persistence backends because I don\u0027t\n\u003e know many of them and it seems irrelevant for this discussion.\n\u003e What seems important is that EMF can\u0027t serialize a Resource with dangling\n\u003e references. Or am I wrong?\n\nYou are totally right. \n\nIn this matter, to keep the integrity of the graph should we not persist the dangling reference in the same resource where the object refer to him.\n\nCase 1:\nCreate A\nCreate B\nLink A to B\nSave A to ResourceX\n\n\nCase 2:\nCreate A\nSave A to ResourceX\nCreate B\nLink A to B\n\nResourceX should have A and B to keep its integrity. Right ?\n\nThe other solution is to throw an exception.\n\nAs a consumer... don\u0027t want to bother to persist my objects all the time.. I play with objects they should know when it is time to persist them or not.\n\nAnother case is the following :\n\nProcess A receive an objectX and objectY. \nProcess A doesn\u0027t know of the objectX or objectY are persistent or transient...\nProcess A create objectZ.\nProcess A needs to link objectX to objectZ and to link objectZ to objectY.\n\nBecause the save isn\u0027t automatically...\nProcess A needs to know if objectX is persistent by looking in which resources it belongs to.\nDepends of the state of objectX it will save or not objectZ.\nAfter its need to save objectZ and all its transient children only and only if objectX was persistent.\n\n\nThis makes the code very ugly...\n\n\n\n\n\n\n\n\n\n",
    "Can you update my last patch without the Test ?",
    "(In reply to comment #28)\n\u003e Can you update my last patch without the Test ?\n\nI meant \n\nCan you check in my last patch?\n\nThank you\n\n",
    "Committed patch #5 to CVS.\n\nSome comments/questions:\n- Can CDOAbstractFeatureRuleAnalyzer.didFetch be derived from fetchCount?\n- See TODO in CDOClusterOfFetchRule.hashCode()\n- See TODO in CDOFetchFeatureInfo.hashCode()\n\n",
    " (In reply to comment #27)\n\u003e In this matter, to keep the integrity of the graph should we not persist the\n\u003e dangling reference in the same resource where the object refer to him.\n\u003e \n\u003e Case 1:\n\u003e Create A\n\u003e Create B\n\u003e Link A to B\n\u003e Save A to ResourceX\n\u003e \n\u003e \n\u003e Case 2:\n\u003e Create A\n\u003e Save A to ResourceX\n\u003e Create B\n\u003e Link A to B\n\u003e \n\u003e ResourceX should have A and B to keep its integrity. Right ?\n\u003e \n\u003e The other solution is to throw an exception.\n\nYes, this is what EMF users expect and what CDO already does.\n",
    "(In reply to comment #31)\n\u003e  (In reply to comment #27)\n\u003e \u003e In this matter, to keep the integrity of the graph should we not persist the\n\u003e \u003e dangling reference in the same resource where the object refer to him.\n\u003e \u003e \n\u003e \u003e Case 1:\n\u003e \u003e Create A\n\u003e \u003e Create B\n\u003e \u003e Link A to B\n\u003e \u003e Save A to ResourceX\n\u003e \u003e \n\u003e \u003e \n\u003e \u003e Case 2:\n\u003e \u003e Create A\n\u003e \u003e Save A to ResourceX\n\u003e \u003e Create B\n\u003e \u003e Link A to B\n\u003e \u003e \n\u003e \u003e ResourceX should have A and B to keep its integrity. Right ?\n\u003e \u003e \n\u003e \u003e The other solution is to throw an exception.\n\u003e Yes, this is what EMF users expect and what CDO already does.\n\nI do not agree 100% with you. I prefer to say it depends of which implementation you are using.\n\nDo you think we could add an option on CDOTransaction to :\n\n- When we link 2 objects together.. and the destination isn\u0027t attach to any resource. Attach it to the same resource as the from object.\n\nSimon\n\n",
    "\u003e \u003e Yes, this is what EMF users expect and what CDO already does.\n\u003e \n\u003e I do not agree 100% with you. I prefer to say it depends of which\n\u003e implementation you are using.\n\u003e \n\u003e Do you think we could add an option on CDOTransaction to :\n\u003e \n\u003e - When we link 2 objects together.. and the destination isn\u0027t attach to any\n\u003e resource. Attach it to the same resource as the from object.\n\u003e \n\u003e Simon\n\u003e \n\nI\u0027m not completely reluctant to have an additional option on CDOTransaction which is off by default. But I\u0027d like to discuss some implications first.\n\nThe most obvious one, what happens if several objects that are contained in multiple resources point to the same non-attached object? Which resource shall become the container of the dangling object?\n\nEd, I\u0027ve CC\u0027ed you because you probably had good reasons in mind when you chose to throw an exception if an attempt is being made to serialize a resource with dangling references. What do you think? (Should be enough for you to read 3-4 of the most recent comments)",
    "I think the client themselves should always ensure the EObject.eResource !\u003d null for all objects they intend to serialize.  Until you\u0027ve explicitly put an object in a resource, you\u0027ve not determined where it should live and having some magic that makes that determination for you seems error prone at best.  The client can quite easily use Resource.getAllContents and iterate over EObject.eCrossReferences to find all dangling references and assign them to an appropriate resource of their choice.",
    "(In reply to comment #34)\n\nThis is what I think.\n\nI\u0027ve got another proposal for you, Simon:\nWhat, if I add vetoable PreCommitEvents?\nYou could listen to them to apply the logic Ed outlined.\nThey could also be used to apply things like constraint validation, ...",
    "(In reply to comment #35)\n\u003e (In reply to comment #34)\n\u003e This is what I think.\n\u003e I\u0027ve got another proposal for you, Simon:\n\u003e What, if I add vetoable PreCommitEvents?\n\u003e You could listen to them to apply the logic Ed outlined.\n\u003e They could also be used to apply things like constraint validation, ...\n\nI agree that we shouldn\u0027t have any magic going around. \n\nIt is why I would like have an option in CDOTransaction or any other mechanisms to allow the user to works in that mode.\n\nIn this way.. it is not magic anymore. This is a pattern that always come back. \nYou want to play with objects in a resource... and save them. This concept exist in some systems... and this is not magic! :-)\n\nPreCommitEvents could be really nice.\n\nBut, I will not be able to add objects in the resource when we set things.\n\nMaybe if we can also add listener to the trackingmodification. (Each time something happen to any objects in a resources the listener could be notify) .. it will be perfect!!!\n\nIn this case.. to know I would like to know when we commit to do some validation .\n\nWhat you think ?\n",
    "(In reply to comment #36)\n\u003e PreCommitEvents could be really nice.\n\nPlease open a feature request for it if you decide it can be helpful for you.\n\n\u003e But, I will not be able to add objects in the resource when we set things.\n\nI didn\u0027t think you meant to intervene at the time objects are modified. I don\u0027t see how an option on CDOTransaction could help here. For this purpose you can use \"ordinary\" EMF Adapters, can\u0027t you?",
    "It seems to me that an object referenced by two different resources is going to be arbitrarily assigned to one of them, depending on which is saved first, and that doesn\u0027t seem good.  It also seems you should use a containment reference if you want something in the resource by virtue of it having been referenced by something already in a resource...",
    "(In reply to comment #38)\n\u003e It seems to me that an object referenced by two different resources is going to\n\u003e be arbitrarily assigned to one of them, depending on which is saved first, and\n\u003e that doesn\u0027t seem good.  It also seems you should use a containment reference\n\u003e if you want something in the resource by virtue of it having been referenced by\n\u003e something already in a resource...\n\nYou could assign it to the first one link them. In this case you need to be aware of when an object is set to another objects.\n\nUsually, (I cannot speak for outside my business) but each department have their resource and their model. When we link objects between two differents resources.. objects are 99.5 already persistent. So this is perfect no problem here.\n\nSo in my processing that I deal with the same resource, I don\u0027t want to bother anymore to save my objects. I just want to play with my objects to do my business. \n\nThings I don\u0027t want to play with .. is persistence (In this case Resource).\nWhen we play with transient objects  (e.g. : transientA)... in most cases (I\u0027m sure you could confirm )  if I link it with another object (e.g.: ObjectB) it will go in the same resource. Otherwise I should attach it in another resource.\n\nobjectB -\u003e transientA\n\nIt makes more sense to persist the object (transientA) instead of throwing an exception.\n\n",
    "(In reply to comment #37)\n\u003e (In reply to comment #36)\n\u003e \u003e PreCommitEvents could be really nice.\n\u003e Please open a feature request for it if you decide it can be helpful for you.\n\u003e \u003e But, I will not be able to add objects in the resource when we set things.\n\u003e I didn\u0027t think you meant to intervene at the time objects are modified. I don\u0027t\n\u003e see how an option on CDOTransaction could help here. For this purpose you can\n\u003e use \"ordinary\" EMF Adapters, can\u0027t you?\n\nThe option in CDOTransaction.. will do whatever it takes to enable this features (maybe by using EMF Adapters...don\u0027t care)\n\nMaybe I just need to add my adapter to the resource... but will be good if CDO gave me this feature. \n\nI think it is feasible.\n\nOtherwise I will need to add an adapter on each objects.. for that I will need to extend CDOResourceImpl..\n\n",
    "There are these options for how dangling references should be handled:\n\n  /**\n   * This can be one of \"THROW\", \"DISCARD\", \"RECORD\", where \"THROW\" is the default.\n   */\n  String OPTION_PROCESS_DANGLING_HREF          \u003d \"PROCESS_DANGLING_HREF\";\n  String OPTION_PROCESS_DANGLING_HREF_THROW    \u003d \"THROW\";\n  String OPTION_PROCESS_DANGLING_HREF_DISCARD  \u003d \"DISCARD\";\n  String OPTION_PROCESS_DANGLING_HREF_RECORD   \u003d \"RECORD\";\n\nSo it\u0027s possible to just discard them as transient.",
    "(In reply to comment #41)\n\u003e There are these options for how dangling references should be handled:\n\u003e   /**\n\u003e    * This can be one of \"THROW\", \"DISCARD\", \"RECORD\", where \"THROW\" is the\n\u003e default.\n\u003e    */\n\u003e   String OPTION_PROCESS_DANGLING_HREF          \u003d \"PROCESS_DANGLING_HREF\";\n\u003e   String OPTION_PROCESS_DANGLING_HREF_THROW    \u003d \"THROW\";\n\u003e   String OPTION_PROCESS_DANGLING_HREF_DISCARD  \u003d \"DISCARD\";\n\u003e   String OPTION_PROCESS_DANGLING_HREF_RECORD   \u003d \"RECORD\";\n\u003e So it\u0027s possible to just discard them as transient.\n\nI don\u0027t want to discard them. I want to persist them.\n\nDo they have an option to persist the dangling reference in the same resource as the parent ? Probably not otherwise you would have mentionned it to me :-)",
    "(In reply to comment #39)\n\u003e You could assign it to the first one link them. In this case you need to be\n\u003e aware of when an object is set to another objects.\n\nIt\u0027s quite usual (never heard of different behavior) that the client who adds a\ncross reference actively attaches the referenced object to a resource of his\nchoice. Doing this automatically at the time the reference is set would break\nthis expectation.\n\n\n\u003e Usually, (I cannot speak for outside my business) but each department have\n\u003e their resource and their model. When we link objects between two differents\n\u003e resources.. objects are 99.5 already persistent. So this is perfect no problem\n\u003e here.\n\nI find this quite unusual ;-)\nWant to say I never saw this behavior, although I don\u0027t want to judge whether\nit\u0027s good or not in your special environment.\n\n\u003e [...]\n\u003e Things I don\u0027t want to play with .. is persistence (In this case Resource).\n\nI think it\u0027s ok to ignore persistence as long as you stay transient. When it\ncomes to persisting, EMF requires you to think about it. I think this is ok.\n\n\u003e When we play with transient objects  (e.g. : transientA)... in most cases (I\u0027m\n\u003e sure you could confirm )  if I link it with another object (e.g.: ObjectB) it\n\u003e will go in the same resource. Otherwise I should attach it in another resource.\n\u003e \n\u003e objectB -\u003e transientA\n\u003e \n\u003e It makes more sense to persist the object (transientA) instead of throwing an\n\u003e exception.\n\nAs I said I don\u0027t agree here and I can\u0027t find any new arguments that support\nyour thesis.\n\nEspecially I\u0027m not happy with developing something that can be achieved with\nordinary/unmodified EMF as well. You don\u0027t need to override CDOResourceImpl to\nhave an EMF adapter attached to all contents. You can simply use an\nEContentAdapter for this purpose.",
    "(In reply to comment #43)\n\u003e (In reply to comment #39)\n\u003e \u003e You could assign it to the first one link them. In this case you need to be\n\u003e \u003e aware of when an object is set to another objects.\n\u003e It\u0027s quite usual (never heard of different behavior) that the client who adds a\n\u003e cross reference actively attaches the referenced object to a resource of his\n\u003e choice. Doing this automatically at the time the reference is set would break\n\u003e this expectation.\n\nI wasn \u0027t clear enough because you didn\u0027t understand me correctly\nWhat I was trying to say is usually when we do cross-reference, objects are already persistent:\nE.g.:\nobjectA belongs to ResourceA \nobjectB belongs to ReosurceB\n\nif we add a link between objectA and objectB.. they stayed in their resources and everybody is happy.\n\nUsually a service that create objects with one resource doesn\u0027t have to bother to save every objects because it belongs only to one resource. Right? For him it is really useful.\n\nThe service that deals with 2 resources... will have to manage his resources anyway. So for him he can choice either rules (you need to persist every objects or when you link an object with a transient.. this object will be persisted in the same reosurce as the other object)\nFor him it will takes the rules he prefers.\n\nFinally, the feature helps a lot for complex graph.. and let say we have very complex graph here with tera-bytes of data. In our EMF kind of Object model created in 2000..... it is one of the first things we have implemented.\n \n I don\u0027t say it needs to act that way.. but to give the opportunity for people to reuse this pattern... like hibernate, Objectivity.. any respectful database have that.\n\n\n\u003e \u003e Usually, (I cannot speak for outside my business) but each department have\n\u003e \u003e their resource and their model. When we link objects between two differents\n\u003e \u003e resources.. objects are 99.5 already persistent. So this is perfect no problem\n\u003e \u003e here.\n\u003e I find this quite unusual ;-)\n\u003e Want to say I never saw this behavior, although I don\u0027t want to judge whether\n\u003e it\u0027s good or not in your special environment.\n\u003e \u003e [...]\n\u003e \u003e Things I don\u0027t want to play with .. is persistence (In this case Resource).\n\u003e I think it\u0027s ok to ignore persistence as long as you stay transient. When it\n\u003e comes to persisting, EMF requires you to think about it. I think this is ok.\n\u003e \u003e When we play with transient objects  (e.g. : transientA)... in most cases (I\u0027m\n\u003e \u003e sure you could confirm )  if I link it with another object (e.g.: ObjectB) it\n\u003e \u003e will go in the same resource. Otherwise I should attach it in another resource.\n\u003e \u003e \n\u003e \u003e objectB -\u003e transientA\n\u003e \u003e \n\u003e \u003e It makes more sense to persist the object (transientA) instead of throwing an\n\u003e \u003e exception.\n\u003e As I said I don\u0027t agree here and I can\u0027t find any new arguments that support\n\u003e your thesis.\n\nThis feature removes anything from people that would like to work in the old way because one solution doesn\u0027t restrict the other ?? Same here... I don\u0027t understand your point view.\n\n\u003e Especially I\u0027m not happy with developing something that can be achieved with\n\u003e ordinary/unmodified EMF as well. You don\u0027t need to override CDOResourceImpl to\n\u003e have an EMF adapter attached to all contents. You can simply use an\n\u003e EContentAdapter for this purpose.\n\nTo add EMF adapter on resource is fine. It will work for objects that are attach/detach to Resource \n\nBut I will need to listen on everyObject that the resource contains. And I will prefer not to add a adapter on every objects.\n\nI tried to attach it on the resource. Doesn\u0027t seems to works.\nEContentAdapter adapterA \u003d...;\nResource resource \u003d cdoView.getResourcePath(\"/test1\");\nresource.eAdapters().add( adapterA );\nEObject object1 \u003d cdoView.getObject(\u003cID\u003e);\nobject1.setSupplier( supplier );\n\nadapterA doesn\u0027t received any messages. :-( I would like to receive message for objects that I modify in that resource. \nIs is suppose to work ?\nIs it a problem in CDO ?\n\nDo you have another suggestion for that problem ?\n\n",
    "Created an attachment (id\u003d78236)\nFIX toDO\n\n(In reply to comment #30)\n\u003e Committed patch #5 to CVS.\n\u003e Some comments/questions:\n\u003e - Can CDOAbstractFeatureRuleAnalyzer.didFetch be derived from fetchCount?\n\nNo it cannot, since didFetch is for a specific call. (Always reset it to false)\nCount is total number of fetch for the life of the Analyzer.\n\n\u003e - See TODO in CDOClusterOfFetchRule.hashCode()\n\u003e - See TODO in CDOFetchFeatureInfo.hashCode()\n\nFixed\n",
    "Created an attachment (id\u003d78242)\nTestCase\n\nI update the code tonight.. and it seems that the merge didn`t work correctly because in my patch they was there.\n\n\nThis was missing : It causes NullPointerException all over the place without initializing them correctly.\n\nclass LoadRevisionIdication\n{\n  protected CDOID contextID \u003d CDOIDNull.NULL;\n  protected int loadRevisionCollectionChunkSize \u003d 1;\n\nThese 2 variables wasn`t initialize \n\nAlso I make my FeatureAnalyzer pass.. this is good!!\n\nI will work on others.\n\nIf you can check-in that code it will be fantastic\n\nThank you!\n\n",
    "Created an attachment (id\u003d78243)\nSession Comments\n\nSession Comments\n/**\n   * TODO I can\u0027t see how recursion is controlled/limited\n   * TODO Should it collect revisions for isMany relationship as well ? \n   *      In this case we will have to serialize CDOViewImpl.loadRevisionCollectionChunkSize \n   *      or CDOFetchRuleManager.getLoadRevisionCollectionChunkSize ?\n   */\n\npublic void collectContainedRevisions\n\nAbout the controlled limitation. \nI think it cannot do an infinite loop.. so I believe it will terminate somewhere. It cannot continue indefinitely.. isn`t ?",
    "(In reply to comment #44)\n\u003e [...]\n\u003e I tried to attach it on the resource. Doesn\u0027t seems to works.\n\u003e EContentAdapter adapterA \u003d...;\n\u003e Resource resource \u003d cdoView.getResourcePath(\"/test1\");\n\u003e resource.eAdapters().add( adapterA );\n\u003e EObject object1 \u003d cdoView.getObject(\u003cID\u003e);\n\u003e object1.setSupplier( supplier );\n\u003e \n\u003e adapterA doesn\u0027t received any messages. :-( I would like to receive message for\n\u003e objects that I modify in that resource. \n\u003e Is is suppose to work ?\n\nYes ;-)\n\n\u003e Is it a problem in CDO ?\n\nIt shouldn\u0027t. Since the EMF UI (editor, outline, properties, ...) seem to work properly I didn\u0027t suspect issues in this area.\n\n\u003e Do you have another suggestion for that problem ?\n\nNo, if it doesn\u0027t work (and it\u0027s not the fault of your client code), please file a bug so that I don\u0027t forget about it.",
    " (In reply to comment #46)\n\u003e These 2 variables wasn`t initialize\nSorry about that, I should be more careful when I change your code!\n\n\u003e If you can check-in that code it will be fantastic\nCommitted to CVS.",
    " (In reply to comment #47)\n\u003e About the controlled limitation.\n\u003e I think it cannot do an infinite loop.. so I believe it will terminate\n\u003e somewhere. It cannot continue indefinitely.. isn`t ?\n\nNo, I don\u0027t think it can recurse indefinitely.\nBut it\u0027s not deterministic in sime way.\nIt only depends on the actual model which seems to be loaded \ndown to its very ends along the to-one containment references.\nSince the whole feature is ooptional and off by default, it\u0027s not\nthat important but I have the feeling that people who use it\nwill ask sooner or later how this feature scales with very deeply \nnested models...\n",
    "(In reply to comment #50)\n\u003e  (In reply to comment #47)\n\u003e \u003e About the controlled limitation.\n\u003e \u003e I think it cannot do an infinite loop.. so I believe it will terminate\n\u003e \u003e somewhere. It cannot continue indefinitely.. isn`t ?\n\u003e No, I don\u0027t think it can recurse indefinitely.\n\u003e But it\u0027s not deterministic in sime way.\n\u003e It only depends on the actual model which seems to be loaded \n\u003e down to its very ends along the to-one containment references.\n\u003e Since the whole feature is ooptional and off by default, it\u0027s not\n\u003e that important but I have the feeling that people who use it\n\u003e will ask sooner or later how this feature scales with very deeply \n\u003e nested models...\nThis feature collectionByContainment is always on.... should it be something we add and remove ?\n\nYes could be..\n\nBut rather to add depth..or an option ...   maybe it would be nice to add annotation on EMF model to support these things ? We can even use the same annotation as Hibernate!! :-)\n\nWhat do you think ?\n\n\n\nThe feature CollectionByRule is something that its on and off.\n",
    "With regard to adding an adapter, adding an adapter to the resource will only notify you object things that directly change the resource.  Each EObject is a separate notifier that\u0027s observed separately.  You can use an EContentAdapter to automatically add an adapter to all objects in the containment tree; be sure to call super in the notifyChanged method, since handling of notifications is how the adapter maintains itself on the children of the containment tree as they are added.",
    "(In reply to comment #52)\n\u003e With regard to adding an adapter, adding an adapter to the resource will only\n\u003e notify you object things that directly change the resource.  Each EObject is a\n\u003e separate notifier that\u0027s observed separately.  You can use an EContentAdapter\n\u003e to automatically add an adapter to all objects in the containment tree; be sure\n\u003e to call super in the notifyChanged method, since handling of notifications is\n\u003e how the adapter maintains itself on the children of the containment tree as\n\u003e they are added.\n\nIn my case I have millions of objects.. and I do not have them on the client necessarly right ?\n\nIf I do that... it will fetch all my objects from the database and bring them to the client space ? \n\n",
    "I suppose it might well do that, yes.  Perhaps setTarget(EObject) could be specialized in some way to deal with that...",
    "(In reply to comment #53)\n\u003e If I do that... it will fetch all my objects from the database and bring them\n\u003e to the client space ? \n\nI don\u0027t believe so.\nEd, is the adapter that is attached for the various generated/reflective UIs an EContentAdapter? I guess it is and it\u0027s implemented singleton-like.\n\nThe above mentioned adapter doesn\u0027t lead to loading whole resources in CDO and you don\u0027t necessarily need an adapter instance per notifier.\n",
    "No, in the UI we use a factory to create an adapter for an object is it\u0027s viewed so if you haven\u0027t viewed it, it won\u0027t be adapted.  In EContentAdapter automatically traverses the whole containment tree to attach itself to all existing nodes.",
    "Ok, that\u0027s not ideal for Simon\u0027s purpose but I guess there are other alternatives to ignore proxies on traversal...",
    "That\u0027s a very good point, which reminds me that EContentAdapter has a resolve method you can override to return false.  In that case it will attach to the proxies themselves and then update itself when the proxies are resolved.  This sounds like it should exactly meet the requirements of attaching only to in-memory instances.",
    "(In reply to comment #58)\n\u003e That\u0027s a very good point, which reminds me that EContentAdapter has a resolve\n\u003e method you can override to return false.  In that case it will attach to the\n\u003e proxies themselves and then update itself when the proxies are resolved.  This\n\u003e sounds like it should exactly meet the requirements of attaching only to\n\u003e in-memory instances.\n\nDoes the new objects that comes after will have an adapter as well ?\n\n\nSo the following code should really work ?\n\nEContentAdapter adapterA \u003d...;\n\nResource resource \u003d cdoView.getResourcePath(\"/test1\");\n\nresource.eAdapters().add( adapterA );\n\nEObject object1 \u003d cdoView.getObject(\u003cID\u003e);\n\n// My adapter should receive a message.\nobject1.setSupplier( supplier );\n\nI will create a testcase to reproduce it and open a new bugs in CDO.\n\n\n\n\n",
    "Created an attachment (id\u003d78395)\nTestCase - EContentAdapter\n\nMy test case shows that when we call \n\nresource.eAdapters().add( contentAdapter );\n\nIt will load objects contains by the resource.\n\nBut I`ve been notified!!\n\nThe expected behavior would be not to load any objects.\n\nAfter calling \n\nSupplier supplier \u003d (Supplier)transaction.getObject(supplierID);\n\nthe adapter should be added at this point automatically.\n\nSo I imagine that the only way to fix that problem using adapter would be to override some method... \nEven if I put adapter on each on them.... I found that I will have some overhead with this approach.. knowing I play with millions of objects... :-(\n\n\n",
    " (In reply to comment #60)\n\n I\u0027ve committed your test case and I can see the point.\n This is certainly not what one would expect.\n \n There\u0027s a line (427) in EContentsEList:\n\t\t if (isIncluded(feature) \u0026\u0026 (!useIsSet() || eObject.eIsSet(feature)))\n where eIsSet() leads to LoadRevisionRequest in the end.\n I\u0027m currently not sure what to do here.\n I\u0027m a bit surprised that  this code is called although you have overridden resolve() in your adapter.\n Can you please file a separate bug so that I don\u0027t forget about it?",
    "There\u0027s not an actual problem with EMF though right?  I would expect that the eIsSet guard is used, but of course if the list isn\u0027t empty, then we will traverse the list.  But it should traverse the basic list which should avoid resolving the containment proxies.\n\n  public List\u003cE\u003e basicList()\n  {\n    return\n      new EContentsEList\u003cE\u003e(eObject, eStructuralFeatures)\n      {\n        @Override\n        protected boolean resolve()\n        {\n          return false;\n        }\n      };\n  }",
    "Ed, I\u0027m not completely sure but my guess is that it relates with CDO proxies which are completely different from EMF proxies. Simon has filed bug# 203426 to track this issue. If you\u0027re interested in it, I suggest that you CC yourself. From my point of view you can remove your CC from this bug because it\u0027s unlikely that the further discussion here is of interest for you. Of course you\u0027re nonetheless invited to stay here ;-)",
    "(In reply to comment #15 and comment #53)\nSimon, \n\n\u003e In my case I have millions of objects.. and I do not have them on the client\n\u003e necessarly right ?\n\u003e \n\nAre these objects stored in different resources? if yes what is the ration of objects per resource?\nDo you have multiple root objects in your resources or you have one root object that holds a large list of children (as you mentioned that the depth is 4, which is pretty shallow)?\n\n\u003e Fetch 120 000 objects :\n\u003e ...\n\u003e With DynamicRule\n\u003e 141 request to the server\n\u003e 11890 objects/sec (I went over  12000 objects/sec ... but after it went down a\n\u003e little bit)\n\n12000 objects/sec is a pretty god number, please can you provide some information of the size of the objects (resources, equivalent XML/XMI size compressed/uncompressed with ZIP) and if their structure/hierarchy actually allows easy optimization of the load operation.\n\n\n",
    "(In reply to comment #64)\n\u003e (In reply to comment #15 and comment #53)\n\u003e Simon, \n\u003e \u003e In my case I have millions of objects.. and I do not have them on the client\n\u003e \u003e necessarly right ?\n\u003e \u003e \n\u003e Are these objects stored in different resources?\nYes, the same resource. \n\u003eif yes what is the ration of objects per resource?\n\nI don\u0027t understand the question... you mean ratio...\nIt really depends of the projects... we have resource that have few thousands...and others with millions...\n\n\n\u003e Do you have multiple root objects in your resources or you have one root object\n\u003e that holds a large list of children (as you mentioned that the depth is 4,\n\u003e which is pretty shallow)?\n\nYes, every accessible objects (except contained relationship) are at the root.\n\n\u003e \u003e Fetch 120 000 objects :\n\u003e \u003e ...\n\u003e \u003e With DynamicRule\n\u003e \u003e 141 request to the server\n\u003e \u003e 11890 objects/sec (I went over  12000 objects/sec ... but after it went down a\n\u003e \u003e little bit)\n\u003e 12000 objects/sec is a pretty god number, please can you provide some\n\u003e information of the size of the objects (resources, equivalent XML/XMI size\n\u003e compressed/uncompressed with ZIP) and if their structure/hierarchy actually\n\u003e allows easy optimization of the load operation.\n\nThe model used is the Model1.. so it is Purchaseporder, Company, Supplier, SalesOrder... etc.. \nThe benchmark are done using CDO and using a MemoryStore as my persistence layer. In my case, I wanted to be independant of the persistence layer. That being said, I\u0027ve obtain the same speed using a database as my store... In this case the objects would need to be in CDO cache in the server side ... otherwise I dropped a little bit.. 9000 objects/sec. But you still need to go through the transport layer...\n\nI will investigate to have the size of my objects... also I will try to provide a test case in CDO ... so we can know when performance goes down!!!!\n\nLet me know if you want to have more details !!\n\nSimon",
    "Fixed in I200710101638."
  ],
  "commentCreationDates": [
    "2007-09-03T13:46:36+02:00",
    "2007-09-06T03:08:37+02:00",
    "2007-09-06T11:50:38+02:00",
    "2007-09-06T14:05:53+02:00",
    "2007-09-07T04:31:31+02:00",
    "2007-09-07T04:32:36+02:00",
    "2007-09-07T10:10:45+02:00",
    "2007-09-07T11:27:46+02:00",
    "2007-09-07T11:57:27+02:00",
    "2007-09-07T12:36:39+02:00",
    "2007-09-07T13:04:20+02:00",
    "2007-09-07T13:17:48+02:00",
    "2007-09-07T15:35:02+02:00",
    "2007-09-07T15:50:37+02:00",
    "2007-09-08T19:46:37+02:00",
    "2007-09-09T16:05:33+02:00",
    "2007-09-10T09:35:38+02:00",
    "2007-09-10T11:48:09+02:00",
    "2007-09-10T12:48:26+02:00",
    "2007-09-10T12:50:05+02:00",
    "2007-09-10T15:05:01+02:00",
    "2007-09-12T04:09:32+02:00",
    "2007-09-12T09:43:49+02:00",
    "2007-09-12T12:59:53+02:00",
    "2007-09-12T13:07:19+02:00",
    "2007-09-12T13:28:14+02:00",
    "2007-09-12T14:08:51+02:00",
    "2007-09-12T14:21:16+02:00",
    "2007-09-12T14:51:02+02:00",
    "2007-09-12T14:51:38+02:00",
    "2007-09-12T17:34:02+02:00",
    "2007-09-12T17:38:30+02:00",
    "2007-09-12T17:44:55+02:00",
    "2007-09-12T17:54:23+02:00",
    "2007-09-12T18:04:10+02:00",
    "2007-09-12T18:10:09+02:00",
    "2007-09-12T18:36:27+02:00",
    "2007-09-12T18:41:05+02:00",
    "2007-09-12T18:41:30+02:00",
    "2007-09-12T19:03:00+02:00",
    "2007-09-12T19:07:30+02:00",
    "2007-09-12T19:10:55+02:00",
    "2007-09-12T19:57:38+02:00",
    "2007-09-12T19:59:36+02:00",
    "2007-09-12T23:51:14+02:00",
    "2007-09-13T00:20:51+02:00",
    "2007-09-13T02:53:50+02:00",
    "2007-09-13T03:06:19+02:00",
    "2007-09-13T10:00:27+02:00",
    "2007-09-13T10:08:36+02:00",
    "2007-09-13T10:12:46+02:00",
    "2007-09-13T13:18:06+02:00",
    "2007-09-13T13:18:38+02:00",
    "2007-09-13T13:28:57+02:00",
    "2007-09-13T13:40:04+02:00",
    "2007-09-13T14:06:23+02:00",
    "2007-09-13T14:09:51+02:00",
    "2007-09-13T14:13:28+02:00",
    "2007-09-13T15:17:21+02:00",
    "2007-09-13T15:41:33+02:00",
    "2007-09-14T03:00:49+02:00",
    "2007-09-14T11:00:00+02:00",
    "2007-09-14T13:08:19+02:00",
    "2007-09-14T13:49:49+02:00",
    "2007-09-14T17:39:55+02:00",
    "2007-09-14T18:29:44+02:00",
    "2007-10-16T11:25:03+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.net4j.util.ImplementationError",
      "message": "Unable to provideCDOID: org.eclipse.emf.cdo.tests.model1.impl.SupplierImpl",
      "elements": [
        {
          "method": "org.eclipse.emf.internal.cdo.CDOViewImpl.provideCDOID",
          "source": "CDOViewImpl.java:402"
        },
        {
          "method": "org.eclipse.emf.cdo.internal.protocol.revision.CDORevisionImpl.writeValues",
          "source": "CDORevisionImpl.java:691"
        },
        {
          "method": "org.eclipse.emf.cdo.internal.protocol.revision.CDORevisionImpl.write",
          "source": "CDORevisionImpl.java:137"
        },
        {
          "method": "org.eclipse.emf.internal.cdo.protocol.CommitTransactionRequest.writeRevisions",
          "source": "CommitTransactionRequest.java:123"
        },
        {
          "method": "org.eclipse.emf.internal.cdo.protocol.CommitTransactionRequest.writeNewObjects",
          "source": "CommitTransactionRequest.java:102"
        },
        {
          "method": "org.eclipse.emf.internal.cdo.protocol.CommitTransactionRequest.requesting",
          "source": "CommitTransactionRequest.java:64"
        },
        {
          "method": "org.eclipse.net4j.signal.RequestWithConfirmation.execute",
          "source": "RequestWithConfirmation.java:48"
        },
        {
          "method": "org.eclipse.net4j.signal.Signal.runSync",
          "source": "Signal.java:130"
        }
      ],
      "number": 0,
      "commentIndex": 21,
      "bugId": "202064",
      "date": "2007-09-12T04:09:32+02:00",
      "product": "EMFT",
      "component": "CDO",
      "severity": "enhancement"
    }
  ],
  "groupId": "202064",
  "bugId": "202064",
  "date": "2007-09-03T13:46:36+02:00",
  "product": "EMFT",
  "component": "CDO",
  "severity": "enhancement"
}