{
  "comments": [
    "this bug is a sequel to Bug #107898 (currently resolved), which apparently only\nfixed part of the problem.\n\nunder the same strange circumstances which enabled the first bug, @Override\nfails to work properly and overiding the method anyway does nothing:\n\n\nclass Bug_Provider {\n  public void enable_bug(Object argument) {}\n}\n\nclass Bug_Checker\u003cT\u003e extends Bug_Provider {\n  public T is_bug_enabled() {\n    return (T) new Boolean(true);\n  }\n}\n\npublic class Bug {\n  public static void main(String[] args) throws InterruptedException {\n    final Bug_Checker\u003cBoolean\u003e first \u003d new Bug_Checker\u003cBoolean\u003e() {\n      @Override // compiler agrees, this is an override\n      public Boolean is_bug_enabled() {\n        return new Boolean(false);\n      }\n    };\n    System.out.println(\"is bug enabled? \" + first.is_bug_enabled()); // false\n\n    first.enable_bug(null);\n\n    final Bug_Checker\u003cBoolean\u003e second \u003d new Bug_Checker\u003cBoolean\u003e() {\n      //@Override // compiler disagrees now!\n      public Boolean is_bug_enabled() {\n        return new Boolean(false);\n      }\n    };\n    System.out.println(\"is bug enabled? \" +second.is_bug_enabled()); // true!\n  }\n}\n\n\nnote that if the second override of is_bug_enabled is declared to return Object\ninstead, it does override the original method (although @Override thinks\notherwise). instead, the compiler should return an error, like it does when the\nbug is disabled.",
    "Well ... a last minute fix went in for a local type problem ... and it appears\nto be playing up a bit here, when I uncomment the 2nd @Override and compile the\nprogram, it blows up:\n\nC:\\Bug.java [error] Internal compiler error\njava.lang.IllegalStateException: Expecting raw type\n\tat org.aspectj.weaver.TypeFactory.createParameterizedType(TypeFactory.java:42)\n\tat org.aspectj.weaver.World.resolveToReferenceType(World.java:262)\n\tat org.aspectj.weaver.World.resolve(World.java:205)\n\tat org.aspectj.weaver.World.resolve(World.java:127)\n\tat\norg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromEclipse(EclipseFactory.java:125)\n\tat\norg.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getSuperclass(EclipseSourceType.java:115)\n\tat org.aspectj.weaver.ReferenceType.getSuperclass(ReferenceType.java:443)\n\tat\norg.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.methodMustOverride(AjProblemReporter.java:356)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:153)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1076)\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1105)\n\ntracing this a little further I put a breakpoint on EclipseSourceType.isGeneric\nand the binding being queried is:\n\nAnonymous type : (id\u003dNoId)\nfinal class $Local$ extends Bug_Checker\u003cjava.lang.Boolean\u003e\n\tenclosing type : Bug\n/*   methods   */\njava.lang.Boolean is_bug_enabled() \n\nwhen I would have expected it to answer TRUE.  Possibly an incorrect lookup of\n$Local$ has caused us to put a parameterized type in as the generic type when it\nshouldn\u0027t have...",
    "indeed, in my before-the-last-minute-fix version of ajc, uncommenting the second\noverride yields an error which does mention $Local$:\n\n\n[error] can\u0027t find type $Local$\n        \n[error] can\u0027t find type $Local$\n        \n/home/user/sgelin3/dev/java/ajc/108014-pending/Bug.java:25 [error] The method\nis_bug_enabled() of type new Bug_Checker\u003cBoolean\u003e(){} must override a superclass\nmethod\npublic Boolean is_bug_enabled() {\n               ^^^^^^^^^\n\n3 errors",
    "The $Local$ issue was occuring because we were trying to put out a message that\nthe method did not override the super method (and at the point the message was\nissued, we hadn\u0027t assigned a constant pool name to the inner type). \n\nThe underlying bug was that we didn\u0027t think the method overrode a super method.\nThe call to enable_bug(null) was signifcant in that it caused us to go looking\nup the hierarchy for an exact method match, based on the inferred argument type.\nWhen passing an Object this finds the method in Bug_Provider that takes an\nObject. When passing null that method is only seen as a *candidate* match, and\nwe have to do some more work. In the \"more work\" we happened to also look at\nITDs made on the type (none in this case) and a horrible side-effect of not\nfinding any was to remove all knowledge of methods in the type of the receiver\n(in your program, the type of first). This erased all trace of is_bug_enabled in\nthe anonymous Bug_Checker\u003cBoolean\u003e class , leaving the program to bind the\nsecond message send to the supertype method and also causing the bad override\nmessage.\n\nThis whole mess should now be cleared up, and a fix is checked into the tree.\nWe\u0027re going to release 1.5.0 M3a with the fix for this bug and also bug 108050\nincluded."
  ],
  "commentCreationDates": [
    "2005-08-25T19:17:38+02:00",
    "2005-08-25T20:13:01+02:00",
    "2005-08-25T21:20:11+02:00",
    "2005-08-26T13:58:07+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.IllegalStateException",
      "message": "Expecting raw type",
      "elements": [
        {
          "method": "org.aspectj.weaver.TypeFactory.createParameterizedType",
          "source": "TypeFactory.java:42"
        },
        {
          "method": "org.aspectj.weaver.World.resolveToReferenceType",
          "source": "World.java:262"
        },
        {
          "method": "org.aspectj.weaver.World.resolve",
          "source": "World.java:205"
        },
        {
          "method": "org.aspectj.weaver.World.resolve",
          "source": "World.java:127"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromEclipse",
          "source": "EclipseFactory.java:125"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getSuperclass",
          "source": "EclipseSourceType.java:115"
        },
        {
          "method": "org.aspectj.weaver.ReferenceType.getSuperclass",
          "source": "ReferenceType.java:443"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.methodMustOverride",
          "source": "AjProblemReporter.java:356"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements",
          "source": "MethodDeclaration.java:153"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve",
          "source": "AbstractMethodDeclaration.java:400"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:1076"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve",
          "source": "TypeDeclaration.java:1105"
        }
      ],
      "number": 0,
      "commentIndex": 1,
      "bugId": "108014",
      "date": "2005-08-25T20:13:01+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "108014",
  "bugId": "108014",
  "date": "2005-08-25T19:17:38+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}