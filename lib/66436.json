{
  "comments": [
    "Build: I20040609 1200\n\nIf code that runs as a result of dispatching a command cancels, it is now\nreported in the UI with an error dialog that says, \"The command for the key you\npressed failed\". Cancelation (signalled by OperationCanceledException) should\nnot be reported to the user as a failure. This seems to have only changed\nrecently (since RC1).  Here is the log entry that is created:\n\n!ENTRY org.eclipse.ui 4 0 Jun 09, 2004 17:48:57.999\n!MESSAGE The command for the key you pressed failed\n!STACK 0\norg.eclipse.core.runtime.OperationCanceledException\n\tat java.lang.Throwable.\u003cinit\u003e(Throwable.java)\n\tat\norg.eclipse.core.runtime.OperationCanceledException.\u003cinit\u003e(OperationCanceledException.java:22)\n\tat org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:147)\n\tat org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:87)\n\tat org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:170)\n\tat org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:95)\n\tat\norg.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:1628)\n\tat org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1668)\n\tat\norg.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:744)\n\tat org.eclipse.jdt.internal.core.JavaProject.setRawClasspath(JavaProject.java:2650)\n\tat org.eclipse.jdt.core.JavaCore$3.run(JavaCore.java:3433)\n\tat\norg.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:34)\n\tat\norg.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:700)\n\tat org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1673)\n\tat org.eclipse.jdt.core.JavaCore.run(JavaCore.java:3246)\n\tat org.eclipse.jdt.core.JavaCore.setClasspathContainer(JavaCore.java:3416)\n\tat\norg.eclipse.pde.internal.core.ModelEntry.updateClasspathContainer(ModelEntry.java:109)\n\tat\norg.eclipse.pde.internal.core.RequiredPluginsInitializer.initialize(RequiredPluginsInitializer.java:40)\n\tat\norg.eclipse.jdt.internal.core.JavaModelManager.initializeContainer(JavaModelManager.java:1248)\n\tat\norg.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:1222)\n\tat\norg.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:833)\n\tat org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:1184)\n\tat\norg.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1888)\n\tat\norg.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1798)\n\tat\norg.eclipse.jdt.internal.core.search.JavaSearchScope.add(JavaSearchScope.java:78)\n\tat\norg.eclipse.jdt.internal.core.search.JavaWorkspaceScope.initialize(JavaWorkspaceScope.java:80)\n\tat\norg.eclipse.jdt.internal.core.search.JavaSearchScope.\u003cinit\u003e(JavaSearchScope.java:52)\n\tat\norg.eclipse.jdt.internal.core.search.JavaWorkspaceScope.\u003cinit\u003e(JavaWorkspaceScope.java:31)\n\tat\norg.eclipse.jdt.core.search.SearchEngine.createWorkspaceScope(SearchEngine.java:424)\n\tat org.eclipse.jdt.internal.ui.actions.OpenTypeAction.run(OpenTypeAction.java:54)\n\tat org.eclipse.jdt.internal.ui.actions.OpenTypeAction.run(OpenTypeAction.java:80)\n\tat org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:276)\n\tat org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:206)\n\tat org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:141)\n\tat org.eclipse.ui.internal.commands.Command.execute(Command.java:132)\n\tat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:469)\n\tat org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:887)\n\tat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:928)\n\tat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:546)\n\tat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.access$2(WorkbenchKeyboard.java:494)\n\tat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard$1.handleEvent(WorkbenchKeyboard.java:259)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java)\n\tat org.eclipse.swt.widgets.Display.filterEvent(Display.java:713)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:795)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:820)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:805)\n\tat org.eclipse.swt.widgets.Control.sendKeyEvent(Control.java:1725)\n\tat org.eclipse.swt.widgets.Control.sendKeyEvent(Control.java:1721)\n\tat org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:3049)\n\tat org.eclipse.swt.widgets.Control.windowProc(Control.java)\n\tat org.eclipse.swt.widgets.Display.windowProc(Display.java)\n\tat org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)\n\tat org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1460)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2383)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1362)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1333)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:252)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:141)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:96)\n\tat\norg.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:334)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:272)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:128)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:79)\n\tat\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:41)\n\tat java.lang.reflect.Method.invoke(Method.java:386)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:185)\n\tat org.eclipse.core.launcher.Main.run(Main.java:638)\n\tat org.eclipse.core.launcher.Main.main(Main.java:622)",
    "The problem is in the commands actionHandler\n\n /**\n     * @see IHandler#execute(Map)\n     */\n    public Object execute(Map parameterValuesByName) throws ExecutionException \n{\n        if ((action.getStyle() \u003d\u003d IAction.AS_CHECK_BOX)\n                || (action.getStyle() \u003d\u003d IAction.AS_RADIO_BUTTON))\n                action.setChecked(!action.isChecked());\n        try {\n            action.runWithEvent(new Event());\n        } catch (Exception e) {\n            throw new ExecutionException(\n                    \"While executing the action, an exception occurred\", e); //\n$NON-NLS-1$\n        }\n        return null;\n    }\nAs this catches all of them it will also catch cancellations",
    "I am happy to let OperationCancelledExceptions to percolate up from here, but I \nhave one concern.  John, you say that this is a recent change, but this code \nhasn\u0027t changed in quite a while.  Has something changed in the underlying jobs \ncode that would make this happen? ",
    "It was my hunch that this changed recently, but looking at the code, I agree it\ndoesn\u0027t look like the commands have changed recently. It turns out that this\nparticular cancelation was a regression (see bug 66437), but it is still\npossible for it to happen after the JDT fix.\n\nI suspect this has not been seen because the large majority of commands will run\nlong running operations in the JFace ModalContext, which converts\nOperationCanceledException into the checked exception InterruptedException,\nwhich must then be caught and handled explicitly by the action. One could argue\nthat action handlers should not be throwing OperationCanceledException, but as a\nlast line of defence I still thing it should be handled by the command\ninfrastructure (perhaps just logged but not with an error dialog to the user?)\nCCing Nick for a second (or third) opinion on how and by whom cancelation should\nbe handled.\n\nI have also logged another bug against JDT for this (bug 66541), since the stack\nillustrates that the open type command is doing long running work in the UI\nthread without some form of runnable context (progress dialog, etc).",
    "Neither the JFace action framework nor the commands mechanism have ever had\nspecial handling for OperationCanceledException.  This needs to be handled by\nthe action itself (JDT\u0027s OpenTypeAction).  If it\u0027s not aware of the possibility\nof this exception, then it needs to handled lower down in its call chain, e.g.\nby whoever calls IWorskpace.run, which is spec\u0027ed to throw\nOperationCanceledException.\n\n",
    "The operation canceled excpetion is thrown by a method that doesn\u0027t take a \nprogess monitor. So far we only expected operation cancel exceptions or \ninterrupted exceptions in cases where we passed a progress monitor. Following \nNick arguments clients now have to wrap all calls with a try/catch \nOperationCanceledException. Is this really something we want to do ?\n\nCC Philippe, since the operation cancel exception is thrown by \nSearchEngine.createWorkspaceScope.",
    "This was raised and discussed in detail in bug 57594, but I don\u0027t know how it\nwas eventually resolved.",
    "The dialog that shows up in this case to the user is scary:\n\nThe command for the you pressed failed\n  Reason:\n   The command for the key you pressed failed\n\nTherefore we should add a band-aid for 3.0. Once the band-aid is in it should \nbe tagged with 3.1.",
    "Erich, are you suggesting a band-aid in the open type dialog, or in the platform\ncommand support? Since the JFace ModalContext handles\nOperationCanceledException, there is some precedent for handling it at the\nplatform level. In 3.0 OperationCanceledException will be more common than\nbefore, since we now have a \"default progress monitor\" that opens a dialog\nwhenever any lock is blocked in the UI thread, and the user is always allowed to\ncancel it, causing OperationCanceledExceptions that were not previously possible.",
    "Unfortunatly, it is a local band-aid only in the Open Type dialog action, \ni.e., the OperationCanceledException will be caught so that it doesn\u0027t \npropagate. \n\nI understand that this doesn\u0027t fully address the problem. This scenario \nillustrates the more general problem nicely:\n1) the OpenTypeAction calls SearchEngine.createWorkspaceScope()\n   -\u003e the API doesn\u0027t take a ProgressMonitor\n   -\u003e the signature doesn\u0027t declare an exception\n   -\u003e the method returns a non-null search scope.\n2) createWorkspaceScope calls a method which takes progress monitor\n   as a side effect.\n3) null gets passed\n4) the UI is blocked and the user operation is canceled\n\nAn OperationCanceledException is fired and caught by the Command \ninfrastructure.\n\nGiven the current API to create a workspace scope I don\u0027t see how this problem \ncan be addressed at the platform level. Do you have ideas?",
    "I was just suggesting that when OperationCanceledException is caught and handled\n(in WorkbenchKeyboard.logException), it could silently log the failure but not\nopen the \"scary\" dialog for the user. Logging the exception (rather than\nignoring it) makes sense because it should not have reached that level and\nshould have been handled higher up in the call chain.",
    "Supressing the error dialog in the case of an OperationCanceledException in \nWorkbenchKeyboard is the better band-aid and I\u0027m favor of doing this.\n\nCC-ing Michael.",
    "Created an attachment (id\u003d12306)\nAnother cancelation reported as error in RC2\n",
    "Erich, the stack trace attached from John is an operation canceled exception \nthrown when the package explorer content provider fetches children from the \nJava model. The only hack I can think of for 3.0 is to catch this exception \nand return an empty array of children. The problem with this is that this \nproject will never have children then unless the user open/closes the project \nor the package explorer. Any opinion ?\n\nIMO we need a better story for this post 3.0 since putting \"random\" band-aids \ninto your code doesn\u0027t seem to be the right solution. As createWorkbenchScope \ngetPackageFragmentRoots doesn\u0027t take a progess monitor.",
    "I find it strange that OperationCanceledException is thrown at all by the\ninfrastructure.  Previously, this would only be thrown by the operation itself,\nafter explicitly checking:\n \tif (monitor.isCanceled())\n\t\tthrow new OperationCanceledException();\n\nSo even if it ran the operation in a progress dialog (or other runnable context)\nthat allowed cancel, and the user hit cancel, OperationCanceledException would\nonly be thrown if the operation checked monitor.isCanceled() and decided to\nthrow it.\n",
    "We discussed this and as far as I can remember the problem is as follows:\n\n- blocking dialog is up\n- user presses the cancel button\n- since the actual thread/operation to be canceled is blocked it can\u0027t\n  check isCanceled(), so the infra structure decides to throw the exception\n  \"on behalf\" of the operation.\n\nBut I agree that this is strange and we should definitelly come up with a \nbetter solution here. One idea would be that the caller of run(Operation...) \nhas to provide a cancel handler which gets control when the user presses the \ncancel button.",
    "Created an attachment (id\u003d12337)\nPatch for the OpenTypeAction.\n",
    "Re comment #14 - the API being called in both of these cases is IWorkspace.run.\nThis method takes a progress monitor and can throw OperationCanceledException.\nThe implementation of IWorkspace.run will throw OperationCanceledException\nwhen all of the following conditions are true:\n\n1) An operation is running in the UI thread\n2) The operation has become blocked by activity in another thread.\n3) The progress monitor is null.\n4) The user has clicked cancel in the progress dialog that we open in this\nsituation.\n\nThis is new in 3.0 (since M4) - the old behavior was lengthy hangs with no\npainting of the UI. Most of these cases end up being involved with classpath\ncomputation, which presumably only began to perform locking operations with the\nintroduction of classpath containers. The longer term solution is to avoid long\nlocking operations when in the UI thread, or within API calls that have no\nprogress monitor parameter. This has been discussed at length in bug 57594\nand bug 57181. I was only suggesting a workaround to handle this situation a bit\nbetter - I know it is not the right answer.",
    "Fix released for OpenTypeAction. Reviewed by Martin Aeschlimann.",
    "The operation canceled exception thrown when the user expnads a node in the \ntree has to be handled by JFace. The only change JDT/UI could do is to catch \nthe exception in the content provider and then returning an empty array. But \nthis would mean that the \"node\" is dead. Meaning although it has children it \ncan never be expanded again.\n\nJFace could detect this case in expand node and could still keep the dummy \nchild element so that the node can be expanded again.\n\nMoving to Platform/UI for consideration.",
    "doug please investigate what we can do here regarding comment #19",
    "I believe Dirk is referring to IStructuredContentProvider.getElements().  \nUnfortunately, this method is called by more than just \nStructuredViewer.getRawChildren().  It is called by the following methods: \n+ StructuredViewer.getRawChildren(Object) \n+ CheckedTreeSelectionDialog.createSelectionButtons(Composite) \n+ CheckedTreeSelectionDialog.evaluateIfTreeEmpty(Object) \n+ ElementTreeSelectionDialog.evaluateIfTreeEmpty(Object) \n+ ListSelectionDialog.okPressed() \n+ ResourceTreeAndListGroup.aboutToOpen() (and several other methods) \n+ CheckboxTreeAndListGroup.aboutToOpen() (and several other methods) \n+ NewProgressViewer.contentProviderGetRoots(Object) \n+ ActionSelectAll.run() \n \nThis is a lot of places to try to defend against OperationCanceledExceptions, \nwhen (ultimately) it is the structured content provider that knows whether this \nkind of exception can be thrown. \n \nI think the \"right\" solution, might be to create an \nIStructuredContentProvider2, which allows for a concept of cancellation. \n \nDeferring the remainder of this fix from RC3.  After 3.0, we will consider this \nfix.  Changing to the \"Viewers\" component, and moving back to Tod (current \nowner of viewers). ",
    "Douglas,\n\nwouldn\u0027t it be enought to fix this bug to handle the operation canceled \nexception in AbstractTreeViewer.createChildren ?",
    "From my perspective, that would be fixing one particular place where things \ncould go wrong, while leaving the others broken.  This seems wrong.  Unless you \nthink that IStructuredContentViewers used in those other cases will never use \nthe jobs infrastruction...? \n \nBut then again, this in\u0027t my area of expertise, so I might be missing something \nhere. ",
    "It seems like a losing battle to handle cancelation in the viewer framework. I\nwould expect it to just percolate up to the event loop and be handled by the\nworkbench advisor\u0027s exception handler - allowing the app to decide how they want\nto handle cancelation.",
    "It would be possible to make viewers be aware of cancelation, either via new API\nor having it handle OperationCanceledException (although we generally try to\nminimize the dependencies on runtime from JFace).\nJust having it percolate up to the event loop may leave the viewer in an\ninconsistent state.  For example, in AbstractTreeViewer.handleTreeExpand, it\ncalls createChildren.  This deletes any dummy element (needed to show the +),\nthen asks for the child elements from the content provider, then creates the\ncorresponding SWT items.  If the call to the content provider fails, either due\nto an OperationCanceledException or some other exception, then the parent node\nwill be expanded but will have no children.  Fortunately, looking at the way\ncreateChildren is implemented, it should ask the content provider again if the\nparent node is collapsed and then expanded again.\n",
    "We (Nick, John, Doug and myself) have discussed this and have come to the \nconsensus that allowing an OperationCancelledException through is a \nprogramming error as Nick says.\n\nHowever we think that it would be best that the commands support uses the \nexception handling from the WorkbenchAdvisor rather than its own.\n\nForwarding to Doug for that work.",
    "Can you please advise what a content provider should do in this situation to \navoid that the viewer ends up in a dead state. \n\n",
    "The root of the problem in these JDT cases is the classpath container\ninitialization that locks the workspace when calling seemingly read-only Java\nmodel methods. This is unexpected from the point of view of a UI-based caller,\nso they do not fork the call into a background thread. and can easily result in\nthe UI thread being locked unexpectedly. In another bug I suggested the\npossibility of JDT core persisting the value of classpath containers between\nsessions, removing the need to perform this complex container initialization at\nthe start of every session. Then JDT UI could then safely call these methods\nwithout fear of locking or cancelation.\n\nFrom the JFace viewer point of view, OperationCanceledException is just another\nruntime exception. As long as viewers are able to recover gracefully from\nruntime exceptions (as comment #25 suggests), then I don\u0027t see what else they\nneed to do.",
    "Comment #26 gives the impression that Platform/UI decided to not handle the \ncase of a canceled getChildren call in the viewers. If this isn\u0027t the case \nthen skip the rest of this comment.\n\nIMO we have the following \"general\" situation:\n\n- methods can throw an OperationCancelException. This is especially true if\n  the method takes a progress monitor.\n\n- if a content provider calls such a method it must deal with the operation\n  cancel exception\n\n- due to the current implementation of the Tree Viewer there is nothing the\n  content provider can do to avoid that the node to be expanded gets dead.\n\nSo we need some additional API to signal such a situation to the Viewer. I see \ntwo possibilities:\n\n- the content provider API takes a progress monitor and is allowed to throw\n  an OperationCancelException or an InterruptedException.\n\n- we get some additional API on a viewer to inform it about the cancelation\n  of a getChildren/getElement call\n\nEven if JDT/Core would fork the call into the background then the only \ndifference would be the type of the exception. We would get an Interrupted \nexception not a OperationCancelException. But the content provider would still \nneed to signal the cancelation to the viewer.",
    "Without introducing new API, it may be possible to force the viewer to \"fix\"\nitself after a cancelation, e.g. using setExpanded and/or refresh(Object).  This\nmay need to be done outside the expand callback.  Note that refresh will drop\nthe children if the parent node is collapsed, causing it to request the children\nagain the next time it\u0027s expanded.\n\nHowever, I think we really need to step back and think about how to really make\nthe viewer framework able to handle long running operations and also\ncancelation, and simplify this for the programmer.\n",
    "At the very least, the key binding architecture shouldn\u0027t handle the exception \nitself.  It should pass it through the WorkbenchAdvisor.  I\u0027ll do that piece of \nthe work to start with. \n \nIt might be appropriate to open a separate bug to deal with the \nOperationCanceledException in general.  I\u0027m not sure, but this seems like a \ndesign flaw.  RuntimeExceptions can interrupt the flow of execution (leaving \npartially initialized data).  So, doesn\u0027t this mean that any place we call out \nto third-party plug-ins (from UI code) we need to defend against \nRuntimeExceptions?  I mean, this was always the case, but the \nOperationCanceledException seems like it might make this a little easier to \ntrigger. \n ",
    "I\u0027ve decided not to make any changes to the command architecture regarding how\nit deals with exceptions.  I had a previous request to ensure that a dialog\nopens if a command fails (Bug 52138), and I still believe that this is the right\nthing to do.  Unfortunately, the WorkbenchAdvisor does not currently do this,\nnor do I feel that it is necessarily the right thing for the WorkbenchAdvisor to do.\n\nThere might be something that can be done by the JFace framework to better\nhandle OperationCanceledExceptions.  In particular, there is a sub-thread in\nthis bug talking about viewers.  I would recommend that, if this is still\nimportant, a separate bug be opened.",
    "Open bug 92347 to track the problem with the stale viewer in the present of\nruntime exceptions."
  ],
  "commentCreationDates": [
    "2004-06-10T00:17:59+02:00",
    "2004-06-10T16:34:12+02:00",
    "2004-06-10T16:36:39+02:00",
    "2004-06-10T18:24:06+02:00",
    "2004-06-10T19:16:07+02:00",
    "2004-06-10T19:37:33+02:00",
    "2004-06-10T20:36:23+02:00",
    "2004-06-16T11:44:16+02:00",
    "2004-06-16T17:54:28+02:00",
    "2004-06-16T18:11:19+02:00",
    "2004-06-16T18:19:23+02:00",
    "2004-06-16T20:34:32+02:00",
    "2004-06-16T20:39:40+02:00",
    "2004-06-16T23:24:53+02:00",
    "2004-06-16T23:31:22+02:00",
    "2004-06-16T23:43:09+02:00",
    "2004-06-16T23:44:10+02:00",
    "2004-06-17T00:04:57+02:00",
    "2004-06-17T11:01:49+02:00",
    "2004-06-17T14:35:44+02:00",
    "2004-06-17T19:46:09+02:00",
    "2004-06-17T21:08:00+02:00",
    "2004-06-18T02:12:43+02:00",
    "2004-06-18T02:48:46+02:00",
    "2004-06-18T16:05:18+02:00",
    "2004-06-23T19:07:16+02:00",
    "2004-07-05T22:24:13+02:00",
    "2004-07-06T12:19:54+02:00",
    "2004-07-06T16:29:53+02:00",
    "2004-07-06T18:16:38+02:00",
    "2004-07-06T20:59:43+02:00",
    "2004-07-15T00:18:52+02:00",
    "2005-04-21T22:30:13+02:00",
    "2005-04-22T10:43:27+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.core.runtime.OperationCanceledException",
      "elements": [
        {
          "method": "java.lang.Throwable.\u003cinit\u003e",
          "source": "Throwable.java"
        },
        {
          "method": "org.eclipse.core.runtime.OperationCanceledException.\u003cinit\u003e",
          "source": "OperationCanceledException.java:22"
        },
        {
          "method": "org.eclipse.core.internal.jobs.ThreadJob.joinRun",
          "source": "ThreadJob.java:147"
        },
        {
          "method": "org.eclipse.core.internal.jobs.ImplicitJobs.begin",
          "source": "ImplicitJobs.java:87"
        },
        {
          "method": "org.eclipse.core.internal.jobs.JobManager.beginRule",
          "source": "JobManager.java:170"
        },
        {
          "method": "org.eclipse.core.internal.resources.WorkManager.checkIn",
          "source": "WorkManager.java:95"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.prepareOperation",
          "source": "Workspace.java:1628"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.run",
          "source": "Workspace.java:1668"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.runOperation",
          "source": "JavaModelOperation.java:744"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.setRawClasspath",
          "source": "JavaProject.java:2650"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore$3.run",
          "source": "JavaCore.java:3433"
        },
        {
          "method": "org.eclipse.jdt.internal.core.BatchOperation.executeOperation",
          "source": "BatchOperation.java:34"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.run",
          "source": "JavaModelOperation.java:700"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.run",
          "source": "Workspace.java:1673"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore.run",
          "source": "JavaCore.java:3246"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore.setClasspathContainer",
          "source": "JavaCore.java:3416"
        },
        {
          "method": "org.eclipse.pde.internal.core.ModelEntry.updateClasspathContainer",
          "source": "ModelEntry.java:109"
        },
        {
          "method": "org.eclipse.pde.internal.core.RequiredPluginsInitializer.initialize",
          "source": "RequiredPluginsInitializer.java:40"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelManager.initializeContainer",
          "source": "JavaModelManager.java:1248"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers",
          "source": "JavaModelManager.java:1222"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer",
          "source": "JavaModelManager.java:833"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore.getClasspathContainer",
          "source": "JavaCore.java:1184"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1888"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1798"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.JavaSearchScope.add",
          "source": "JavaSearchScope.java:78"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.JavaWorkspaceScope.initialize",
          "source": "JavaWorkspaceScope.java:80"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.JavaSearchScope.\u003cinit\u003e",
          "source": "JavaSearchScope.java:52"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.JavaWorkspaceScope.\u003cinit\u003e",
          "source": "JavaWorkspaceScope.java:31"
        },
        {
          "method": "org.eclipse.jdt.core.search.SearchEngine.createWorkspaceScope",
          "source": "SearchEngine.java:424"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.actions.OpenTypeAction.run",
          "source": "OpenTypeAction.java:54"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.actions.OpenTypeAction.run",
          "source": "OpenTypeAction.java:80"
        },
        {
          "method": "org.eclipse.ui.internal.PluginAction.runWithEvent",
          "source": "PluginAction.java:276"
        },
        {
          "method": "org.eclipse.ui.internal.WWinPluginAction.runWithEvent",
          "source": "WWinPluginAction.java:206"
        },
        {
          "method": "org.eclipse.ui.commands.ActionHandler.execute",
          "source": "ActionHandler.java:141"
        },
        {
          "method": "org.eclipse.ui.internal.commands.Command.execute",
          "source": "Command.java:132"
        },
        {
          "method": "org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand",
          "source": "WorkbenchKeyboard.java:469"
        },
        {
          "method": "org.eclipse.ui.internal.keys.WorkbenchKeyboard.press",
          "source": "WorkbenchKeyboard.java:887"
        },
        {
          "method": "org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent",
          "source": "WorkbenchKeyboard.java:928"
        },
        {
          "method": "org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings",
          "source": "WorkbenchKeyboard.java:546"
        },
        {
          "method": "org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$2",
          "source": "WorkbenchKeyboard.java:494"
        },
        {
          "method": "org.eclipse.ui.internal.keys.WorkbenchKeyboard$1.handleEvent",
          "source": "WorkbenchKeyboard.java:259"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.filterEvent",
          "source": "Display.java:713"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:795"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:820"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:805"
        },
        {
          "method": "org.eclipse.swt.widgets.Control.sendKeyEvent",
          "source": "Control.java:1725"
        },
        {
          "method": "org.eclipse.swt.widgets.Control.sendKeyEvent",
          "source": "Control.java:1721"
        },
        {
          "method": "org.eclipse.swt.widgets.Control.WM_CHAR",
          "source": "Control.java:3049"
        },
        {
          "method": "org.eclipse.swt.widgets.Control.windowProc",
          "source": "Control.java"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.windowProc",
          "source": "Display.java"
        },
        {
          "method": "org.eclipse.swt.internal.win32.OS.DispatchMessageW",
          "source": "Native Method"
        },
        {
          "method": "org.eclipse.swt.internal.win32.OS.DispatchMessage",
          "source": "OS.java:1460"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:2383"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1362"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1333"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:252"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:141"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:96"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:334"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:272"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:128"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:79"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:41"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:386"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:185"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:638"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:622"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "66436",
      "date": "2004-06-10T00:17:59+02:00",
      "product": "Platform",
      "component": "UI",
      "severity": "major"
    }
  ],
  "groupId": "66436",
  "bugId": "66436",
  "date": "2004-06-10T00:17:59+02:00",
  "product": "Platform",
  "component": "UI",
  "severity": "major"
}