{
  "comments": [
    "I just downloaded AJDT version 1.2.0.20050124144759 and I am running Eclipse\n3.1M4.  I tried to use aspectJ on an existing Java 5 project.  There are no\naspects in it yet, just straight Java 5.  The project runs just fine as a\nstandard Java project. \n\nWhen add the AspectJ nature and I try to compile the project, no class files are\ngenerated and I get this error generated on a type that is parameterized:\n\nInternal compiler error\norg.aspectj.weaver.BCException: Bad type name: \n\n\tat org.aspectj.weaver.TypeX.nameToSignature(TypeX.java:634)\n\n\tat org.aspectj.weaver.TypeX.forName(TypeX.java:87)\n\n\tat\norg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:155)\n\n\tat\norg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:163)\n\n\tat\norg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:229)\n\n\tat\norg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224)\n\n\tat\norg.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:675)\n\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.traverse(ConstructorDeclaration.java:447)\n\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1133)\n\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:314)\n\n\tat\norg.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:171)\n\n\tat\norg.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:111)\n\n\tat\norg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:354)\n\n\tat\norg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:138)\n\n\tat\norg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:373)\n\n\tat\norg.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682)\n\n\tat\norg.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)\n\n\tat\norg.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)\n\n\tat org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)\n\n\tat\norg.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165)\n\n\nThe source code of the file that generates this error is:\n\npackage mj.compiler.ast;\n\nimport java.util.Vector;\n\nimport mj.compiler.Driver;\nimport mj.compiler.Visitor;\n\npublic class Sequence\u003cT extends AST\u003e extends AST {\n\t\n\tprivate Vector\u003cT\u003e elements \u003d new Vector\u003cT\u003e();\n\t\n\tpublic Sequence() {\n\t\tsuper(0, 0);\n    }\n\t\n\tpublic Sequence(T element) {\n\t\tsuper(element);\n\t\telements.add(element);\n    }\n    \n\tpublic int length()       { return elements.size(); }\n\tpublic T elementAt(int i) { return elements.elementAt(i); }\n\n    public Sequence add(T element) {\n    \telements.add(element);\n\t\treturn this;\n    }\n    \n    public Sequence add(int pos, T element) {\n    \telements.add(pos, element);\n    \treturn this;\n    }\n    \n    public Sequence addAll(Sequence\u003cT\u003e others) {\t\t\n\t\tif(  others \u003d\u003d null ) return this;\n\t\telements.addAll(others.elements);\n\t\treturn this;\n    }\n    \n    public void visitChildren(Visitor v) {\n    \tfor( AST element : elements ) {\n    \t\telement.visit(v);\n        }\n    }\n    \n    public void replaceChild(AST old, AST gnu) {\n    \tT NEW \u003d (T)gnu;\n    \tfor(int i \u003d 0; i \u003c elements.size(); i++ ) {\n    \t\tif( elements.get(i) \u003d\u003d old ) {\n    \t\t\telements.set(i, NEW);\n    \t\t\treturn;\n    \t\t}\n    \t}\n    \tthrow new Driver.CompileError(\"Can\u0027t find child in replaceChild.\");\n    }\n\n\t/*** START GENERATED VISITOR PROTOCOL ***///TODO\n    public void visit(mj.compiler.Visitor v) {\n        v.visitSequence(this);\n    }\n\t/*** END GENERATED VISITOR PROTOCOL ***/\n}\n\n\nHope this helps something.\n\nps- I am able to create and run a very simple AspectJ project with an aspect,\nadvice, and some Java 5 syntax.",
    "This looks like the weaver code that builds the structure model for ajdt is\nchoking on some generic type name its not expecting to see. I\u0027m reassigning to\nAndy temporarily as I\u0027m on a plane the next two days...",
    "I\u0027ve recreated from the command line by compiling that type with -emacssym\n(which generated the ASM).  Adrian is correct that we choke on the generic\nsignature.\n\nAlthough not all that helpful a temporary workaround is to turn off structure\nmodel building in the project properties, it should then compile the code\nsuccessfully (but the xref view will be empty...)",
    "I think I know what\u0027s going wrong here and will plan on fixing it this week.",
    "Andy: the ASM part of this is fixed, but note the following caveat.\n\nThe problem was that the weaver\u0027s TypeX.nameToSignature(String name) can\u0027t \nhandle generic return types, for example the \"T\" in:\n\npublic T elementAt(int i) {\n  return elements.elementAt(i);\n}\n\nI\u0027ve made the AsmHierarchyBuilder robust to that problem, which means that \nwhen building a signature it will put \u003cundefined\u003e whenever the weaver can\u0027t \nresolve a name.  I committed a minimal test of this to, which now passes (if \nthe single test is uncommented and 1.5 is required).\n\n/ajde/testsrc/org/aspectj/ajde/GenericsTest.java\n\nNote that the hierarchy of the structure model is correct, although it would \nbe nice to get the right type name in there for clients that make use the \nbytecode signature.  I\u0027ll leave this open in case you want to use this test \ncase to experiment.  In that case you may also want to inspect the catch catch\n(BCException) clause in AsmHierarchyBuilder.",
    "lets take one more look at this one before closing out m2...",
    "the fix for bug 843333 should ensure that TypeX.forName never sees a\nparameterized type. This is certainly good enough for m2. Moving the bug to m3\nwhere we will pass parameterized types through in all probability.",
    "(In reply to comment #4)\n\u003e The problem was that the weaver\u0027s TypeX.nameToSignature(String name) can\u0027t \n\u003e handle generic return types, for example the \"T\" in:\n\u003e \n\u003e public T elementAt(int i) {\n\u003e   return elements.elementAt(i);\n\u003e }\nI\u0027ve encountered the same problem using AJDT 1.2.0.200503135046 AND Eclipse\n3.1M6, only my class has no methods with a generic return type or generic\nparameters.\n\n\u003d\u003d\u003d Source for my file \u003d\u003d\u003d\npackage com.merklenet.test.mock;\n\nimport java.rmi.MarshalledObject;\nimport java.rmi.RemoteException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.merklenet.knowledgelink.prototype.framework.Envelope;\nimport com.merklenet.knowledgelink.prototype.framework.ServiceIdentifier;\n\nimport net.jini.core.entry.Entry;\nimport net.jini.core.entry.UnusableEntryException;\nimport net.jini.core.event.EventRegistration;\nimport net.jini.core.event.RemoteEventListener;\nimport net.jini.core.lease.Lease;\nimport net.jini.core.transaction.Transaction;\nimport net.jini.core.transaction.TransactionException;\nimport net.jini.space.JavaSpace;\n\npublic class MockJavaSpaceForEnvelopes implements JavaSpace {\n   private Map\u003cServiceIdentifier, Set\u003cEnvelope\u003e\u003e envelopes \u003d \n      new HashMap\u003cServiceIdentifier, Set\u003cEnvelope\u003e\u003e();\n\n   public MockJavaSpaceForEnvelopes() {\n      super();\n   }\n\n   public Lease write(Entry entry, Transaction txn, long lease) \n      throws TransactionException, RemoteException \n   {\n      return write((Envelope) entry, txn, lease);\n   }\n\n   public Lease write(Envelope entry, Transaction txn, long lease) \n         throws TransactionException, RemoteException \n   {\n      synchronized (envelopes) {\n         Set\u003cEnvelope\u003e envelopesForService \u003d getEnvelopeSetForTemplate(entry);\n         envelopesForService.add(entry);\n         envelopes.notify();\n      }\n      return null;\n   }\n\n   private Set\u003cEnvelope\u003e getEnvelopeSetForTemplate(Envelope entry) {\n      Set\u003cEnvelope\u003e envelopesForService \u003d envelopes.get(entry.currentAddressee);\n      if (envelopesForService \u003d\u003d null) {\n         envelopesForService \u003d new HashSet\u003cEnvelope\u003e();\n         envelopes.put(entry.currentAddressee, envelopesForService);\n      }\n      return envelopesForService;\n   }\n\n   public Entry read(Entry tmpl, Transaction txn, long timeout) \n         throws UnusableEntryException, TransactionException, \n            InterruptedException, RemoteException \n   {\n      return read((Envelope) tmpl, txn, timeout);\n   }\n\n   public Entry read(Envelope tmpl, Transaction txn, long timeout) \n      throws UnusableEntryException, TransactionException, \n         InterruptedException, RemoteException \n   {\n      synchronized (envelopes) {\n         if (getEnvelopeSetForTemplate(tmpl).isEmpty()) {\n            envelopes.wait(timeout);\n         }\n         return readIfExists(tmpl, txn, timeout);\n      }\n   }\n\n   public Entry readIfExists(Entry tmpl, Transaction txn, long timeout) \n      throws UnusableEntryException, TransactionException, \n         InterruptedException, RemoteException \n   {\n      return readIfExists((Envelope) tmpl, txn, timeout);\n   }\n\n   public Entry readIfExists(Envelope tmpl, Transaction txn, long timeout) \n      throws UnusableEntryException, TransactionException, \n         InterruptedException, RemoteException \n   {\n      synchronized (envelopes) {\n         Set\u003cEnvelope\u003e envelopeSetForTemplate \u003d getEnvelopeSetForTemplate(tmpl);\n         if (envelopeSetForTemplate.isEmpty())\n            return null;\n         return envelopeSetForTemplate.iterator().next();\n      }\n   }\n\n   public Entry take(Entry tmpl, Transaction txn, long timeout) \n      throws UnusableEntryException, TransactionException, \n         InterruptedException, RemoteException \n   {\n      return take((Envelope) tmpl, txn, timeout);\n   }\n\n   public Entry take(Envelope tmpl, Transaction txn, long timeout) \n      throws UnusableEntryException, TransactionException, \n         InterruptedException, RemoteException \n   {\n      synchronized (envelopes) {\n         if (getEnvelopeSetForTemplate(tmpl).isEmpty()) {\n            envelopes.wait(timeout);\n         }\n         return takeIfExists(tmpl, txn, timeout);\n      }\n   }\n\n   public Entry takeIfExists(Entry tmpl, Transaction txn, long timeout) \n      throws UnusableEntryException, TransactionException, \n         InterruptedException, RemoteException \n   {\n      return takeIfExists((Envelope) tmpl, txn, timeout);\n   }\n\n   public Entry takeIfExists(Envelope tmpl, Transaction txn, long timeout) \n      throws UnusableEntryException, TransactionException, \n         InterruptedException, RemoteException \n   {\n      synchronized (envelopes) {\n         Set\u003cEnvelope\u003e envelopeSetForTemplate \u003d getEnvelopeSetForTemplate(tmpl);\n         if (envelopeSetForTemplate.isEmpty())\n            return null;\n         Entry result \u003d envelopeSetForTemplate.iterator().next();\n         envelopeSetForTemplate.remove(result);\n         return result;\n      }\n   }\n\n   public EventRegistration notify(Entry tmpl, Transaction txn, \n         RemoteEventListener listener, long lease, MarshalledObject handback) \n      throws TransactionException, RemoteException \n   {\n      throw new UnsupportedOperationException(\"notify\");\n   }\n\n   public Entry snapshot(Entry e) throws RemoteException {\n      throw new UnsupportedOperationException(\"snapshot\");\n   }\n}\n\u003d\u003d\u003d\u003d\u003d\u003d",
    "The failing code has now be upgraded to support basic generics - the use of\nparameterized types and raw types *should* be ok... so this might be resolved in\nthe next version of AJDT...  unfortunately without a simple testcase I can\u0027t\nconfirm that right now...",
    "Created an attachment (id\u003d20796)\nAspectJ Eclipse project illustrating the bug\n",
    "(In reply to comment #8)\n\u003e The failing code has now be upgraded to support basic generics - the use of\n\u003e parameterized types and raw types *should* be ok... so this might be resolved in\n\u003e the next version of AJDT...  unfortunately without a simple testcase I can\u0027t\n\u003e confirm that right now...\nThank you for looking at this.\n\nI created a simple testcase and attached it.  I discovered that the file where\nthe error was reported was *not* the file with the problem -- it just had the\nbad luck of being the last file in the build path.\n\nMy test case has two java files, a parametized interface and a parametized type\nimplementing the interface.  If the parametized type does not implement the\ninterface, then there the error does not occur.",
    "This appears fixed with the work I\u0027ve done for bug 97763.\n\nWithout my changes (actually with the dev build 20050510144051), on compiling\nthe attached test program I was getting:\n\n[error] can\u0027t find type test.TroubleInterface\u003cjava.lang.Object\u003e\n\n\n1 error\n\nNow with my changes, I don\u0027t get any errors at all.\n\nWaiting on a dev build to be uploaded now...",
    "Fixed in latest dev build from http://eclipse.org/aspectj/downloads.php"
  ],
  "commentCreationDates": [
    "2005-01-24T22:13:15+01:00",
    "2005-01-24T22:21:37+01:00",
    "2005-01-25T08:57:53+01:00",
    "2005-01-25T16:57:30+01:00",
    "2005-01-27T17:13:01+01:00",
    "2005-03-23T14:19:21+01:00",
    "2005-03-23T20:33:39+01:00",
    "2005-05-03T23:15:42+02:00",
    "2005-05-06T17:36:16+02:00",
    "2005-05-07T04:48:06+02:00",
    "2005-05-07T04:58:57+02:00",
    "2005-06-01T18:30:25+02:00",
    "2005-06-03T17:34:00+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.aspectj.weaver.BCException",
      "message": "Bad type name:",
      "elements": [
        {
          "method": "org.aspectj.weaver.TypeX.nameToSignature",
          "source": "TypeX.java:634"
        },
        {
          "method": "org.aspectj.weaver.TypeX.forName",
          "source": "TypeX.java:87"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding",
          "source": "EclipseFactory.java:155"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings",
          "source": "EclipseFactory.java:163"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember",
          "source": "EclipseFactory.java:229"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember",
          "source": "EclipseFactory.java:224"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit",
          "source": "AsmHierarchyBuilder.java:675"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.traverse",
          "source": "ConstructorDeclaration.java:447"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse",
          "source": "TypeDeclaration.java:1133"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse",
          "source": "CompilationUnitDeclaration.java:314"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild",
          "source": "AsmHierarchyBuilder.java:171"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit",
          "source": "AsmHierarchyBuilder.java:111"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit",
          "source": "EclipseFactory.java:354"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing",
          "source": "AjCompilerAdapter.java:138"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:373"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation",
          "source": "AjBuildManager.java:682"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild",
          "source": "AjBuildManager.java:168"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild",
          "source": "AjBuildManager.java:102"
        },
        {
          "method": "org.aspectj.ajde.internal.CompilerAdapter.compile",
          "source": "CompilerAdapter.java:122"
        },
        {
          "method": "org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run",
          "source": "AspectJBuildManager.java:165"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "83565",
      "date": "2005-01-24T22:13:15+01:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "83565",
  "bugId": "83565",
  "date": "2005-01-24T22:13:15+01:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}