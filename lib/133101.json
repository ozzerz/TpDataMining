{
  "comments": [
    "The version I used is 4.10 for Eclipse 3.1.x\n\njava.util.ConcurrentModificationException\n\tat java.util.HashMap$HashIterator.nextEntry(HashMap.java:787)\n\tat java.util.HashMap$KeyIterator.next(HashMap.java:823)\n\tat java.util.AbstractCollection.toArray(AbstractCollection.java:176)\n\tat java.util.ArrayList.\u003cinit\u003e(ArrayList.java:136)\n\tat org.eclipse.mylar.internal.core.MylarContext.getInteresting(MylarContext.java:131)\n\tat org.eclipse.mylar.internal.core.CompositeContext.getInteresting(CompositeContext.java:71)\n\tat org.eclipse.mylar.internal.core.MylarContextManager.getInterestingDocuments(MylarContextManager.java:686)\n\tat org.eclipse.mylar.internal.core.MylarContextManager.getInterestingDocuments(MylarContextManager.java:704)\n\tat org.eclipse.mylar.internal.ide.MylarIdePlugin.getInterestingResources(MylarIdePlugin.java:189)\n\tat org.eclipse.mylar.internal.ide.team.MylarContextChangeSet.getAllResourcesInChangeContext(MylarContextChangeSet.java:164)\n\tat org.eclipse.mylar.internal.ide.team.MylarContextChangeSet.contains(MylarContextChangeSet.java:173)\n\tat org.eclipse.team.internal.core.subscribers.SubscriberChangeSetCollector$EventHandler.removeFromAllSets(SubscriberChangeSetCollector.java:218)\n\tat org.eclipse.team.internal.core.subscribers.SubscriberChangeSetCollector$EventHandler.handleChange(SubscriberChangeSetCollector.java:202)\n\tat org.eclipse.team.internal.core.subscribers.SubscriberChangeSetCollector$EventHandler.doDispatchEvents(SubscriberChangeSetCollector.java:84)\n\tat org.eclipse.team.internal.core.BackgroundEventHandler.dispatchEvents(BackgroundEventHandler.java:354)\n\tat org.eclipse.team.internal.core.BackgroundEventHandler.processEvents(BackgroundEventHandler.java:334)\n\tat org.eclipse.team.internal.core.BackgroundEventHandler$1.run(BackgroundEventHandler.java:173)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:76)",
    "Oh. I read the code. Below is the method to throw this exception:\n\n\tpublic List\u003cIMylarElement\u003e getInteresting() {\n\t\tList\u003cIMylarElement\u003e elements \u003d new ArrayList\u003cIMylarElement\u003e();\n\n\t\tfor (String key : new ArrayList\u003cString\u003e(nodes.keySet())) {\n\t\t\tMylarContextElement info \u003d nodes.get(key);\n\t\t\tif (info.getInterest().isInteresting()) {\n\t\t\t\telements.add(info);\n\t\t\t}\n\t\t}\n\t\treturn elements;\n\t}\n\n\nCreat the copy list can\u0027t avoid ConcurrentModificationException.\n\nAs I said before, we should use Collections.synchronizedList method. Below is the javadoc for it:\npublic static List synchronizedList(List list)\nReturns a synchronized (thread-safe) list backed by the specified list. In order to guarantee serial access, it is critical that all access to the backing list is accomplished through the returned list.\nIt is imperative that the user manually synchronize on the returned list when iterating over it: \n\n  List list \u003d Collections.synchronizedList(new ArrayList());\n      ...\n  synchronized(list) {\n      Iterator i \u003d list.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \nFailure to follow this advice may result in non-deterministic behavior. \nThe returned list will be serializable if the specified list is serializable. \n\n\nParameters:\nlist - the list to be \"wrapped\" in a synchronized list. \nReturns:\na synchronized view of the specified list.\n",
    "I will remove the new ArrayList() idiom in all the places it occurrs and replace it with locking as suggested.\n\nFound a good article on tradoffs here:\nhttp://www-128.ibm.com/developerworks/java/library/j-jtp07233.html",
    "Another exception found by Rob:\n\njava.util.ConcurrentModificationException\nat java.util.HashMap$HashIterator.nextEntry(HashMap.java:787)\nat java.util.HashMap$KeyIterator.next(HashMap.java:823)\nat java.util.AbstractCollection.toArray(AbstractCollection.java:176)\nat java.util.ArrayList.\u003cinit\u003e(ArrayList.java:136)\nat\norg.eclipse.mylar.internal.core.MylarContext.getInteresting(MylarContext.java:129)\nat\norg.eclipse.mylar.internal.core.CompositeContext.getInteresting(CompositeContext.java:71)\nat\norg.eclipse.mylar.internal.core.MylarContextManager.getInterestingDocuments(MylarContextManager.java:802)\nat\norg.eclipse.mylar.internal.core.MylarContex",
    "Created an attachment (id\u003d39859)\nmylar/context/zip\n\n",
    "Created an attachment (id\u003d39860)\nmylar/context/zip\n\nupdated",
    "Here\u0027s another:\n\njava.util.ConcurrentModificationException\n\tat java.util.HashMap$HashIterator.nextEntry(HashMap.java:787)\n\tat java.util.HashMap$KeyIterator.next(HashMap.java:823)\n\tat java.util.AbstractCollection.toArray(AbstractCollection.java:176)\n\tat java.util.ArrayList.\u003cinit\u003e(ArrayList.java:137)\n\tat org.eclipse.mylar.internal.core.MylarContext.getInteresting(MylarContext.java:129)",
    "*** Bug 144053 has been marked as a duplicate of this bug. ***",
    "Fixed.",
    "Created an attachment (id\u003d44472)\nmylar/context/zip\n\n",
    "So it looks like the synchronized(..) approach to synchronization acutally results in more ConcurrentModificationExceptions than coyping the list did.  Need to investigate...\n\n\t\tList\u003cIMylarElement\u003e elements \u003d new ArrayList\u003cIMylarElement\u003e();\n\t\tSet\u003cString\u003e keys \u003d Collections.synchronizedSet(elementMap.keySet());\n\t\tsynchronized (keys) {\n\t\t\tfor (String key : keys) {\n\t\t\t\tMylarContextElement info \u003d elementMap.get(key);\n\t\t\t\tif (info.getInterest().isInteresting()) {\n\t\t\t\t\telements.add(info);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "(In reply to comment #10)\n\u003e So it looks like the synchronized(..) approach to synchronization acutally\n\u003e results in more ConcurrentModificationExceptions than coyping the list did. \n\u003e Need to investigate...\n\u003e \n\u003e                 List\u003cIMylarElement\u003e elements \u003d new ArrayList\u003cIMylarElement\u003e();\n\u003e                 Set\u003cString\u003e keys \u003d\n\u003e Collections.synchronizedSet(elementMap.keySet());\n\u003e                 synchronized (keys) {\n\u003e                         for (String key : keys) {\n\u003e                                 MylarContextElement info \u003d elementMap.get(key);\n\u003e                                 if (info.getInterest().isInteresting()) {\n\u003e                                         elements.add(info);\n\u003e                                 }\n\u003e                         }\n\u003e                 }\n\u003e \n\nIsn\u0027t keySet() create a new instance every time? I\u0027d just syncronize on elementMap or use concurrent collections from Java 5.\n",
    "Thanks, that seems to have been the problematic oversight.  I switched to synchronizing on a ConcurrentHashMap and so far the problem appears to be resolved."
  ],
  "commentCreationDates": [
    "2006-03-24T05:53:22+01:00",
    "2006-03-24T06:00:20+01:00",
    "2006-03-28T03:18:07+02:00",
    "2006-04-26T20:26:03+02:00",
    "2006-04-29T04:58:26+02:00",
    "2006-04-29T05:00:46+02:00",
    "2006-06-12T22:54:15+02:00",
    "2006-06-12T22:54:25+02:00",
    "2006-06-15T02:45:08+02:00",
    "2006-06-15T02:45:24+02:00",
    "2006-06-16T01:33:43+02:00",
    "2006-06-16T01:40:55+02:00",
    "2006-06-17T00:48:10+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.util.ConcurrentModificationException",
      "elements": [
        {
          "method": "java.util.HashMap$HashIterator.nextEntry",
          "source": "HashMap.java:787"
        },
        {
          "method": "java.util.HashMap$KeyIterator.next",
          "source": "HashMap.java:823"
        },
        {
          "method": "java.util.AbstractCollection.toArray",
          "source": "AbstractCollection.java:176"
        },
        {
          "method": "java.util.ArrayList.\u003cinit\u003e",
          "source": "ArrayList.java:136"
        },
        {
          "method": "org.eclipse.mylar.internal.core.MylarContext.getInteresting",
          "source": "MylarContext.java:131"
        },
        {
          "method": "org.eclipse.mylar.internal.core.CompositeContext.getInteresting",
          "source": "CompositeContext.java:71"
        },
        {
          "method": "org.eclipse.mylar.internal.core.MylarContextManager.getInterestingDocuments",
          "source": "MylarContextManager.java:686"
        },
        {
          "method": "org.eclipse.mylar.internal.core.MylarContextManager.getInterestingDocuments",
          "source": "MylarContextManager.java:704"
        },
        {
          "method": "org.eclipse.mylar.internal.ide.MylarIdePlugin.getInterestingResources",
          "source": "MylarIdePlugin.java:189"
        },
        {
          "method": "org.eclipse.mylar.internal.ide.team.MylarContextChangeSet.getAllResourcesInChangeContext",
          "source": "MylarContextChangeSet.java:164"
        },
        {
          "method": "org.eclipse.mylar.internal.ide.team.MylarContextChangeSet.contains",
          "source": "MylarContextChangeSet.java:173"
        },
        {
          "method": "org.eclipse.team.internal.core.subscribers.SubscriberChangeSetCollector$EventHandler.removeFromAllSets",
          "source": "SubscriberChangeSetCollector.java:218"
        },
        {
          "method": "org.eclipse.team.internal.core.subscribers.SubscriberChangeSetCollector$EventHandler.handleChange",
          "source": "SubscriberChangeSetCollector.java:202"
        },
        {
          "method": "org.eclipse.team.internal.core.subscribers.SubscriberChangeSetCollector$EventHandler.doDispatchEvents",
          "source": "SubscriberChangeSetCollector.java:84"
        },
        {
          "method": "org.eclipse.team.internal.core.BackgroundEventHandler.dispatchEvents",
          "source": "BackgroundEventHandler.java:354"
        },
        {
          "method": "org.eclipse.team.internal.core.BackgroundEventHandler.processEvents",
          "source": "BackgroundEventHandler.java:334"
        },
        {
          "method": "org.eclipse.team.internal.core.BackgroundEventHandler$1.run",
          "source": "BackgroundEventHandler.java:173"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:76"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "133101",
      "date": "2006-03-24T05:53:22+01:00",
      "product": "Mylyn",
      "component": "Core",
      "severity": "major"
    },
    {
      "exceptionType": "java.util.ConcurrentModificationException",
      "elements": [
        {
          "method": "java.util.HashMap$HashIterator.nextEntry",
          "source": "HashMap.java:787"
        },
        {
          "method": "java.util.HashMap$KeyIterator.next",
          "source": "HashMap.java:823"
        },
        {
          "method": "java.util.AbstractCollection.toArray",
          "source": "AbstractCollection.java:176"
        },
        {
          "method": "java.util.ArrayList.\u003cinit\u003e",
          "source": "ArrayList.java:136"
        },
        {
          "method": "org.eclipse.mylar.internal.core.MylarContext.getInteresting",
          "source": "MylarContext.java:129"
        },
        {
          "method": "org.eclipse.mylar.internal.core.CompositeContext.getInteresting",
          "source": "CompositeContext.java:71"
        },
        {
          "method": "org.eclipse.mylar.internal.core.MylarContextManager.getInterestingDocuments",
          "source": "MylarContextManager.java:802"
        }
      ],
      "number": 1,
      "commentIndex": 3,
      "bugId": "133101",
      "date": "2006-04-26T20:26:03+02:00",
      "product": "Mylyn",
      "component": "Core",
      "severity": "major"
    },
    {
      "exceptionType": "java.util.ConcurrentModificationException",
      "elements": [
        {
          "method": "java.util.HashMap$HashIterator.nextEntry",
          "source": "HashMap.java:787"
        },
        {
          "method": "java.util.HashMap$KeyIterator.next",
          "source": "HashMap.java:823"
        },
        {
          "method": "java.util.AbstractCollection.toArray",
          "source": "AbstractCollection.java:176"
        },
        {
          "method": "java.util.ArrayList.\u003cinit\u003e",
          "source": "ArrayList.java:137"
        },
        {
          "method": "org.eclipse.mylar.internal.core.MylarContext.getInteresting",
          "source": "MylarContext.java:129"
        }
      ],
      "number": 2,
      "commentIndex": 6,
      "bugId": "133101",
      "date": "2006-06-12T22:54:15+02:00",
      "product": "Mylyn",
      "component": "Core",
      "severity": "major"
    }
  ],
  "groupId": "133101",
  "bugId": "133101",
  "date": "2006-03-24T05:53:22+01:00",
  "product": "Mylyn",
  "component": "Core",
  "severity": "major"
}