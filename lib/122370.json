{
  "comments": [
    "Adding a setter to the Moody example makes it clear that the annotation style (@DeclareParents) results in different behavior than the classic (declare parents) style.\n\nCalling the setter in a \"declare parents\"-advised object behaves as one would expect.  However, calling the setter with a \"@DeclareParents\"-advised object has no effect -- that is, you can call the setter (and see that it\u0027s been called) and immediately call the getter, only to find that the value didn\u0027t change.  The following examples (all in \"package moody;\") illustrate:\n\npublic enum Mood { HAPPY, JOLLY }\n\nClassic style:\n-------------\npublic aspect ClassicMoodIndicator {\n   public interface Moody {\n      Mood getMood();\n      void setMood(Mood mood);\n   }\n\n   private Mood Moody.mood \u003d Mood.HAPPY;\n\n   public Mood Moody.getMood() { return mood; }\n   public void Moody.setMood(Mood mood) { this.mood \u003d mood; }\n\n   declare parents : moody.ClassicMoodImplementor implements Moody;\n}\n\npublic class ClassicMoodImplementor { }\n\nAnnotation style:\n----------------\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.DeclareParents;\n\n@Aspect\npublic class AnnotationMoodIndicator {\n   public interface Moody {\n      Mood getMood();\n      void setMood(Mood mood);\n   }\n\n   public static class MoodyImpl implements Moody {\n      private Mood mood \u003d Mood.HAPPY;\n\n      public Mood getMood() { return mood; }\n      public void setMood(Mood mood) { this.mood \u003d mood; }\n   }\n\n   @DeclareParents(value\u003d\"moody.AnnotationMoodImplementor\",defaultImpl\u003dMoodyImpl.class)\n   private Moody implementedInterface;\n}\n\npublic class AnnotationMoodImplementor { }\n\nJUnit TestCase:\n--------------\nimport junit.framework.TestCase;\n\npublic class MoodTester extends TestCase {\n   public MoodTester(String name) { super(name); }\n\n   public void testClassic() {\n      ClassicMoodImplementor cmi0 \u003d new ClassicMoodImplementor();\n      ClassicMoodImplementor cmi1 \u003d new ClassicMoodImplementor();\n      \n      assertEquals(\"cmi0 should be HAPPY\", Mood.HAPPY, cmi0.getMood());\n      \n      cmi1.setMood(Mood.JOLLY);\n      assertEquals(\"cmi1 should be JOLLY\", Mood.JOLLY, cmi1.getMood());\n      assertEquals(\"cmi0 should be *still* be HAPPY\", Mood.HAPPY, cmi0.getMood());\n   }\n   \n   public void testAnnotation() {\n      AnnotationMoodImplementor ami0 \u003d new AnnotationMoodImplementor();\n      AnnotationMoodImplementor ami1 \u003d new AnnotationMoodImplementor();\n      \n      assertEquals(\"ami0 should be HAPPY\", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood());\n      \n      ((AnnotationMoodIndicator.Moody) ami1).setMood(Mood.JOLLY);\n      assertEquals(\"ami1 should be JOLLY\", Mood.JOLLY, ((AnnotationMoodIndicator.Moody) ami1).getMood());\n      assertEquals(\"ami0 should be *still* be HAPPY\", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood());\n   }\n}\n\nResult:\n------\nThe test run is as follows:\n..F\nTime: 0.021\nThere was 1 failure:\n1) testAnnotation(moody.MoodTester)junit.framework.AssertionFailedError: ami1 should be JOLLY expected:\u003cJOLLY\u003e but was:\u003cHAPPY\u003e\n       at moody.MoodTester.testAnnotation(MoodTester.java:27)\n       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n       at moody.MoodTester.main(MoodTester.java:7)\n\nFAILURES!!!\nTests run: 2,  Failures: 1,  Errors: 0\n\nFor classic, you can see that cmi1.setMood was successful and cmi0/cmi1 are decoupled (that is, calling setMood on cmi1 has no impact on cmi0).  The annotation style, however, fails because ami1.setMood appears to have done nothing.  The result should have been that ami1 is JOLLY and ami0 HAPPY (I include the second assert because both ami0 \u0026 ami1 ended up JOLLY in RC1).\n\nThe current behavior makes @DeclareParents unusable for retaining field state (near as I can tell, it retains state throughout the method invocation, but not beyond it, like it is creating and discarding a backing object with each method invocation).",
    "Created an attachment (id\u003d34841)\npatch containing failing testcase\n\nApply this patch to the test project.\n\nThis patch contains two tests converted from the supplied testcase. The first is the failing case with @AspectJ style and the second is the code style. The code style test is only there for investigation and shouldn\u0027t be checked into HEAD.",
    "Decompiling AnnotationMoodIndicator we see the following:\n\n   0:   aload_0\n   1:   getfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_Ann\notationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;\n   4:   ifnull  7                                       \u003c---- cause of failure\n   7:   aload_0\n   8:   new     #21; //class moody/AnnotationMoodIndicator$MoodyImpl\n   11:  dup\n   12:  invokespecial   #22; //Method moody/AnnotationMoodIndicator$MoodyImpl.\"\u003c\ninit\u003e\":()V\n   15:  putfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_Ann\notationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;\n   18:  aload_0\n\nfor both the getMood() and setMood(moody.Mood) methods. In other words, no matter what, we always create a new instance of MoodyImpl rather than using the one we\u0027ve got. Instead what we want to do is to only create a new one if we don\u0027t already have one. Changing BcelTypeMunger.mungeMethodDelegate(..) to do this results in:\n\n   0:   aload_0\n   1:   getfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_Ann\notationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;\n   4:   ifnonnull       18\n   7:   aload_0\n   8:   new     #21; //class moody/AnnotationMoodIndicator$MoodyImpl\n   11:  dup\n   12:  invokespecial   #22; //Method moody/AnnotationMoodIndicator$MoodyImpl.\"\u003c\ninit\u003e\":()V\n   15:  putfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_Ann\notationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;\n   18:  aload_0\n\nand everything works as expected.",
    "Created an attachment (id\u003d34845)\nfailing testcase\n\nApply this patch to the tests project.\n\nReplaces the previous testcase patch as removes the code style case.",
    "Created an attachment (id\u003d34846)\npatch containing fix\n\nApply this patch to the weaver project.\n\nThis patch contains the fix described in comment #2.",
    "patch is committed - I dont think the code gen can have been tested, this is a very serious bug.  Luckily our 1.5.1 release is imminent.\n\nIt now correctly creates and *keeps* an instance for the multiple calls to get/set.\n\nThe fix will be available in a development build soon.",
    "fix available."
  ],
  "commentCreationDates": [
    "2005-12-30T05:54:07+01:00",
    "2006-02-16T14:41:46+01:00",
    "2006-02-16T15:38:47+01:00",
    "2006-02-16T15:40:13+01:00",
    "2006-02-16T15:43:27+01:00",
    "2006-02-16T16:52:10+01:00",
    "2006-02-17T12:42:34+01:00"
  ],
  "traces": [
    {
      "exceptionType": "junit.framework.AssertionFailedError",
      "message": "ami1 should be JOLLY expected:\u003cJOLLY\u003e but was:\u003cHAPPY\u003e",
      "elements": [
        {
          "method": "moody.MoodTester.testAnnotation",
          "source": "MoodTester.java:27"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "moody.MoodTester.main",
          "source": "MoodTester.java:7"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "122370",
      "date": "2005-12-30T05:54:07+01:00",
      "product": "AspectJ",
      "component": "Library",
      "severity": "critical"
    }
  ],
  "groupId": "122370",
  "bugId": "122370",
  "date": "2005-12-30T05:54:07+01:00",
  "product": "AspectJ",
  "component": "Library",
  "severity": "critical"
}