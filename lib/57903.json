{
  "comments": [
    "3.0M8\n\nPossible fix:  Replace line 3 below with \n\tif (fBufferOffset + fBufferLength \u003d\u003d fRangeOffset+fRangeLength)\n\nI am writing a colorizer for jsp pages.  As part of this effort, I am using \nthe FastJavaPartitioner to partition the scriptlet code into the correct java \nchunks.  So the crux of the problem is that I am only partitioning part of a \ndocument.  In doing so, I ran into a problem in BufferedDocumentScanner.read() \nthat does not correctly test for end of partitioning range and ends up \nthrowing an ArrayIndexOutOfBounds exception (in some cases, depending on the \nexact data).  \n\nI\u0027ve included my test program and the code from BufferedDocumentScanner.\n\nThe problem appears to be that on line 3 the test is done against the length \nof the document instead of fRangeOffset+fRangeLength.  This means that instead \nof returning EOF, updateBuffer() is called and fOffset is set to 0 and fBuffer\n[0] is returned without checking to make sure that the range is not ended.  \nThe next time through read, fOffset is 1,  fBufferLength is 0, and garbage is \nreturned until the end of the array is reached.\n\nThis doesn\u0027t cause the exception all the time (although garbage data is still \nreturned), because of vagaries with the FastJavaPartitioner state machine.\n\nException trace:\n\njava.lang.ArrayIndexOutOfBoundsException: 1000\n\tat org.eclipse.jdt.internal.ui.text.BufferedDocumentScanner.read\n(BufferedDocumentScanner.java:115)\n\tat org.eclipse.jdt.internal.ui.text.FastJavaPartitionScanner.nextToken\n(FastJavaPartitionScanner.java:101)\n\tat FastPartitionScannerTest.main(FastPartitionScannerTest.java:34)\n\nProgram demonstrating bug:\n\nimport org.eclipse.jdt.internal.ui.javaeditor.PartiallySynchronizedDocument;\nimport org.eclipse.jdt.internal.ui.text.FastJavaPartitionScanner;\nimport org.eclipse.jface.text.rules.Token;\n\npublic class FastPartitionScannerTest\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tFastJavaPartitionScanner scanner\u003dnew FastJavaPartitionScanner\n();\n\t\tPartiallySynchronizedDocument document\u003dnew \nPartiallySynchronizedDocument();\n\t\tdocument.set(\"\u003c%/**f%\u003e\");\n\t\tscanner.setRange(document,2,4);\n\t\tToken t\u003d(Token) scanner.nextToken();\n\t\tSystem.out.println(t.toString());\n\t}\n}\n\n\nBufferedDocumentScanner.read():\n1\tpublic final int read() {\n\n2\t\tif (fOffset \u003d\u003d fBufferLength) {\n3***\t\t\tif (fBufferOffset + fBufferLength \u003d\u003d \nfDocument.getLength())\n4\t\t\t\treturn EOF;\n5\t\t\telse {\n6\t\t\t\tupdateBuffer(fBufferOffset + fBufferLength);\n7***\t\t\t\tfOffset\u003d 0;\n8\t\t\t}\n9\t\t}\n10\t\treturn fBuffer[fOffset++];\n11\t}",
    "*** Bug 129363 has been marked as a duplicate of this bug. ***",
    "Fixed in HEAD.\nAvailable in builds \u003e I20060321-0800."
  ],
  "commentCreationDates": [
    "2004-04-08T16:54:50+02:00",
    "2006-02-27T08:26:50+01:00",
    "2006-03-21T17:38:12+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ArrayIndexOutOfBoundsException",
      "message": "1000",
      "elements": [
        {
          "method": "org.eclipse.jdt.internal.ui.text.BufferedDocumentScanner.read",
          "source": "BufferedDocumentScanner.java:115"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.FastJavaPartitionScanner.nextToken",
          "source": "FastJavaPartitionScanner.java:101"
        },
        {
          "method": "FastPartitionScannerTest.main",
          "source": "FastPartitionScannerTest.java:34"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "57903",
      "date": "2004-04-08T16:54:50+02:00",
      "product": "JDT",
      "component": "Text",
      "severity": "normal"
    }
  ],
  "groupId": "57903",
  "bugId": "57903",
  "date": "2004-04-08T16:54:50+02:00",
  "product": "JDT",
  "component": "Text",
  "severity": "normal"
}