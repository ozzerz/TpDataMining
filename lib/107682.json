{
  "comments": [
    "Or at least work.\n\nWhen two or more plugins extend org.eclipse.ui.editors.documentProviders for the\nsame file extension and/or content type, Eclipse makes a random* choice of one\nof them to create the document for the content. Since almost no editors work at\nall when their own document class is not used to open a file, using this API\nguarantees that all but one plugins in this situation are broken.\n\n* The choice is random enough that under certain circumstances one\ndocumentProvider will be used while at other times the other is. This leads to\n_both_ plugins being broken for different use cases.",
    "To reproduce this, install the WTP editors and XMLBuddy (free download). Use\nFile \u003e Open File to open an \"external\" XML file. Change the default editor back\nand forth between XMLBuddy and the WTP XML editor and Open File. One of the\neditors will fail. The stack trace when XMLBuddy is used to edit the file but\nWTP is chosen to create the document looks like this:\n\norg.eclipse.jface.util.Assert$AssertionFailedException: Assertion failed: \n\tat org.eclipse.jface.util.Assert.isTrue(Assert.java:180)\n\tat org.eclipse.jface.util.Assert.isTrue(Assert.java:165)\n\tat com.objfac.xmleditor.partition.Partitioner.computePartitioning(Partitioner.java)\n\tat\norg.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.computePartitioning(BasicStructuredDocument.java:1059)\n\tat org.eclipse.jface.text.TextUtilities.computePartitioning(TextUtilities.java:426)\n\tat\norg.eclipse.jface.text.presentation.PresentationReconciler.createPresentation(PresentationReconciler.java:443)\n\tat\norg.eclipse.jface.text.presentation.PresentationReconciler.processDamage(PresentationReconciler.java:560)\n\tat\norg.eclipse.jface.text.presentation.PresentationReconciler.access$3(PresentationReconciler.java:558)\n\tat\norg.eclipse.jface.text.presentation.PresentationReconciler$InternalListener.inputDocumentChanged(PresentationReconciler.java:118)\n\tat org.eclipse.jface.text.TextViewer.fireInputDocumentChanged(TextViewer.java:2439)\n\tat org.eclipse.jface.text.TextViewer.setDocument(TextViewer.java:2488)\n\tat org.eclipse.jface.text.source.SourceViewer.setDocument(SourceViewer.java:491)\n\tat org.eclipse.jface.text.source.SourceViewer.setDocument(SourceViewer.java:435)\n\tat\norg.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:2882)\n\tat\norg.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:2649)\n\tat\norg.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:53)\n\tat\norg.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:314)\n\tat com.objfac.xmleditor.BaseEditor.createPartControl(BaseEditor.java)\n\tat com.objfac.xmleditor.XMLEditor.createPartControl(XMLEditor.java)\n\tat\norg.eclipse.ui.internal.EditorReference.createPartHelper(EditorReference.java:585)\n\tat org.eclipse.ui.internal.EditorReference.createPart(EditorReference.java:365)\n\tat\norg.eclipse.ui.internal.WorkbenchPartReference.getPart(WorkbenchPartReference.java:552)\n\tat org.eclipse.ui.internal.PartPane.setVisible(PartPane.java:283)\n\tat\norg.eclipse.ui.internal.presentations.PresentablePart.setVisible(PresentablePart.java:126)\n\tat\norg.eclipse.ui.internal.presentations.util.PresentablePartFolder.select(PresentablePartFolder.java:268)\n\tat\norg.eclipse.ui.internal.presentations.util.LeftToRightTabOrder.select(LeftToRightTabOrder.java:65)\n\tat\norg.eclipse.ui.internal.presentations.util.TabbedStackPresentation.selectPart(TabbedStackPresentation.java:391)\n\tat\norg.eclipse.ui.internal.PartStack.refreshPresentationSelection(PartStack.java:1102)\n\tat org.eclipse.ui.internal.PartStack.setSelection(PartStack.java:1051)\n\tat org.eclipse.ui.internal.PartStack.showPart(PartStack.java:1256)\n\tat org.eclipse.ui.internal.PartStack.add(PartStack.java:442)\n\tat org.eclipse.ui.internal.EditorStack.add(EditorStack.java:109)\n\tat\norg.eclipse.ui.internal.EditorSashContainer.addEditor(EditorSashContainer.java:60)\n\tat org.eclipse.ui.internal.EditorAreaHelper.addToLayout(EditorAreaHelper.java:212)\n\tat org.eclipse.ui.internal.EditorAreaHelper.addEditor(EditorAreaHelper.java:202)\n\tat org.eclipse.ui.internal.EditorManager.createEditorTab(EditorManager.java:753)\n\tat\norg.eclipse.ui.internal.EditorManager.openEditorFromDescriptor(EditorManager.java:665)\n\tat org.eclipse.ui.internal.EditorManager.openEditor(EditorManager.java:628)\n\tat\norg.eclipse.ui.internal.WorkbenchPage.busyOpenEditorBatched(WorkbenchPage.java:2323)\n\tat org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:2258)\n\tat org.eclipse.ui.internal.WorkbenchPage.access$9(WorkbenchPage.java:2250)\n\tat org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:2236)\n\tat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)\n\tat org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2231)\n\tat org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2204)\n\tat\norg.eclipse.ui.internal.editors.text.OpenExternalFileAction.run(OpenExternalFileAction.java:129)\n\tat\norg.eclipse.ui.internal.editors.text.OpenExternalFileAction.run(OpenExternalFileAction.java:98)\n\tat org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:246)\n\tat org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:223)\n\tat\norg.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:538)\n\tat\norg.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)\n\tat\norg.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:843)\n\tat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3080)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2713)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1699)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1663)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:367)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)\n\tat\norg.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:163)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:278)\n\tat org.eclipse.core.launcher.Main.run(Main.java:973)\n\tat org.eclipse.core.launcher.Main.main(Main.java:948)\n\nNote that org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument has no\nbusiness being in this stack trace!",
    "*** Bug 49594 has been marked as a duplicate of this bug. ***",
    "(In reply to comment #2)\n\u003e *** Bug 49594 has been marked as a duplicate of this bug. ***\n\nBug 49594 is not quite a duplicate, it describes a similar problem with a\ndifferent extension point (org.eclipse.core.filebuffers.documentCreation).  I\nassume same is true of org.eclipse.core.filebuffers.documentSetup and\norg.eclipse.core.filebuffers.annotationModelCreation.",
    "Actually it is the same problem. org.eclipse.core.filebuffers.documentCreation\nextensions can also conflict _and_ they can conflict with\norg.eclipse.ui.editors.documentProviders extensions. (The latter is actually\nwhat is happening in my earlier stack trace. WST uses documentCreation while\nXMLBuddy uses documentProviders.)\n\nLike you, I\u0027m suspicious that\norg.eclipse.core.filebuffers.annotationModelCreation has the same issue, but I\nhaven\u0027t actually seen an example. Since viewers are not shared it could be this\nworks ok.\n\nI don\u0027t see a conflict problem with org.eclipse.core.filebuffers.documentSetup.",
    "See Bug 89195 for a horrible example. It should be possible for multiple\ndifferent content types to be detected for the same file without interference;\nindeed, it is intrinsic that any file in XML syntax - Ant, Maven, J2EE, XSLT -\nis also an XML file and can be edited by any XML editor. The conceptual problem\nis that there is not, nor will ever be, a single \"best\" document creator\nassociated with a file. The document creator that must be used when a file is\nopened is the one required by the plugin that opens it.\n\nHistorically, I know Text got in this state by trying to satisfy two requirements:\n\n- If a user makes a change in one editor and the file is also open in another\neditor, the change should be reflected in the other.\n\n- It should be possible to open files outside the workspace in Eclipse.\n\nwhile losing sight of this requirement:\n\n- It should be possible for the user (or Eclipse) to choose any editor for any file.\n\nThe whole \"content type\" thing has just been a distraction. As Bug 89195 shows,\neach editor is trying to use content types to force creation of the document\nclass appropriate for that editor. Completely wrong-headed.\n\nI note this is marked for 3.2. Some discussion of the proposed solution would\nsure be nice. ",
    "Would a solution be acceptable where the problem we see now only might happen if\ntwo different editors are used to open the same file i.e.\n- open a file with whatever editor would always work\n- open the same file again with above editor would also always work and they would\n  be in sync as long a file buffers and/or text file document provider is used\n- open the same file again with a different editor might fail if that editor\n  expects more from a document than what\u0027s speced in IDocument",
    "I\u0027m not sure I follow your proposal, Dani. But, will chime in on some of the \ngeneral issues in this area -- and there are many. \n\n1. The bug described in comment 2 ... \"BasicStructuredDocument has no\nbusiness being in this stack trace\" ... is really just a bug against \nwtp.sse ... we are not meeting the spec of IDocument and Partioners, \nI\u0027d guess, and otherwise, an editor shouldn\u0027t mind (too much) who implements \nIDocument. \n\n2. bug 89195 is not really the same problem as this one, IMHO. That issue would\nbe a problem if no editors (or even documents) were involved at all. Its a case\nthat \"ant\" is not a very distinct \"language\" but the ant team is (rightfully)\ntrying to make things easier for users by identifying ant content, and providing\nspecial functions for cases a resource is ant content. (And they are just an\nover eager bunch :)\n\n3. The participant pattern (and actually the whole plugin pattern) in Eclipse\ndoes not have a well organized story for what to do if there are \"conflicting\"\ncontributions for something. Who wins? Ultimately, there will be cases where a\nuser will have to \"pick one\" .... but I have not seen any general infrastructure\nfor this, or good examples, or an overall design recommendation for how to\nhandle  it in a consistent fashion. [And, I know, everyone hopes it shouldn\u0027t be\nneeded, \nthat we could be intuitive and know exactly what the users wants ... but ... ]\n\n4. I know to \"editor people\" it seems no big deal, but plesae don\u0027t think of a\nDocument as just an editor construct. It should be a full fledged \"text model\"\nobject all in its own right, no matter what UI is modifying it. Which makes it\nthis general problem all the worse (but the solution needs to apply to\nnon-editor use cases as well). \n\nSo ... where to from here? Has anyone else thought of any of the above issues? \nWould it help to take a step back and detail the requirements, design, and\ndirection of \"Document\"? and FileBuffers? and DocumentProviders? (And, apologies\nin advance if these design documents already exist and I just don\u0027t know about\nthem). \n\nThanks for reading. \n\n\n",
    "(In reply to comment #6)\n\u003e Would a solution be acceptable where the problem we see now only might happen if\n\u003e two different editors are used to open the same file i.e.\n\nDoesn\u0027t sound like a solution to me, especially now that it is possible (and\neasy) to open a file again in the same window with a different editor.\n\nWhy can\u0027t we just establish as reality what is already true in practice? A\nplugin that opens a file needs to be able to specify the document class used for\nthe file. Data sharing and multi-editor synchronization is great, but the\ndocument belongs to the plugin, not to Eclipse. So a way needs to be found to\nshare data without forcing editors to share the IDocument object.",
    "(In reply to comment #7)\n\nI very much agree with most of David\u0027s comments. I say that up front because it\nis sometimes not obvious to people I am agreeing with them. ;-}\n\n\u003e 1. ...an editor shouldn\u0027t mind (too much) who implements \n\u003e IDocument.\n\nBut the horse is already out of the barn. The Java editor won\u0027t work unless it\ngets a synchronizable document. The WTP editors won\u0027t work unless they get a\nstructured document. It was quite a struggle to get XMLBuddy to be as\ndocument-neutral as it is, and it is still crippled when it isn\u0027t able to use\nits own DocumentProvider.\n\nOTOH, if Text were to declare that an editor _must_ not depend on the class of\nits IDocument (or IDocumentProvider) objects - and all existing editors could\nget the functionality they currently depend on in other ways - that would be fine.\n\n\u003e 2. bug 89195 is not really the same problem as this one, IMHO. \n\nIMHO it is. ;-} The editors are trying to use content type to force selection of\ntheir own document creators. I cry foul. This is just a hack to overcome the\nproblem described in this bug. Eliminate the need for the hack and you will\neliminate Bug 89195 as well.\n\n\u003e 3. The participant pattern (and actually the whole plugin pattern) in Eclipse\n\u003e does not have a well organized story for what to do if there are \"conflicting\"\n\u003e contributions for something. Who wins? Ultimately, there will be cases where a\n\u003e user will have to \"pick one\" .... but I have not seen any general infrastructure\n\u003e for this, or good examples, or an overall design recommendation for how to\n\u003e handle  it in a consistent fashion.\n\nI snipped the part that seemed to suggest, gee, maybe we can\u0027t do this right. Of\ncourse we can. For the editor case, user picks editor (or Eclipse picks default\neditor) and everything else is determined by the selection of the editor. For\nthe programmable case, plugin picks editor (or whatever, see below) and\neverything else is determined by the selection of the editor.\n\n\u003e 4. I know to \"editor people\" it seems no big deal, but plesae don\u0027t think of a\n\u003e Document as just an editor construct. It should be a full fledged \"text model\"\n\u003e object all in its own right, no matter what UI is modifying it. Which makes it\n\u003e this general problem all the worse (but the solution needs to apply to\n\u003e non-editor use cases as well).\n\nI don\u0027t agree, but mostly because IDocument seems hopelessly contaminated by\nhistory. There needs to be a text model, that\u0027s for sure, but it seems unlikely\nit can be the document object. Water under the bridge.\n\n\u003e So ... where to from here? Has anyone else thought of any of the above issues? \n\u003e Would it help to take a step back and detail the requirements, design, and\n\u003e direction of \"Document\"? and FileBuffers? and DocumentProviders? (And, apologies\n\u003e in advance if these design documents already exist and I just don\u0027t know about\n\u003e them).\n\nYes! The right thing to do is stop trying to make the current broken API work,\nstep back and find the right abstractions, move forward from there.\n\nDavid is dead right that there needs to be an abstraction that is not\nnecessarily an editor but is a \"file opener\". There needs to be an abstraction\nfor the data model of a file to allow sharing transparent to the current\ndocument object. From current requirements, the data model needs to be\nsynchronized to prevent collisions and allow atomic \"transactions\". What are its\nother requirements?\n\nI personally believe that error/warning/info annotations are not data model\nproperties but properties of the \"file opener\". Different views of the data\ninduce different error states. E.g., is the file an XML file, an XSLT file or a\nspecific type of transform?\n\nLike David, if there are any design documentation or proposals, I would love to\nsee them. Just a requirements list would be great!",
    "I agree that the current situation is a problem.\n\nFile buffers intent was to offer access to a shared document to several clients\n(actions, models, editors) that need the document and want to share it, however,\nit was not the intent to make this editor specific or aware. The idea was that\nthis shared document is the common ground i.e. documentCreation and setup should\nonly be used if it is seen as *the* common ground (i.e. master). If an editor\nwould require a special document type and/or setup then the idea was that it\nshould achieve this using its own file document provider (eventually wrapping\nthe document it gets from file buffers) because the document provider was\ninvented to provide the correct document and setup for a given editor family. It\nwas not the intent that each editor uses the file buffer extension points. This\nshould only be done if the intent is to share the creation and setup to all\nclients (which should be rare).\n\nHaving said that, the problems started  with implementation provided for the\nJava editor (and others in the Eclipse SDK) which exactly gave the impression\nthat those extension points should be used by editor providers. In addition the\nJava editor\u0027s implementation of IDocumentSetupParticipant contradicts to the\nspec of IDocumentSetupParticipant by setting a partitioner for the default\npartitioning in case the document doesn\u0027t implement IDocumentExtension3.\n\nUntil we have better solution (a fix without any changes on the client side will\nmost likely not be possible) there are several things clients could do:\n1) if you can live with the fact that your editor\u0027s document is only shared\nbetween your editors you can provide your own document provider which does not\nuse file buffers (e.g. FileDocumentProvider)\n2) if you want sharing but expect a special document and setup you can implement\nyour own document provider that gets the document from file buffers and wraps it\nand you would not contribute any file buffer extensions. Note that this solution\nmight still fail if there\u0027s are documentSetup contributions from different\nproviders for the same content type.",
    "(In reply to comment #10)\n\nDani, I\u0027m not sure I understand your response. In the first place, document\ncreation and setup (the assignment of a partitioner) are very different cases.\nAn editor may be able to work with any IDocument implementation but I have never\nseen one that would work with any partitioner other than its own. Unless I am\nmissing something I subtract \"and setup\" from your reply.\n\nThe suggestion that an editor provide its own documentprovider to wrap the\nfilebuffers-created document seems to forget that filebuffers also creates the\ndocumentprovider for external files.\n\nLastly, \"*the* common ground\" makes no sense to me. IDocument is the common\nground. Everything else is a plugin extension, and you can hardly expect two\nindependently developed plugins to agree on what the common ground would be for\na file type. (Moreover, if an API is undocumented as to intent you can hardly\nexpect plugins to use it according to its intent.) I see the document creation\nAPIs as an ugly hack to satisfy the Java editor, which needed its document class\nto be synchronized so multiple threads could use it at once. The true ugliness\nis revealed by the fact it only works if there is only one document creator for\n*.java files.\n\nThe root question is: why do editors/views/models need their own document type?\nI see two use cases.\n\nEvery editor of any sophistication has multiple threads that need to\nsimultaneously access the document. There are two possible implementations: make\na copy of the document contents on the UI thread for each background thread to\nuse and validate the results of the background thread with the mod stamp, or\nsynchronize access to the document. The latter is the only performant solution\nfor large files (XML has use cases in the hundreds of megabytes). Therefore\nsynchronization should be implemented in the base documents created by file\nbuffers. This would eliminate the need for Java and Ant to have special document\nclasses (Ant\u0027s doesn\u0027t work, anyway).\n\nThe second important use case is implementing IDocument to add extensions\nrelated to the editor-specific document model, which is apparently why the WTP\neditors do it. In the MVC paradigm, the sourceviewer is the viewer, the document\nis the model and the editor (or whatever) is the controller. So naturally when\napplications have more sophisticated models than plain text, e.g., Java\u0027s AST or\nXML\u0027s tree, they tend to lump these together. I personally believe it is a\nmistake to extend the IDocument implementation for this purpose; all that is\nrequired is that the editor-specific model be 1-1 to the shared document. I\nbelieve I have seen a comment to this effect from David. It would be simple\nenough to hang the editor-specific model on the editor-specific partitioner\nalready stored in the document object.\n\nTherefore, lacking any valid use cases, the document creator extension points\nshould be deprecated in 3.2 and all misleading examples removed from the core\ndistribution. Plugins should not provide document creators _or_\ndocumentproviders - the latter don\u0027t work for external files, for which\nfilebuffers creates a documentprovider that actually works.\n\nWhile you are up, please deprecate setDocumentPartitioner() and\ngetDocumentPartitioner() in IDocument. These have no place in the world of\nshared documents and I don\u0027t believe there are any valid use cases that don\u0027t\nwant sharing. The fact that there are some cases where users don\u0027t *get* sharing\nis just an implementation artifact; these cases should be eliminated. If there\nis a need to read/write a file in a non-shared way, java.io.File is there for\nthe purpose. It should not be possible using IDocument.",
    "Let me see if I can summarize one short term solution to at least do better than\nwe are now for the specific \"interested parties\". \n\n1. WTP document start using documentChanged2 instead of the very old\ndocumentChange (I\u0027m not really sure what this accomplishes, I guess we are \nsupposed to do something with the region that\u0027s returned from it, but its unclear\nwhat the constract is, exactly. \n2. WTP stop setting default partition at all (and be on the look out for NPE\u0027s). \n3. WTP AND XML Buddy implement getFileDocumentProvider in their editor to return \nan instance of their document provider (and * not use * the plugin.xml extension\npoint for it. (I\u0027m not sure what XMLBuddy needs for a document, I assume the\n\"generic\" one, but with their own partioner?). \n5. WTP\u0027s documentProvider would still \"force\" use the common StrucutredDocument\nand all we need from it. When an editor is not used, we\u0027d still use document\nfactory so it would still be the common ground shared document. When someone\nbesides an editor got a document. (And, recall, that\u0027s actually our greatest\nconcern ... editors could work perfectly, but if our document is not used when\nsomeone tries to use our model, then they are hosed). \n\nNot sure the above will work as all expect, but I think that\u0027s the next step to\ntry. And we\u0027ll try to sort out the higher level theoretical things later? \n\n\nAs for our documents special needs, there is quite a few. Thread safety (job\nsafety) is one. Another is to be able to call \u0027replace\u0027 (or add positions) from\nnon-Dispaly thread. \n\nMore imporantly, even then document is changed, we \u0027reparse\u0027 a certain amount of\nour strucuture, and send out more specific document events than generic document\ndoes. (I do not like the reconciler thread concept). Its for this reason, I do\nnot think we could ever simply \"wrap\" an existing document that others might\nhave access to (in an unwrapped fashion) since we could not then control the\nexact sequence of events and parses. And, recall, we often need to get a\ndocument, even when we are not editing! To build other models, refactor links, etc. \n\nLastly, there\u0027s some improvements I think need to be made to document that I\nassumed another implemetation would be the best way to solve. But that\u0027s a long\nstory, so let\u0027s focus on the specific short term solution to see if any better. \n\n",
    "(In reply to comment #12)\nSounds good and moves in the right direction, but I think there are at least two\nissues.\n\n- If XMLBuddy opens a file and then WTP opens the same file, either there is not\ngoing to be any sharing or WTP isn\u0027t going to work. (XMLBuddy is pretty\ndocument-agnostic as we do the stupid thing and copy the document for background\nthreads.)\n\n- For external files, I think Eclipse creates the documentprovider and the\neditor doesn\u0027t really get any say in the matter. Could be wrong. Dani?\n\nI still don\u0027t understand why WTP needs to specify the document class. The part\nof your requirements I understood all seem to deal with concurrent access. If\nthe default document created by filebuffers provided synchronization, what else\nwould you need?",
    "re comment 11:\n\nBob, let me try to answer your comment:\n\n\u003eAn editor may be able to work with any IDocument implementation but I have never\n\u003eseen one that would work with any partitioner other than its own.\nAn editor requires his own partitioning being in place but it should be\nirrelevant whether there are other partitionings around. Problems arise if the\neditor does not have its own partitioning but uses the default partitioning and\nsomeone else also registers a partitioner for the default partitioning. I\nIDocumentSetupParticipant specifies this and those who do otherwise basically\nviolate the spec. Initially we considered not to call the participant if the\ndocument doesn\u0027t implement IDocumentExtension3 but there might be other aspects\nthat someone would like to setup (be it simply to know when this happens). Up to\nknow the extension point itself only mentioned that IDocumentSetupParticipant\nmust be implemented. I\u0027ve now also explicitly written that into the extension\npoint doc.\n\n\u003eThe suggestion that an editor provide its own documentprovider to wrap the\n\u003efilebuffers-created document seems to forget that filebuffers also creates the\n\u003edocumentprovider for external files.\nFile buffers don\u0027t create documentProviders. But yes, we provide a default\ndocument provider for external files for those using the implicit document\nprovider but every editor can define its own (explicit) document provider by\ncalling AbstractTextEditor.setDocumentProvider(IDocumentProvider provider).\n\n\u003eLastly, \"*the* common ground\" makes no sense to me. IDocument is the common\n\u003eground. Everything else is a plugin extension, \nThis is true for IDEs and other tools that are developed to be extensible but\nmany clients use Eclipse to build their applications (see rcp) and they might\nwell have some other common ground.\n\n\u003e...for large files (XML has use cases in the hundreds of megabytes). Therefore\n\u003esynchronization should be implemented in the base documents created by file\n\u003ebuffers.\nThat\u0027s my current thinking i.e. you\u0027ll get synchronized document that\u0027s shared\nand that implements IDocument. Whoever wants more can do more based on that\ndocument.\n\n\u003eTherefore, lacking any valid use cases, the document creator extension points\n\u003eshould be deprecated in 3.2\nThat\u0027s again my plan.\n\n\u003eWhile you are up, please deprecate setDocumentPartitioner() and\n\u003egetDocumentPartitioner() in IDocument. These have no place in the world of\n\u003eshared documents \nThis can\u0027t happen because lots of clients will never need/use that sharing and\nare fully happy with the default partitioning.",
    "\u003e- For external files, I think Eclipse creates the documentprovider and the\n\u003eeditor doesn\u0027t really get any say in the matter. Could be wrong. Dani?\nAs outline in the previous comment every editor is free to use its own document\nprovider.\n\n\u003eI still don\u0027t understand why WTP needs to specify the document class.\nDavid, can you give a short explanation for Bob?",
    "Answer to comment 12 will follow this weekend.",
    "(In reply to comment #14)\n\u003e Problems arise if the\n\u003e editor does not have its own partitioning but uses the default partitioning\n\u003e and someone else also registers a partitioner for the default partitioning.\n\nWhat default partitioning? In my experience the default partitioning is no\npartitioning, i.e., getDocumentPartitioner() returns null.\n\n\u003e Up to\n\u003e know the extension point itself only mentioned that IDocumentSetupParticipant\n\u003e must be implemented. I\u0027ve now also explicitly written that into the extension\n\u003e point doc.\n\nThat\u0027s good, but I fear you\u0027re not writing to the right audience. The people who\nneed to know there\u0027s a collision problem with setDocumentPartitioner() and\nshared documents are those who don\u0027t know about the extension point.\n\n\u003e File buffers don\u0027t create documentProviders. But yes, we provide a default\n\u003e document provider for external files for those using the implicit document\n\u003e provider\n\n;-}\n\n\u003e but every editor can define its own (explicit) document provider by\n\u003e calling AbstractTextEditor.setDocumentProvider(IDocumentProvider provider).\n\nSure you can, but the external file example shows that editors that do define\ntheir own document providers wind up broken because of assumptions in the\ndocument provider about specific IEditorInput types. When the next release\nintroduces an input type that uses a URI instead of any sort of file, all\nexisting document providers will be hopelessly broken. It\u0027s not even possible to\nadjust to the external file input type - it\u0027s not API. This whole (input) area\nis crap. It should be possible to read and write documents without having to\ncast, excuse me, adapt, down to specific input types. But that\u0027s a digression.\n\nLeaving aside the impossibility of writing a general-purpose document provider,\nwhat is the provider supposed to do? One would guess from the name it should\nprovide a document. But if it creates its own document object, it won\u0027t get\nsharing. What is the code sequence that allows a document provider to fetch a\nshared document object from filebuffers?\n\nYou can probably answer the last question, but do you see why I think that\ndocument users are better off not implementing document providers? They have far\nbetter insulation from future extensions if they leave the matter to Eclipse.\n\n\u003e \u003eLastly, \"*the* common ground\" makes no sense to me. IDocument is the common\n\u003e \u003eground. Everything else is a plugin extension, \n\u003e This is true for IDEs and other tools that are developed to be extensible but\n\u003e many clients use Eclipse to build their applications (see rcp) and they might\n\u003e well have some other common ground.\n\nThey might want UI that doesn\u0027t assume toolbars, too, but they don\u0027t get one\nfrom RCP. RCP is not a blank slate.\n\n\u003e That\u0027s my current thinking i.e. you\u0027ll get synchronized document that\u0027s shared\n\u003e and that implements IDocument. Whoever wants more can do more based on that\n\u003e document.\n\nHooray! Please note my comment to Bug 75767.\n\n\u003e \u003eTherefore, lacking any valid use cases, the document creator extension points\n\u003e \u003eshould be deprecated in 3.2\n\u003e That\u0027s again my plan.\n\n+1\n\n\u003e \u003eWhile you are up, please deprecate setDocumentPartitioner() and\n\u003e \u003egetDocumentPartitioner() in IDocument. These have no place in the world of\n\u003e \u003eshared documents \n\u003e This can\u0027t happen because lots of clients will never need/use that sharing and\n\u003e are fully happy with the default partitioning.\n\nOf course it can happen. The alternative, using a named document partitioner, is\njust as easy to use and has no hidden pitfalls. It\u0027s not like you would be\nremoving functionality.\n\n",
    "\u003eWhat default partitioning? In my experience the default partitioning is no\n\u003epartitioning, i.e., getDocumentPartitioner() returns null.\nCorrect. What I meant was: clients registering their partitioner either via\nsetDocumentPartitioner(IDocumentPartitioner) or as\nIDocumentExtension3.DEFAULT_PARTITIONING.\n\n\u003e It\u0027s not even possible to\n\u003eadjust to the external file input type - it\u0027s not API.\nThis should probably be changed so that clients can use it.\n\nIf we\u0027d deprecate get/setDocumentPartitioner(IDocumentPartitioner) then we\nshould also deprecate the IDocumentExtension3.DEFAULT_PARTITIONING constant\notherwise this could result in the same conflict again. The problem with the\ndeprecation is that those who want to get rid of the deprecation are force to\nimplement IDocumentExtension3 even if the eventually live in a closed world.",
    "In reply to comment 12:\n\n\n\u003e1. WTP document start using documentChanged2 instead of the very old\n\u003edocumentChange (I\u0027m not really sure what this accomplishes, I guess we are \nIs a good idea but not really connected to this PR.\n\n\u003esupposed to do something with the region that\u0027s returned from it,\nFor example the DocumentPartitioningChangedEvent.setPartitionChange(...) can be\nreduced to the region that changed instead of using 0..length.\n\n\u003e but its unclear what the constract is, exactly. \nThe minimal region that includes all partition changes caused by the invocation\nof the document partitioner.\n\n\u003e3. WTP AND XML Buddy implement getFileDocumentProvider in their editor to \u003ereturn \n\u003ean instance of their document provider (and * not use * the plugin.xml\n\u003eextension point for it. \nDo not overwrite getDocumentProvider() [I assume that\u0027s what you meant with\ngetFileDocumentProvider]. Instead call setDocumentProvider(...) in your editor\u0027s\nconstructor to set the explicit document provider.\n\n\u003e5. WTP\u0027s documentProvider would still \"force\" use the common StrucutredDocument\n\u003eand all we need from it. When an editor is not used, we\u0027d still use document\n\u003efactory so it would still be the common ground shared document.\nStay away form using the documentCreation extension point. I plan to deprecate\nit for 3.2. If you need your special document type then you could introduce your\nown document factory from where clients can get the specialized document.\n",
    "(In reply to comment #18)\n\nWhat is the API that allows a document provider to fetch a shared document\nobject from filebuffers (so it can be shadowed)?\n\n\u003e \u003e It\u0027s not even possible to\n\u003e \u003eadjust to the external file input type - it\u0027s not API.\n\u003e This should probably be changed so that clients can use it.\n\nYou might want to change its name, as well, to e.g. PathEditorInput, to stop\nneeding to explain what \"JavaFile\" means.\n\n\u003e If we\u0027d deprecate get/setDocumentPartitioner(IDocumentPartitioner) then we\n\u003e should also deprecate the IDocumentExtension3.DEFAULT_PARTITIONING constant\n\u003e otherwise this could result in the same conflict again. The problem with the\n\u003e deprecation is that those who want to get rid of the deprecation are force to\n\u003e implement IDocumentExtension3 even if the eventually live in a closed world.\n\nThat kind of inconvenience is all over Eclipse. \"Deprecated; use\nIDocumentExtension3.setDocumentPartitioner()\". No biggie. (There are a number of\nother methods in IDocumentExtension3 that should be deprecated in IDocument, as\nwell. IIRC, they must all be used together.\n\nAs for \"closed world\", I think of that as a state of blissful ignorance that\nends the first time a document must be opened by two different processes. ;-}",
    "Just thought of this: When you make JavaFileEditorInput API, you should also\nprovide a single documentprovider for JavaFileEditorInput, IFileEditorInput and\nIStorageEditorInput. IIRC, except for getting the input and output streams most\nof the code is common, including getting encoding right per content types. Then\n\"external files\" wouldn\u0027t need to be a special case.",
    "Question for David: If the shared document object produced by filebuffers allows\nsynchronization, why do need your own IDocument implementation? If you hang\nother \"model\" data off it, why don\u0027t you just hang that data elsewhere? Maybe\nsubclassing isn\u0027t the best solution. (It\u0027s certainly not the easiest.)",
    "Please refere to bug 111313",
    "Fixed in HEAD.\nAvailable in builds \u003e N20060105-0010.\n\nSee for details see bug 96917, comment 17.",
    "verifying...",
    "verified in I20060214-0010",
    "*** Bug 101846 has been marked as a duplicate of this bug. ***",
    "Sorry to ask a stupid question, but: Can someone please summarize what the right course of action should be for plugin authors that are implementing editors derived from CompilationUnitEditor and need to create custom documents? Do we extend at org.eclipse.core.internal.filebuffers.ExtensionsRegistry? Do we need to define a content type as well? Or do we need to implement our own document provider that does buffering, compilation unit creation, etc. just to add some additional state to the Document object?",
    "It depends whether your editor edits Java files or soemthing different (e.g. non *.java files). If so, a different content type makes sense.\n\nBest way is to have your own document provider that adapts the file buffer document."
  ],
  "commentCreationDates": [
    "2005-08-23T02:44:05+02:00",
    "2005-08-23T02:47:55+02:00",
    "2005-08-23T10:51:34+02:00",
    "2005-08-23T18:35:52+02:00",
    "2005-08-23T18:52:09+02:00",
    "2005-09-01T19:04:32+02:00",
    "2005-09-02T10:25:49+02:00",
    "2005-09-02T17:14:49+02:00",
    "2005-09-04T01:47:54+02:00",
    "2005-09-04T02:20:24+02:00",
    "2005-09-09T18:07:46+02:00",
    "2005-09-11T19:30:51+02:00",
    "2005-09-12T09:21:14+02:00",
    "2005-09-13T07:48:33+02:00",
    "2005-09-16T18:42:41+02:00",
    "2005-09-16T18:44:42+02:00",
    "2005-09-16T18:45:21+02:00",
    "2005-09-17T19:08:21+02:00",
    "2005-09-18T14:14:09+02:00",
    "2005-09-18T14:28:34+02:00",
    "2005-09-18T17:34:35+02:00",
    "2005-09-18T17:40:38+02:00",
    "2005-09-18T17:45:08+02:00",
    "2005-10-04T00:13:15+02:00",
    "2006-01-05T14:51:33+01:00",
    "2006-02-14T17:07:40+01:00",
    "2006-02-14T17:35:34+01:00",
    "2006-03-27T17:26:32+02:00",
    "2006-04-07T17:04:29+02:00",
    "2006-04-09T16:46:33+02:00"
  ],
  "traces": [
    {
      "exceptionType": "org.eclipse.jface.util.Assert$AssertionFailedException",
      "message": "Assertion failed:",
      "elements": [
        {
          "method": "org.eclipse.jface.util.Assert.isTrue",
          "source": "Assert.java:180"
        },
        {
          "method": "org.eclipse.jface.util.Assert.isTrue",
          "source": "Assert.java:165"
        },
        {
          "method": "com.objfac.xmleditor.partition.Partitioner.computePartitioning",
          "source": "Partitioner.java"
        },
        {
          "method": "org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.computePartitioning",
          "source": "BasicStructuredDocument.java:1059"
        },
        {
          "method": "org.eclipse.jface.text.TextUtilities.computePartitioning",
          "source": "TextUtilities.java:426"
        },
        {
          "method": "org.eclipse.jface.text.presentation.PresentationReconciler.createPresentation",
          "source": "PresentationReconciler.java:443"
        },
        {
          "method": "org.eclipse.jface.text.presentation.PresentationReconciler.processDamage",
          "source": "PresentationReconciler.java:560"
        },
        {
          "method": "org.eclipse.jface.text.presentation.PresentationReconciler.access$3",
          "source": "PresentationReconciler.java:558"
        },
        {
          "method": "org.eclipse.jface.text.presentation.PresentationReconciler$InternalListener.inputDocumentChanged",
          "source": "PresentationReconciler.java:118"
        },
        {
          "method": "org.eclipse.jface.text.TextViewer.fireInputDocumentChanged",
          "source": "TextViewer.java:2439"
        },
        {
          "method": "org.eclipse.jface.text.TextViewer.setDocument",
          "source": "TextViewer.java:2488"
        },
        {
          "method": "org.eclipse.jface.text.source.SourceViewer.setDocument",
          "source": "SourceViewer.java:491"
        },
        {
          "method": "org.eclipse.jface.text.source.SourceViewer.setDocument",
          "source": "SourceViewer.java:435"
        },
        {
          "method": "org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer",
          "source": "AbstractTextEditor.java:2882"
        },
        {
          "method": "org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl",
          "source": "AbstractTextEditor.java:2649"
        },
        {
          "method": "org.eclipse.ui.texteditor.StatusTextEditor.createPartControl",
          "source": "StatusTextEditor.java:53"
        },
        {
          "method": "org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl",
          "source": "AbstractDecoratedTextEditor.java:314"
        },
        {
          "method": "com.objfac.xmleditor.BaseEditor.createPartControl",
          "source": "BaseEditor.java"
        },
        {
          "method": "com.objfac.xmleditor.XMLEditor.createPartControl",
          "source": "XMLEditor.java"
        },
        {
          "method": "org.eclipse.ui.internal.EditorReference.createPartHelper",
          "source": "EditorReference.java:585"
        },
        {
          "method": "org.eclipse.ui.internal.EditorReference.createPart",
          "source": "EditorReference.java:365"
        },
        {
          "method": "org.eclipse.ui.internal.WorkbenchPartReference.getPart",
          "source": "WorkbenchPartReference.java:552"
        },
        {
          "method": "org.eclipse.ui.internal.PartPane.setVisible",
          "source": "PartPane.java:283"
        },
        {
          "method": "org.eclipse.ui.internal.presentations.PresentablePart.setVisible",
          "source": "PresentablePart.java:126"
        },
        {
          "method": "org.eclipse.ui.internal.presentations.util.PresentablePartFolder.select",
          "source": "PresentablePartFolder.java:268"
        },
        {
          "method": "org.eclipse.ui.internal.presentations.util.LeftToRightTabOrder.select",
          "source": "LeftToRightTabOrder.java:65"
        },
        {
          "method": "org.eclipse.ui.internal.presentations.util.TabbedStackPresentation.selectPart",
          "source": "TabbedStackPresentation.java:391"
        },
        {
          "method": "org.eclipse.ui.internal.PartStack.refreshPresentationSelection",
          "source": "PartStack.java:1102"
        },
        {
          "method": "org.eclipse.ui.internal.PartStack.setSelection",
          "source": "PartStack.java:1051"
        },
        {
          "method": "org.eclipse.ui.internal.PartStack.showPart",
          "source": "PartStack.java:1256"
        },
        {
          "method": "org.eclipse.ui.internal.PartStack.add",
          "source": "PartStack.java:442"
        },
        {
          "method": "org.eclipse.ui.internal.EditorStack.add",
          "source": "EditorStack.java:109"
        },
        {
          "method": "org.eclipse.ui.internal.EditorSashContainer.addEditor",
          "source": "EditorSashContainer.java:60"
        },
        {
          "method": "org.eclipse.ui.internal.EditorAreaHelper.addToLayout",
          "source": "EditorAreaHelper.java:212"
        },
        {
          "method": "org.eclipse.ui.internal.EditorAreaHelper.addEditor",
          "source": "EditorAreaHelper.java:202"
        },
        {
          "method": "org.eclipse.ui.internal.EditorManager.createEditorTab",
          "source": "EditorManager.java:753"
        },
        {
          "method": "org.eclipse.ui.internal.EditorManager.openEditorFromDescriptor",
          "source": "EditorManager.java:665"
        },
        {
          "method": "org.eclipse.ui.internal.EditorManager.openEditor",
          "source": "EditorManager.java:628"
        },
        {
          "method": "org.eclipse.ui.internal.WorkbenchPage.busyOpenEditorBatched",
          "source": "WorkbenchPage.java:2323"
        },
        {
          "method": "org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor",
          "source": "WorkbenchPage.java:2258"
        },
        {
          "method": "org.eclipse.ui.internal.WorkbenchPage.access$9",
          "source": "WorkbenchPage.java:2250"
        },
        {
          "method": "org.eclipse.ui.internal.WorkbenchPage$9.run",
          "source": "WorkbenchPage.java:2236"
        },
        {
          "method": "org.eclipse.swt.custom.BusyIndicator.showWhile",
          "source": "BusyIndicator.java:69"
        },
        {
          "method": "org.eclipse.ui.internal.WorkbenchPage.openEditor",
          "source": "WorkbenchPage.java:2231"
        },
        {
          "method": "org.eclipse.ui.internal.WorkbenchPage.openEditor",
          "source": "WorkbenchPage.java:2204"
        },
        {
          "method": "org.eclipse.ui.internal.editors.text.OpenExternalFileAction.run",
          "source": "OpenExternalFileAction.java:129"
        },
        {
          "method": "org.eclipse.ui.internal.editors.text.OpenExternalFileAction.run",
          "source": "OpenExternalFileAction.java:98"
        },
        {
          "method": "org.eclipse.ui.internal.PluginAction.runWithEvent",
          "source": "PluginAction.java:246"
        },
        {
          "method": "org.eclipse.ui.internal.WWinPluginAction.runWithEvent",
          "source": "WWinPluginAction.java:223"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection",
          "source": "ActionContributionItem.java:538"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.access$2",
          "source": "ActionContributionItem.java:488"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem$5.handleEvent",
          "source": "ActionContributionItem.java:400"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java:66"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:843"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java:3080"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:2713"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1699"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1663"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:367"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:143"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:103"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:226"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:376"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:163"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.core.launcher.Main.invokeFramework",
          "source": "Main.java:334"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:278"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:973"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:948"
        }
      ],
      "number": 0,
      "commentIndex": 1,
      "bugId": "107682",
      "date": "2005-08-23T02:47:55+02:00",
      "product": "Platform",
      "component": "Text",
      "severity": "normal"
    }
  ],
  "groupId": "107682",
  "bugId": "107682",
  "date": "2005-08-23T02:44:05+02:00",
  "product": "Platform",
  "component": "Text",
  "severity": "normal"
}