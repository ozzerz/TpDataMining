{
  "comments": [
    "This has been happening a lot, but I\u0027m having trouble figuring out why it\u0027s happening.  It\u0027s always \"5\".  It happens both in Eclipse and from the command line.\n\njava.lang.ArrayIndexOutOfBoundsException\nat org.aspectj.org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidType(ProblemReporter.java:2992)\nat org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.reportInvalidType(TypeReference.java:170)\nat org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:136)\nat org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:123)\nat org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:214)\nat org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:436)\nat org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getAnnotationTypes(EclipseSourceType.java:443)\nat org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAnnotationStyleAspect(EclipseSourceType.java:123)\nat org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAspect(EclipseSourceType.java:108)\nat org.aspectj.weaver.ReferenceType.isAspect(ReferenceType.java:159)\nat org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.verifyAnyTypeParametersMeetBounds(AjLookupEnvironment.java:269)\nat org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:228)\nat org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)\nat org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)\nat org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)\nat org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)\nat org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)\nat org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)\nat org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)\n\nArrayIndexOutOfBoundsException thrown: 5",
    "It is happening because of a problem with one of the annotations you have put on a type - we crash trying to report the error concerning the annotation.  Although the stack trace mentions aspects, it is breaking in the code that is trying to find out if you have the @Aspect annotation on the type it is processing, so it may be any type in the system.\n\nDepending on how large your program is, you could try removing the annotations from some of the types and checking what makes it go away - clearly this is a bug but I\u0027d like to come up with a test program before working to fix it if I can.",
    "like your other bug ... this could be mismatched versions of compiler/weaver.  Is this AJDT1.4 or AJDT 1.3.1 ?",
    "I did a clean install of Eclipse 3.2RC7 and an install of the latest AJDT 1.4 using \"Find and Install\" within Eclipse.  I haven\u0027t seen the other bug since doing that, but this bug was present before and also still now.",
    "How big is your project? Does it have many dependencies? are you able to send it to me?  I don\u0027t mind trying to compile and debug this locally.  Basically I\u0027d remove annotations from types until it went away to find the culprit...",
    "It\u0027s a multiple project workspace with lots of classes and aspect advice.  Pretty much huge.  And it\u0027s a closed source project, too, so I can\u0027t just send it to you.  I\u0027m working on deleting it piece by piece and checking that the compiler error still happens.  I\u0027ll figure out the minimal code needed to reproduce it.",
    "great, thanks! ",
    "Created an attachment (id\u003d45633)\nEclipse projects to reproduce the bug\n\nThis assumes you have already installed Eclipse 3.2 release and installed the AJDT 1.4 release plugin into it.\n\nSteps to reproduce:\n\n1. Extract bug.zip into an empty folder.\n2. Start Eclipse and choose that folder as your workspace.\n3. Click the icon to \"Go to the workbench.\"\n4. Right-click in the Package Explorer and choose Import.\n5. Select \"General:Existing Projects into Workspace\" and click Next.\n6. Browse for \"Select root directory\" and choose the folder into which you extracted the zip.\n7. Deselect project2.  ONLY project1 should be checked at this time.\n8. Click Finish.\n9. Workspace builds. Verify that nothing is displayed in the \"Problems\" pane.\n10. Repeat steps 4 through 6.\n11. ONLY project2 should be available for importing now.  Be sure it is checked.\n12. Click Finish.\n13. AspectJ Internal Compiler Error:\n\njava.lang.ArrayIndexOutOfBoundsException\nat org.aspectj.org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidType(ProblemReporter.java:2992)\nat org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.reportInvalidType(TypeReference.java:170)\nat org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:136)\nat org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:123)\nat org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:214)\nat org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:436)\nat org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getAnnotationTypes(EclipseSourceType.java:443)\nat org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAnnotationStyleAspect(EclipseSourceType.java:123)\nat org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAspect(EclipseSourceType.java:108)\nat org.aspectj.weaver.ReferenceType.isAspect(ReferenceType.java:159)\nat org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.verifyAnyTypeParametersMeetBounds(AjLookupEnvironment.java:269)\nat org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:228)\nat org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)\nat org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)\nat org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)\nat org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)\nat org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)\nat org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)\nat org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)\nat org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)\n\nArrayIndexOutOfBoundsException thrown: 1",
    "This bug still exists in the 1.5.2 release.",
    "couple of problems lurking here - caused by the combination of a project dependency ,an inner annotation type and the code being in packages.  thanks for the test program!\n\nIn AjLookupEnvironment.createAnnotationFromBcelAnnotation() we didn\u0027t correctly build the positions array - we made it too short, and hence the arrayindexoutofboundsexception.  Because the annotation type was a nested type we mistakenly referred to it via its binary name (so a $ delimiter for the inner type).  We had to undo that and use its \u0027source name\u0027.\n\nWith those two things fixed we now get an error about the visibility of the annotation type.  But ... we only get this error when building Project2 - so I am still investigating...\n\nI\u0027ve reset the version of this bug to 1.5.1 as that is the version it was found on.",
    "So good to hear that you\u0027re working on this!  This bug has me pulling my hair out because it basically means I can\u0027t use the AspectJ builder to build this workspace at the moment.\n\nThe nested annotation type is declared private, but the privileged aspect should have permission to use it because it\u0027s privileged.",
    "fix for the AIOOBE is in.  Fix for priliveged aspect being able to see the private inner annotation will take longer.",
    "It should be possible for the privileged aspect to see and use the private inner annotation type.  However, I don\u0027t think we should be attaching the private annotation to types targeted with declare @type.  If we do that we are creating something that effectively breaks the type checking rules - and if any tool checks it (the visibility of the annotation) then it will see that the target type shouldn\u0027t actually be able to see the annotation.  And that is what is happening here on the incremental compile.\n\nNormally in AspectJ, for this kind of construct we would add a public \u0027thing\u0027 to the target type with a mangled name - such that AspectJ understood it represented the private type, but no other tool would.  If we did this then the type system would be nice and correct.  So, in this situation:\n\nclass A {\n  private @interface M {}\n}\n\nprivileged aspect X {\n  declare @type: C: @A.M;\n}\n\nclass C {\n}\n\nclass C would get a mangled public annotation, perhaps \u0027public @interface ajc$A$M\u0027.  The compiler would correctly be able to recognize this as a reference to the private annotation for the purposes of matching advice:\n\n\u0027before(): call(* (@A.M *).*(..)) {}\u0027\n\nand any tool that checks the visibility of the annotation wouldn\u0027t find the visibility rules violated.\n\nI imagine implementing this to be a couple of weeks work - and at the moment we only have this one example use case.  If we had another one or two then that would make it more of a priority - so I\u0027m moving this out to 1.6.0\n\nA testcase is committed in MultiProjectIncrementalTests called: testDeclareAtType_pr149293() that shows the incremental compilation failure.\n\nRight now I\u0027m trying to decide whether to police it for now and produce a compiler limitation error if this is attempted.",
    "Mangling may produce problems.  Consider this use case:\n\npublic abstract class Base {\n  private @interface AspectApplied { }\n  protected Base() {\n    if (!getClass().isAnnotationPresent(AspectApplied.class)) {\n      throw new RuntimeException(\"aspect not woven into class\");\n    }\n  }\n}\n\npublic class Derived extends Base {\n  public Derived() {\n    // implicit call to super()\n  }\n}\n\npublic privileged aspect Aspect {\n  declare @type : Base+ : @Base.AspectApplied;\n}\n\nThe intent is that authors of subclasses of Base will be unable to annotate those subclasses with the private @AspectApplied, and they cannot escape the runtime check that their subclass does indeed have the annotation.  This is a way to check at runtime that subclasses of Base have been woven with Aspect, which is important when third parties would be extending Base but might not be using the AspectJ compiler: they will receive a nasty surprise at runtime and be forced to compile their subclasses with AspectJ and weave with Aspect.",
    "You cannot write this code:\n\nclass A {\n  private @interface M {}\n}\n\n@A.M\nclass B {\n}\n\nC:\\\u003ejavac A.java\nA.java:5: A.M has private access in A\n@A.M\n  ^\n1 error\n\nAnd I don\u0027t think AspectJ should be providing a back door to make it possible.\n\nTo do what you are suggesting, you would use the AspectJ reflection support - and that would understand/hide any mangling.  In your example, this code:\n\nif (!getClass().isAnnotationPresent(AspectApplied.class)) {\n\nis relying on how AspectJ chooses to implement declare @type at the moment.  What you would be better writing is something like (this is not yet implemented in AjType):\n\nif (!AjTypeSytem.getAjType(getClass()).isAnnotationPresent(AspectApplied.class)) {\n\nand the AjTypeSystem can hide everything related to the mangling."
  ],
  "commentCreationDates": [
    "2006-06-30T14:20:01+02:00",
    "2006-06-30T14:27:22+02:00",
    "2006-06-30T15:10:59+02:00",
    "2006-06-30T15:15:29+02:00",
    "2006-06-30T15:39:45+02:00",
    "2006-06-30T15:45:12+02:00",
    "2006-06-30T16:17:55+02:00",
    "2006-07-01T04:50:57+02:00",
    "2006-07-03T06:01:05+02:00",
    "2006-07-03T11:09:09+02:00",
    "2006-07-03T11:18:57+02:00",
    "2006-07-03T16:35:39+02:00",
    "2006-10-17T10:03:34+02:00",
    "2006-10-17T10:32:51+02:00",
    "2006-10-17T10:41:42+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ArrayIndexOutOfBoundsException",
      "elements": [
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidType",
          "source": "ProblemReporter.java:2992"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.reportInvalidType",
          "source": "TypeReference.java:170"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType",
          "source": "TypeReference.java:136"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType",
          "source": "TypeReference.java:123"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType",
          "source": "Annotation.java:214"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations",
          "source": "ASTNode.java:436"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getAnnotationTypes",
          "source": "EclipseSourceType.java:443"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAnnotationStyleAspect",
          "source": "EclipseSourceType.java:123"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAspect",
          "source": "EclipseSourceType.java:108"
        },
        {
          "method": "org.aspectj.weaver.ReferenceType.isAspect",
          "source": "ReferenceType.java:159"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.verifyAnyTypeParametersMeetBounds",
          "source": "AjLookupEnvironment.java:269"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings",
          "source": "AjLookupEnvironment.java:228"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile",
          "source": "Compiler.java:301"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:315"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation",
          "source": "AjBuildManager.java:887"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild",
          "source": "AjBuildManager.java:244"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild",
          "source": "AjBuildManager.java:163"
        },
        {
          "method": "org.aspectj.ajde.internal.CompilerAdapter.compile",
          "source": "CompilerAdapter.java:122"
        },
        {
          "method": "org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run",
          "source": "AspectJBuildManager.java:191"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "149293",
      "date": "2006-06-30T14:20:01+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.ArrayIndexOutOfBoundsException",
      "elements": [
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidType",
          "source": "ProblemReporter.java:2992"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.reportInvalidType",
          "source": "TypeReference.java:170"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType",
          "source": "TypeReference.java:136"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType",
          "source": "TypeReference.java:123"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType",
          "source": "Annotation.java:214"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations",
          "source": "ASTNode.java:436"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getAnnotationTypes",
          "source": "EclipseSourceType.java:443"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAnnotationStyleAspect",
          "source": "EclipseSourceType.java:123"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAspect",
          "source": "EclipseSourceType.java:108"
        },
        {
          "method": "org.aspectj.weaver.ReferenceType.isAspect",
          "source": "ReferenceType.java:159"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.verifyAnyTypeParametersMeetBounds",
          "source": "AjLookupEnvironment.java:269"
        },
        {
          "method": "org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings",
          "source": "AjLookupEnvironment.java:228"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile",
          "source": "Compiler.java:301"
        },
        {
          "method": "org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile",
          "source": "Compiler.java:315"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation",
          "source": "AjBuildManager.java:887"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild",
          "source": "AjBuildManager.java:244"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild",
          "source": "AjBuildManager.java:199"
        },
        {
          "method": "org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild",
          "source": "AjBuildManager.java:170"
        },
        {
          "method": "org.aspectj.ajde.internal.CompilerAdapter.compile",
          "source": "CompilerAdapter.java:117"
        },
        {
          "method": "org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run",
          "source": "AspectJBuildManager.java:191"
        }
      ],
      "number": 1,
      "commentIndex": 7,
      "bugId": "149293",
      "date": "2006-07-01T04:50:57+02:00",
      "product": "AspectJ",
      "component": "Compiler",
      "severity": "normal"
    }
  ],
  "groupId": "149293",
  "bugId": "149293",
  "date": "2006-06-30T14:20:01+02:00",
  "product": "AspectJ",
  "component": "Compiler",
  "severity": "normal"
}