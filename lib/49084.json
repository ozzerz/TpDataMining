{
  "comments": [
    "java.lang.StringIndexOutOfBoundsException: String index out of range: -1\n\tat java.lang.String.charAt(String.java:444)\n\tat\norg.eclipse.jdt.internal.corext.util.CodeFormatterUtil.isDifferent(CodeFormatterUtil.java:395)\n\tat\norg.eclipse.jdt.internal.corext.util.CodeFormatterUtil.commentDifferent(CodeFormatterUtil.java:353)\n\tat\norg.eclipse.jdt.internal.corext.util.CodeFormatterUtil.emulateNewWithOld(CodeFormatterUtil.java:317)\n\tat\norg.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format2(CodeFormatterUtil.java:187)\n\tat\norg.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format(CodeFormatterUtil.java:101)\n\tat\norg.eclipse.jdt.internal.ui.text.java.JavaFormattingStrategy.format(JavaFormattingStrategy.java:86)\n\tat\norg.eclipse.jface.text.formatter.ContentFormatter2.format(ContentFormatter2.java:806)\n\tat\norg.eclipse.jface.text.formatter.ContentFormatter2.formatMaster(ContentFormatter2.java:661)\n\tat\norg.eclipse.jface.text.formatter.ContentFormatter2.format(ContentFormatter2.java:487)\n\tat org.eclipse.jface.text.source.SourceViewer.doOperation(SourceViewer.java:668)\n\tat\norg.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.doOperation(JavaSourceViewer.java:124)\n\tat\norg.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:174)\n\tat\norg.eclipse.ui.texteditor.TextOperationAction$1.run(TextOperationAction.java:122)\n\tat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:84)\n\tat org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:120)\n\tat org.eclipse.jface.action.Action.runWithEvent(Action.java:842)\n\tat\norg.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:509)\n\tat\norg.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:461)\n\tat\norg.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:408)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:847)\n\tat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2294)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1975)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1506)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1482)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:246)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:139)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:47)\n\tat\norg.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:242)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:84)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.eclipse.core.internal.boot.OSGiBootLoader.basicRun(OSGiBootLoader.java:239)\n\tat org.eclipse.core.internal.boot.OSGiBootLoader.run(OSGiBootLoader.java:665)\n\tat org.eclipse.core.internal.boot.OSGiBootLoader.run(OSGiBootLoader.java:652)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:299)\n\tat org.eclipse.core.launcher.Main.run(Main.java:767)\n\tat org.eclipse.core.launcher.Main.main(Main.java:601)\n\n\nAgainst 3.0 i20031211\nsee attached source to format.",
    "Created an attachment (id\u003d7217)\na source file to reformat\n\n(attached as binary to preserve actual content)",
    "Martin, please investigate.",
    "I can\u0027t reproduce the problem with your attached code. How did you envoke the \nformatter? Using Source-\u003eFormat? What was the text selection?\n\nIs it intentionally that the file contains two package statements?\n\nThe problem only shows up when the old formatter is enabled.",
    "What?!! It does not contain 2 pakage statements!\nSeams like file upload/download is broken on bugzilla...\n\nI do not select any text, I click anywhere, right click, source, format.\n\nhere is the code inlined: see also a zip in attachment\n\n-------cut here---------------\n/* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n * The Apache Software License, Version 1.1\n *\n * Copyright (c) 2001 The Apache Software Foundation.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The end-user documentation included with the redistribution,\n *    if any, must include the following acknowledgment:\n *       \"This product includes software developed by the\n *        Apache Software Foundation (http://www.sf.net/).\"\n *    Alternately, this acknowledgment may appear in the software itself,\n *    if and wherever such third-party acknowledgments normally appear.\n *\n * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n *    \"Apache EHCache\" must not be used to endorse or promote products\n *    derived from this software without prior written permission. For\n *    written permission, please contact sf@sf.net.\n *\n * 5. Products derived from this software may not be called \"Apache\",\n *    \"Apache EHCache\", nor may \"Apache\" appear in their name, without\n *    prior written permission of the Apache Software Foundation.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS\u0027\u0027 AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * \u003chttp://www.sf.net/\u003e.\n */\n\npackage net.sf.ehcache.store;\n\nimport net.sf.ehcache.Cache;\nimport net.sf.ehcache.Element;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.RandomAccessFile;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * A disk cache implementation.\n *\n * @version $Id: DiskStore.java,v 1.9 2003/11/15 04:36:30 gregluck Exp $\n * @author Adam Murdoch\n * @author Greg Luck\n */\npublic class DiskStore implements Store {\n    private static final Log LOG \u003d LogFactory.getLog(DiskStore.class.getName());\n\n    /** Map of all disk caches. */\n    private static Map caches \u003d Collections.synchronizedMap(new HashMap());\n\n    final String name;\n    private boolean active;\n    private RandomAccessFile file;\n    private final Map elements \u003d new HashMap();\n    private final Map spool \u003d new HashMap();\n    private Thread spoolThread;\n    private Thread expiryThread;\n    private final ArrayList freeSpace \u003d new ArrayList();\n    private long totalSize;\n    private int expiryThreadInterval;\n    private Cache cache;\n\n    private File dataFile;\n    private int status;\n\n//    /**\n//     * Creates a Disk Store with defaults.\n//     * \u003cp\u003e\n//     * The expiry thread will run once every 5 minutes.\n//     **/\n//    public DiskStore(Cache cache, String diskPath) {\n//        this(cache, diskPath, 1);//5 * 60 * 5);\n//    }\n\n\n    /** Creates a cache. */\n    public DiskStore(Cache cache, String diskPath, int expiryThreadInterval) {\n\n        status \u003d Store.STATUS_UNINITIALISED;\n\n        this.cache \u003d cache;\n        name \u003d cache.getName();\n        caches.put(name, this);\n\n        try {\n            // Make sure the cache directory exists\n            final File diskDir \u003d new File(diskPath);\n            if (diskDir.exists() \u0026\u0026 !diskDir.isDirectory()) {\n                throw new Exception(\n                        \"Store directory \\\"\" + diskDir.getCanonicalPath() + \"\\\"\nexists and is not a directory.\");\n            }\n            if (!diskDir.exists() \u0026\u0026 !diskDir.mkdirs()) {\n                throw new Exception(\"Could not create cache directory \\\"\" +\ndiskDir.getCanonicalPath() + \"\\\".\");\n            }\n\n            // Clean up the files, if they exist\n            dataFile \u003d new File(diskDir, name + \".data\");\n            dataFile.delete();\n\n            // Create the indexed file\n            file \u003d new RandomAccessFile(dataFile, \"rw\");\n\n            active \u003d true;\n\n            // Start up the spool thread\n            spoolThread \u003d new SpoolThread();\n            spoolThread.start();\n\n            // Start up the expiry thread\n            expiryThread \u003d new ExpiryThread(expiryThreadInterval);\n            expiryThread.start();\n\n            status \u003d Store.STATUS_ALIVE;\n        } catch (final Exception e) {\n            // Cleanup on error\n            dispose();\n            LOG.error(name + \"Cache: Could not create disk store\", e);\n        }\n    }\n\n    /**\n     * Locates a cache, by name.\n     */\n    public static Store getCache(final String name) {\n        return (Store) caches.get(name);\n    }\n\n    /** Asserts that the cache is active. */\n    private void checkActive() throws Exception {\n        if (!active) {\n            throw new Exception(name + \"Cache: The Disk store is not active.\");\n        }\n    }\n\n    /**\n     * Returns the cache type.\n     */\n    public int getCacheType() {\n        return Store.DISK_CACHE;\n    }\n\n    /**\n     * Returns the cache name this disk cache is spooling for\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the cache status.\n     */\n    public synchronized int getStatus() {\n        return Store.STATUS_ALIVE;\n    }\n\n    /**\n     * Gets an {@link Element} from the Disk Store.\n     * @return The element may not be null but the value may be,\n     * as it is softly referenced. This should be checked by callers of this method.\n     */\n    public synchronized Element get(final Serializable key) throws IOException {\n        try {\n            checkActive();\n\n            // Check in the spool.  Remove if present\n            Element element \u003d (Element) spool.remove(key);\n            if (element !\u003d null) {\n                element.updateAccessStatistics();\n                return element;\n            }\n\n            // Check if the element is on disk\n            final DiskElement diskElement \u003d (DiskElement) elements.get(key);\n            if (diskElement \u003d\u003d null) {\n                // Not on disk\n                return null;\n            }\n\n            // Load the element\n            file.seek(diskElement.position);\n            final byte[] buffer \u003d new byte[diskElement.payloadSize];\n            file.readFully(buffer);\n            final ByteArrayInputStream instr \u003d new ByteArrayInputStream(buffer);\n            final ObjectInputStream objstr \u003d new ObjectInputStream(instr);\n            element \u003d Element.readFrom(objstr);//(Element) objstr.readObject();\n            element.updateAccessStatistics();\n            return element;\n        } catch (Exception e) {\n            LOG.error(name + \"Cache: Could not read disk store element for key \"\n+ key, e);\n        }\n        return null;\n    }\n\n\n    /**\n     * Gets an Array of the keys for all elements in the memory cache\n     * @return An Object[]\n     */\n    public synchronized Object[] getKeyArray() {\n        return elements.keySet().toArray();\n    }\n\n    /**\n     * Returns the current cache size.\n     */\n    public synchronized int getSize() {\n        try {\n            checkActive();\n            return elements.size() + spool.size();\n        } catch (Exception e) {\n            LOG.error(name + \"Cache: Could not determine size of disk store.\", e);\n            return 0;\n        }\n    }\n\n    /**\n     * Puts an item to the cache.\n     */\n    public synchronized void put(final Element entry) throws IOException {\n        try {\n            checkActive();\n\n            // Spool the entry\n            spool.put(entry.getKey(), entry);\n            notifyAll();\n        } catch (Exception e) {\n            LOG.error(name + \"Cache: Could not write disk store element for \" +\nentry.getKey(), e);\n        }\n    }\n\n    /**\n     * Removes an item from the cache.\n     */\n    public synchronized boolean remove(final Serializable key) throws IOException {\n        try {\n            checkActive();\n\n            // Remove the entry from the spool\n            final Object spoolValue \u003d spool.remove(key);\n            if (spoolValue !\u003d null) {\n                return true;\n            }\n\n            // Remove the entry from the file\n            final DiskElement element \u003d (DiskElement) elements.remove(key);\n            if (element !\u003d null) {\n                freeBlock(element);\n                return true;\n            }\n        } catch (Exception e) {\n            LOG.error(name + \"Cache: Could not remove disk store entry for \" +\nkey, e);\n        }\n        return false;\n    }\n\n    /** Marks a block as free. */\n    private void freeBlock(final DiskElement element) {\n        totalSize -\u003d element.payloadSize;\n        element.payloadSize \u003d 0;\n        freeSpace.add(element);\n    }\n\n    /**\n     * Removes all cached items from the cache.\n     */\n    public synchronized void removeAll() throws IOException {\n        try {\n            checkActive();\n\n            // Ditch all the elements, and truncate the file\n            spool.clear();\n            elements.clear();\n            freeSpace.clear();\n            totalSize \u003d 0;\n            file.setLength(0);\n        } catch (Exception e) {\n            // Clean up\n            LOG.error(name + \"Cache: Could not rebuild disk store\", e);\n            dispose();\n        }\n    }\n\n    /**\n     * Prepares for shutdown.\n     */\n    public synchronized void dispose() {\n        // Close the cache\n        try {\n            elements.clear();\n            spool.clear();\n            freeSpace.clear();\n            if (file !\u003d null) {\n                file.close();\n            }\n            dataFile.delete();\n        } catch (Exception e) {\n            LOG.error(name + \"Cache: Could not shut down disk cache\", e);\n        } finally {\n            active \u003d false;\n            file \u003d null;\n            notifyAll();\n        }\n    }\n\n    /**\n     * Whether there are any elements waiting to be spooled to disk.\n     * @return false if there are elements waiting, otherwise true\n     */\n    public synchronized boolean isSpoolEmpty() {\n        return (!active || spool.size() \u003d\u003d 0);\n    }\n\n    /**\n     * Main method for the spool thread.\n     *\n     * Note that the spool thread locks the cache for the entire time it is\nwritting elements to the disk.\n     * TODO - Give cache lookups preference to writes\n     */\n    private synchronized void spoolThreadMain() {\n        while (true) {\n            // Wait for elements in the spool\n            while (active \u0026\u0026 spool.size() \u003d\u003d 0) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                    // Bail\n                    return;\n                }\n            }\n            if (!active) {\n                return;\n            }\n\n            // Write elements to disk\n            try {\n                flushSpool();\n            } catch (IOException e) {\n                LOG.error(name + \"Cache: Could not write elements to disk\ncache\", e);\n            }\n        }\n    }\n\t\n    \n    \n    static class MyBAOS extends ByteArrayOutputStream {\n    \tbyte[] getBuff() {\n    \t\treturn super.buf;\n    \t}\n    \t\n    \tint getCount() {\n    \t\treturn super.count;\n    \t}\n    }\n    \n    \n    /**\n     * Flushes all spooled elements to disk.\n     * Note that the cache is locked for the entire time that the spool is being\nflushed.\n     */\n    private synchronized void flushSpool() throws IOException {\n        try {\n            // Write elements to the DB\n            for (Iterator iterator \u003d spool.values().iterator();\niterator.hasNext();) {\n                final Element element \u003d (Element) iterator.next();\n                final Serializable key \u003d element.getKey();\n\n                // Remove the old entry, if any\n                final DiskElement oldBlock \u003d (DiskElement) elements.remove(key);\n                if (oldBlock !\u003d null) {\n                    freeBlock(oldBlock);\n                }\n\n                // Serialise the entry\n                // TODO - use a custom OutputStream\n                \n                //-----------------\n                \n//                final ByteArrayOutputStream outstr \u003d new ByteArrayOutputStream();\n//                final ObjectOutputStream objstr \u003d new ObjectOutputStream(outstr);\n//                objstr.writeObject(element);\n//                objstr.close();\n//                final byte[] buffer \u003d outstr.toByteArray();\n//                // Check for a free block\n//                DiskElement diskElement \u003d findFreeBlock(buffer.length);\n//                if (diskElement \u003d\u003d null) {\n//                    diskElement \u003d new DiskElement();\n//                    diskElement.position \u003d file.length();\n//                    diskElement.blockSize \u003d buffer.length;\n//                }\n//\n//                // TODO - cleanup block on failure\n//                // Write the record\n//                file.seek(diskElement.position);\n//                file.write(buffer);\n//                if (cache.isEternal()) {\n//                    // Never expires\n//                    diskElement.expiryTime \u003d Long.MAX_VALUE;\n//                } else {\n//                    // Calculate expiry time\n//                    long timeToLive \u003d element.getCreationTime() +\ncache.getTimeToLiveSeconds() * 1000;\n//                    long timeToIdle \u003d element.getLastAccessTime() +\ncache.getTimeToIdleSeconds() * 1000;\n//                    diskElement.expiryTime \u003d Math.max(timeToLive, timeToIdle);\n//                }\n//\n//                // Add to index, update stats\n//                diskElement.payloadSize \u003d buffer.length;\n//                totalSize +\u003d buffer.length;\n//                elements.put(key, diskElement);\n                \n                \n                final MyBAOS outstr \u003d new MyBAOS();\n                final ObjectOutputStream objstr \u003d new ObjectOutputStream(outstr);\n                element.writeTo(objstr);//objstr.writeObject(element);\n                objstr.close();\n                final byte[] _buffer \u003d outstr.getBuff();//.toByteArray();\n\t\tfinal int cnt \u003d outstr.getCount();\n\t\t\n                // Check for a free block\n                DiskElement diskElement \u003d findFreeBlock(cnt);\n                if (diskElement \u003d\u003d null) {\n                    diskElement \u003d new DiskElement();\n                    diskElement.position \u003d file.length();\n                    diskElement.blockSize \u003d cnt;\n                }\n\n                // TODO - cleanup block on failure\n                // Write the record\n                file.seek(diskElement.position);\n                file.write(_buffer, 0, cnt);\n                \n                if (cache.isEternal()) {\n                    // Never expires\n                    diskElement.expiryTime \u003d Long.MAX_VALUE;\n                } else {\n                    // Calculate expiry time\n                    long timeToLive \u003d element.getCreationTime() +\ncache.getTimeToLiveSeconds() * 1000;\n                    long timeToIdle \u003d element.getLastAccessTime() +\ncache.getTimeToIdleSeconds() * 1000;\n                    diskElement.expiryTime \u003d Math.max(timeToLive, timeToIdle);\n                }\n\n                // Add to index, update stats\n                diskElement.payloadSize \u003d cnt;\n                totalSize +\u003d cnt;\n                elements.put(key, diskElement);\n                \n                //-----------------\n                \n            }\n        } finally {\n            // Clear the spool.  Do this regardless of whether the writes failed\n- just ditch the elements\n            spool.clear();\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(name + \"Disk Store: \" + \" elements \u003d \" + elements.size() +\n\", free blocks \u003d \" + freeSpace.size()\n                    + \", used \u003d \"\n                    + totalSize\n                    + \" bytes, total \u003d \"\n                    + file.length()\n                    + \" bytes.\");\n        }\n    }\n\n    /**\n     * The main method for the expiry thread.\n     */\n    private void expiryThreadMain(final int expiryInterval) {\n        try {\n            while (true) {\n                // Sleep for the specified time (the time is in seconds)\n                Thread.sleep(expiryInterval * 1000);\n\n                // Clean up the elements\n                expireElements();\n            }\n        } catch (InterruptedException e) {\n            // Bail on interruption\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(name + \"Cache: Expiry thread interrupted on Disk Store.\");\n            }\n        }\n    }\n\n    /**\n     * Removes expired elements.\n     * Note that the cache is locked for the entire time that elements are being\nexpired.\n     */\n    private synchronized void expireElements() {\n        final long now \u003d System.currentTimeMillis();\n\n        // Clean up the spool\n        for (Iterator iterator \u003d spool.values().iterator(); iterator.hasNext();) {\n            final Element element \u003d (Element) iterator.next();\n            if (cache.isExpired(element)) {\n                // An expired element\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(name + \"Cache: Removing expired spool element \" +\nelement.getKey() + \" from Disk Store\");\n                }\n                iterator.remove();\n            }\n        }\n\n        // Clean up disk elements\n        for (Iterator iterator \u003d elements.entrySet().iterator();\niterator.hasNext();) {\n            final Map.Entry entry \u003d (Map.Entry) iterator.next();\n            final DiskElement element \u003d (DiskElement) entry.getValue();\n            if (now \u003e\u003d element.expiryTime) {\n                // An expired element\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(name + \"Cache: Removing expired spool element \" +\nentry.getKey() + \" from Disk Store\");\n                }\n                iterator.remove();\n                freeBlock(element);\n            }\n        }\n    }\n\n    /** Allocates a free block. */\n    private DiskElement findFreeBlock(final int length) {\n        for (int i \u003d 0; i \u003c freeSpace.size(); i++) {\n            final DiskElement element \u003d (DiskElement) freeSpace.get(i);\n            if (element.blockSize \u003e\u003d length) {\n                freeSpace.remove(i);\n                return element;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns a {@link String} representation of the {@link DiskStore}\n     */\n    public String toString() {\n        StringBuffer sb \u003d new StringBuffer();\n        sb.append(\"[ dataFile \u003d \").append(dataFile.getAbsolutePath())\n                .append(\", active\u003d\").append(active)\n                .append(\", totalSize\u003d\").append(totalSize)\n                .append(\", status\u003d\").append(status)\n                .append(\", expiryThreadInterval \u003d \").append(expiryThreadInterval)\n                .append(\" ]\");\n        return sb.toString();\n    }\n\n    /**\n     * A reference to an on-disk elements.\n     */\n    private static class DiskElement {\n        long position;\n        int payloadSize;\n        int blockSize;\n        long expiryTime;\n    }\n\n    /**\n     * A background thread that writes objects to the file.\n     */\n    private class SpoolThread extends Thread {\n        public SpoolThread() {\n            super(\"Store \" + name + \" Spool Thread\");\n            setDaemon(true);\n        }\n\n        /**\n         * Main thread method.\n         */\n        public void run() {\n            spoolThreadMain();\n        }\n    }\n\n    /**\n     * A background thread that removes expired objects.\n     */\n    private class ExpiryThread extends Thread {\n        private final int expiryInterval;\n\n        public ExpiryThread(final int expiryInterval) {\n            super(\"Store \" + name + \" Expiry Thread\");\n            this.expiryInterval \u003d expiryInterval;\n            setDaemon(true);\n        }\n\n        /**\n         * Main thread method.\n         */\n        public void run() {\n            expiryThreadMain(expiryInterval);\n        }\n\n\n    }\n}\n",
    "Created an attachment (id\u003d7224)\nDiskStore.zip\n",
    "Thanks a lot for the file. Unfortunatly I still can\u0027t reproduce it. What are \nyour code formatter settings?\nMaybe  the bug has already been fixed, that\u0027s possible too.",
    "with both inlined and zip files? Anyway.\n\nsettings: (I use the old formatter, not the new one.)\n\nnewlines tab:\n-just the last one is enabled (insert new line in empty block)\n\nline length tab:\n-code\u003d200\n-comment\u003d80\n\nstyle tab:\n-enable only last one (insert tabs for indent, not space)\n-8 spaces per indentation\n\ncomment tab:\n-do not format comment\n-(incase this is ignored, of the 8 checkboxes, all set except 1st and 4rd)\n",
    "Ok, got it! Fixed \u003e 20031219\n\nThanks a lot for your help!",
    "Using 3.0M6: not fixed.\n\n\njava.lang.StringIndexOutOfBoundsException: String index out of range: -1\n\tat java.lang.String.charAt(String.java:444)\n\tat\norg.eclipse.jdt.internal.corext.util.CodeFormatterUtil.isDifferent(CodeFormatterUtil.java:395)\n\tat\norg.eclipse.jdt.internal.corext.util.CodeFormatterUtil.commentDifferent(CodeFormatterUtil.java:353)\n\tat\norg.eclipse.jdt.internal.corext.util.CodeFormatterUtil.emulateNewWithOld(CodeFormatterUtil.java:317)\n\tat\norg.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format2(CodeFormatterUtil.java:187)\n\tat\norg.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format(CodeFormatterUtil.java:101)\n\tat\norg.eclipse.jdt.internal.ui.text.java.JavaFormattingStrategy.format(JavaFormattingStrategy.java:93)\n\tat\norg.eclipse.jface.text.formatter.ContentFormatter2.format(ContentFormatter2.java:806)\n\tat\norg.eclipse.jface.text.formatter.ContentFormatter2.formatMaster(ContentFormatter2.java:661)\n\tat\norg.eclipse.jface.text.formatter.ContentFormatter2.format(ContentFormatter2.java:487)\n\tat org.eclipse.jface.text.source.SourceViewer.doOperation(SourceViewer.java:668)\n\tat\norg.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.doOperation(JavaSourceViewer.java:124)\n\tat\norg.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:187)\n\tat\norg.eclipse.ui.texteditor.TextOperationAction$1.run(TextOperationAction.java:122)\n\tat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:84)\n\tat org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:120)\n\tat org.eclipse.jface.action.Action.runWithEvent(Action.java:842)\n\tat\norg.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:509)\n\tat\norg.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:461)\n\tat\norg.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:408)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:847)\n\tat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2311)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1992)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1506)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1482)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:246)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:139)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:47)\n\tat\norg.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:85)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:279)\n\tat org.eclipse.core.launcher.Main.run(Main.java:742)\n\tat org.eclipse.core.launcher.Main.main(Main.java:581)\n",
    "This got fixed for the first integration build after M6 (note, the target \nmilestone is set to M7)."
  ],
  "commentCreationDates": [
    "2003-12-17T22:02:41+01:00",
    "2003-12-17T22:04:27+01:00",
    "2003-12-18T08:50:52+01:00",
    "2003-12-18T09:28:16+01:00",
    "2003-12-18T14:27:41+01:00",
    "2003-12-18T14:28:32+01:00",
    "2003-12-18T16:24:29+01:00",
    "2003-12-18T16:59:34+01:00",
    "2003-12-19T13:20:10+01:00",
    "2003-12-23T01:49:30+01:00",
    "2003-12-26T18:53:01+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.StringIndexOutOfBoundsException",
      "message": "String index out of range: -1",
      "elements": [
        {
          "method": "java.lang.String.charAt",
          "source": "String.java:444"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.isDifferent",
          "source": "CodeFormatterUtil.java:395"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.commentDifferent",
          "source": "CodeFormatterUtil.java:353"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.emulateNewWithOld",
          "source": "CodeFormatterUtil.java:317"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format2",
          "source": "CodeFormatterUtil.java:187"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format",
          "source": "CodeFormatterUtil.java:101"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaFormattingStrategy.format",
          "source": "JavaFormattingStrategy.java:86"
        },
        {
          "method": "org.eclipse.jface.text.formatter.ContentFormatter2.format",
          "source": "ContentFormatter2.java:806"
        },
        {
          "method": "org.eclipse.jface.text.formatter.ContentFormatter2.formatMaster",
          "source": "ContentFormatter2.java:661"
        },
        {
          "method": "org.eclipse.jface.text.formatter.ContentFormatter2.format",
          "source": "ContentFormatter2.java:487"
        },
        {
          "method": "org.eclipse.jface.text.source.SourceViewer.doOperation",
          "source": "SourceViewer.java:668"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.doOperation",
          "source": "JavaSourceViewer.java:124"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation",
          "source": "CompilationUnitEditor.java:174"
        },
        {
          "method": "org.eclipse.ui.texteditor.TextOperationAction$1.run",
          "source": "TextOperationAction.java:122"
        },
        {
          "method": "org.eclipse.swt.custom.BusyIndicator.showWhile",
          "source": "BusyIndicator.java:84"
        },
        {
          "method": "org.eclipse.ui.texteditor.TextOperationAction.run",
          "source": "TextOperationAction.java:120"
        },
        {
          "method": "org.eclipse.jface.action.Action.runWithEvent",
          "source": "Action.java:842"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection",
          "source": "ActionContributionItem.java:509"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.access$2",
          "source": "ActionContributionItem.java:461"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem$5.handleEvent",
          "source": "ActionContributionItem.java:408"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java:82"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:847"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java:2294"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:1975"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1506"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1482"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:246"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:139"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:47"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:242"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:84"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:324"
        },
        {
          "method": "org.eclipse.core.internal.boot.OSGiBootLoader.basicRun",
          "source": "OSGiBootLoader.java:239"
        },
        {
          "method": "org.eclipse.core.internal.boot.OSGiBootLoader.run",
          "source": "OSGiBootLoader.java:665"
        },
        {
          "method": "org.eclipse.core.internal.boot.OSGiBootLoader.run",
          "source": "OSGiBootLoader.java:652"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:324"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:299"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:767"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:601"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "49084",
      "date": "2003-12-17T22:02:41+01:00",
      "product": "JDT",
      "component": "UI",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.StringIndexOutOfBoundsException",
      "message": "String index out of range: -1",
      "elements": [
        {
          "method": "java.lang.String.charAt",
          "source": "String.java:444"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.isDifferent",
          "source": "CodeFormatterUtil.java:395"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.commentDifferent",
          "source": "CodeFormatterUtil.java:353"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.emulateNewWithOld",
          "source": "CodeFormatterUtil.java:317"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format2",
          "source": "CodeFormatterUtil.java:187"
        },
        {
          "method": "org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format",
          "source": "CodeFormatterUtil.java:101"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaFormattingStrategy.format",
          "source": "JavaFormattingStrategy.java:93"
        },
        {
          "method": "org.eclipse.jface.text.formatter.ContentFormatter2.format",
          "source": "ContentFormatter2.java:806"
        },
        {
          "method": "org.eclipse.jface.text.formatter.ContentFormatter2.formatMaster",
          "source": "ContentFormatter2.java:661"
        },
        {
          "method": "org.eclipse.jface.text.formatter.ContentFormatter2.format",
          "source": "ContentFormatter2.java:487"
        },
        {
          "method": "org.eclipse.jface.text.source.SourceViewer.doOperation",
          "source": "SourceViewer.java:668"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.doOperation",
          "source": "JavaSourceViewer.java:124"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation",
          "source": "CompilationUnitEditor.java:187"
        },
        {
          "method": "org.eclipse.ui.texteditor.TextOperationAction$1.run",
          "source": "TextOperationAction.java:122"
        },
        {
          "method": "org.eclipse.swt.custom.BusyIndicator.showWhile",
          "source": "BusyIndicator.java:84"
        },
        {
          "method": "org.eclipse.ui.texteditor.TextOperationAction.run",
          "source": "TextOperationAction.java:120"
        },
        {
          "method": "org.eclipse.jface.action.Action.runWithEvent",
          "source": "Action.java:842"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection",
          "source": "ActionContributionItem.java:509"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.access$2",
          "source": "ActionContributionItem.java:461"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem$5.handleEvent",
          "source": "ActionContributionItem.java:408"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java:82"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:847"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java:2311"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:1992"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1506"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1482"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:246"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:139"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:47"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:226"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:85"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:324"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:279"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:742"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:581"
        }
      ],
      "number": 1,
      "commentIndex": 9,
      "bugId": "49084",
      "date": "2003-12-23T01:49:30+01:00",
      "product": "JDT",
      "component": "UI",
      "severity": "normal"
    }
  ],
  "groupId": "49084",
  "bugId": "49084",
  "date": "2003-12-17T22:02:41+01:00",
  "product": "JDT",
  "component": "UI",
  "severity": "normal"
}