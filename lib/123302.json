{
  "comments": [
    "java.lang.NullPointerException\n\tat org.eclipse.cdt.core.ErrorParserManager.findFilePath(ErrorParserManager.java:268)\n\tat org.eclipse.cdt.internal.errorparsers.GCCErrorParser.processLine(GCCErrorParser.java:238)\n\tat org.eclipse.cdt.internal.errorparsers.GCCErrorParser.processLine(GCCErrorParser.java:24)\n\tat org.eclipse.cdt.core.ErrorParserManager.processLine(ErrorParserManager.java:194)\n\tat org.eclipse.cdt.core.ErrorParserManager.checkLine(ErrorParserManager.java:399)\n\tat org.eclipse.cdt.core.ErrorParserManager.write(ErrorParserManager.java:389)\n\tat java.io.OutputStream.write(OutputStream.java:58)\n\tat org.eclipse.cdt.internal.core.ProcessClosure$ReaderThread.run(ProcessClosure.java:54)\n\n\nI\u0027ve done a little digging, and this occurs because  ErrorParserManager.fBaseDirectory is null after close() is invoked, but the EPM is still in use as an output stream.  This happens in GeneratedMakefileBuilder.invokeMake()[INCREMENTAL_BUILD] when the project has a pre-build step:\n\n(1) the EPM is instantiated and initialized\n(2) launcher.execute() is called for process \"make -q main-build\"; the purpose is to determine if the pre-build step should actually be done for this INCREMENTAL_BUILD.\n(3) launcher.waitAndRead() is called with the EPM passed in as stdout and stdin (via EPM.getOutputStream() which simply returns *this, e.g. the EPM object)\n(4) waitAndRead() creates a ProcessClosure with the EPM passed in as stdout and stdin\n(5) waitAndRead() calls runNonBlocking() on the ProcessClosure object -- which causes two ReaderThreads to be created and started, one for \"stdout\" (the EPM as reciever), and one for \"stderr\" (again, the EPM as reciever).\n(6) once the process finishes, waitAndRead returns.  The process exit ALSO ends the process\u0027s output streams, and the ReaderThread.run()\u0027s \"finally\" clause is called:\n    try { fOutputStream.flush(); } catch (IOException e) {} \u003c\u003c\u003c the EPM\n    try { fInputStream.close(); } catch (IOException e) {}  \u003c\u003c\u003c the process\u0027s\n\nNote that the ReaderThread is very careful not to close the EPM here.  This is good. Unfortunately...\n\n(7) During all this, launcher.waitAndRead() is sitting in a loop, waiting for the ReaderThreads started by ProcessClosure.runNonBlocking() to finish.  It does this by looping on:\n    while (!monitor.isCanceled() \u0026\u0026 closure.isAlive()) { ... }\n\nBut let\u0027s look at closure.isAlive():\n   if (fProcess !\u003d null) {\n      if (fOutputReader.isAlive() || fErrorReader.isAlive()) {\n\t  return true;\n      }\n      fProcess \u003d null;\n      fOutputReader.close(); \u003c\u003c\u003c the EPM!\n      fErrorReader.close();  \u003c\u003c\u003c the EPM!\n      fOutputReader \u003d null;\n      fErrorReader \u003d null;\n   }\n   return false;\n\nNote that once either of the ReaderThreads dies, then close() is called on the EPM.  (Multiple calls are okay, since the EPM does reference counting).  The problem is, we\u0027ve now called EPM.getOutputStream() twice, and then EPM.close() twice -- so the reference count is now 0.  When the reference count reaches zero, EPM.close() does this:\n    fBaseDirectory \u003d null;\n\nThere is no way, short of calling the *private* method EPM.initErrorParserManager(), to reset fBaseDirectory to a \"good\" value.  You really just have to create a new EPM.\n\nBut GeneratedMakefileBuilder.invokeMake() (which originally created the EPM back in step #1) doesn\u0027t do that.  After laucher.waitAndRead() returns, and IF the process\u0027s exitValue() is non-zero, GMB.invokeMake() simply falls thru to launching the \"real\" \u0027make pre-build main-build\u0027 using the same stdout (\u003d\u003d EPM) and stderr (\u003d\u003dEPM). \n\nBut these streams are now invalid, with fBaseDirectory \u003d\u003d null.  Which leads to the NPE above.  I *think* the fix is to add the following lines\n\n    epm \u003d new ErrorParserManager(getProject(), workingDirectory, this, errorParsers);\n    epm.setOutputStream(consoleOutStream);\n    stdout \u003d epm.getOutputStream();\n    stderr \u003d epm.getOutputStream();\n\nduring the \"cleanup\" phase of the \u0027make -q main-build\u0027 process launch (see patch).  Unfortunately, I haven\u0027t been able to test the patch yet \u0027cause I\u0027m still setting up an environment in which to work on the CDT itself (\u0027til now I\u0027ve only done plugin development and actual C++ work in eclipse).  I\u0027ll post more later, but I\u0027d appreciate any pointers or evaluation of my analysis above.",
    "Created an attachment (id\u003d32786)\npatch for NPE in GeneratedMakefileBuilder.invokeMake()\n\n",
    "Attached patch does eliminate the NPE under these conditions, and no adverse behaviors are observed.\n",
    "Hi Charles,\n\nI agree with your analysis of the problem, but not with the proposed patch.  I think the code should continue to use the same ErrorParserManager for both executes so that the errors from both get reported by the call to epm.reportProblems.  I suggest that the correct fix is to fix the reference counting.  Specifically, change the 2 calls to:\n\nif (launcher.waitAndRead(stdout, stderr, ...\n\nTo:\n\nif (launcher.waitAndRead(epm.getOutputStream(), epm.getOutputStream(), ...\n\nWould you test this fix to see if it solves your problem?\n\nThanks,\nLeo",
    "Created an attachment (id\u003d32939)\nAlternate fix, suggested by Leo\n\nHmm...that will work, but then the variables stdout and stderr are never used EXCEPT to explicitly close them.  However, we *need* those variables to exist specifically so that the EPM doesn\u0027t get closed after the prebuild step.  IOW, stdout and stderr are present strictly for the beneficial side effect of ensuring the EPM\u0027s refcount stays \u003e 0.  Although technically you only need one of them, not both.\n\nThat would make a tempting target for a future programmer to eliminate the \"unused\" variable(s).  The attached patch attempts to address this with a clarifying comment.  Not tested yet, but will report back.\n",
    "(In reply to comment #4)\n\u003e Created an attachment (id\u003d32939) [edit]\n\u003e Alternate fix, suggested by Leo\n\n[snip]\n\n\u003e That would make a tempting target for a future programmer to eliminate the\n\u003e \"unused\" variable(s).  The attached patch attempts to address this with a\n\u003e clarifying comment.  Not tested yet, but will report back.\n\nYep, tested the attached patch and the NPE does not occur, and the EPM\u0027s refcount stays \u003e 0 until explicitly closed in GeneratedMakefileBuilder.invokeMake().\n\n\n",
    "Thanks Charles.  I\u0027ve tested this on Windows and it looks good.  I\u0027ll commit the change to the 3.0 branch as well as Head next week with some other fixes.",
    "Patch is appled to 3.0.2 and Head"
  ],
  "commentCreationDates": [
    "2006-01-10T20:05:40+01:00",
    "2006-01-10T20:07:39+01:00",
    "2006-01-11T20:00:36+01:00",
    "2006-01-12T02:29:53+01:00",
    "2006-01-12T21:59:00+01:00",
    "2006-01-13T16:54:53+01:00",
    "2006-01-13T17:01:42+01:00",
    "2006-01-17T00:49:26+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.cdt.core.ErrorParserManager.findFilePath",
          "source": "ErrorParserManager.java:268"
        },
        {
          "method": "org.eclipse.cdt.internal.errorparsers.GCCErrorParser.processLine",
          "source": "GCCErrorParser.java:238"
        },
        {
          "method": "org.eclipse.cdt.internal.errorparsers.GCCErrorParser.processLine",
          "source": "GCCErrorParser.java:24"
        },
        {
          "method": "org.eclipse.cdt.core.ErrorParserManager.processLine",
          "source": "ErrorParserManager.java:194"
        },
        {
          "method": "org.eclipse.cdt.core.ErrorParserManager.checkLine",
          "source": "ErrorParserManager.java:399"
        },
        {
          "method": "org.eclipse.cdt.core.ErrorParserManager.write",
          "source": "ErrorParserManager.java:389"
        },
        {
          "method": "java.io.OutputStream.write",
          "source": "OutputStream.java:58"
        },
        {
          "method": "org.eclipse.cdt.internal.core.ProcessClosure$ReaderThread.run",
          "source": "ProcessClosure.java:54"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "123302",
      "date": "2006-01-10T20:05:40+01:00",
      "product": "CDT",
      "component": "cdt-build",
      "severity": "normal"
    }
  ],
  "groupId": "123302",
  "bugId": "123302",
  "date": "2006-01-10T20:05:40+01:00",
  "product": "CDT",
  "component": "cdt-build",
  "severity": "normal"
}