{
  "comments": [
    "3.0 M8\n\nI think this may be a test case for the problem Darin S was talking about this \nweek: (don\u0027t know how many of these steps are relevent yet)\n\n1. set refresh on startup on; only resource perspective open.\n2. add a new java file to a plug-in project\n3. start eclipse.\n4. quickly: switch to java perspective\n5. quickly: open type dialog\n\nI occasionally get a stack trace written to the log file (follows).  I get \nseveral errors since I cannot resolve the classpath entries.  The only fix is \nto startup again or close and reopen the project.\n\n!SESSION Apr 01, 2004 18:59:41.271 ---------------------------------------------\njava.version\u003d1.4.2_04\njava.vendor\u003dSun Microsystems Inc.\nBootLoader constants: OS\u003dwin32, ARCH\u003dx86, WS\u003dwin32, NL\u003den_US\n!ENTRY org.eclipse.core.runtime 4 2 Apr 01, 2004 18:59:41.271\n!MESSAGE Problems occurred when invoking code from plug-\nin: \"org.eclipse.core.runtime\".\n!STACK 0\njava.lang.NullPointerException\n\tat org.eclipse.jdt.launching.JavaRuntime.getPreferences\n(JavaRuntime.java:1525)\n\tat org.eclipse.jdt.launching.JavaRuntime.initializeVMConfiguration\n(JavaRuntime.java:1260)\n\tat org.eclipse.jdt.launching.JavaRuntime.initializeVMTypes\n(JavaRuntime.java:252)\n\tat org.eclipse.jdt.launching.JavaRuntime.getDefaultVMId\n(JavaRuntime.java:431)\n\tat org.eclipse.jdt.launching.JavaRuntime.getDefaultVMInstall\n(JavaRuntime.java:377)\n\tat org.eclipse.jdt.internal.launching.JREContainerInitializer.resolveVM\n(JREContainerInitializer.java:72)\n\tat org.eclipse.jdt.internal.launching.JREContainerInitializer.initialize\n(JREContainerInitializer.java:46)\n\tat org.eclipse.jdt.core.JavaCore$1.run(JavaCore.java:1176)\n\tat org.eclipse.core.internal.runtime.InternalPlatform.run\n(InternalPlatform.java:610)\n\tat org.eclipse.core.runtime.Platform.run(Platform.java:521)\n\tat org.eclipse.jdt.core.JavaCore.getClasspathContainer\n(JavaCore.java:1171)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1841)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1764)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1736)\n\tat org.eclipse.jdt.core.JavaCore.setClasspathContainer\n(JavaCore.java:3316)\n\tat org.eclipse.pde.internal.core.ModelEntry.updateClasspathContainer\n(ModelEntry.java:107)\n\tat org.eclipse.pde.internal.core.RequiredPluginsInitializer.initialize\n(RequiredPluginsInitializer.java:40)\n\tat org.eclipse.jdt.core.JavaCore$1.run(JavaCore.java:1176)\n\tat org.eclipse.core.internal.runtime.InternalPlatform.run\n(InternalPlatform.java:610)\n\tat org.eclipse.core.runtime.Platform.run(Platform.java:521)\n\tat org.eclipse.jdt.core.JavaCore.getClasspathContainer\n(JavaCore.java:1171)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1841)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1764)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1736)\n\tat org.eclipse.jdt.internal.core.search.JavaSearchScope.add\n(JavaSearchScope.java:78)\n\tat org.eclipse.jdt.internal.core.search.JavaWorkspaceScope.initialize\n(JavaWorkspaceScope.java:79)\n\tat org.eclipse.jdt.internal.core.search.JavaSearchScope.\u003cinit\u003e\n(JavaSearchScope.java:52)\n\tat org.eclipse.jdt.internal.core.search.JavaWorkspaceScope.\u003cinit\u003e\n(JavaWorkspaceScope.java:30)\n\tat org.eclipse.jdt.core.search.SearchEngine.createWorkspaceScope\n(SearchEngine.java:430)\n\tat org.eclipse.jdt.internal.ui.actions.OpenTypeAction.run\n(OpenTypeAction.java:54)\n\tat org.eclipse.jdt.internal.ui.actions.OpenTypeAction.run\n(OpenTypeAction.java:80)\n\tat org.eclipse.ui.internal.PluginAction.runWithEvent\n(PluginAction.java:269)\n\tat org.eclipse.ui.internal.WWinPluginAction.runWithEvent\n(WWinPluginAction.java:207)\n\tat org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection\n(ActionContributionItem.java:550)\n\tat org.eclipse.jface.action.ActionContributionItem.access$2\n(ActionContributionItem.java:502)\n\tat org.eclipse.jface.action.ActionContributionItem$6.handleEvent\n(ActionContributionItem.java:474)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:769)\n\tat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2578)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2256)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1562)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1536)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench\n(Workbench.java:257)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:139)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run\n(IDEApplication.java:90)\n\tat org.eclipse.core.internal.runtime.PlatformActivator$1.run\n(PlatformActivator.java:277)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run\n(EclipseStarter.java:239)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run\n(EclipseStarter.java:117)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke\n(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke\n(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:267)\n\tat org.eclipse.core.launcher.Main.run(Main.java:692)\n\tat org.eclipse.core.launcher.Main.main(Main.java:676)\n\nI have a workspace that can cause the red X\u0027s to show up fairly often - the \nstack trace may be a red herring.  \n\nDon\u0027t know where the bug goes, so putting in debug to start because launching \nis in the stack trace.",
    "I have never had a stack trace produced from my \"red X\" workspaces...the log \nwas always clean. Hopefully this gives us a place to start.\nI can look into this more tomorrow when I need a break from profiling :-)",
    "Others are encountering this problem with other steps.  My inclination is that \nthis is dependent on the order of computing the class-path dependencies and \nplug-in activation ",
    "John, we need to look at this.",
    "Created an attachment (id\u003d9291)\ndebug log for error case\n",
    "Created an attachment (id\u003d9292)\ndebug log (when the error does not occur)\n",
    "I ran these steps again with debugging turned on, then once more without step \n5.  I am adding two attachments: the \"failure\" log and the \"success\" log.  It \nappears that in the failure log, we are detecting a circularity and aborting.  \nThis is occurring because we are accessing the state during the computation \n(there is no circularity) - the end result is that the container is incorrectly \ncomputed.  \n\nI believe the correct way to handle this is to use thread locals for the \ncomputations in progress, but there is clever behavior for using previous \nvalues that I don\u0027t follow. (So, my attempt at transitioning to thread locals \ndidn\u0027t work)",
    "I can reproduce an NPE similar to the one noted in the initial report (I need \nto be in debug mode and manually steps through the code).\nIt is the result of a race condition. \nHere is a simplified version of the problem:\n - in a thread, the plugin A is starting, we are still in the code that \ntriggers the automagic activation (EclipseClassLoader.findLocalClass) and the \nplugin object is not initialized yet.\n - in another thread, the code A.getDefault() is called, this triggers \nclassloading which ends up in the same instance of EclipseClassLoader in \nfindLocalClass. Here because A is starting we just return the class which is \nstill being initialized in the other thread.\n\nI have an idea for a fix.\n\nI don\u0027t move the bug to equinox because you were tracking another problem. \nMove it if necessary.",
    "Version v_420a of org.eclipse.jdt.core now uses thread locals for the \ncomputations in progress. You can download a patch from \nhttp://dev.eclipse.org/viewcvs/index.cgi/%7Echeckout%7E/jdt-core-\nhome/r3.0/main.html#updates.",
    "Should this bug be moved to JCORE?",
    "This bug is not fixed (yet).  If I add synchronized around the initializer \ninvocation, it makes the problem go away (but this feels like it may introduce \nother problems).  Are we using CONTAINER_INITIALIZATION_IN_PROGRESS somewhere \nin a shared way?\n",
    "Moving to JDT Core",
    "One thing I noticed with latest I20040413 is that after restarting my \nworkspace, all my installed JREs were gone, except the one I used to launch \nEclipse on... this would easily account for fooling us into thinking the JRE \ninit didn\u0027t work, since there was no JRE to bind to... this would be a Debug \nissue.",
    "John, we\u0027re not using CONTAINER_INITIALIZATION_IN_PROGRESS in a shared way. We \nnow suspect that an initializer did not do its job and failed to initialize the \ncontainer. \n\nHowever I\u0027ve never been able to reproduce the problem you\u0027re seeing. We \nimproved the tracing in v_421b. It is posted as an early preview on our update \npage. Can you please give it a try?",
    "The runtime problem highlighted comment #7 has been fixed yesterday. The\nrationale of the solution is captured in bug #58879.",
    "Still unsure where the problem is. Will try to force the failure by throwing an \nOperationCanceledException the first time the JRE container is being \ninitialized.",
    "Just to clarify: comment #15 is describing a debug investigation strategy. We \nsuspect we are now fine, but still want to recreate problem conditions. If we \nguessed right, this was a combination of exception occurring during container \ninitializer (implementation exception or operation cancelled for other test \ncases).",
    "Update: I am trying to reproduce this on another machine and am failing.  The \ntiming appears to be fairly sensitive.  I won\u0027t have access to the known \nfailing machine until end of this week. Will annotate with success if I \nreproduce it earlier; otherwise, no update til end of this week.",
    "More info. Jerome was able to reproduce the problem in debugger this morning \nusing JohnW\u0027s import tool. The problem seems located in PDE land. Actually, \nJohn\u0027s original trace was showing the problem, but I missed it last night.\n\nThe interesting portion is copied below. You will notice that PDE sets the \nrequiredPlugins container to an empty value when requested to initialize it. \nFrom thereon the JavaModel and builder are both confused, as we will trust the \nempty container to be the true value.\n\nFrom the debug information, it seems that the PDE model has no entry for the \ncom.ibm.xtools.common.core.provider project, and thus default to an empty \ncontainer instead. It feels like the PDE model should definitely know about \nthis project at this stage, since it got added as a resource and recorded in \nthe JavaModel (visible in package explorer at this stage).\n\nThread[ModalContext,6,main] CPContainer SET  - setting container\nThread[ModalContext,6,main] \tcontainer path: \norg.eclipse.pde.core.requiredPlugins\nThread[ModalContext,6,main] \tprojects: {com.ibm.xtools.common.core.provider}\nThread[ModalContext,6,main] \tvalues: {\nThread[ModalContext,6,main] \t\tPlug-in Dependencies {\nThread[ModalContext,6,main]  \t\t}\nThread[ModalContext,6,main] \t}\n...\njava.lang.Exception: \u003cFake exception\u003e\n\tat org.eclipse.jdt.core.JavaCore.getClasspathContainer\n(JavaCore.java:1167)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1841)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1755)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1727)\n\tat org.eclipse.jdt.core.JavaCore.setClasspathContainer\n(JavaCore.java:3425)\n\tat \norg.eclipse.pde.internal.core.ModelEntry.updateUnknownClasspathContainer\n(ModelEntry.java:151)\n\tat org.eclipse.pde.internal.core.RequiredPluginsInitializer.initialize\n(RequiredPluginsInitializer.java:38)\n\tat org.eclipse.jdt.core.JavaCore.getClasspathContainer\n(JavaCore.java:1174)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1841)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1755)\n\tat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath\n(JavaProject.java:1727)\n\tat \norg.eclipse.jdt.internal.core.DeltaProcessor.createExternalArchiveDelta\n(DeltaProcessor.java:699)\n\tat org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged\n(DeltaProcessor.java:1864)\n\tat org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged\n(DeltaProcessingState.java:246)\n\tat org.eclipse.core.internal.events.NotificationManager$2.run\n(NotificationManager.java:268)\n\tat org.eclipse.core.internal.runtime.InternalPlatform.run\n(InternalPlatform.java:599)\n\tat org.eclipse.core.runtime.Platform.run(Platform.java:541)\n\tat org.eclipse.core.internal.events.NotificationManager.notify\n(NotificationManager.java:260)\n\tat org.eclipse.core.internal.events.NotificationManager.broadcastChanges\n(NotificationManager.java:148)\n\tat org.eclipse.core.internal.resources.Workspace.broadcastChanges\n(Workspace.java:158)\n\tat org.eclipse.core.internal.resources.Workspace.endOperation\n(Workspace.java:880)\n\tat org.eclipse.core.internal.resources.Workspace.run\n(Workspace.java:1656)\n\tat org.eclipse.ui.actions.WorkspaceModifyOperation.run\n(WorkspaceModifyOperation.java:105)\n\tat com.rational.aurora.tools.wizards.ProjectLoader.loadProject\n(ProjectLoader.java:55)\n\tat com.rational.aurora.tools.wizards.ProjectSetImportPage.importProject\n(ProjectSetImportPage.java:678)\n\tat com.rational.aurora.tools.wizards.ProjectSetImportPage.importProjects\n(ProjectSetImportPage.java:655)\n\tat com.rational.aurora.tools.wizards.ProjectSetImportPage.access$4\n(ProjectSetImportPage.java:592)\n\tat com.rational.aurora.tools.wizards.ProjectSetImportPage$12.run\n(ProjectSetImportPage.java:507)\n\tat org.eclipse.jface.operation.ModalContext$ModalContextThread.run\n(ModalContext.java:101)\n\n\nFurther investigations shows that though the Java model did get updated, we did \nnot yet notify clients of the project addition. As a consequence, this could \nexplain why PDE did not update its model yet. In general, we do issue Java \ndeltas when notified of resource deltas... so the issue may live there, \nexplaining why extra autobuilds may resolve the problem, since they could force \nintermediate delta broadcasts.\n",
    "To see the problem as soon as it occurs, put a breakpoint in \nProblemHandler.java at line 118.",
    "Here is what we think happens.\n\nWhen the project com.ibm.xtools.common.core.provider is being imported, the \nimport tool is building it before the platform got a chance to broadcast the \ndelta, and thus the JavaModel did not broadcast it either. Then, when the \nmanual build occurs, it is initializing the requiredPlugins container, which \nPDE sets empty since its model did not get updated yet.\n\nContainer initializers should *never* rely on JavaModel notifications to \nperform update their own model and be able to answer containers upon request. \nIndeed, these requests may occur at any stage. The theory is that a JRE \ncontainer should only consult installed JRE tables, and a PDE container should \nonly consult project resources and plugin.xml (to simplify). This being said, \nwe still don\u0027t understand why the JavaModel got updated (could be some lazy \ninitialization as opposed to reaction to a rsc delta).\nWe still don\u0027t understand either why the first project \ncom.ibm.xtools.common.core did initialize ok.\n",
    "If deltas are further issued, then PDE seems to react properly, and reset \ncontainers appropriately afterwards; therefore things which are broken at one \nstage, are then fixed up later on, and one may not notice it, unless a build \noccurs in the intermediate stage. This explains why the build in the end is \ncleaning up the remaining issues.",
    "Further investigation shows the following:\nJohnW\u0027s importer creates the 2 projects in 2 operations. When the importer \ncreates the 2nd project in an IWorkspaceRunnable, at the end of the operation:\n1. JDT Core adds the project to the Java Model\n2. JDT Core asks the PDE initializer for the PDE container of the 2nd project\n-\u003e At this point the PDE model is not up-to-date and PDE sets an empty container\n3. JDT Core sends the \u0027added 2nd project\u0027 Java delta\n4. The importer forces an incremental build. The Java builder is using the \nempty PDE container, thus creating many compile errors.\n-\u003e Why isn\u0027t the PDE container up-to-date at this point? I\u0027m investigating.\n",
    "PDE is not listening to Java deltas. It is updating the PDE container in \nreaction to the PRE_AUTO_BUILD notification that happens after step 3 (and in \nthe failing case, this happens after step 4).",
    "Thanks, this explains why final extra build cleans up problems as we will \nconsider it a classpath change due to PDE forcing a container change at later \nstage.\n\nSo PDE doesn\u0027t update based on Java notifications, which is good, but still \nthey react too late for being able to feed us an appropriate container value \nwhen we request it (for computing Java delta during POST_CHANGE notification).\n\nIdeally, PDE should listen for POST_CHANGE as well (or instead?), and update \nits model, if it could register before our listener; but API-wise this seems \nimpossible to accomplish.\n\nInstead, it could maybe lazily initialize its model, on demand, instead of only \nrelying on notifications (btw you may also want to check bug 38658 for a corner \ncase where deltas are missed unless you add extra support). \n\nMoving to PDE UI for further acting.",
    "To clarify. Listening to PRE_AUTO_BUILD notifications was likely good enough \nfor 2.1 timeframe, but since we moved to background autobuilds, a \nPRE_AUTO_BUILD will always occur after the corresponding POST_CHANGE got issued \nin another thread. \nSo I believe that PDE should always listen to POST_CHANGE instead of \nPRE_AUTO_BUILD independantly from solving the manual build scenario.",
    "My previous build should have read:\nSo I believe that PDE should always listen to POST_CHANGE instead of \nPRE_AUTO_BUILD independantly from solving the explicit build scenario (from \naurora import tool).",
    "I just verified that listening to POST_CHANGE instead of PRE_AUTO_BUILD does \nnot work, as it will break the import scenario.\n\nThe code where PDE listens to resource changes and reacts by \nadding/removing/modifying plug-in models is in \norg.eclipse.pde.internal.core.WorkspaceModelManager.resourceChanged().\nWe listened to two events: PRE_AUTO_BUILD and PRE_CLOSE.\n\nAs a test, I replaced the code (pasted below), so that I could listen to \nPOST_CHANGE and see if indeed I will get all the notification, but that did \nnot happen.  Upon importing a project using the plug-in import wizard, no \nPOST_CHANGE notification was fired, so PDE did not add the plug-in to its \nmodels and the pde container was not therefore resolved.  Putting the \nPRE_AUTO_BUILD back in, PDE was indeed notified when a plug-in was imported \ninto the workspace.\nswitch (event.getType()) {\n    case IResourceChangeEvent.POST_CHANGE :\n\thandleResourceDelta(event.getDelta());\n\tprocessModelChanges();\n\tbreak;\n\t/*case IResourceChangeEvent.PRE_AUTO_BUILD :\n\thandleResourceDelta(event.getDelta());\n\tprocessModelChanges();\n\tbreak;*/\n    case IResourceChangeEvent.PRE_CLOSE :\n\tIProject project \u003d (IProject)event.getResource();\n\tremoveWorkspaceModel(project);\n\tprocessModelChanges();\n\tbreak;\n    }\n\nJohnA, could you please clarify (to me at least) when PRE_AUTO_BUILD gets \nfired and when POST_CHANGE gets fired...\nAlso is it true, as per comments above, that every PRE_AUTO_BUILD is always \npreceded by a POST_CHANGE?  If so, why did PDE get no notification at all \nduring the import in the scenario above when we were listening to POST_CHANGE \nonly?\n",
    "I did your test and also changed the listener registration:\n\tworkspace.addResourceChangeListener(this,\n\t\t\t\tIResourceChangeEvent.PRE_CLOSE\n\t\t\t\t| IResourceChangeEvent.POST_CHANGE\n\t\t\t\t);\n\nMy test passed with this change.  This is my no means exhaustive, but it is \ntesting several code paths.",
    "Thanks John, I had forgotten to change the listener registration.  I will do \nmore exhaustive testing on this one, but it seems like POST_CHANGE instead of \nPRE_AUTO_BUILD is the right approach here.\n\nHowever, while this fixes the import scenario, there remains the problem when \nyou get a lot of red X\u0027s upon startup with \"importing\" and \"resource \nnotification\" completely out of the picture.\n\nSo, the workbench comes up, and the container is not initialized correctly.  I \nthought this was taken care by PDE and JDT/Core last week, but I think there \nis still a case that is unaccounted for.",
    "Using POST_CHANGE is ok only if you can guarantee your listener is registered \nbefore ours. If not, then based on timing you may still see the problem in the \nfuture.\n\nYou should still be able to discover unitialized pieces on demand.",
    "I missed the question to me in comment #27.  I am actually eager to know if my\ndescription in the porting guide is useful for you here. If you look for\n\"IResourceChangeEvent\" in the porting guide, you will find a detailed\ndescription of when the various resource change events used to occur, and when\nthey occur in Eclipse 3.0. If this is still not clear, please let me know\n(offline) and I will explain in more detail.",
    "Thanks JohnA, I will do that.\n\nAs for comment #30,\nKeeping track of workspace plug-ins has become more challenging in 3.0.  While \nin the past, we only had to account for importing/deleting/closing projects, \nin 3.0 there are new challenges.  Now, adding a manifest.mf for example to an \nexisting plug-in causes changes in the dependency chain, because a manifest.mf \nsupercedes the \u003cimport\u003e statements in a plugin.xml, and PDE has to react to \nit.  As another example, removing a manifest.mf from a plug-in with a \nplugin.xml warrants a similar reaction from PDE.\n\nTherefore, PDE counts on and puts all its faith in resource notifications to \nupdate our internal view of the plug-ins in the workspace.  PDE honors all \ncontainer initialization requests from JDT, that is not the problem .  The \nproblem is that JDT/Core queries us to resolve the container very frequently, \nand we have to be on our toes and ready to give back our up-to-date view of \nthe workspace at all times.  \n\nFor this to be successful 100% of the time, as Philippe points out, PDE has to \nupdate its plug-in models before JDT asks for the new value of the container, \nand there is no way to gurantee that our listener is registered before the JDT \nlistener.",
    "I understand, thus I suggest you populate your model based on resource \ndirectly, and update portions of it based on resource deltas. I think it would \ndo the trick, as in this particular case you could discover the project \nexistence without needing to get a delta for it. \n\nJohnA - alternatively, could platform provide a way to register a listener \nbefore another one ? As you do for registering builders...",
    "Philippe, we are actually doing exactly that.\nUpon startup, the first time PDE needs to discover what is in the workspace, \nwe establish a state by populating our model with info from existing \nresources.   After we finish the model initialization, we register a workspace \nresource change listener, so that we could be notified of deltas fired \nthereafter.\n\nAnd now we anxiously await JohnA\u0027s response to Philippe\u0027s question \u003cg\u003e",
    "\u003e alternatively, could platform provide a way to register a listener \n\u003e before another one ? As you do for registering builders...\n\nListeners are internal implementation details of each plugin - they are not\nexposed in any way.  How would PDE know which listener is JDT\u0027s? What if JDT\nregistered two or more listeners, or wanted to remove its listeners? How would\nconflicting demands on listener order be reconciled? We have seen from builders\nthat establishing a reasonable, stable order can be extremely complex, and there\nare far more listeners than there are builders. In short, this is not a road we\nwant to go down.",
    "I was a quiet observer of this defect, but would like to add my $.02. It \nappears that in this case the main problem is between PDE and JDT i.e. order \nof two specific resource listeners of many listeners that both PDE and JDT \nhave in various places.\n\nSince PDE depends on JDT, how about this:\n\n1) JDT exposes something \nlike \u0027addPriorityResourceListener/removePriorityResourceListener\u0027 to JDT Core\n2a) The listeners registered this way are cached and when JDT adds itself to \nworkspace, it adds these listeners first\n2b) Alternatively, JDT does not ever add priority listeners to the workspace. \nInstead, it calls their \u0027resourceChanged\u0027 before processing it itself, thus \nensuring that priority listeners are called in, well, priority :-).\n\nIt seems far-fetched but this way PDE-JDT handshake would be fully controlled -\n it would not depend on the random order.",
    "Given platform doesn\u0027t want to offer this functionality, we will add support \nalong option 2b so as to address this problem. It will broadcast POST_CHANGE \ndelta (only) event prior to doing anything with it, and thus give you room for \nimprovement. It is not going to be a general purpose resource listener you can \nregister to as an alternative to listening to the platform directly (in \nparticular, it will not give access to other type of event notifications, for \nwhich you will need to still register directly to the platform). It also does \nnot offer a way to get priviledged access to post POST_CHANGE notifications.\nAPI would look like:\nJavaCore#addPreResourceChangeListener(IResourceChangeListener listener)\nJavaCore#removePreResourceChangeListener(IResourceChangeListener listener)\nspec\u0027ed only for POST_CHANGE notifications.\n\nNote that for this very defect, it looks actually like the POST_CHANGE move is \nenough, since the explicit build invocation in aurora import tool isn\u0027t wrapped \nin operation itself (which means POST_CHANGE will be notified at the end of \nproject addition operation). If however, the tool was batching all operations, \nthen we would likely hit the same problem again.",
    "The new APIs JavaCore#addPreProcessingResourceChangeListener\n(IResourceChangeListener) and removePreProcessingResourceChangeListener\n(IResourceChangeListener) will be in today\u0027s rebuild.",
    "I just added the calls to Java Core\u0027s new APIs in the org.eclipse.pde.core \nfrom HEAD.\n\nUsing I-200404281424, I ran a runtime workbench and tested the new code by \ndoing several import operations and other workspace resource deletion/addition \noperations.  Everything is working fine.\n\nJohnW, using pde.core from head and I-200404281424, please verify that your \nscenario works before we could close this defect.  Thanks.\n",
    "It appears that there are more problems here.\n1. My simple test case passed (without Wassim\u0027s fix), just using the \nintegration build.  So, I moved onto the real test case (import 76 projects \ninstead of 2).  This failed.  So, I tried it with Wassim\u0027s fix.  It fails in \nthe same way.\n\nNew failure mode: 4 projects claim that they cannot be built until their \nprerequisite project is built.\n\nThe problem appears to be that the dynamic references are not being set.  I \nput a breakpoint on the only setter (updateProjectReferencesIfNecessary) and \nit is always bailing out immediately (canChangeResources\u003dfalse).  This means \nthat at least one key project has no dynamic references so the build order is \ncomputed incorrectly.  This means that the key project is built too early \n(therefore it complains) and its dependent projects complain as well.\n\nNOTE: I have seen an intermittent indefinite postponement during the import.  \nWill open another defect when I can describe it better.",
    "Setting classpath containers is an operation which may require to modify \nresources. In particular, it may need to create some markers and/or change \nproject references, which is the situation you mentionned.\n\nWhen container initialization is invoked during POST_CHANGE, the platform has \nlocked the resource tree. Therefore, we defensively avoid triggering some \noperations which would result in exceptions from the platform, and thus do not \ngenerate markers and/or touch project references as these are forbidden \ndescription changes.\n\nThe marker creation is not a big deal, as it will only be deferred until the \nnext autobuild occurs (our builder will recreate them if necessary). But the \nproject references is a bigger issue, as we do not fix it up later on. \nGiven we stepped away from using static references towards dynamic ones, I \nwould question the fact that these are still considered as resource modifying \noperations (since need to perform #setDescription). Couldn\u0027t the platform allow \na dynamic project ref to be recorded even when the resource tree is locked ?\nWe will explore deferring the dynamic references update until next \nPRE_AUTO_BUILD notification, but this may be hard to achieve due to the \ncomplexity of our implementation in this area.\n\n",
    "Readopting to continue investigation.\nThe simple 2 plugins scenario is not solved (see bug 60367), but the larger one \nwith 76 projects still fails.",
    "As JohnA commented in bug 60367, the remaining issues are likely due to the \nfact that a manual build is invoked in the middle of the operation, before \nnotifications could reach us in a satisfactory manner.\n\nJohnA proposed to cause a delta broadcast inside the manual build operations \nto ensure we get enough notifications in this case.\nQuestion1:\n   Can you still broadcast if the #build invocation is itself buried in a    \n   batch operation ?\nQuestion2:\n   How does this extra delta broadcast affects the overall delta story ? \n   Will regular autobuild see these deltas ?\nQuestion3:\n   Why not rather simply allowing to set project references even when \n   resource tree is locked, at least for dynamic ones ?",
    "Before performing an explicit build, the import tool should add code to wait \non autobuild. This will ensure the delta broadcasts have occurred before the \nexplicit build runs.",
    "Question1:\n   Firing PRE_AUTO_BUILD events in the middle of an operation would be new. I\ndon\u0027t anticipate a big impact, since periodic deltas are already occurring\ninside operations.  We can\u0027t solve this problem without the possibility of a new\nevent in the middle of an operation that can change the workspace.\n\nQuestion2:\n   Regular autobuild would still see those events exactly as before. As always,\neach AUTO_BUILD event contains a delta since the end of the last POST_AUTO_BUILD\nevent.\n\nQuestion3:\n   This is not sufficient, because there is no guarantee that POST_CHANGE will\noccur between the project creation and the manual build.\n\nRe comment #44: I don\u0027t think it is acceptable to require clients to change\ntheir code here. From the client\u0027s point of view, they are just creating a bunch\nof projects and building them - the fact that the build requires project\nrefeference initialization to happen (and that this happens in the autobuild\njob) should be transparent.",
    "Platform core is now sending PRE_AUTO_BUILD and POST_AUTO_BUILD around manual\nworkspace builds. I have created new event constants (same values) with better\nnames to reflect this change: PRE_WORKSPACE_BUILD and POST_WORKSPACE_BUILD.",
    "Re: comment#45 question 3:\nHow could a POST_CHANGE not occur at the end of the project creation \noperation ? It is part of the operation contract afaik.\n\nMoreover, what if instead import tool had built individual projects instead of \nworkspace ?",
    "*** Bug 60250 has been marked as a duplicate of this bug. ***",
    "JohnW - can we close this one now ?",
    "Jerome: pls verify it works now, and dispose.",
    "I verified that JohnW\u0027s original scenario (where 2 projects are imported with \nthe Aurora importer) is fixed from JDT Core\u0027s point of view using I20040506. \nHowever with JohnW\u0027s target platform, the \u0027Plug-in Dependencies\u0027 doesn\u0027t \ncontain the osgi jar, which prevent the project from being build.\n\nMoving to PDE to investigate. (Wassim if you need JohnW\u0027s target platform, let \nme know)",
    "The reason why osgi was not added to the classpath is because the manifest.mf \nfor John\u0027s target platform is out of date.  It does not contain a Bundle-\nClasspath header that lists all the JARs provided by that plug-in.\n\nThe Equinox team has updated their manifests since that build, and PDE is \nhappy again.\n\nClosing this bug report.",
    "I\u0027m running with I20040511 (0800) and have an up to date full source \nworkspace.  o.e.core.runtime osgi.jar is missing from PDE Container. Re-\nopening.",
    "Jim, if you have a full-source workspace, why would you expect osgi.jar to \nappear on the classpath?  org.eclipse.osgi is in source form, is it not?",
    "I meant to say that org.eclipse.osgi does not show up in the container.\n\nThe particular problem I\u0027m seeing seems to be a problem with PDE picking up \ninfo from MANIFEST.MF for org.eclipse.osgi plug-in.",
    "Jeff and I noticed that tweaking MANIFEST.MF in org.eclipse.osgi we could get \norg.eclipse.runtime to build properly. But there are other problems:\n- org.eclipse.runtime.compatibility has org.eclipse.runtime in it\u0027s PDE \nclasspath container, but not org.eclipse.update.configurator\n",
    "Something is really rotten! PDE isn\u0027t matching up extensions with extension \npoints (even within the same plug-in):\nUnknown extension point: \u0027org.eclipse.ui.contexts\u0027 plugin.xml org.eclipse.u \nline 60\tMay 11, 2004 12:54:25 PM\n",
    "interestingly, when I look at the update.configurator build path properties I \nsee \"org.eclipse.pde.core.requiredPlugins (outbound)\" and I have compile errors \nin compatibility (which requires update.configurator).\n",
    "I\u0027ve entered bug 61771 to track problems with PDE not finding plug-ins and \nextension points.",
    "We need to reduce the number of variables to figure out what has gone wrong.\nThe only change that PDE made since last week\u0027s I-build is to implement the \nconcurrency recommendations made in bug 60910 comment #5.  \n\nI will revert to what PDE looked like before this change (one class), and see \nif the problems are still there.  This will help us determine if this new \nwacky behavior is due to this change alone or if the changes made by JDT and \nPlatform over the past week are contributing to it.\n",
    "While undoing the changes referred to in comment #60 seemed to have brought \nthings back to normal, the situation is not resolved by any stretch of the \nimagination.  \nThe concurrency issues that warranted this change still exist and need to be \naddressed, and we need to figure out what went wrong and why things got worse, \ninstead of better.\nUnfortunately I could not reproduce the problems people were seeing today in \nmy workspace.  So if anybody encounters the problem again, please attach your \nworkspace to this bug report so that we could get to the bottom of this thing.",
    "*** Bug 61771 has been marked as a duplicate of this bug. ***",
    "I don\u0027t know about the rest of you, but I find this situation quite disturbing. If making the code more \nthread safe leads to additional problems, then the code is somehow relying on the unsafe behavior. \nblech.",
    "What does \u0027blech\u0027 mean?",
    "Sorry, I misspelled it. From the hacker\u0027s dictionary:\n\nbletch /blech/ interj.\n    [from Yiddish/German `brechen\u0027, to  vomit, poss. via comic-strip exclamation `blech\u0027] Term\n    of disgust. Often used in \"Ugh, bletch\". ",
    "Addressed this bug by reinstating the thread-safe code for PluginModelManager \nand introducing new thread-safe code for WorkspaceModelManager and \nExternalModelManager.\n\nThis one was occurring as a result of two other bugs.\nRefer to bug 61774 comment 4 and bug 61744 comment 6 for an explanation of \nwhat was going on.\n\nThe fix is in today\u0027s 1600 build.",
    "I think this bug has resurfaced in M9, albeit in a less vicious form.\nEach time I startup, Eclipse fails to find any plugin dependencies for any of my\nprojects (and hence marks my files with hundreds of red crosses)\nHowever if I edit and save plugin.xml, it will then succesfully rebuild that\nproject.\nStrangely though, cleaning and rebuilding the project does not work. \n\nNB - I am working on a Windows platform, if that\u0027s relevant.",
    "Try RC1.  Should you still encounter a problem, and if at all possible, please \nattach a workspace (of reasonable size) on which we could reproduce the \nproblem.  thanks.",
    "Also make sure that your target platform, as specified on the Plug-in \nDevelopment preference page is a build that is dated no earlier than M9.",
    "No response for a week.\nClosing as WORKSFORME, since I haven\u0027t seen the red X upon startup phenomenon \nsince M9.\nReopen if you have a reproducible test case or if you can provide a workspace \nexhibiting the problem."
  ],
  "commentCreationDates": [
    "2004-04-02T05:34:09+02:00",
    "2004-04-02T07:24:43+02:00",
    "2004-04-05T23:07:57+02:00",
    "2004-04-06T16:00:28+02:00",
    "2004-04-07T17:37:18+02:00",
    "2004-04-07T17:37:51+02:00",
    "2004-04-07T17:39:58+02:00",
    "2004-04-08T05:39:27+02:00",
    "2004-04-08T16:28:27+02:00",
    "2004-04-11T16:35:33+02:00",
    "2004-04-13T04:56:41+02:00",
    "2004-04-14T03:14:36+02:00",
    "2004-04-14T13:36:36+02:00",
    "2004-04-14T13:54:18+02:00",
    "2004-04-16T19:11:33+02:00",
    "2004-04-19T12:20:22+02:00",
    "2004-04-19T12:43:08+02:00",
    "2004-04-20T18:03:04+02:00",
    "2004-04-27T12:11:55+02:00",
    "2004-04-27T12:16:19+02:00",
    "2004-04-27T12:30:36+02:00",
    "2004-04-27T12:35:36+02:00",
    "2004-04-27T12:55:46+02:00",
    "2004-04-27T13:09:44+02:00",
    "2004-04-27T13:33:41+02:00",
    "2004-04-27T13:46:13+02:00",
    "2004-04-27T18:27:11+02:00",
    "2004-04-27T19:16:05+02:00",
    "2004-04-27T20:22:17+02:00",
    "2004-04-27T20:31:28+02:00",
    "2004-04-27T20:49:43+02:00",
    "2004-04-27T21:12:25+02:00",
    "2004-04-27T21:33:05+02:00",
    "2004-04-27T22:09:39+02:00",
    "2004-04-27T22:27:41+02:00",
    "2004-04-27T22:46:25+02:00",
    "2004-04-27T23:37:10+02:00",
    "2004-04-28T13:29:14+02:00",
    "2004-04-28T14:09:06+02:00",
    "2004-04-28T22:59:48+02:00",
    "2004-04-29T02:45:18+02:00",
    "2004-04-29T12:04:41+02:00",
    "2004-04-30T11:27:51+02:00",
    "2004-05-01T13:27:00+02:00",
    "2004-05-03T12:42:00+02:00",
    "2004-05-03T21:21:05+02:00",
    "2004-05-04T01:52:44+02:00",
    "2004-05-04T12:16:10+02:00",
    "2004-05-04T18:50:50+02:00",
    "2004-05-05T13:05:23+02:00",
    "2004-05-07T16:05:59+02:00",
    "2004-05-10T11:44:45+02:00",
    "2004-05-11T07:48:06+02:00",
    "2004-05-11T18:38:24+02:00",
    "2004-05-11T18:46:17+02:00",
    "2004-05-11T19:02:35+02:00",
    "2004-05-11T19:41:38+02:00",
    "2004-05-11T19:48:26+02:00",
    "2004-05-11T20:08:32+02:00",
    "2004-05-11T20:17:10+02:00",
    "2004-05-11T21:27:19+02:00",
    "2004-05-12T04:07:38+02:00",
    "2004-05-12T04:09:18+02:00",
    "2004-05-12T15:12:42+02:00",
    "2004-05-12T15:59:07+02:00",
    "2004-05-12T16:28:09+02:00",
    "2004-05-14T04:23:30+02:00",
    "2004-06-02T21:17:25+02:00",
    "2004-06-02T21:25:40+02:00",
    "2004-06-02T21:27:57+02:00",
    "2004-06-10T05:21:02+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.jdt.launching.JavaRuntime.getPreferences",
          "source": "JavaRuntime.java:1525"
        },
        {
          "method": "org.eclipse.jdt.launching.JavaRuntime.initializeVMConfiguration",
          "source": "JavaRuntime.java:1260"
        },
        {
          "method": "org.eclipse.jdt.launching.JavaRuntime.initializeVMTypes",
          "source": "JavaRuntime.java:252"
        },
        {
          "method": "org.eclipse.jdt.launching.JavaRuntime.getDefaultVMId",
          "source": "JavaRuntime.java:431"
        },
        {
          "method": "org.eclipse.jdt.launching.JavaRuntime.getDefaultVMInstall",
          "source": "JavaRuntime.java:377"
        },
        {
          "method": "org.eclipse.jdt.internal.launching.JREContainerInitializer.resolveVM",
          "source": "JREContainerInitializer.java:72"
        },
        {
          "method": "org.eclipse.jdt.internal.launching.JREContainerInitializer.initialize",
          "source": "JREContainerInitializer.java:46"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore$1.run",
          "source": "JavaCore.java:1176"
        },
        {
          "method": "org.eclipse.core.internal.runtime.InternalPlatform.run",
          "source": "InternalPlatform.java:610"
        },
        {
          "method": "org.eclipse.core.runtime.Platform.run",
          "source": "Platform.java:521"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore.getClasspathContainer",
          "source": "JavaCore.java:1171"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1841"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1764"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1736"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore.setClasspathContainer",
          "source": "JavaCore.java:3316"
        },
        {
          "method": "org.eclipse.pde.internal.core.ModelEntry.updateClasspathContainer",
          "source": "ModelEntry.java:107"
        },
        {
          "method": "org.eclipse.pde.internal.core.RequiredPluginsInitializer.initialize",
          "source": "RequiredPluginsInitializer.java:40"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore$1.run",
          "source": "JavaCore.java:1176"
        },
        {
          "method": "org.eclipse.core.internal.runtime.InternalPlatform.run",
          "source": "InternalPlatform.java:610"
        },
        {
          "method": "org.eclipse.core.runtime.Platform.run",
          "source": "Platform.java:521"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore.getClasspathContainer",
          "source": "JavaCore.java:1171"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1841"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1764"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1736"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.JavaSearchScope.add",
          "source": "JavaSearchScope.java:78"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.JavaWorkspaceScope.initialize",
          "source": "JavaWorkspaceScope.java:79"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.JavaSearchScope.\u003cinit\u003e",
          "source": "JavaSearchScope.java:52"
        },
        {
          "method": "org.eclipse.jdt.internal.core.search.JavaWorkspaceScope.\u003cinit\u003e",
          "source": "JavaWorkspaceScope.java:30"
        },
        {
          "method": "org.eclipse.jdt.core.search.SearchEngine.createWorkspaceScope",
          "source": "SearchEngine.java:430"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.actions.OpenTypeAction.run",
          "source": "OpenTypeAction.java:54"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.actions.OpenTypeAction.run",
          "source": "OpenTypeAction.java:80"
        },
        {
          "method": "org.eclipse.ui.internal.PluginAction.runWithEvent",
          "source": "PluginAction.java:269"
        },
        {
          "method": "org.eclipse.ui.internal.WWinPluginAction.runWithEvent",
          "source": "WWinPluginAction.java:207"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection",
          "source": "ActionContributionItem.java:550"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.access$2",
          "source": "ActionContributionItem.java:502"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem$6.handleEvent",
          "source": "ActionContributionItem.java:474"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java:82"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:769"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java:2578"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:2256"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1562"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1536"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:257"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:139"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:90"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:277"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:239"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:117"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:39"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:25"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:324"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:267"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:692"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:676"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "57181",
      "date": "2004-04-02T05:34:09+02:00",
      "product": "PDE",
      "component": "UI",
      "severity": "critical"
    },
    {
      "exceptionType": "java.lang.Exception",
      "message": "\u003cFake exception\u003e",
      "elements": [
        {
          "method": "org.eclipse.jdt.core.JavaCore.getClasspathContainer",
          "source": "JavaCore.java:1167"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1841"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1755"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1727"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore.setClasspathContainer",
          "source": "JavaCore.java:3425"
        },
        {
          "method": "org.eclipse.pde.internal.core.ModelEntry.updateUnknownClasspathContainer",
          "source": "ModelEntry.java:151"
        },
        {
          "method": "org.eclipse.pde.internal.core.RequiredPluginsInitializer.initialize",
          "source": "RequiredPluginsInitializer.java:38"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore.getClasspathContainer",
          "source": "JavaCore.java:1174"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1841"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1755"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1727"
        },
        {
          "method": "org.eclipse.jdt.internal.core.DeltaProcessor.createExternalArchiveDelta",
          "source": "DeltaProcessor.java:699"
        },
        {
          "method": "org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged",
          "source": "DeltaProcessor.java:1864"
        },
        {
          "method": "org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged",
          "source": "DeltaProcessingState.java:246"
        },
        {
          "method": "org.eclipse.core.internal.events.NotificationManager$2.run",
          "source": "NotificationManager.java:268"
        },
        {
          "method": "org.eclipse.core.internal.runtime.InternalPlatform.run",
          "source": "InternalPlatform.java:599"
        },
        {
          "method": "org.eclipse.core.runtime.Platform.run",
          "source": "Platform.java:541"
        },
        {
          "method": "org.eclipse.core.internal.events.NotificationManager.notify",
          "source": "NotificationManager.java:260"
        },
        {
          "method": "org.eclipse.core.internal.events.NotificationManager.broadcastChanges",
          "source": "NotificationManager.java:148"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.broadcastChanges",
          "source": "Workspace.java:158"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.endOperation",
          "source": "Workspace.java:880"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.run",
          "source": "Workspace.java:1656"
        },
        {
          "method": "org.eclipse.ui.actions.WorkspaceModifyOperation.run",
          "source": "WorkspaceModifyOperation.java:105"
        },
        {
          "method": "com.rational.aurora.tools.wizards.ProjectLoader.loadProject",
          "source": "ProjectLoader.java:55"
        },
        {
          "method": "com.rational.aurora.tools.wizards.ProjectSetImportPage.importProject",
          "source": "ProjectSetImportPage.java:678"
        },
        {
          "method": "com.rational.aurora.tools.wizards.ProjectSetImportPage.importProjects",
          "source": "ProjectSetImportPage.java:655"
        },
        {
          "method": "com.rational.aurora.tools.wizards.ProjectSetImportPage.access$4",
          "source": "ProjectSetImportPage.java:592"
        },
        {
          "method": "com.rational.aurora.tools.wizards.ProjectSetImportPage$12.run",
          "source": "ProjectSetImportPage.java:507"
        },
        {
          "method": "org.eclipse.jface.operation.ModalContext$ModalContextThread.run",
          "source": "ModalContext.java:101"
        }
      ],
      "number": 1,
      "commentIndex": 18,
      "bugId": "57181",
      "date": "2004-04-27T12:11:55+02:00",
      "product": "PDE",
      "component": "UI",
      "severity": "critical"
    }
  ],
  "groupId": "57181",
  "bugId": "57181",
  "date": "2004-04-02T05:34:09+02:00",
  "product": "PDE",
  "component": "UI",
  "severity": "critical"
}