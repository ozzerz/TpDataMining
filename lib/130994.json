{
  "comments": [
    "Hit a deadlock in StructureEdit after modifying the .component file on the file system and restarting Eclipse. I feel that this is a high severity issue that should be addressed for 1.0.2 because people frequently edit .component file by hand and in the team environment it is not uncommon for project files to change outside of eclipse.\n\nMain Thread - Refreshing the Package Explorer view.\n * Got a java monitor on ModuleStructuralModel.\n * Blocks acquiring a scheduling rule to be able to do a refreshLocal on the .component file.\n\nWorker-7 (Job Thread) - Scanning projects on startup to build a model for BEA-specific functionality. Inside IVirtualComponent.exists() call.\n * The job holds the scheduling rule for the entire project.\n * Blocks trying to get a hold of the java monitor on ModuleStructuralModel.\n\nThis deadlock is similar in cause to https://bugs.eclipse.org/bugs/show_bug.cgi?id\u003d126115, although this one involves different code.\n\nTo avoid this deadlock, an explicit scheduling rule for the .component file should be acquired prior to get a lock on the java monitor.\n\nThread [Main Thread] (Suspended)\n\tObject.wait(long) line: not available [native method]\n\tThreadJob.joinRun(IProgressMonitor) line: 183\n\tImplicitJobs.begin(ISchedulingRule, IProgressMonitor, boolean) line: 88\n\tJobManager.beginRule(ISchedulingRule, IProgressMonitor) line: 190\n\tWorkManager.checkIn(ISchedulingRule, IProgressMonitor) line: 96\n\tWorkspace.prepareOperation(ISchedulingRule, IProgressMonitor) line: 1676\n\tFile(Resource).refreshLocal(int, IProgressMonitor) line: 1240\n\tFile.refreshLocal(int, IProgressMonitor) line: 342\n\tComponentCoreURIConverter(WorkbenchURIConverterImpl).createPlatformResourceInputStream(String) line: 501\n\tComponentCoreURIConverter(URIConverterImpl).createInputStream(URI) line: 442\n\tWTPModulesResource(ResourceImpl).load(Map) line: 829\n\tWTPModulesResource(TranslatorResourceImpl).load(Map) line: 384\n\tProjectResourceSetEditImpl(ResourceSetImpl).demandLoad(Resource) line: 249\n\tProjectResourceSetEditImpl(ProjectResourceSetImpl).demandLoad(Resource) line: 83\n\tProjectResourceSetEditImpl(ResourceSetImpl).demandLoadHelper(Resource) line: 264\n\tProjectResourceSetEditImpl(ResourceSetImpl).getResource(URI, boolean) line: 349\n\tProjectResourceSetEditImpl(ProjectResourceSetImpl).getResource(URI, boolean) line: 262\n\tWorkbenchResourceHelper.getOrCreateResource(URI, ResourceSet) line: 299\n\tModuleStructuralModel(EditModel).getResource(URI) line: 685\n\tModuleStructuralModel(EditModel).getPrimaryResource() line: 1513\n\tModuleStructuralModel.prepareProjectModulesIfNecessary() line: 175\n\tModuleStructuralModel.getPrimaryRootObject() line: 99\n\tStructureEdit.getComponentModelRoot() line: 438\n\tStructureEdit.getWorkbenchModules() line: 468\n\tStructureEdit.getComponent() line: 906\n\tVirtualComponent.getMetaResources() line: 228\n\tVirtualFolder(VirtualContainer).members(int) line: 157\n\tVirtualFolder(VirtualContainer).members() line: 140\n\tAppLibrariesContainer(FlexibleProjectContainer).\u003cinit\u003e(IPath, IJavaProject, IProject, IPath[], FlexibleProjectContainer$PathType[]) line: 133\n\tAppLibrariesContainer.\u003cinit\u003e(IPath, IJavaProject) line: 36\n\tAppLibrariesContainerInitializer.initialize(IPath, IJavaProject) line: 24\n\tJavaModelManager.initializeContainer(IJavaProject, IPath) line: 1754\n\tJavaModelManager.getClasspathContainer(IPath, IJavaProject) line: 1199\n\tJavaCore.getClasspathContainer(IPath, IJavaProject) line: 1372\n\tJavaProject.getResolvedClasspath(IClasspathEntry[], IPath, boolean, boolean, Map) line: 2046\n\tJavaProject.getResolvedClasspath(boolean, boolean, boolean) line: 1954\n\tJavaProject.buildStructure(OpenableElementInfo, IProgressMonitor, Map, IResource) line: 332\n\tJavaProject(Openable).generateInfos(Object, HashMap, IProgressMonitor) line: 233\n\tJavaProject(JavaElement).openWhenClosed(Object, IProgressMonitor) line: 488\n\tJavaProject(JavaElement).getElementInfo(IProgressMonitor) line: 232\n\tJavaProject(JavaElement).getElementInfo() line: 218\n\tJavaProject(JavaElement).getChildren() line: 173\n\tJavaProject.getPackageFragmentRoots() line: 1713\n\tRefactoringAvailabilityTester.isInferTypeArgumentsAvailable(IJavaElement) line: 386\n\tRefactoringAvailabilityTester.isInferTypeArgumentsAvailable(IStructuredSelection) line: 413\n\tInferTypeArgumentsAction.selectionChanged(IStructuredSelection) line: 97\n\tInferTypeArgumentsAction(SelectionDispatchAction).dispatchSelectionChanged(ISelection) line: 210\n\tInferTypeArgumentsAction(SelectionDispatchAction).selectionChanged(SelectionChangedEvent) line: 205\n\tViewer$2.run() line: 162\n\tInternalPlatform.run(ISafeRunnable) line: 1044\n\tPlatform.run(ISafeRunnable) line: 783\n\tJFaceUtil$1.run(ISafeRunnable) line: 44\n\tSafeRunnable.run(ISafeRunnable) line: 148\n\tPackageExplorerPart$PackageExplorerProblemTreeViewer(Viewer).fireSelectionChanged(SelectionChangedEvent) line: 160\n\tPackageExplorerPart$PackageExplorerProblemTreeViewer(StructuredViewer).updateSelection(ISelection) line: 1784\n\tPackageExplorerPart$PackageExplorerProblemTreeViewer(StructuredViewer).handleSelect(SelectionEvent) line: 1027\n\tStructuredViewer$4.widgetSelected(SelectionEvent) line: 1053\n\tOpenStrategy.fireSelectionEvent(SelectionEvent) line: 209\n\tOpenStrategy.access$3(OpenStrategy, SelectionEvent) line: 204\n\tOpenStrategy$1.handleEvent(Event) line: 364\n\tEventTable.sendEvent(Event) line: 66\n\tTree(Widget).sendEvent(Event) line: 843\n\tDisplay.runDeferredEvents() line: 3125\n\tDisplay.readAndDispatch() line: 2758\n\tWorkbench.runEventLoop(Window$IExceptionHandler, Display) line: 1699\n\tWorkbench.runUI() line: 1663\n\tWorkbench.createAndRunWorkbench(Display, WorkbenchAdvisor) line: 367\n\tPlatformUI.createAndRunWorkbench(Display, WorkbenchAdvisor) line: 143\n\tIDEApplication.run(Object) line: 103\n\tPlatformActivator$1.run(Object) line: 226\n\tEclipseStarter.run(Object) line: 376\n\tEclipseStarter.run(String[], Runnable) line: 163\n\tInitialMethodInvoker.invoke(Object, Object[]) line: not available\n\tMethod.invoke(Object, Object[], int) line: not available\n\tMain.invokeFramework(String[], URL[]) line: 334\n\tMain.basicRun(String[]) line: 278\n\tMain.run(String[]) line: 973\n\tMain.main(String[]) line: 948\n\nThread [Worker-7] (Suspended)\n\tEMFWorkbenchContext.getEditModelForRead(String, Object, Map) line: 137\n\tModuleCoreNature(EditModelNature).getEditModelForRead(String, Object, Map) line: 49\n\tModuleCoreNature(EditModelNature).getEditModelForRead(String, Object) line: 39\n\tModuleCoreNature.getModuleStructuralModelForRead(Object) line: 238\n\tStructureEdit.\u003cinit\u003e(ModuleCoreNature, boolean) line: 315\n\tStructureEdit.getStructureEditForRead(IProject) line: 114\n\tVirtualComponent.exists() line: 87\n\tWebProject.refreshWebProjectInfo() line: 752\n\tWebProjectManager.rescanWebProject(WebProject, boolean) line: 366\n\tWebProjectManager.access$0(WebProjectManager, WebProject, boolean) line: 362\n\tWebProjectManager$1.run(IProgressMonitor) line: 188\n\tWorker.run() line: 76",
    "Added to 1.0.2 hotlist. Setting priority to P2, target to 1.0.2 M102.",
    "Hi Kosta....\n\nI read the referenced bug....\n\nAre you suggesting that we wrap our calls that enter the synchronized calls in ModuleStructuralModel in a call to the JobMontor with a rule of the .component file?   not sure I\u0027m following....",
    "Essentially we have to make sure that the scheduling rule on the .component file and monitor on the ModuleStructuralModel are always acquired in the same order. As we cannot guarantee that the monitor will always be acquired first, the only solution is to make sure that the api always grabs the scheduling rule first. I do this in the Faceted Project api by utilizing the IWorkspace.run() method. You can pass in a scheduling rule into that. The workspace runnable is executed on the same thread after the scheduling rule is acquired. You don\u0027t have to change any api semantics.",
    "03/09 status meeting - This bug came in last night, Chuck will investigate this bug.",
    "03/16 WTP status meeting:\n\nChuck - We can\u0027t quite reproduce it, but based on suggestions from Konstantin, we have created a patch that we want to pass along to Konstantin to try. ",
    "Created an attachment (id\u003d36939)\nPatch for common modulecore plugin\n\nKosta, can you try this patch?  it uses the scheduling rule lock before aquiring the object monitor.",
    "Created an attachment (id\u003d37369)\nModuleStructuralModel patch\n\n",
    "Dropping change....\n",
    "no negative votes 24 hours....\n\n",
    "So, my \"request review\" wasn\u0027t strong enough? I still think this too risky to put in 1.0.2, and was waiting for Ted Bashor to finish/report on their review and for him to make a recommendation. \n\nAnd, I mean risky in the sense of could too easily cause regressions that would not be found easily (that is, the deadlocks might just occur else where, under other circumstances). \n\nEspecially since we can not reproduce it, I wonder how urgent it is to take that risk? \n\n",
    "We\u0027re relying heavily on Chuck\u0027s assessment of risk, his testing, his knowledge of any dependent code using this api/resource, and his judgement that this seems architecturally like the \"right thing to do\".\n\nAs noted, this appears to be a self-contained solution for a not unreasonable client scenario (client holds the scheduling rule for the project).  One that we\u0027ve obvously hit intermittently.\n\nI really can\u0027t say how likely it is that there are other clients who would be broken by this change.  I agree that it would be perfectly understandable to hold back a threading change like this.  But if Chuck feels it\u0027s safe, I\u0027d also note that we have an another week of testing, and it would be a straightforward rollback if something does come up.\n\nSorry to be wishy washy - it would help us, but I can\u0027t really rate the risk.\n\n(BTW, I noticed that Chuck included an instaceof check before ((WTPModulesResource)res).getRootObject() in resNeedsMigrating() --- a ClassCastException we\u0027ve definitely triggered before...)",
    "Decided to hold off...   I am not sure this resolves this case, and we can develop a more comprehensive fix in 1.5...    Ted if you can show this fixes this case we can reconsider",
    "Thanks Chuck, that keeps me from being quite such the bad guy I am :) and officialy vetoing ... well, no, I will officially veto anyway :) \n\nI was hoping for more of a technical review from Ted (or Kosta, or other \"thread expert\") ... its not that I don\u0027t trust Chuck :) ... but as Chuck says, this is complex stuff and almoost always takes more than one pair of eyes on the problem. And ... my main concern is this is being approached as a \"wack the mole\" game, so the mole will just pop up elsewhere. One week is not enough time to test this type of a change. \n\nI will officially veto so I can specif what it would take for me to reconsider: \n(And, would be more than happy to reconsider if these are addressed, and if it really is important to fix a reproducible problem -- with the original description, this only happens if modele file edited ... from outside eclipse? .. and then deadlocks on startup? ... and then what? kill and restart? that is not quite as bad as deadlocking just in the middle of typing, or middle of publishing, where data could be left in an inconsistent state). \n\nSo, considerations: \n\nI\u0027d like a JUnit test or some clear sequence of steps so we can at least say we have a reproducable case that this fix does indeed fix! And, if we had that, we might be able to suggest other workarounds? \n\nIn reveiwing the patch, I\u0027d like the synchronized (monitor) blocks removed from the scheduling rule blocks as I think that is the (increased) risk of deadlock in this case and it seems to me to be not well explained why they are needed, if the scheduleing rule is supposed to be the gate keeper. Normally \"synchronized\" and \"rules\" do not mix well. (that is, as far as I know ... but am willing for someone to explain it to me differently). \n\nI\u0027d like it documented how, if and when, clients of this API should acquire the scheduling rule before they make a call on this object. And since this is essentially a behavior change in 1.0.2, would have to be a darn good reason! :)  \n\nTo me, the main purpose/advantage of scheduling rules is they can (and need) to be acquired and \"combined\" in well documented ways, by all clients, and then all is ran in an appropriately protected way. It is seldom, I believe, all that important or workable to aquire rules in an \"invisible\" way. (though again, am quite open to being educated otherwise). \n\n\n\n\n\n",
    "Adding John as I know he loves these sort of threading/job discussions. :) \n\nJohn, if you have any obvious insights, feel free to comment, but, I suspect a comprehensive review leading to a solutoin would take quite a while ... so, I am not requesting that. \n\nThanks, ",
    "Moving to R1.5 release - \n\nI\u0027m ok with using one locking scheme, and if scheduling rules are used everywhere this would work.\n\nWe need to identify everywhere we use java monitors, and scheduling rules, and use only one scheme.\n",
    "I was out for a few weeks so I couldn\u0027t review the patches or comment on anything here. In any case...\n\nI think that switching to only use scheduling rules is not a good solution as it puts an undue performance burden on readers. However, if the monitor object is public it exposes code to deadlocks from users grabbing the monitor manually prior to acquiring a scheduling rule. The monitor object should be made private to address that. \n\nFor what\u0027s it\u0027s worth, here is the description of the policy that I implemented for the faceted project data structure. Since the policy has been put in place, we\u0027ve had no deadlocks reported against this code. This policy does not assume \"correct\" api user behavior. It\u0027s designed to protect the data structure against deadlocks regardless of how the api is used. If anyone sees a hole in this policy or a hole in the implementation, by all means please let me know so I can make it better.\n\n * Synchronization Notes\n * \n * 1. There is an internal lock object that\u0027s used to synchronize access to\n *    the data structure. By synchronizing on an internal object, outside code\n *    cannot cause a deadlock by synchronizing on the FacetedProject object.\n *    \n * 2. Readers synchronize on the lock object for the duration of the method\n *    call. This protects the readers from writers and makes sure that reader\n *    is not reading stale data from thread\u0027s local memory.\n *    \n * 3. All collections that are returned by the reader methods are guaranteed\n *    to not change after the fact. This is implemented through a copy-on-write \n *    policy.\n * \n * 4. Writers synchronize on the lock object briefly at the start of the method \n *    and mark the FacetedProject as being modified. If the project is already\n *    being modified, the new writer will wait. Inside the bodies of the\n *    modifier methods, the writer thread is only synchronized on the lock\n *    object while modifying the internal datastructures. These synchronization\n *    sections are kept short and they never span over code that might modify\n *    file system resources. This is done to prevent deadlocks. Once the write\n *    is complete, the writer thread synchronizes on the lock object, resets the \n *    \"being modified\" flag, and notifies any writers that may be waiting. ",
    "Kosta, that\u0027s a nice write up (but, I\u0027ll have to look at the code while I read it, to understand it :) so, what class should I look at?) \n\nNow that your back ... first, congratulations :) \nSecond, do you agree this can/should wait to 1.5? \n\nEven for 1.5, any concrete suggestions you have (i.e. patch files :) \nmight make it easier (for me) to understand. \n\nThanks",
    "The implementation of the policy referenced in Comment #16 can be found in the org.eclipse.wst.common.project.facet.core.internal.FacetedProject class.\n\nI will have to defer to Ted for a confirmation as to whether the fix can/should wait for 1.5. In my opinion all deadlocks are high severity as they are difficult to recover from. However whether this is critical to fix for 1.0.2 depends on how often this happens.\n\nReviewing the patch, I have the following comments:\n\n1. While the current patch is not deadlock-proof (the monitor is public), it reduces the deadlock potential present in the existing code. I examined the relevant BEA code and I a pretty confident that this patch would have fixed the problem reported here.\n\n2. I believe there is a bug in the acquireComponentRule method. When there is a currently running job, the code simply checks to see if there is any rule associated with it and goes on if such rule exists. The correct behavior is to check if the existing rule encompasses the componentFile rule. If does, go on. If it doesn\u0027t, this code needs to wait.\n\n3. Platform provides an IWorkspace.run method that handles scheduling, setup, and teardown of rule-based jobs correctly. I recommend that we use that method instead of trying to implement similar logic ourselves. \n\n4. I notice that there are four places in the patch that scheduling rule acquisition has been wrapped around monitor acquisition. Without digging deep into the implementation, its hard for me to tell whether it is necessary in all of these cases. Forgive me if this is obvious, but I thought I\u0027d ellaborate a bit on this so that whoever is more familiar with this code base can make the correct determination... It is not necessary to wrap scheduling rule acquisition around every monitor acquisition. It only needs to be done when there is a potential that a scheduling rule might be acquired (such as via resource-modifying operations) within the scope of the monitor. For instance, consider the following situations:\n\nA:\n\nsynchronized( myMonitor )\n{\n    this.state \u003d new byte[] { 1, 2, 3 };\n    this.file.setContents( new ByteArrayInputStream( this.state ), 0, null );\n}\n\nB:\n\nsynchronized( myMonitor )\n{\n    this.state \u003d new byte[] { 1, 2, 3 };\n}\n\nTo prevent deadlocks, a scheduling rule for this.file should be acquired ouside the synchronized block in A, but it is not necessary for B.\n\n",
    "I didn\u0027t see the same deadlock after modifying the .component file for a Web project on the latest WTP build (I do not have access to the BEA testcase). I did notice the exception below when the file is refreshed. It looked like some of the synchronization areas in Kosta\u0027s original stack trace have been removed. Is it possible to confirm if this is still an issue?\n\n\n\n!ENTRY org.eclipse.jst.j2ee.webservice.ui 4 0 2006-07-31 12:18:34.045\n!MESSAGE Attempted to beginRule: F/TestEARWeb/.settings, does not match outer scope rule: org.eclipse.jst.j2ee.navigator.internal.NonConflictingRule@49924992\n!STACK 0\njava.lang.IllegalArgumentException: Attempted to beginRule: F/TestEARWeb/.settings, does not match outer scope rule: org.eclipse.jst.j2ee.navigator.internal.NonConflictingRule@49924992\n\tat org.eclipse.core.runtime.Assert.isLegal(Assert.java:62)\n\tat org.eclipse.core.internal.jobs.ThreadJob.illegalPush(ThreadJob.java:116)\n\tat org.eclipse.core.internal.jobs.ThreadJob.push(ThreadJob.java:225)\n\tat org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:80)\n\tat org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:219)\n\tat org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:96)\n\tat org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:1684)\n\tat org.eclipse.core.internal.resources.Resource.refreshLocal(Resource.java:1396)\n\tat org.eclipse.core.internal.resources.File.refreshLocal(File.java:334)\n\tat org.eclipse.jem.util.emf.workbench.WorkbenchURIConverterImpl.createPlatformResourceInputStream(WorkbenchURIConverterImpl.java:501)\n\tat org.eclipse.emf.ecore.resource.impl.URIConverterImpl.createInputStream(URIConverterImpl.java:449)\n\tat org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:892)\n\tat org.eclipse.wst.common.internal.emf.resource.CompatibilityXMIResourceImpl.load(CompatibilityXMIResourceImpl.java:259)\n\tat org.eclipse.wst.common.internal.emf.resource.TranslatorResourceImpl.load(TranslatorResourceImpl.java:388)\n\tat org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.demandLoad(ResourceSetImpl.java:249)\n\tat org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.demandLoad(ProjectResourceSetImpl.java:83)\n\tat org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.demandLoadHelper(ResourceSetImpl.java:264)\n\tat org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getResource(ResourceSetImpl.java:390)\n\tat org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.getResource(ProjectResourceSetImpl.java:262)\n\tat org.eclipse.wst.common.internal.emfworkbench.WorkbenchResourceHelper.getOrCreateResource(WorkbenchResourceHelper.java:384)\n\tat org.eclipse.wst.common.internal.emfworkbench.integration.EditModel.getResource(EditModel.java:717)\n\tat org.eclipse.wst.common.componentcore.internal.ModuleStructuralModel.getPrimaryResource(ModuleStructuralModel.java:226)\n\tat org.eclipse.wst.common.componentcore.internal.ModuleStructuralModel.prepareProjectModulesIfNecessary(ModuleStructuralModel.java:185)\n\tat org.eclipse.wst.common.componentcore.internal.ModuleStructuralModel.getPrimaryRootObject(ModuleStructuralModel.java:108)\n\tat org.eclipse.wst.common.componentcore.internal.StructureEdit.getComponentModelRoot(StructureEdit.java:442)\n\tat org.eclipse.wst.common.componentcore.internal.StructureEdit.getWorkbenchModules(StructureEdit.java:471)\n\tat org.eclipse.wst.common.componentcore.internal.StructureEdit.getComponent(StructureEdit.java:914)\n\tat org.eclipse.wst.common.componentcore.internal.resources.VirtualResource.getReadOnlyComponent(VirtualResource.java:317)\n\tat org.eclipse.wst.common.componentcore.internal.resources.VirtualResource.getProjectRelativePaths(VirtualResource.java:116)\n\tat org.eclipse.wst.common.componentcore.internal.resources.VirtualResource.getProjectRelativePath(VirtualResource.java:147)\n\tat org.eclipse.wst.common.componentcore.internal.resources.VirtualResource.getWorkspaceRelativePath(VirtualResource.java:107)\n\tat org.eclipse.wst.common.componentcore.internal.impl.PlatformURLModuleConnection.resolve(PlatformURLModuleConnection.java:67)\n\tat org.eclipse.wst.common.componentcore.internal.impl.ComponentCoreURIConverter.normalize(ComponentCoreURIConverter.java:80)\n\tat org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getResource(ResourceSetImpl.java:353)\n\tat org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.getResource(ProjectResourceSetImpl.java:262)\n\tat org.eclipse.wst.common.internal.emfworkbench.WorkbenchResourceHelper.getOrCreateResource(WorkbenchResourceHelper.java:384)\n\tat org.eclipse.wst.common.internal.emfworkbench.integration.EditModel.getResource(EditModel.java:717)\n\tat org.eclipse.wst.common.componentcore.internal.ArtifactEditModel.getResource(ArtifactEditModel.java:173)\n\tat org.eclipse.jst.j2ee.internal.webservice.componentcore.util.WSCDDArtifactEdit.getDeploymentDescriptorResource(WSCDDArtifactEdit.java:123)\n\tat org.eclipse.jst.j2ee.internal.webservice.componentcore.util.WSCDDArtifactEdit.getWscddXmiResource(WSCDDArtifactEdit.java:97)\n\tat org.eclipse.jst.j2ee.internal.webservice.helper.WebServicesManager.getWorkspace13ServiceRefs(WebServicesManager.java:619)\n\tat org.eclipse.jst.j2ee.internal.webservice.WebServiceViewerSynchronization.indexWebServices(WebServiceViewerSynchronization.java:154)\n\tat org.eclipse.jst.j2ee.internal.webservice.WebServiceViewerSynchronization.access$0(WebServiceViewerSynchronization.java:150)\n\tat org.eclipse.jst.j2ee.internal.webservice.WebServiceViewerSynchronization$WebServiceIndexJob.run(WebServiceViewerSynchronization.java:234)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)",
    "Kosta -- can you confirm if this deadlock is still an issue on the latest builds?",
    "I\u0027m resolving this defect for now, as Michael mentions...   the synchronization code has been removed around the loading of the .component file, and is handled by the \"loading\" adapter that was introduced as a general EMF loading synchronization scheme. - see CompatibilityXMIResourceImpl.addSynchronizationLoadingAdapter();",
    "Sorry that I haven\u0027t responded sooner. We are not to the point yet where we can validate whether this remains to be an issue. With the work that has been done around this code path, I am fine with closing this for now."
  ],
  "commentCreationDates": [
    "2006-03-08T22:32:07+01:00",
    "2006-03-09T08:43:24+01:00",
    "2006-03-09T16:31:49+01:00",
    "2006-03-09T16:50:01+01:00",
    "2006-03-10T16:02:30+01:00",
    "2006-03-17T15:36:12+01:00",
    "2006-03-25T23:11:54+01:00",
    "2006-03-31T00:14:27+02:00",
    "2006-04-05T23:52:36+02:00",
    "2006-04-05T23:53:06+02:00",
    "2006-04-06T00:00:47+02:00",
    "2006-04-06T02:23:50+02:00",
    "2006-04-06T06:30:44+02:00",
    "2006-04-06T07:11:01+02:00",
    "2006-04-06T07:14:31+02:00",
    "2006-04-06T16:19:55+02:00",
    "2006-04-10T18:53:03+02:00",
    "2006-04-11T05:05:31+02:00",
    "2006-04-12T20:16:23+02:00",
    "2006-07-31T19:55:36+02:00",
    "2006-08-03T14:47:47+02:00",
    "2006-08-07T20:25:12+02:00",
    "2006-08-07T23:28:00+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.IllegalArgumentException",
      "message": "Attempted to beginRule: F/TestEARWeb/.settings, does not match outer scope rule: org.eclipse.jst.j2ee.navigator.internal.NonConflictingRule@49924992",
      "elements": [
        {
          "method": "org.eclipse.core.runtime.Assert.isLegal",
          "source": "Assert.java:62"
        },
        {
          "method": "org.eclipse.core.internal.jobs.ThreadJob.illegalPush",
          "source": "ThreadJob.java:116"
        },
        {
          "method": "org.eclipse.core.internal.jobs.ThreadJob.push",
          "source": "ThreadJob.java:225"
        },
        {
          "method": "org.eclipse.core.internal.jobs.ImplicitJobs.begin",
          "source": "ImplicitJobs.java:80"
        },
        {
          "method": "org.eclipse.core.internal.jobs.JobManager.beginRule",
          "source": "JobManager.java:219"
        },
        {
          "method": "org.eclipse.core.internal.resources.WorkManager.checkIn",
          "source": "WorkManager.java:96"
        },
        {
          "method": "org.eclipse.core.internal.resources.Workspace.prepareOperation",
          "source": "Workspace.java:1684"
        },
        {
          "method": "org.eclipse.core.internal.resources.Resource.refreshLocal",
          "source": "Resource.java:1396"
        },
        {
          "method": "org.eclipse.core.internal.resources.File.refreshLocal",
          "source": "File.java:334"
        },
        {
          "method": "org.eclipse.jem.util.emf.workbench.WorkbenchURIConverterImpl.createPlatformResourceInputStream",
          "source": "WorkbenchURIConverterImpl.java:501"
        },
        {
          "method": "org.eclipse.emf.ecore.resource.impl.URIConverterImpl.createInputStream",
          "source": "URIConverterImpl.java:449"
        },
        {
          "method": "org.eclipse.emf.ecore.resource.impl.ResourceImpl.load",
          "source": "ResourceImpl.java:892"
        },
        {
          "method": "org.eclipse.wst.common.internal.emf.resource.CompatibilityXMIResourceImpl.load",
          "source": "CompatibilityXMIResourceImpl.java:259"
        },
        {
          "method": "org.eclipse.wst.common.internal.emf.resource.TranslatorResourceImpl.load",
          "source": "TranslatorResourceImpl.java:388"
        },
        {
          "method": "org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.demandLoad",
          "source": "ResourceSetImpl.java:249"
        },
        {
          "method": "org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.demandLoad",
          "source": "ProjectResourceSetImpl.java:83"
        },
        {
          "method": "org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.demandLoadHelper",
          "source": "ResourceSetImpl.java:264"
        },
        {
          "method": "org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getResource",
          "source": "ResourceSetImpl.java:390"
        },
        {
          "method": "org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.getResource",
          "source": "ProjectResourceSetImpl.java:262"
        },
        {
          "method": "org.eclipse.wst.common.internal.emfworkbench.WorkbenchResourceHelper.getOrCreateResource",
          "source": "WorkbenchResourceHelper.java:384"
        },
        {
          "method": "org.eclipse.wst.common.internal.emfworkbench.integration.EditModel.getResource",
          "source": "EditModel.java:717"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.ModuleStructuralModel.getPrimaryResource",
          "source": "ModuleStructuralModel.java:226"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.ModuleStructuralModel.prepareProjectModulesIfNecessary",
          "source": "ModuleStructuralModel.java:185"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.ModuleStructuralModel.getPrimaryRootObject",
          "source": "ModuleStructuralModel.java:108"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.StructureEdit.getComponentModelRoot",
          "source": "StructureEdit.java:442"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.StructureEdit.getWorkbenchModules",
          "source": "StructureEdit.java:471"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.StructureEdit.getComponent",
          "source": "StructureEdit.java:914"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.resources.VirtualResource.getReadOnlyComponent",
          "source": "VirtualResource.java:317"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.resources.VirtualResource.getProjectRelativePaths",
          "source": "VirtualResource.java:116"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.resources.VirtualResource.getProjectRelativePath",
          "source": "VirtualResource.java:147"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.resources.VirtualResource.getWorkspaceRelativePath",
          "source": "VirtualResource.java:107"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.impl.PlatformURLModuleConnection.resolve",
          "source": "PlatformURLModuleConnection.java:67"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.impl.ComponentCoreURIConverter.normalize",
          "source": "ComponentCoreURIConverter.java:80"
        },
        {
          "method": "org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getResource",
          "source": "ResourceSetImpl.java:353"
        },
        {
          "method": "org.eclipse.jem.internal.util.emf.workbench.ProjectResourceSetImpl.getResource",
          "source": "ProjectResourceSetImpl.java:262"
        },
        {
          "method": "org.eclipse.wst.common.internal.emfworkbench.WorkbenchResourceHelper.getOrCreateResource",
          "source": "WorkbenchResourceHelper.java:384"
        },
        {
          "method": "org.eclipse.wst.common.internal.emfworkbench.integration.EditModel.getResource",
          "source": "EditModel.java:717"
        },
        {
          "method": "org.eclipse.wst.common.componentcore.internal.ArtifactEditModel.getResource",
          "source": "ArtifactEditModel.java:173"
        },
        {
          "method": "org.eclipse.jst.j2ee.internal.webservice.componentcore.util.WSCDDArtifactEdit.getDeploymentDescriptorResource",
          "source": "WSCDDArtifactEdit.java:123"
        },
        {
          "method": "org.eclipse.jst.j2ee.internal.webservice.componentcore.util.WSCDDArtifactEdit.getWscddXmiResource",
          "source": "WSCDDArtifactEdit.java:97"
        },
        {
          "method": "org.eclipse.jst.j2ee.internal.webservice.helper.WebServicesManager.getWorkspace13ServiceRefs",
          "source": "WebServicesManager.java:619"
        },
        {
          "method": "org.eclipse.jst.j2ee.internal.webservice.WebServiceViewerSynchronization.indexWebServices",
          "source": "WebServiceViewerSynchronization.java:154"
        },
        {
          "method": "org.eclipse.jst.j2ee.internal.webservice.WebServiceViewerSynchronization.access$0",
          "source": "WebServiceViewerSynchronization.java:150"
        },
        {
          "method": "org.eclipse.jst.j2ee.internal.webservice.WebServiceViewerSynchronization$WebServiceIndexJob.run",
          "source": "WebServiceViewerSynchronization.java:234"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:58"
        }
      ],
      "number": 0,
      "commentIndex": 19,
      "bugId": "130994",
      "date": "2006-07-31T19:55:36+02:00",
      "product": "Web Tools",
      "component": "wst.common",
      "severity": "critical"
    }
  ],
  "groupId": "130994",
  "bugId": "130994",
  "date": "2006-03-08T22:32:07+01:00",
  "product": "Web Tools",
  "component": "wst.common",
  "severity": "critical"
}