{
  "comments": [
    "I launched a runtime workbench in debug mode. The workbench did not come up. The\nconsole was available. Only the following bundles were active (all the others\nwere resolved):\n\nid\tType\tState       Bundle\n0\t     \tACTIVE     System Bundle [0]\n416\t     \tACTIVE    \nreference:file:d:/target/osgi-equinox/eclipse/plugins/org.eclipse.osgi.services\n[416]\n417\t     \tACTIVE    \nreference:file:d:/target/osgi-equinox/eclipse/plugins/org.eclipse.osgi.util [417]\n418\t     \tACTIVE    \nreference:file:d:/target/osgi-equinox/eclipse/plugins/org.apache.xerces [418]\n419\t     \tACTIVE    \nreference:file:d:/target/osgi-equinox/eclipse/plugins/org.eclipse.core.runtime.osgi\n[419]\n\t\tFragment\u003d493\n420\t     \tACTIVE    \nreference:file:d:/target/osgi-equinox/eclipse/plugins/org.eclipse.update.configurator\n[420]\n\nThis has happenned once in a while. If I try again, the problem disappears.\nFollowing are the stack traces of all threads:\n\norg.eclipse.core.launcher.Main at localhost:2103 (Suspended)\n\tSystem Thread [Finalizer] (Suspended)\n\t\tObject.wait(long) line: not available [native method]\n\t\tReferenceQueue.remove(long) line: 111\n\t\tReferenceQueue.remove() line: 127\n\t\tFinalizer$FinalizerThread.run() line: 159\n\tSystem Thread [Reference Handler] (Suspended)\n\t\tObject.wait(long) line: not available [native method]\n\t\tReference$Lock(Object).wait() line: 426\n\t\tReference$ReferenceHandler.run() line: 113\n\tSystem Thread [Signal Dispatcher] (Suspended)\n\tThread [Thread-1] (Suspended)\n\t\tObject.wait(long) line: not available [native method]\n\t\tEventThread(Object).wait() line: 426\n\t\tEventThread.getNextEvent() line: 156\n\t\tEventThread.run() line: 107\n\tThread [OSGi Console] (Suspended)\n\t\tObject.wait(long) line: not available [native method]\n\t\tFrameworkConsole.console() line: 285\n\t\tFrameworkConsole.console(String[]) line: 257\n\t\tFrameworkConsole.run() line: 232\n\t\tThread.run() line: 536\n\tThread [Thread-2] (Suspended)\n\t\tEclipseClassLoader(DefaultClassLoader).findClass(String) line: 117\n\t\tEclipseClassLoader.basicFindClass(String) line: 68\n\t\tEclipseClassLoader.findClass(String) line: 45\n\t\tEclipseClassLoader(BundleClassLoader).findLocalClass(String) line: 276\n\t\tBundleLoader.findLocalClass(String) line: 208\n\t\tImportClassLoader.findClass(String) line: 317\n\t\tBundleLoader.findImportedClass(String) line: 241\n\t\tBundleLoader.findClass(String) line: 286\n\t\tBundleLoader.findClass(String) line: 270\n\t\tEclipseClassLoader(BundleClassLoader).loadClass(String, boolean) line: 89\n\t\tEclipseClassLoader(ClassLoader).loadClass(String) line: 255\n\t\tEclipseClassLoader(ClassLoader).loadClassInternal(String) line: 315\n\t\tClass.getDeclaredConstructors0(boolean) line: not available [native method]\n\t\tClass.privateGetDeclaredConstructors(boolean) line: 1590\n\t\tClass.getConstructor0(Class[], int) line: 1762\n\t\tClass.newInstance0() line: 276\n\t\tClass.newInstance() line: 259\n\t\tBundleContext.loadBundleActivator() line: 1168\n\t\tBundleContext.start() line: 1195\n\t\tBundle.startWorker(boolean) line: 677\n\t\tBundle.resume() line: 800\n\t\tFramework.resumeBundle(Bundle) line: 1304\n\t\tStartLevelListener.resumeBundles(Bundle[], boolean) line: 195\n\t\tStartLevelListener.incFWSL(StartLevelEvent) line: 85\n\t\tStartLevelImpl.dispatchEvent(Object, Object, int, Object) line: 450\n\t\tListenerList.dispatchEvent(EventSource, int, Object) line: 150\n\t\tEventThread$EventThreadItem.dispatchEvent() line: 61\n\t\tEventThread.run() line: 107\n\tThread [DestroyJavaVM] (Suspended)\n\tThread [Worker-0] (Suspended)\n\t\tClass.forName0(String, boolean, ClassLoader) line: not available [native method]\n\t\tClass.forName(String) line: 140\n\t\tConfigurationElement.implementsIExecutableExtension(Object) line: 363\n\t\tConfigurationElement.createExecutableExtension(Bundle, String, Object,\nIConfigurationElement, String) line: 169\n\t\tConfigurationElement.createExecutableExtension(Bundle, String, String, Object,\nIConfigurationElement, String) line: 129\n\t\tConfigurationElement.createExecutableExtension(String) line: 118\n\t\tPlatformURLPluginHandlerFactory.installURL(IConfigurationElement) line: 100\n\t\tPlatformURLPluginHandlerFactory.register(IExtension) line: 54\n\t\tPlatformURLPluginHandlerFactory$1.registryChanged(IRegistryChangeEvent) line: 78\n\t\tExtensionRegistry$ExtensionEventDispatcherJob.run(IProgressMonitor) line: 477\n\t\tWorker.run() line: 61\n\tThread [Worker-1] (Suspended)\n\t\tEclipseClassLoader(DefaultClassLoader).findClass(String) line: 117\n\t\tEclipseClassLoader.basicFindClass(String) line: 68\n\t\tEclipseClassLoader.findClass(String) line: 45\n\t\tEclipseClassLoader(BundleClassLoader).findLocalClass(String) line: 276\n\t\tBundleLoader.findLocalClass(String) line: 208\n\t\tImportClassLoader.findClass(String) line: 317\n\t\tBundleLoader.findImportedClass(String) line: 241\n\t\tBundleLoader.findImportedClass(String) line: 253\n\t\tBundleLoader.findClass(String) line: 286\n\t\tEclipseClassLoader(BundleClassLoader).loadClass(String, boolean) line: 89\n\t\tEclipseClassLoader(ClassLoader).loadClass(String) line: 255\n\t\tEclipseClassLoader(ClassLoader).loadClassInternal(String) line: 315\n\t\tClass.forName0(String, boolean, ClassLoader) line: not available [native method]\n\t\tClass.forName(String) line: 140\n\t\tConfigurationElement.implementsIExecutableExtension(Object) line: 363\n\t\tConfigurationElement.createExecutableExtension(Bundle, String, Object,\nIConfigurationElement, String) line: 169\n\t\tConfigurationElement.createExecutableExtension(Bundle, String, String, Object,\nIConfigurationElement, String) line: 129\n\t\tConfigurationElement.createExecutableExtension(String) line: 118\n\t\tPlatformURLPluginHandlerFactory.installURL(IConfigurationElement) line: 100\n\t\tPlatformURLPluginHandlerFactory.register(IExtension) line: 54\n\t\tPlatformURLPluginHandlerFactory$1.registryChanged(IRegistryChangeEvent) line: 78\n\t\tExtensionRegistry$ExtensionEventDispatcherJob.run(IProgressMonitor) line: 477\n\t\tWorker.run() line: 61\n\tThread [Worker-2] (Suspended)\n\t\tObject.wait(long) line: not available [native method]\n\t\tWorkerPool.sleep(long) line: 109\n\t\tWorkerPool.startJob(Worker) line: 135\n\t\tWorker.run() line: 54",
    "Created an attachment (id\u003d6242)\nstartup log and VM stack trace dump\n\nHappened now when starting using the build. This is stack trace is more\ninteresting. Long story short:\n- a fragment class in thread A is trying to find a class that is in the\nfragment (but looks first in the master)\n- master class in thread B is trying to find a class that is in the fragment\n(using reflection)\n- thread A gets the fragment bundle classloader lock\n(ClassLoader.loadClassInternal) and then tries to get the master classloader\nlock (DefaultClassLoader.findClass)\n- thread B gets the master bundle classloader lock\n(ClassLoader.loadClassInternal) and the tries to get the fragment classloader\nlock (DefaultClassLoader.findClass)\n",
    "This is due to the Sun JDK implementation of ClassLoader.loadClassInternal().  \nIt is synchronized.\n\nDetails of this bug can be found at:\n\nhttp://developer.java.sun.com/developer/bugParade/bugs/4670071.html\n\nNeed to look for workarounds.\n\nAlso look at the behaviour in standard Eclipse\n\n",
    "In the Core team meeting I explained this problem and John Arthorne pointed out\nthat a probably reason for this not being an issue in regular Eclipse is that\nfragments do not have their own classloaders, and plugin dependencies are always\nhierarchical (acyclic).",
    "We realized that and will try to figure out what are the difference. Apparently \nthe first striking difference is the way fragments are being handled in Equinox \nsince they have there own classloader, whereas in eclipse jars of fragments \nwere directly being put on the classpath of the plugin.",
    "I have checked in a workaround for Sun\u0027s defect 4670071.  Here is a summary of \nthe workaround:\n\n1.  Bundle ClassLoaders are flaged as locked when the ClassLoader.loadClass\n(String name) method is called.  We assume that the \nClassLoader.loadClassInternal(String name) calls this method so we flag the \nClassLoader as locked when this method is called even though we may not really \nbe locked.\n\n2.  If we detect that a Thread is trying to load a class from a locked \nClassLoader and that Thread already has a lock to another ClassLoader then we \ninsert ourselves into a Hash keyed by our locked ClassLoader with the value of \nthe ClassLoader we need to aquire the lock too.\n\n3.  Then we check the Hash for an entry that is keyed by the ClassLoader we are \ntrying to aquire the lock to.  If an entry exists and the value of that entry \nis the ClassLoader we already have a lock to then we are in a classic deadlock \nsituation and go to step 4, otherwise we go to step 5.\n\n4.  At this point all we can do is perform a ClassLoader.wait() on the \nClassLoader we already have a lock on.  This will release our lock and give the \nother Thread trying to aquire our lock a chance to continue which should allow \nthen to give up the lock you need.\n\n5. Continue to try to aquire the lock to the other ClassLoader to load the \nclass.\n\n",
    "I am eventually getting ClassCircularityErrors with 1.4.2_01:\n\n!ENTRY org.eclipse.core.runtime 4 2 Oct 24, 2003 11:22:45.590\n!MESSAGE An internal error occurred during: \"Status Line Update\".\n!STACK 0\njava.lang.ClassCircularityError: org/eclipse/ui/progress/UIJob$1\n\tat org.eclipse.ui.progress.UIJob.run(UIJob.java:74)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:62)\n\nI would say they may be related to the workaround described above.\n\nUnfortunately, I don\u0027t have any further details to provide...",
    "Yes, you are probably getting the ClassCircularityErrors from the workaround \nfor the deadlock.  Unfortunately the workaround surfaces another sun bug that \ncauses the errors. See sun bug #4699981 ClassCircularityError thrown without \nreason during class loading.\n\nThe fragment classloading model has changed as of 10/24/2003.  Now fragments \nare loaded using the same classloader of the host.  This should help reduce the \nlikelihood of a deadlock situation from occurring.  We may want to disable the \ndeadlock workaround.  If we do not disable the workaround we need to determine \nif the ClassCircularityErrors still occur with the new fragment loading model.\n\n\n",
    "This issue is largely resovled by the merging of the fragment jars on to the \nhost classloader.  This greatly reduces the incidence of circular classloader \ndependencies.\n\nthe possibility still exists but only to the same extent that it does in \nEclispe."
  ],
  "commentCreationDates": [
    "2003-09-25T00:39:30+02:00",
    "2003-09-25T21:58:13+02:00",
    "2003-09-29T22:00:00+02:00",
    "2003-09-30T23:01:01+02:00",
    "2003-09-30T23:16:44+02:00",
    "2003-10-02T18:38:23+02:00",
    "2003-10-24T18:00:05+02:00",
    "2003-10-24T22:07:54+02:00",
    "2003-11-28T18:46:58+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ClassCircularityError",
      "message": "org/eclipse/ui/progress/UIJob$1",
      "elements": [
        {
          "method": "org.eclipse.ui.progress.UIJob.run",
          "source": "UIJob.java:74"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:62"
        }
      ],
      "number": 0,
      "commentIndex": 6,
      "bugId": "43619",
      "date": "2003-10-24T18:00:05+02:00",
      "product": "Equinox",
      "component": "Incubator",
      "severity": "normal"
    }
  ],
  "groupId": "43619",
  "bugId": "43619",
  "date": "2003-09-25T00:39:30+02:00",
  "product": "Equinox",
  "component": "Incubator",
  "severity": "normal"
}