{
  "comments": [
    "Hello AspectJ team,\n\n\nI\u0027m using AspectJ with some kind of pointcut reuse (achieved by placing certain public pointcuts into an otherwise empty Aspect and referencing these from other aspects). As this feature works in most situations I suppose it is a supported feature of AspectJ. If such a style of pointcut reuse is not intended in AspectJ just ignore this bug report.\n\nWhen trying to apply an advice using LTW for a RMI application that uses dynamic proxies the class-loading fails with a NullPointerException. But interestingly that only happens when the pointcut used in the Aspect is itself referring to a reusable pointcut (which could be the case for complex pointcuts that share common parts). When I inline the reusable pointcut into the pointcut that\u0027s used by the advice everything runs fine. The pointcut definition in question could be even some completely unrelated pointcut and LTW\u0027s class-loading fails too (which I assume is the case since AspectJ has to intercept the class-loading anyway).\n\nI\u0027ve tested it with the development build: aspectj-DEVELOPMENT-20060925164058\n\n\nHere\u0027s the reusable (simplified for testcase purposes :) pointcut definition:\n\n\tpublic final aspect DemoPointcuts {\n\t    public static pointcut justATestReferenced() :\n\t    \tcall(* System.getenv()); // content of this pointcut seems to be unrelated to problem reported. Could be anything you like.\n\t}\n\n\n\n\nHere\u0027s the aspect in question:\n\n\tpublic final aspect TestcaseToReproducePotentialBug {\n    \n\t  private pointcut justATest() :\n\t  \tDemoPointcuts.justATestReferenced() \n\t\t// NOTE that replacing the previous line with the inline call works fine:   call(* System.getenv()) \n\t  ;\n  \n\t  after() returning() : justATest() {\n\t  \tSystem.out.println(\"TEST\");\n\t  }\n  \n\t}    \n\n\n\n\nAnd that\u0027s the stack-trace for the class-loading process, having RMI dynamic proxies involed:\n\n27.09.2006 11:24:47 org.aspectj.weaver.tools.Jdk14Trace error\nFATAL: preProcess\njava.lang.NullPointerException\n\tat org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1404)\n\tat org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1274)\n\tat org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1103)\n\tat org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:337)\n\tat org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:243)\n\tat org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:76)\n\tat org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)\n\tat sun.instrument.TransformerManager.transform(TransformerManager.java:122)\n\tat sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)\n\tat java.lang.reflect.Proxy.defineClass0(Native Method)\n\tat java.lang.reflect.Proxy.getProxyClass(Proxy.java:504)\n\tat sun.rmi.server.LoaderHandler.loadProxyClass(LoaderHandler.java:641)\n\tat sun.rmi.server.LoaderHandler.loadProxyClass(LoaderHandler.java:588)\n\tat java.rmi.server.RMIClassLoader$2.loadProxyClass(RMIClassLoader.java:628)\n\tat java.rmi.server.RMIClassLoader.loadProxyClass(RMIClassLoader.java:294)\n\tat sun.rmi.server.MarshalInputStream.resolveProxyClass(MarshalInputStream.java:238)\n\tat java.io.ObjectInputStream.readProxyDesc(ObjectInputStream.java:1500)\n\tat java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1463)\n\tat java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1699)\n\tat java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1305)\n\tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:348)\n\tat sun.rmi.server.UnicastRef.unmarshalValue(UnicastRef.java:290)\n\tat sun.rmi.server.UnicastRef.invoke(UnicastRef.java:139)\n\tat java.rmi.server.RemoteObjectInvocationHandler.invokeRemoteMethod(RemoteObjectInvocationHandler.java:179)\n\tat java.rmi.server.RemoteObjectInvocationHandler.invoke(RemoteObjectInvocationHandler.java:132)\n\tat $Proxy4.prepareLogin(Unknown Source)\n\tat demo.Demo.main(Demo.java:73)\n\n\n\nBest Regards \u0026 keep up the good work,\nChristian",
    "This has the same symptoms, but perhaps different cause, to Bug 151182 \"NPE in BcelWeaver using LTW\". In this case we are generating a proxy class rather than reflection delegate using Unsafe. Please can you turn on trace, that will go to stderr, so we can find out a bit more about what\u0027s going on by specifying the following system properties:\n\n            -Dorg.aspectj.tracing.enabled\u003dtrue\n            -Dorg.aspectj.tracing.factory\u003ddefault\n            -Dorg.aspectj.tracing.messages\u003dtrue\n",
    "Created an attachment (id\u003d51078)\nverbose debug logs\n\n",
    "Created an attachment (id\u003d51094)\nHighlights\n\nChristian,\n\nThanks for the trace which I think tells me what is going wrong although not why. Attached is an interesting part. Here is a commentary\n1.\tWe create a weaving adaptor for the proxy loader\n2.\tWe _start_ to initialize it and register the two aspects: RuntimeExceptionCheck and DemoAspect.\n3.\tWe seem to create several ReflectionWorld instances while parsing the pointcuts for DemoAspect. This needs investigation and is probably the cause of the bug. This class was written for non-LTW pointcut parsing using reflection and probably needs some adjustment to work properly inside LTWWorld.\n4.\tI believe an Error is thrown and control is returned to JMVTI without completing the adaptor initialization: prepareForWeave() has not been called, there is no exit trace and addLibraryAspect() is not the the stack trace for the NPE. We only handle Exceptions today, like the NPE in this report, on the understanding that Errors tend to be fatal. However I think we need to catch Errors and disable the adaptor.\n5.\tWe attempt to weave class $Proxy5 using the uninitialized weaver.\n\nYou appear to have a good workaround by not using a pointcut library. You could exclude proxies from weaving by adding \u003cexclude within\u003d\"$Proxy*\"/\u003e to the \u003cweaver\u003e section of aop.xml but that _won?t_ because the problem happens during adaptor initialization. Another approach would be to exclude weaving for proxy loaders inside Aj as we do for reflection delegate loaders on the grounds that these are system classes. \n\nI will add more trace and exception handling to ensure we capture the Error and weaver is disabled. I will also investigate the use of ReflectionWorld. I may then ask you to reproduce the problem once more (if I still can?t) with an updated build. In the meantime could you post your aspects so that I can add a testcase to the suite?\n",
    "Matthew,\n\nthanks for you in-depth analysis.\n\nI\u0027ve further tested the whole stuff and continously stripped the code in question down. To my own surprise I\u0027ve eventually found the solution:\n\nWhen stripping down the pointcut library further and further I\u0027ve noticed that the pointcut library contains unused (i.e. unreferenced) pointcut definitions with execution pointcuts that reference a class from javax.servlet. As I wanted to reuse my pointcut library for the RMI based application I\u0027m working on I simply copied the pointcut library into the app\u0027s classpath. Since the RMI based app has nothing to do with web-development its runtime classpath didn\u0027t contian the servlet-api which holds the unused javax.servlet class. As soon as I commented-out the unused servlet-related pointcut definition (which works well in a servlet-based environment) the whole stuff ran as expected. On the other hand, when keeping the unused pointcut definition within the pointcut library *and* adding the otherwise not required servlet-api to the runtime classpath of the RMI app the whole stuff ran fine too.\n\nSo it all boils down to having all referenced compile-time required libraries (i.e. servlet-api) also within the runtime-classpath when the application has LTW aspects that (even when unused at run-time) reference these otherwise compile-time dependencies. As the whole RMI app does not have any dependency (either compile-time or run-time) on servlet-api I didn\u0027t add that to the classpath. But as (though unused) parts of the pointcut library I wrote have compile-time dependencies on servlet-api and (in case the pointcuts will be referenced in aspects) also run-time dependencies on the servlet-api I simply have to resolve these dependencies by adding the missing jar to the runtime classpath. \n\nThe interesting point is the fact that the pointcut definition in question which was referencing the servlet api was not used in any aspect. Neither in an aspect of the RMI app nor within the pointcut library. So I thought that adding servlet api to the classpath is not required. But when LTW comes into play certain things that are otherwise static become dynamic (by design, as it is LTW) so I had to rethink about the classpath.  :-)\n\nI hope that this information is helpful to you. Maybe the exception message could be clearer for other users. And maybe I\u0027ve even (by chance) pointed you to some code blocks that should be inspected anyway... \n\nSo just keep up the good work \u0026 Best Regards,\nChristian\n\n\nBTW: If you need any further stuff from me or would like me to test a newer dev build against my app without having servlet-api in the classpath, just let me know... \n\n",
    "While the declaration of an aspect with missing dependencies should fail AspectJ LTW should cope more gracefully and issue a message that helps users to correct their configuration. Could you possibly post the offending aspects to help me reproduce the problem? Thanks again for your co-operation and diagnosis of the problem.",
    "In the absence of a testcase to reproduce the problem I suggest prevention of secondary failure. The adaptor should be disabled by default so that if initialization fails for some reason we won\u0027t be able to use it. Also I will restore the catch (Throwable) in Aj to report any Errors which we have now discovered are swallowed by JVMTI.",
    "sorry for the rather late reply (I was a few days offline while on travel)...\n\nThe following is the pointcut library that I reuse from different aspects:\n\n\npublic aspect Pointcuts {\n\n    public pointcut anyMethodCall() :\n        call(* *(..));\n\n    public pointcut anyMethodExecution() :\n        execution(* *(..));\n\n    public pointcut anyPublicMethodExecution() :\n        execution(public * *(..));\n\n    public pointcut anyNonPrivateMethodExecution() :\n        execution(!private * *(..));\n\n    public pointcut anyConstructorCall() :\n        call(new(..));\n\n    public pointcut anyPublicConstructorCall() :\n        call(public new(..));\n\n    public pointcut anyNonPrivateConstructorCall() :\n        call(!private new(..));\n\n\n    public pointcut servletGetRequest(\njavax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) :\n        execution(void javax.servlet.http.HttpServlet.doGet(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse))\n        \u0026\u0026 args(request, response);\n\n\n}\n\nWhen I try to use any advice from some other aspect which references one of the non-web-relevant pointcuts defined in the pointcut library AspectJ\u0027s LTW tries to load the \"Pointcuts\" pointcut library. During that initialization process even the javax.servlet classes must be resolveable to AspectJ\u0027s LTW runtime classpath though the last pointcut in the above library (the only one that\u0027s referencing the javax.servlet classes) is not used. Neither within the pointcuts library or within some advice referencing it. So the dependency is only a compile-time dependency in \"normal\" non-AOP programming. But in a world of LTW this otherwise compile-time dependency becomes a runtime-dependency.",
    "As an aside and suggestion, on the Glassbox project we have to work around these kinds of issues, e.g., by using\n\n    public pointcut servletRequestExec() :\n        within(HttpServlet+) \u0026\u0026 !within(HttpJspPage+) \u0026\u0026 (execution(* HttpServlet.do*(..)) || execution(* HttpServlet.service(..)));\n\n    before(Object servlet, Object request) : servletRequestExec() \u0026\u0026 this(servlet) \u0026\u0026 args(request, *) {\n...\n\nI am testing a converted version of our servlet monitor that uses reflection to allow a shared aspect that handles servlets even though the containing classloader doesn\u0027t have that API visible.\n\nWhen weaving of javax..* is allowed with AspectJ, we can instead use this technique to handle the situation:\n\n  declare parents: javax.servlet.http.HttpServlet implements IHttpServlet;\n  private interface IHttpServlet { /* extract needed methods from HttpServlet */ }\n\nThen in advice refer to IHttpServlet instead.",
    "I still cannot reproduce this problem even with provided testcase. I might need the aop.xml file being used and the other aspects. I suspect the failure occurs if type resolution for the Servlet classes happens during adaptor initialization when registering the Pointcuts library aspect. However by default we do no resolution of pointcut types until weaving. However we do if completeBinaryTypes\u003dtrue which is now disabled by default. But even with this re-enabled I can\u0027t see a failure.\n\nThe next thing to try will be a class loader hierarchy using TestServer because the problem may lie in completeBinaryTypes/completeNonLocalType().",
    "I am closing this because I don\u0027t believe the problem still exists given the number of changes. If a similar problem does occur the weaver will remain disabled and we will get more diagnostic information."
  ],
  "commentCreationDates": [
    "2006-09-27T14:18:00+02:00",
    "2006-09-27T15:29:21+02:00",
    "2006-09-28T13:21:46+02:00",
    "2006-09-28T17:46:24+02:00",
    "2006-09-29T10:43:14+02:00",
    "2006-09-29T16:59:27+02:00",
    "2006-10-04T11:54:20+02:00",
    "2006-10-05T18:17:16+02:00",
    "2006-10-05T18:31:00+02:00",
    "2006-10-13T10:24:07+02:00",
    "2006-11-01T10:18:04+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers",
          "source": "BcelWeaver.java:1404"
        },
        {
          "method": "org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor",
          "source": "BcelWeaver.java:1274"
        },
        {
          "method": "org.aspectj.weaver.bcel.BcelWeaver.weave",
          "source": "BcelWeaver.java:1103"
        },
        {
          "method": "org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes",
          "source": "WeavingAdaptor.java:337"
        },
        {
          "method": "org.aspectj.weaver.tools.WeavingAdaptor.weaveClass",
          "source": "WeavingAdaptor.java:243"
        },
        {
          "method": "org.aspectj.weaver.loadtime.Aj.preProcess",
          "source": "Aj.java:76"
        },
        {
          "method": "org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform",
          "source": "ClassPreProcessorAgentAdapter.java:55"
        },
        {
          "method": "sun.instrument.TransformerManager.transform",
          "source": "TransformerManager.java:122"
        },
        {
          "method": "sun.instrument.InstrumentationImpl.transform",
          "source": "InstrumentationImpl.java:155"
        },
        {
          "method": "java.lang.reflect.Proxy.defineClass0",
          "source": "Native Method"
        },
        {
          "method": "java.lang.reflect.Proxy.getProxyClass",
          "source": "Proxy.java:504"
        },
        {
          "method": "sun.rmi.server.LoaderHandler.loadProxyClass",
          "source": "LoaderHandler.java:641"
        },
        {
          "method": "sun.rmi.server.LoaderHandler.loadProxyClass",
          "source": "LoaderHandler.java:588"
        },
        {
          "method": "java.rmi.server.RMIClassLoader$2.loadProxyClass",
          "source": "RMIClassLoader.java:628"
        },
        {
          "method": "java.rmi.server.RMIClassLoader.loadProxyClass",
          "source": "RMIClassLoader.java:294"
        },
        {
          "method": "sun.rmi.server.MarshalInputStream.resolveProxyClass",
          "source": "MarshalInputStream.java:238"
        },
        {
          "method": "java.io.ObjectInputStream.readProxyDesc",
          "source": "ObjectInputStream.java:1500"
        },
        {
          "method": "java.io.ObjectInputStream.readClassDesc",
          "source": "ObjectInputStream.java:1463"
        },
        {
          "method": "java.io.ObjectInputStream.readOrdinaryObject",
          "source": "ObjectInputStream.java:1699"
        },
        {
          "method": "java.io.ObjectInputStream.readObject0",
          "source": "ObjectInputStream.java:1305"
        },
        {
          "method": "java.io.ObjectInputStream.readObject",
          "source": "ObjectInputStream.java:348"
        },
        {
          "method": "sun.rmi.server.UnicastRef.unmarshalValue",
          "source": "UnicastRef.java:290"
        },
        {
          "method": "sun.rmi.server.UnicastRef.invoke",
          "source": "UnicastRef.java:139"
        },
        {
          "method": "java.rmi.server.RemoteObjectInvocationHandler.invokeRemoteMethod",
          "source": "RemoteObjectInvocationHandler.java:179"
        },
        {
          "method": "java.rmi.server.RemoteObjectInvocationHandler.invoke",
          "source": "RemoteObjectInvocationHandler.java:132"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "158957",
      "date": "2006-09-27T14:18:00+02:00",
      "product": "AspectJ",
      "component": "LTWeaving",
      "severity": "normal"
    }
  ],
  "groupId": "158957",
  "bugId": "158957",
  "date": "2006-09-27T14:18:00+02:00",
  "product": "AspectJ",
  "component": "LTWeaving",
  "severity": "normal"
}