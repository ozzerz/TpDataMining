{
  "comments": [
    "3.2\n\nThe AST has the rule that a binding is either 100% correct or null.\nIn some situations we loose quite some information due to that. E.g. in bug 149088           \nin \u0027c.add\u0027 we don\u0027t know that \u0027c\u0027 is a variable if \u0027List\u0027 is not imported yet.\n    protected String foo() {\n        List c \u003d new ArrayList();\n        c.add(null);\n        return c;\n    }\n\nA solution would be to add an additional option that would let all \u0027c\u0027 have a variable bidning with \u0027Object\u0027 as variable type.",
    "See also bug 110976 for problems with duplicate methods.",
    "This bug is conditionned by progress on bug 156731",
    "Would an API like getResilientBinding() or a better name be enough to fix this issue?\nThe idea would be that this method would return a binding that is potentially incomplete. It would be the case when the binding returns right now is null.",
    "Actually, the compiler binding already exists here; it is just filtered out by the DOM, since DOM bindings must be sound or absent.\n\nI think we could provide an alternate API for getting the partial binding. (getPartialBinding() ? getErrorBinding() ?). ",
    "Where would this API be? On all AST nodes that offer a resolveBinding? How is the parent (getDeclaringType) of such a variable binding going to look like. Will it contain the incomplete variable binding?\n\nMaybe I misunderstood the idea. But it seems that we can\u0027t maintain compatibility that way.\n\nI would suggest to rather introduce a new flag on the ASTParser to state that \u0027recovered\u0027 bindings can exist.\nImportant is that we have to spec what this means compared to the existing behaviour.\na. You can get bindings for things that can\u0027t correctly be resolved\nb. You can get bindings that return \u0027null\u0027 at places where after the old spec it can\u0027t (for example IVariableBinding.getDeclaredType)\n\na.) is not a real problem, b.) is problematic and can lead to null pointer exceptions if such a binding is passed to old code.\n\nTherefore I suggest to instead of using \u0027null\u0027 we should use a \u0027dummy\u0027 error binding instead. Such a binding would be marked with a special flag.\n\nIn the given example:\nWhen an AST with \u0027recovered bindings enabled\u0027 is created on the code from comment 0:\n\nc would have a variable binding as if everything is normal except getDeclaredType returns a error binding %List%\n\n%List% would have name \u0027List\u0027, no members, default package and a flags set called \u0027errorBindning\u0027.\n\nIf we have a second unresolve reference to \u0027List\u0027 in the code we can think of using the identical binding again, or, to avoid any extra work here, use a new one.\n\n\n\n\n\n",
    "(In reply to comment #5)\n\u003e Therefore I suggest to instead of using \u0027null\u0027 we should use a \u0027dummy\u0027 error\n\u003e binding instead. Such a binding would be marked with a special flag.\nThis could break existing users as well since they are expecting null when nothing can be fully resolved.\nThey might miss \"invalid\" cases if they detect them using a null check.\n\nDeferring to 3.3M6 since Martin is on vacations till M5 is out.",
    "That\u0027s why I suggested a new flag on the ASTParser to state that\n\u0027recovered\u0027 binding can exist at places where \u0027null\u0027 was returned before.\n\nBut what I wanted to say is that is is less problematic to suddendly return something where \u0027null\u0027 returned was before,\n (example: myASTNode.resolveBinding())\ncompared to return \u0027null\u0027 where it was spec\u0027ed that \u0027null\u0027 can\u0027t be returned\n (example: variableBinding.getType())\n",
    "So we should add a setBindingRecovery(boolean). This would allow bindings to be \"resolved\" even if they had errors.\nWe should define what \"default\" behavior is expected in case of errors.\nHowever without changes in the compiler, the case in comment 0 would continue to fail.\nThe compiler binding for the local declaration c is null. I would expect a missing binary type binding or at least something I could use to \"create\" a DOM binding not null?.\nKent, Philippe,\n\nIs this doable or null is expected as the returned type of the local inside the compiler?",
    "Same issue for the method bindings.",
    "Postponing post 3.3.",
    "Re: comment 8. \nI think you have a local var with a null type. It is inserted in scopes, and bound from subsequent references. The DOM could reflect this.\n\nI am a bit skeptical about retrofitting this in existing binding APIs (with new mode), since older clients may accidentally start trying to process these. Think for instance of clients traversing a DOM AST obtained through reconcile.\nOr are we saying this mode wouldn\u0027t be made public ? i.e. need to create the AST through a different API... ?\n\nTagging tentatively for M6, for investigation.",
    "(In reply to comment #11)\n\u003e Re: comment 8. \n\u003e I think you have a local var with a null type. It is inserted in scopes, and\n\u003e bound from subsequent references. The DOM could reflect this.\nThe binding for the local variable is null. So there is nothing that can be done to create a fake binding on the DOM side.\nYou can check regression tests org.eclipse.jdt.core.tests.dom.ASTConverterTestAST3_2#test0666/test0667.\nThey reflect the actual DOM bindings.\n\nWe could add a new flag on the ASTParser that would be used to set that error bindings can be created. I don\u0027t see the advantage of getting a non-null binding vs a null binding since there is nothing that can be done with this binding anyway.\n\nAdding a new option that would preserve the actual behavior by default should not be an API breakage.\nSome documentation might need to be updated to reflect it.\n\nAny thought?\n",
    "Olivier - I just debugged through the testcase, and could see that on compiler side, the variable is created with a null type, and subsequent reference from message send is correctly bound to the variable \u0027c\u0027 (null type).\n",
    "yes, but I would like to get something not null in order to create a fake binding on the DOM side.",
    "The variable binding is not null; only its type is, since unbound. This is an incomplete variable binding, which is what was requested in the first place. What more do you need ?",
    "I would have expected the type to be a missing binary type binding.\nMartin, do you expect each null value to be converted to \"java.lang.Object\" type binding ?\n\nSo we should add a method:\nsetBindingRecovery(boolean) on the org.eclipse.jdt.core.dom.ASTParser class.\n\nThen I guess we also need a way for the user to know that the binding is an incomplete binding. So we might need a flag on the binding itself.\nisRecoveredBinding() defined on org.eclipse.jdt.core.dom.IBinding.\n\nAny comment?",
    "However for the method case, it is a bit worse since the binding is null.\nI don\u0027t have a method binding with null for the \"unbound\" parts (either return type, thrown exception types or any of the parameter types).",
    "comment 16:\nI think there are two solutions, simple and deluxe:\na.) simple: varBinding.getType() return the binding for \u0027java.lang.Object\u0027. No API is provided for the client to find out that this binding has been added by recovery.\nBut this would already help us.\nb.) There is a way to mark bindings that are recovered: varBinding.getType() would returned a type binding where \u0027typeBinding.isRecoveredBinding() \u003d\u003d true\u0027. But, this can\u0027t be \u0027java.lang.Object\u0027 as there can only be one such binding in the environment and that binding has \u0027typeBinding.isRecoveredBinding() \u003d\u003d false\u0027.\nSo it would be its own binding. It doesn\u0027t need any methods, package ect. If you want to be nice it could have a name as found in the code.\n\nc.) varBinding.getType() returns null: This is a no-go as this is against the spec of IVariableBinding and changing that would hurt many old clients when they happen to get hands a \u0027recovered\u0027 AST.\n\ncomment 17:\nLet\u0027s just start with variables. We will later see if methods are useful and important as well.",
    "(In reply to comment #18)\n\u003e I think there are two solutions, simple and deluxe:\n\u003e a.) simple: varBinding.getType() return the binding for \u0027java.lang.Object\u0027. No\n\u003e API is provided for the client to find out that this binding has been added by\n\u003e recovery.\nWithout a way for the user to know that the binding is recovered, this could end up being misleading. Object might not be the \"actual\" type of the variable.\n\n\u003e b.) There is a way to mark bindings that are recovered: varBinding.getType()\n\u003e would returned a type binding where \u0027typeBinding.isRecoveredBinding() \u003d\u003d true\u0027.\n\u003e But, this can\u0027t be \u0027java.lang.Object\u0027 as there can only be one such binding in\n\u003e the environment and that binding has \u0027typeBinding.isRecoveredBinding() \u003d\u003d\n\u003e false\u0027.\nI would have reported the variable binding to be recovered, not its type itself.\nOr both of them should be reported as recovered?\n\n\u003e So it would be its own binding. It doesn\u0027t need any methods, package ect. If\n\u003e you want to be nice it could have a name as found in the code.\nWe might also want to create a binding that has the same source name as in the code. It would belong to the default package, no methods, no fields, etc.\n\n\u003e c.) varBinding.getType() returns null: This is a no-go as this is against the\n\u003e spec of IVariableBinding and changing that would hurt many old clients when\n\u003e they happen to get hands a \u0027recovered\u0027 AST.\nAgree. This is not an acceptable solution. This is why null is returned for the binding right now.\n\n\u003e comment 17:\n\u003e Let\u0027s just start with variables. We will later see if methods are useful and\n\u003e important as well.\nFor method, I guess I could create a fake method binding based on the code. Not sure this is helpful.\nI\u0027ll prepare a patch for variable only for now.",
    "Re: comment 16.\nMissing binary bindings are only created from within binaries, which isn\u0027t the case here (i.e. in situations where we have the full signature at hand).\n\nI am not convinced of adding Object as a placeholder. I know we do it in case superclass is missing. Can\u0027t we introduce use a \u0027void\u0027 type instead or some bottom type object ? Then it would be obvious it representing an unbound type. Alternatively, we could create a type by the simple name (in default package?), this would allow to carry the simple name information... or maybe rather some problem type binding with a simple/qualified name in it ?\n\n",
    "I have three cases on which I\u0027d like to know what should be returned:\n- the array case:\n    protected String foo() {\n        List[] c \u003d bar();\n        c.add(null);\n        return c;\n    }\nDo you expect an array of a recovered binding named \"List\"?\n\n- the qualified name case:\n\n    protected String foo() {\n        p1.p2.T c \u003d bar();\n        c.add(null);\n        return c;\n    }\nDo you expect the recovered binding to have a qualified name (p1.p2.T) and a simple name (T) ?\n\n- the parameterized type case:\n    protected String foo() {\n        p1.p2.T\u003cString\u003e c \u003d bar();\n        c.add(null);\n        return c;\n    }\n\nShould the recovered binding be a parameterized type binding ?\n\nLet me know what you expect. I almost have a prototype working.",
    "It would be good to get an array type resp. a parameterized type binding there. \nAlso having  qualification this would be great, but no problem if the type binding is just simple name. After all it could also be that type \u0027T\u0027 is inside a outer type \u0027p2\u0027. ",
    "What kind of equality do you expect between recovered bindings?\nShould the two recovered bindings for List (for c1 and c) be equals or \u003d\u003d in this case ?\n...\n    protected String foo() {\n        List c \u003d new ArrayList();\n        List c2 \u003d new ArrayList();\n        c.add(null);\n        return c;\n    }\n...\nSame question for array binding of recovered binding.\nAnd is such an array binding also considered as a recovered binding ?\n\nSame question for parameterized type binding.",
    "I think it\u0027s ok if they are _not_ identical. If you want to make them identical, sure, but the the client couldn\u0027t and shouldn\u0027t rely on this.\n\nI think the array bidning shouldn\u0027t be marked as recovered: The array part of the type is correct. It\u0027s just the element type that has a problem.\nBut I\u0027m also fine with having it marked. I guess there are also good arguments for that.",
    "I remove method bindings from the title and I will open a new bug for the incomplete method binding.",
    "Added bug 176631.\nPlease add yourself to the cc list.",
    "Created an attachment (id\u003d60387)\nFirst draft\n\nMartin,\n\nPlease give it a try and let me know if this goes into the right direction.",
    "Created an attachment (id\u003d60388)\nRegression tests\n\n",
    "API-wise this looks good. Maybe the comment on \u0027IBinding.isRecovered()\u0027 could be more precise or give an example.\nIs it ok to say that a recovered binding stands for an unresolvable reference in the AST?\n\nThere are other places where you can create an AST and where we have to allow the new AST parser option:\n\n- ICompilationUnit.reconcile(..., recoverBindings,...)\n- ReconcileContext\n\nIt would also be nice to have a way to know from an AST that binding resolving is enabled, something like AST.isBindingRecovery (bug 130001)\n\nWhile trying out the patch, I got the following exception (I can provide the code example)\njava.lang.ClassCastException: org.eclipse.jdt.core.dom.RecoveredTypeBinding cannot be cast to org.eclipse.jdt.core.dom.TypeBinding\n\tat org.eclipse.jdt.core.dom.DefaultBindingResolver.getTypeBinding(DefaultBindingResolver.java:337)\n\tat org.eclipse.jdt.core.dom.DefaultBindingResolver.resolveType(DefaultBindingResolver.java:1512)\n\tat org.eclipse.jdt.core.dom.Type.resolveBinding(Type.java:169)\n\tat org.eclipse.jdt.astview.views.ASTViewContentProvider.getNodeChildren(ASTViewContentProvider.java:152)\n\n\n",
    "Yes, please provide the test case.",
    "- apply the patch from comment 27 to jdt.core but change \u0027createAST\u0027 to always create an AST with binding recovery\n- open AST view on the following code\n\npackage p;\n\npublic class A {\n\tB foo() {\n\t\t\n\t}\n}\n",
    "Created an attachment (id\u003d60687)\nFix for Martin\u0027s problem\n\nThis should fix your issue.",
    "Agree that for consistency, ICompilationUnit#reconcile(...) should also have a flag to say that recovered bindings are requested. However instead of adding yet another boolean, we should replace the boolean parameters with an int paramater that would combine forceProblemDetection, enableStatementsRecovery, and recoverBindings.\nI also agree that ReconcileContext#getAST3() should take all these flags into account.",
    "comment 33 makes sense to me.",
    "+1",
    "Released for 3.3M6 as a macro patch with fix for 149567.\nRegression tests added in org.eclipse.jdt.core.tests.dom.ASTConverter15Test#test0253/0257 and org.eclipse.jdt.core.tests.dom.ASTConverterTestAST3_2#test0670/0673",
    "Verified for 3.3 M6 using build I20070320-0010"
  ],
  "commentCreationDates": [
    "2006-07-04T14:47:54+02:00",
    "2006-07-04T17:15:21+02:00",
    "2006-09-13T15:19:26+02:00",
    "2007-01-11T18:14:15+01:00",
    "2007-01-11T18:15:12+01:00",
    "2007-01-12T10:14:58+01:00",
    "2007-01-29T16:41:13+01:00",
    "2007-02-12T17:12:05+01:00",
    "2007-02-14T15:56:41+01:00",
    "2007-02-14T16:08:21+01:00",
    "2007-02-23T15:56:55+01:00",
    "2007-02-23T18:10:51+01:00",
    "2007-02-23T19:23:54+01:00",
    "2007-02-26T23:08:17+01:00",
    "2007-02-27T00:46:10+01:00",
    "2007-02-27T00:56:07+01:00",
    "2007-02-27T16:23:49+01:00",
    "2007-02-27T16:27:00+01:00",
    "2007-02-27T16:47:07+01:00",
    "2007-02-27T17:03:26+01:00",
    "2007-02-27T22:44:19+01:00",
    "2007-02-28T20:39:11+01:00",
    "2007-03-01T09:00:54+01:00",
    "2007-03-01T20:52:30+01:00",
    "2007-03-02T12:14:49+01:00",
    "2007-03-07T18:33:20+01:00",
    "2007-03-07T18:35:18+01:00",
    "2007-03-07T18:37:14+01:00",
    "2007-03-07T18:37:35+01:00",
    "2007-03-12T16:34:27+01:00",
    "2007-03-12T16:40:19+01:00",
    "2007-03-12T16:53:14+01:00",
    "2007-03-13T17:31:01+01:00",
    "2007-03-14T11:53:42+01:00",
    "2007-03-14T14:12:13+01:00",
    "2007-03-15T15:47:42+01:00",
    "2007-03-15T17:08:47+01:00",
    "2007-03-20T16:34:02+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.ClassCastException",
      "message": "org.eclipse.jdt.core.dom.RecoveredTypeBinding cannot be cast to org.eclipse.jdt.core.dom.TypeBinding",
      "elements": [
        {
          "method": "org.eclipse.jdt.core.dom.DefaultBindingResolver.getTypeBinding",
          "source": "DefaultBindingResolver.java:337"
        },
        {
          "method": "org.eclipse.jdt.core.dom.DefaultBindingResolver.resolveType",
          "source": "DefaultBindingResolver.java:1512"
        },
        {
          "method": "org.eclipse.jdt.core.dom.Type.resolveBinding",
          "source": "Type.java:169"
        },
        {
          "method": "org.eclipse.jdt.astview.views.ASTViewContentProvider.getNodeChildren",
          "source": "ASTViewContentProvider.java:152"
        }
      ],
      "number": 0,
      "commentIndex": 29,
      "bugId": "149567",
      "date": "2007-03-12T16:34:27+01:00",
      "product": "JDT",
      "component": "Core",
      "severity": "enhancement"
    }
  ],
  "groupId": "149567",
  "bugId": "149567",
  "date": "2006-07-04T14:47:54+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "enhancement"
}