{
  "comments": [
    "getSelectionWithoutDependants() throws a NPE because the viewer parameter is \nnull.  The underlying problem is as follows:\n\n1. In AbstractTool.mouseDown(), the current viewer is set in a field.\n2. From mouseDown(), handleButtonDown() is called.  The implementation is in \nSelectEditPartTracker, a subclass of AbstractTool.\n3. handleButtonDown() calls select() on the viewer, which triggers workbench \nselection change notifications.\n4. In the particular case that I encounter, we have a view listening for \nworkbench selection change notifications that must invoke a \nIRunnableWithProgress in the context of a workbench window.  This removes the \nfocus from the edit part and then restores it.  However, this leaves the \nSelectEditPartTracker with no viewer set.\n\nHere is the stack trace:\n\njava.lang.NullPointerException\n\tat java.lang.Throwable.\u003cinit\u003e(Throwable.java)\n\tat java.lang.Throwable.\u003cinit\u003e(Throwable.java)\n\tat java.lang.NullPointerException.\u003cinit\u003e(NullPointerException.java:60)\n\tat org.eclipse.gef.tools.ToolUtilities.getSelectionWithoutDependants\n(ToolUtilities.java:29)\n\tat org.eclipse.gef.tools.DragEditPartsTracker.createOperationSet\n(DragEditPartsTracker.java:150)\n\tat org.eclipse.gef.tools.AbstractTool.getOperationSet\n(AbstractTool.java:575)\n\tat org.eclipse.gef.tools.DragEditPartsTracker.captureSourceDimensions\n(DragEditPartsTracker.java:108)\n\tat org.eclipse.gef.tools.DragEditPartsTracker.setState\n(DragEditPartsTracker.java:516)\n\tat org.eclipse.gef.tools.AbstractTool.stateTransition\n(AbstractTool.java:1260)\n\tat org.eclipse.gef.tools.SelectEditPartTracker.handleButtonDown\n(SelectEditPartTracker.java:93)\n\tat org.eclipse.gef.tools.AbstractTool.mouseDown(AbstractTool.java:974)\n\tat org.eclipse.gef.tools.SelectionTool.mouseDown\n(SelectionTool.java:481)\n\tat org.eclipse.gef.EditDomain.mouseDown(EditDomain.java:194)\n\tat org.eclipse.gef.ui.parts.DomainEventDispatcher.dispatchMousePressed\n(DomainEventDispatcher.java:314)\n\tat org.eclipse.draw2d.LightweightSystem$EventHandler.mouseDown\n(LightweightSystem.java:491)\n\tat org.eclipse.swt.widgets.TypedListener.handleEvent\n(TypedListener.java:132)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java)\n\tat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1353)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1324)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench\n(Workbench.java:243)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:141)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run\n(IDEApplication.java:90)\n\tat org.eclipse.core.internal.runtime.PlatformActivator$1.run\n(PlatformActivator.java:298)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run\n(EclipseStarter.java:249)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run\n(EclipseStarter.java:126)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke\n(NativeMethodAccessorImpl.java:84)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke\n(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke\n(DelegatingMethodAccessorImpl.java:59)\n\tat java.lang.reflect.Method.invoke(Method.java:390)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:269)\n\tat org.eclipse.core.launcher.Main.run(Main.java:722)\n\tat org.eclipse.core.launcher.Main.main(Main.java:706)",
    "I tagged this bug with the wrong GEF version.  It should have been 3.0.  \nSpecifically, I tested it against the I20040619 GEF build on top of Eclipse \n3.0 RC3.",
    "Created an attachment (id\u003d12571)\nTest case\n\nI attach a simple test case that illustrates this problem.\n\nIt requires the GEF logic example (I used I20040619).  The testcase plugin\ncontributes a new view that registers a selection listener on the workbench\nwindow\u0027s selection service.  Inside this listener, it invokes an\nIRunnableWithProgress that does nothing.\n\nSTEPS TO REPRODUCE:\n1. Create a new GEF logic 4 bit adder model example.\n2. Open the testcase view (Window -\u003e Show View -\u003e Other... -\u003e Sample Category\n-\u003e Sample View).\n3. Click on an element in the logic diagram.\n4. Look at the Eclipse log file for the NPE.",
    "See bug 65985.",
    "Please try to reproduce using the RC2 version of the Platform.",
    "I reproduced the test case from comment #2 using Eclipse 3.0 RC2 and GEF \nI20040619.",
    "Thanks, I will investigate with the testcase.",
    "I don\u0027t see anything we can do here.  At first I was thinking that the tool \nshould be in its TERMINAL state because it was deactivated when focus was \nlost.  But doing that won\u0027t help you because then you will never be able to \ndrag anything with the mouse.\n\nWhat is it you want to happen?  Do you want the hourglass cursor when you \nselect something?  The selection tool unloads any drag tracker when focus lost \noccurs.  The canvas should not lose focus during a mouse drag, if it does, the \ndrag is aborted.\n\nSo we could avoid the NPE, but then you could not drag.",
    "Can you use fork\u003d\u003dTRUE so that the UI is not temporarily disabled?  This will \navoid the focusLost event.  I\u0027m guessing that this is what the Problems/Tasks \nviews do.",
    "We can\u0027t call call run() with the fork\u003d\u003dtrue because the call is made when \ncreating a new editor in AbstractTextEditor.internalInit(), which we can\u0027t \nchange or override.\n\nOur current workaround is to check if the active tool has a drag tracker \n(using reflection to access the private getDragTracker() method) and if it \ndoes then we cache it.  Then, after the runnable has finished, we call \nsetViewer() on the cached drag tracker tool to restore the correct viewer.\n\nWe will keep on using our workaround since a solution at the GEF level doesn\u0027t \nseem reasonable.\n\nThanks for your help in taking a look at this.",
    "Why don\u0027t you build a delay into your selection listener similar to Windows \nExplorer. In other words, invoke a Display.timerExec(opensEditor, 500). If \nselection changes before then, cancel that runnable and start a new one.\n\nThere are lots of cases where you will receive several selection events in \nrapid succession and it makes sense to only react to the last one.",
    "Actually, we will fix this but it isn\u0027t the desired fix you are after, and may \neven break your workaround.",
    "On windows, a native Tree or Table shows selection on mousedown, but *fires* \nnotification on mouse up. But if you drag the mouse the widgets fire selection \nsooner.  So if we emulate this behavior you would still have problems once the \nmouse starts dragging, and it may break clients.\n\nSteve, is there some way we could identify and ignore the spurious focusLost \nevent?  It seems that in this scenario focus is guaranteed to return to the \ncontrol which had it (unless setFocus or dispose occurs?)",
    "Not really, if focus is actually lost, then we can\u0027t (shouldn\u0027t) try to fake \nthat it didn\u0027t or other things might break.  Can you create a simple SWT only \ntest case and log a problem report?  Thanks.",
    "AT:\norg.eclipse.gef.tools.SelectEditPartTracker.handleButtonDown\n(SelectEditPartTracker.java:93)\n\nThe drag tracker has been deactivated at this point, but is still attempting to \ndo more processing of the mouseDown because it is still in STATE_INITIAL.\n\nThe fix is to add setState(STATE_TERMINAL) to AbstractTool#deactivate().  This \nway, any tool which has been deactivated will not continue to do stuff if it \ncorrectly checks its current state.",
    "*** Bug 70607 has been marked as a duplicate of this bug. ***"
  ],
  "commentCreationDates": [
    "2004-06-21T16:45:23+02:00",
    "2004-06-21T17:07:02+02:00",
    "2004-06-21T17:14:04+02:00",
    "2004-06-21T19:13:56+02:00",
    "2004-06-21T19:16:23+02:00",
    "2004-06-21T19:37:18+02:00",
    "2004-06-21T20:55:30+02:00",
    "2004-06-22T19:39:06+02:00",
    "2004-06-22T19:46:35+02:00",
    "2004-06-23T23:44:19+02:00",
    "2004-06-24T00:01:55+02:00",
    "2004-06-24T00:02:34+02:00",
    "2004-08-18T21:26:43+02:00",
    "2004-09-08T00:36:49+02:00",
    "2004-10-13T19:26:42+02:00",
    "2004-10-29T16:39:07+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "java.lang.Throwable.\u003cinit\u003e",
          "source": "Throwable.java"
        },
        {
          "method": "java.lang.Throwable.\u003cinit\u003e",
          "source": "Throwable.java"
        },
        {
          "method": "java.lang.NullPointerException.\u003cinit\u003e",
          "source": "NullPointerException.java:60"
        },
        {
          "method": "org.eclipse.gef.tools.ToolUtilities.getSelectionWithoutDependants",
          "source": "ToolUtilities.java:29"
        },
        {
          "method": "org.eclipse.gef.tools.DragEditPartsTracker.createOperationSet",
          "source": "DragEditPartsTracker.java:150"
        },
        {
          "method": "org.eclipse.gef.tools.AbstractTool.getOperationSet",
          "source": "AbstractTool.java:575"
        },
        {
          "method": "org.eclipse.gef.tools.DragEditPartsTracker.captureSourceDimensions",
          "source": "DragEditPartsTracker.java:108"
        },
        {
          "method": "org.eclipse.gef.tools.DragEditPartsTracker.setState",
          "source": "DragEditPartsTracker.java:516"
        },
        {
          "method": "org.eclipse.gef.tools.AbstractTool.stateTransition",
          "source": "AbstractTool.java:1260"
        },
        {
          "method": "org.eclipse.gef.tools.SelectEditPartTracker.handleButtonDown",
          "source": "SelectEditPartTracker.java:93"
        },
        {
          "method": "org.eclipse.gef.tools.AbstractTool.mouseDown",
          "source": "AbstractTool.java:974"
        },
        {
          "method": "org.eclipse.gef.tools.SelectionTool.mouseDown",
          "source": "SelectionTool.java:481"
        },
        {
          "method": "org.eclipse.gef.EditDomain.mouseDown",
          "source": "EditDomain.java:194"
        },
        {
          "method": "org.eclipse.gef.ui.parts.DomainEventDispatcher.dispatchMousePressed",
          "source": "DomainEventDispatcher.java:314"
        },
        {
          "method": "org.eclipse.draw2d.LightweightSystem$EventHandler.mouseDown",
          "source": "LightweightSystem.java:491"
        },
        {
          "method": "org.eclipse.swt.widgets.TypedListener.handleEvent",
          "source": "TypedListener.java:132"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1353"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1324"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:243"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:141"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:90"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:298"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:249"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:126"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:84"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "NativeMethodAccessorImpl.java:57"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "DelegatingMethodAccessorImpl.java:59"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Method.java:390"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:269"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:722"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:706"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "68003",
      "date": "2004-06-21T16:45:23+02:00",
      "product": "GEF",
      "component": "GEF",
      "severity": "normal"
    }
  ],
  "groupId": "68003",
  "bugId": "68003",
  "date": "2004-06-21T16:45:23+02:00",
  "product": "GEF",
  "component": "GEF",
  "severity": "normal"
}