{
  "comments": [
    "I tried to reduce this to a simple reproducible example but I was unable to do\nso because the same source file would sometimes compile and work correctly and\nsometimes compile incorrectly and I couldn\u0027t determine what conditions caused\nit.  When I tried to simplify my problem code I couldn\u0027t reproduce the problem.\n Hopefully you\u0027ll be able to do something with what I could submit.\n\nFirst, the problem relates to the code generated for an Enum that implements an\ninterface one method having a generic return type and implementing the method in\neach enum value instead of one implementing method for the whole enum class.  In\nthis code, there is a class called \"Shipment\".  It has an field called\nworkflowType whose type is an enum class called WorkflowType.  The enum class\nimplements an interface ValuedEnum\u003cString\u003e.  The interface has a method called\n\"getInternalValue()\" whose return type is the generic type used for the\ninterface, in this case String.  There is a class called\nTestEnumImplementGenerics which instantiates the Shipment class, sets the\nworkflowType to the Buyer enum value, invokes the getInternalValue() method and\nstores the result in a String (forcing the cast from Object).\n\nWhen I first ran the TestEnumImplementGenerics class, I got the following error:\nValue 1\nException in thread \"main\" java.lang.AbstractMethodError:\ncom.aex.repair.ship.data.Shipment$WorkflowType.getInternalValue()Ljava/lang/Object;\n\tat\ncom.aex.repair.ship.data.TestEnumImplementGenerics.main(TestEnumImplementGenerics.java:25)\n\nI went in the Shipment class and added \"public abstract String\ngetInternalValue();\" to the WorkflowType enum.  When I ran the test, the output was:\nValue 1\nBUYER\n\nI then commented out the line I just added.  I still received the same output:\nValue 1\nBUYER\n\nI then cleaned the project (no code changes) - just a recompilation.  Now I get\nthe error again:\nValue 1\nException in thread \"main\" java.lang.AbstractMethodError:\ncom.aex.repair.ship.data.Shipment$WorkflowType.getInternalValue()Ljava/lang/Object;\n\tat\ncom.aex.repair.ship.data.TestEnumImplementGenerics.main(TestEnumImplementGenerics.java:25)\n\n\nThis may also be a problem with the incremental compiler.\n\nI\u0027m took a copy of the java and class files when it worked and when it failed. \nI\u0027ll attach those.  Maybe someone can look at the results and figure out how to\nreproduce it and what\u0027s going wrong.",
    "Created an attachment (id\u003d19521)\nContains the working and failing versions of the java and class files\n\nThis tar/gz file contains a directory called \"generics\".  Inside is a directory\ncalled \"fails\" and one called \"passes\".  The only difference between them is\nthe generated class files for one of the enum types.\n\nbash-2.05b$ diff -r /tmp/generics/fails /tmp/generics/passes\nFiles /tmp/generics/fails/com/aex/repair/ship/data/Shipment$1.class and\n/tmp/generics/passes/com/aex/repair/ship/data/Shipment$1.class differ\nFiles /tmp/generics/fails/com/aex/repair/ship/data/Shipment$2.class and\n/tmp/generics/passes/com/aex/repair/ship/data/Shipment$2.class differ\n",
    "What build are you using?",
    "Sorry.  3.1M6",
    "Ok, I finally have a small test case which illustrates the problem on my\nmachine.  I\u0027m using 3.1M6 on Gentoo Linux.\n\n1.  First you need to create two classes ClassWithBadEnum.java and\nPlaceholder.java in package \"bad\":\n\nClassWithBadEnum.java:\npackage bad;\n\npublic class ClassWithBadEnum {\n\tpublic interface EnumInterface\u003cT extends Object\u003e {\n\t    public T getMethod();\n\t}\n\n\tpublic enum EnumClass implements EnumInterface\u003cString\u003e {\n\t\tENUM1 { public String getMethod() { return \"ENUM1\";} },\n\t\tENUM2 { public String getMethod() { return \"ENUM2\";} };\n\t}\n\tprivate EnumClass enumVar;\n\tpublic EnumClass getEnumVar() {\n\t\treturn enumVar;\n\t}\n\tpublic void setEnumVar(EnumClass enumVar) {\n\t\tthis.enumVar \u003d enumVar;\n\t}\n\n\tpublic static void main(String... argv) {\n\t\tint a \u003d 1;\n\t\tClassWithBadEnum badEnum \u003d new ClassWithBadEnum();\n\t\tbadEnum.setEnumVar(ClassWithBadEnum.EnumClass.ENUM1);\n\t\t// Should fail if bug manifests itself because there will be two\ngetInternalValue() methods\n\t\t// one returning an Object instead of a String\n\t\tSystem.out.println(\"Should fail with a java.lang.AbstractMethodError if the\nbug manifests itself\");\n\t\tString s3 \u003d badEnum.getEnumVar().getMethod();\n\t\tSystem.out.println(\"Didn\u0027t fail\");\n\t\tSystem.out.println(s3);\n\t}\n}\n\nPlaceholder.java:\npackage bad;\n\npublic class Placeholder {\n    public static void main(String... argv) {\n        ClassWithBadEnum badEnum \u003d new ClassWithBadEnum();\n\t\t badEnum.setEnumVar(ClassWithBadEnum.EnumClass.ENUM1);\n\t}\n}\n\n\nEven though the Placeholder class doesn\u0027t do anything, I couldn\u0027t get the bug to\nmanifest itself without having another class referencing the problem class.\n\n2.  Run class ClassWithBadEnum and get the following output:\n\nShould fail with a java.lang.AbstractMethodError if the bug manifests itself\nDidn\u0027t fail\nENUM1\n\n\n3.  Clean project using Project\u003eClean...\n\n4.  Run class ClassWithBadEnum again with the following output:\n\nShould fail with a java.lang.AbstractMethodError if the bug manifests itself\nException in thread \"main\" java.lang.AbstractMethodError:\nbad.ClassWithBadEnum$EnumClass.getMethod()Ljava/lang/Object;\n\tat bad.ClassWithBadEnum.main(ClassWithBadEnum.java:26)\n\n\n5.  Make any change (such as changing the value of variable \"a\" from 1 to 2 in\nClassWithBadEnum).\n\n6.  Run class ClassWithBadEnum and get the following output:\n\nShould fail with a java.lang.AbstractMethodError if the bug manifests itself\nDidn\u0027t fail\nENUM1\n",
    "I\u0027m getting the same error running Eclipse 3.1M6 on Windows XP Pro testing the\ncase described by Jim: the bytecode generated by cleaning the project fails\nwhereas the incrementally generated class file does not.",
    "Reproduced",
    "Problem is that in clean build scenario, first enum constant ENUM1 generated\nclass: ClassWithBadEnum$1 is missing definition for method: #getMethod(); hence\nthe AbstractMethodError.\n\n",
    "Actually problem is that an offending extra bridge method got inserted on class\nfor ENUM1.",
    "GOOD \n\n  // Method descriptor #18 ()Ljava/lang/String;\n  // Stack: 1, Locals: 1\n  public String getMethod();\n    0  ldc \u003cString \"ENUM1\"\u003e [20]\n    2  areturn\n      Line numbers:\n        [pc: 0, line: 9]\n      Local variable table:\n        [pc: 0, pc: 3] local: this index: 0 type: Lp/ClassWithBadEnum$1;\n\nBAD  \n  // Method descriptor #21 ()Ljava/lang/Object;\n  // Stack: 1, Locals: 1\n  public bridge synthetic Object getMethod();\n    0  aload_0 [local_0]\n    1  invokevirtual p/ClassWithBadEnum$1.getMethod()Ljava/lang/String; [23]\n    4  areturn\n      Line numbers:\n        [pc: 0, line: 1]",
    "Ignore comments from comment#7 to comment#9.\n\nProblem is that somehow the bridge methods did not get generated in clean build\nsituation, but fine incrementally. Also trying to recreate the problem in batch\nmode did not reproduce it either.\n",
    "Issue seems located in method verifier.\nPut a breakpoint in MethodVerifier#checkMethods()\n\nWhen recreating (in runtime workbench, clean build), first hit of the breakpoint\nis during remote resolution of ENUM1 field (when accessed from Placeholder).\n\nvoid checkMethods() {\n\tboolean mustImplementAbstractMethods \u003d mustImplementAbstractMethods();\n\tboolean skipInheritedMethods \u003d mustImplementAbstractMethods \u0026\u0026\ncanSkipInheritedMethods(); // have a single concrete superclass so only check\noverridden methods\n\nmustImplementAbstractMethods \u003d\u003d false\nskipInheritedMethods \u003d\u003d false\n\nThen later on, we hit the breakpoint again when processing the same local type;\nhowever this time around\n\nmustImplementAbstractMethods \u003d\u003d false\nskipInheritedMethods \u003d\u003d true !?!?\n\nQ1. why do we verify it twice ?\nQ2. why different setup then ?\n",
    "Before debugging, close all editors in runtime workspace to avoid confusion.\nActual data is then:\n\n- hit on #checkMethods() for ENUM1 occurs through Placeholder forward ref.\nThen:\nmustImplementAbstractMethods \u003d\u003d true\nskipInheritedMethods \u003d\u003d true\n\nThen later on, we hit the breakpoint again when processing ENUM2 in context of\nits declaring class (no reprocessing of ENUM1). However then:\n\nmustImplementAbstractMethods \u003d\u003d true\nskipInheritedMethods \u003d\u003d false  ?!?\n\nThis is the scenario in which then ENUM2 gets a bridge method, whereas ENUM1 did\nnot get any.\n\nSuspecting it has to do with abstractness of superclass EnumClass",
    "Indeed, in between the 2 hits, we enter the following code which toggles\nabstractness of enum superclass.\n\nboolean mustImplementAbstractMethod(ReferenceBinding declaringClass) {\n\tif (!this.type.isEnum())\n\t\treturn super.mustImplementAbstractMethod(declaringClass);\n\tif (this.type.isAnonymousType())\n\t\treturn true; // body of enum constant must implement any inherited abstract\nmethods\n\tif (this.type.isAbstract())\n\t\treturn false; // is an enum that has since been tagged as abstract by the code\nbelow\n\n\t// enum type needs to implement abstract methods if one of its constants does\nnot supply a body\n\tTypeDeclaration typeDeclaration \u003d this.type.scope.referenceContext;\n\tFieldDeclaration[] fields \u003d typeDeclaration.fields;\n\tint length \u003d typeDeclaration.fields \u003d\u003d null ? 0 : typeDeclaration.fields.length;\n\tif (length \u003d\u003d 0) return true; // has no constants so must implement the method\nitself\n\tfor (int i \u003d 0; i \u003c length; i++) {\n\t\tFieldDeclaration fieldDecl \u003d fields[i];\n\t\tif (fieldDecl.getKind() \u003d\u003d AbstractVariableDeclaration.ENUM_CONSTANT)\n\t\t\tif (!(fieldDecl.initialization instanceof QualifiedAllocationExpression))\n\t\t\t\treturn true;\n\t}\n\n\t// tag this enum as abstract since an abstract method must be implemented AND\nall enum constants define an anonymous body\n\t// as a result, each of its anonymous constants will see it as abstract and\nmust implement each inherited abstract method\n\tthis.type.modifiers |\u003d IConstants.AccAbstract;\n\treturn false;\n}",
    "I have a fix. I moved the abstract bit setting to\nClassScope#checkAndSetModifiers, where it should have lived initially.\n\nSuspect a proper testcase needs to written as a builder test, since\nClassWithBadEnum needs to be requested as source, and not initially on the\ncommand line as when using batch test.",
    "Added EnumTest#test104. Important point is to have a forward reference from\nPlaceholder to ENUM1.\n\nFixed",
    "Verified in i20050527-0010"
  ],
  "commentCreationDates": [
    "2005-04-04T21:30:41+02:00",
    "2005-04-04T21:33:13+02:00",
    "2005-04-04T23:06:26+02:00",
    "2005-04-04T23:29:58+02:00",
    "2005-04-21T16:46:02+02:00",
    "2005-05-05T19:58:54+02:00",
    "2005-05-17T22:52:12+02:00",
    "2005-05-17T23:21:51+02:00",
    "2005-05-17T23:56:26+02:00",
    "2005-05-17T23:57:05+02:00",
    "2005-05-18T00:21:58+02:00",
    "2005-05-18T01:03:33+02:00",
    "2005-05-18T01:17:49+02:00",
    "2005-05-18T01:25:43+02:00",
    "2005-05-18T01:45:52+02:00",
    "2005-05-18T11:13:30+02:00",
    "2005-05-27T16:26:37+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.AbstractMethodError",
      "message": "com.aex.repair.ship.data.Shipment$WorkflowType.getInternalValue()Ljava/lang/Object;",
      "elements": [
        {
          "method": "com.aex.repair.ship.data.TestEnumImplementGenerics.main",
          "source": "TestEnumImplementGenerics.java:25"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "90215",
      "date": "2005-04-04T21:30:41+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.AbstractMethodError",
      "message": "com.aex.repair.ship.data.Shipment$WorkflowType.getInternalValue()Ljava/lang/Object;",
      "elements": [
        {
          "method": "com.aex.repair.ship.data.TestEnumImplementGenerics.main",
          "source": "TestEnumImplementGenerics.java:25"
        }
      ],
      "number": 1,
      "commentIndex": 0,
      "bugId": "90215",
      "date": "2005-04-04T21:30:41+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.AbstractMethodError",
      "message": "bad.ClassWithBadEnum$EnumClass.getMethod()Ljava/lang/Object;",
      "elements": [
        {
          "method": "bad.ClassWithBadEnum.main",
          "source": "ClassWithBadEnum.java:26"
        }
      ],
      "number": 2,
      "commentIndex": 4,
      "bugId": "90215",
      "date": "2005-04-21T16:46:02+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "90215",
  "bugId": "90215",
  "date": "2005-04-04T21:30:41+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}