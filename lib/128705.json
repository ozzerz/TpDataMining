{
  "comments": [
    "The attached .java file and .class output file (from Sun\u0027s javac for version 5) is a file that will not compile on the Eclipse compiler with the -1.5 flag set or the -inlineJSR flag set.  The _jspService method inlines to around 130K bytes of code.  This file - the Java source is programmatically generated - is from a PMR from Oracle (PMR successfully dealt with).\n\n1) Sun in their 1.5 compiler will generate jsr bytecodes (complete with the 1.5 version tag) if they fail to inline the jsr\u0027s.\n\n2) This file will not copmile under the Sun Java6 javac early access compiler.\n\nThe problem is that the finally clause of just under 500 bytes is inlined about 270 times.  The format of the file is that there are multiple return points scattered throughout the source code and each of these becomes an inline point.\n\nIs it possible for the compiler to generate code that goto\u0027s a common jsr followed by return point reducing the number of inline locations.  I suspect this pattern may show up elsewhere with other customers and it appears that Sun currently can\u0027t handle it for Java6, so it would be an advantage for us to be able to compile the class without jsr\u0027s.\n\nI will attach enough files (inlinetest.zip) to compile the class with the following command line:\n\nD:\\test2\u003ejavac -cp ascontrol.jar;oc4j-internal.jar;ojsp.jar;servlet.jar;uix2.jar _topology.java",
    "There were errors when trying to attach the sample code - A .zip of the source file and supporting libraries for compilation have been forwarded to Olivier Thomann.",
    "Actually, using regular branch to subroutine (and back, using some tableswitch to map back to proper location) is not doable due to some classfile limitations.\n\ne.g. for code:\npublic class X {\n\tpublic static void main(String[] args) {\n\t\tnew X().foo(args);\n\t}\n\tint foo(String[] args){\n\t\ttry {\n\t\t\tif (args \u003d\u003d null) return 0;\n\t\t\tif (args.length \u003d\u003d 0) return args.length;\n\t\t} finally {\n\t\t\tSystem.out.print(\"finally\");\n\t\t}\n\t\tSystem.out.println();\n\t\treturn 2;\n\t}\n}\n\nI could generate:\n  // Method descriptor #20 ([Ljava/lang/String;)I\n  // Stack: 3, Locals: 5\n  int foo(String[] args);\n     0  aload_1 [args]\n     1  ifnonnull 11\n     4  iconst_0\n     5  istore_2\n     6  goto 39\n     9  iconst_0\n    10  ireturn\n    11  aload_1 [args]\n    12  arraylength\n    13  ifne 80\n    16  aload_1 [args]\n    17  arraylength\n    18  istore 4\n    20  iconst_1\n    21  istore_2\n    22  goto 39\n    25  iload 4\n    27  ireturn\n    28  goto 80\n    31  astore_3\n    32  iconst_2\n    33  istore_2\n    34  goto 39\n    37  aload_3\n    38  athrow\n    39  getstatic System.out : PrintStream [23]\n    42  ldc \u003cString \"finally\"\u003e [29]\n    44  invokevirtual PrintStream.print(String) : void [31]\n    47  iload_2\n    48  tableswitch default: 85\n          case 0: 9\n          case 1: 25\n          case 2: 37\n          case 3: 85\n    80  iconst_4\n    81  istore_2\n    82  goto 39\n    85  getstatic System.out : PrintStream [23]\n    88  invokevirtual PrintStream.println() : void [37]\n    91  iconst_2\n    92  ireturn\n      Exception Table:\n        [pc: 0, pc: 9] -\u003e 31 when : any\n        [pc: 11, pc: 25] -\u003e 31 when : any\n        [pc: 28, pc: 31] -\u003e 31 when : any\n        [pc: 80, pc: 85] -\u003e 31 when : any\n      Line numbers:\n        [pc: 0, line: 7]\n        [pc: 11, line: 8]\n        [pc: 31, line: 9]\n        [pc: 37, line: 11]\n        [pc: 39, line: 10]\n        [pc: 47, line: 11]\n        [pc: 85, line: 12]\n        [pc: 91, line: 13]\n      Local variable table:\n        [pc: 0, pc: 93] local: this index: 0 type: X\n        [pc: 0, pc: 93] local: args index: 1 type: String[]\n\n\nBut this is illegal from verifier standpoint:\njava.lang.VerifyError: (class: X, method: foo signature: ([Ljava/lang/String;)I) Accessing value from uninitialized register 4\n\tat java.lang.Class.forName0(Native Method)\n\tat java.lang.Class.forName(Class.java:164)\n\tat Compile.main(Compile.java:108)",
    "We can hack to issue JSR bytecodes as a fallback plan, but in Java7 these are forbidden. So this would only be a temporary workaround.",
    "Philippe - I understand that some inlining situations would lead to inline bloat always.  The sample I sent has multiple \"return\" places leading to excessive inlining.  My suggestion is, in the presence of multiple returns, to replace the returns with goto\u0027s to a single return point and inline there.  The line number table for the return source code lines would be the goto bytecodes, not the return bytecode.  This is a solution to a limited subset of the inlining problems.",
    "Also it wouldn\u0027t work in situation where some non-constant value is returned.\nSo it would only improve situation for return instruction in void methods or return constant.\n\nIn other circumstances, it would break bytecode verification, as the returned value must be cached in a variable which is treated as unitialized from bytecode verifier standpoint.",
    "Different approach, which could benefit this usecase. Simply branch into similar subroutine sequences (either inlining finally or not).\n\ne.g.\npublic class X {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(new X().foo(args));\n\t}\n\tString foo(String[] args) {\n\t\ttry {\n\t\t\tif (args \u003d\u003d null) return \"KO\";\n\t\t\tswitch(args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn \"OK\";\n\t\t\tcase 1:\n\t\t\t\treturn \"KO\";\n\t\t\tcase 3:\n\t\t\t\treturn \"OK\";\n\t\t\tdefault:\n\t\t\t\treturn \"KO\";\n\t\t\t}\n\t\t} finally {\n\t\t\tSystem.out.print(\"FINALLY:\");\n\t\t}\n\t}\n}\n\n  // Method descriptor #26 ([Ljava/lang/String;)Ljava/lang/String;\n  // Stack: 2, Locals: 3\n  String foo(String[] args);\n     0  aload_1 [args]\n     1  ifnonnull 15\n     4  getstatic System.out : PrintStream [16]\n     7  ldc \u003cString \"FINALLY:\"\u003e [35]\n     9  invokevirtual PrintStream.print(String) : void [37]\n    12  ldc \u003cString \"KO\"\u003e [40]\n    14  areturn\n    15  aload_1 [args]\n    16  arraylength\n    17  tableswitch default: 65\n          case 0: 48\n          case 1: 59\n          case 2: 65\n          case 3: 62\n    48  getstatic System.out : PrintStream [16]\n    51  ldc \u003cString \"FINALLY:\"\u003e [35]\n    53  invokevirtual PrintStream.print(String) : void [37]\n    56  ldc \u003cString \"OK\"\u003e [42]\n    58  areturn\n    59  goto 4\n    62  goto 48\n    65  goto 4\n    68  astore_2\n    69  getstatic System.out : PrintStream [16]\n    72  ldc \u003cString \"FINALLY:\"\u003e [35]\n    74  invokevirtual PrintStream.print(String) : void [37]\n    77  aload_2\n    78  athrow\n      Exception Table:\n        [pc: 0, pc: 4] -\u003e 68 when : any\n        [pc: 15, pc: 48] -\u003e 68 when : any\n        [pc: 59, pc: 68] -\u003e 68 when : any\n\n\nReuse occurs as soon as the sequence is the strictly the same:\n- same break/continue target label\n- return from void method\n- same constant being returned\n\nOther situations are not optimizable, since the returned value needs to be cached before finally runs, and thus each sequence may denote a different cached value.",
    "WITHOUT optimization, the last test case would produce:\n\n  // Method descriptor #26 ([Ljava/lang/String;)Ljava/lang/String;\n  // Stack: 2, Locals: 3\n  String foo(String[] args);\n      0  aload_1 [args]\n      1  ifnonnull 15\n      4  getstatic System.out : PrintStream [16]\n      7  ldc \u003cString \"FINALLY:\"\u003e [35]\n      9  invokevirtual PrintStream.print(String) : void [37]\n     12  ldc \u003cString \"KO\"\u003e [40]\n     14  areturn\n     15  aload_1 [args]\n     16  arraylength\n     17  tableswitch default: 81\n          case 0: 48\n          case 1: 59\n          case 2: 81\n          case 3: 70\n     48  getstatic System.out : PrintStream [16]\n     51  ldc \u003cString \"FINALLY:\"\u003e [35]\n     53  invokevirtual PrintStream.print(String) : void [37]\n     56  ldc \u003cString \"OK\"\u003e [42]\n     58  areturn\n     59  getstatic System.out : PrintStream [16]\n     62  ldc \u003cString \"FINALLY:\"\u003e [35]\n     64  invokevirtual PrintStream.print(String) : void [37]\n     67  ldc \u003cString \"KO\"\u003e [40]\n     69  areturn\n     70  getstatic System.out : PrintStream [16]\n     73  ldc \u003cString \"FINALLY:\"\u003e [35]\n     75  invokevirtual PrintStream.print(String) : void [37]\n     78  ldc \u003cString \"OK\"\u003e [42]\n     80  areturn\n     81  getstatic System.out : PrintStream [16]\n     84  ldc \u003cString \"FINALLY:\"\u003e [35]\n     86  invokevirtual PrintStream.print(String) : void [37]\n     89  ldc \u003cString \"KO\"\u003e [40]\n     91  areturn\n     92  astore_2\n     93  getstatic System.out : PrintStream [16]\n     96  ldc \u003cString \"FINALLY:\"\u003e [35]\n     98  invokevirtual PrintStream.print(String) : void [37]\n    101  aload_2\n    102  athrow\n      Exception Table:\n        [pc: 0, pc: 4] -\u003e 92 when : any\n        [pc: 15, pc: 48] -\u003e 92 when : any",
    "In presence of multiple scopes with different local variables, the optimization is causing grief.\ne.g. \npublic class X {\n\tpublic void save() {\n\t\tint a \u003d 3;\n\t\ttry {\n\t\t\tObject warnings \u003d null;\n\t\t\ttry {\n\t\t\t\tObject contexts \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tSystem.out.println(warnings);\n\t\t\t\t\treturn;\n\t\t\t\t} catch (NullPointerException npe) {\n\t\t\t\t\tSystem.out.println(contexts);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tint dummy1 \u003d 11;\n\t\t\tSystem.out.println(dummy1);\n\t\t\tint dummy2 \u003d 12;\n\t\t\tSystem.out.println(dummy2);\n\t\t\treturn;\n\t\t} finally {\n\t\t\tint b \u003d 4;\n\t\t\tSystem.out.println(\"#save -\u003e \" + b + a);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew X().save();\n\t}\n}\n\nproduces\n\n  // Method descriptor #6 ()V\n  // Stack: 4, Locals: 7\n  public void save();\n      0  iconst_3\n      1  istore_1 [a]\n      2  aconst_null\n      3  astore_2 [warnings]\n      4  aconst_null\n      5  astore_3 [contexts]\n      6  getstatic System.out : PrintStream [15]\n      9  aload_2 [warnings]\n     10  invokevirtual PrintStream.println(Object) : void [21]\n\nSUBROUTINE\n     13  iconst_4\n     14  istore 6 [b]\n     16  getstatic System.out : PrintStream [15]\n     19  new StringBuilder [27]\n     22  dup\n     23  ldc \u003cString \"#save -\u003e \"\u003e [29]\n     25  invokespecial StringBuilder(String) [31]\n     28  iload 6 [b]\n     30  invokevirtual StringBuilder.append(int) : StringBuilder [34]\n     33  iload_1 [a]\n     34  invokevirtual StringBuilder.append(int) : StringBuilder [34]\n     37  invokevirtual StringBuilder.toString() : String [38]\n     40  invokevirtual PrintStream.println(String) : void [42]\n     43  return\n\nCATCH NULL POINTER EXCEPTION\n     44  astore 4 [npe]\n     46  getstatic System.out : PrintStream [15]\n     49  aload_3 [contexts]\n     50  invokevirtual PrintStream.println(Object) : void [21]\n     53  goto 13\n\nCATCH EXCEPTION\n     56  astore_3 [e]\n     57  goto 13\n\nCATCH EXCEPTION\n     60  astore_2 [e]\n     61  bipush 11\n     63  istore_3 [dummy1]\n     64  getstatic System.out : PrintStream [15]\n     67  iload_3 [dummy1]\n     68  invokevirtual PrintStream.println(int) : void [44]\n     71  bipush 12\n     73  istore 4 [dummy2]\n     75  getstatic System.out : PrintStream [15]\n     78  iload 4 [dummy2]\n     80  invokevirtual PrintStream.println(int) : void [44]\n     83  goto 13\n\nCATCH ANY\n     86  astore 5\n     88  iconst_4\n     89  istore 6 [b]\n     91  getstatic System.out : PrintStream [15]\n     94  new StringBuilder [27]\n     97  dup\n     98  ldc \u003cString \"#save -\u003e \"\u003e [29]\n    100  invokespecial StringBuilder(String) [31]\n    103  iload 6 [b]\n    105  invokevirtual StringBuilder.append(int) : StringBuilder [34]\n    108  iload_1 [a]\n    109  invokevirtual StringBuilder.append(int) : StringBuilder [34]\n    112  invokevirtual StringBuilder.toString() : String [38]\n    115  invokevirtual PrintStream.println(String) : void [42]\n    118  aload 5\n    120  athrow\n      Exception Table:\n        [pc: 6, pc: 44] -\u003e 44 when : java.lang.NullPointerException\n        [pc: 4, pc: 56] -\u003e 56 when : java.lang.Exception\n        [pc: 2, pc: 13] -\u003e 60 when : java.lang.Exception\n        [pc: 43, pc: 60] -\u003e 60 when : java.lang.Exception\n        [pc: 2, pc: 13] -\u003e 86 when : any\n        [pc: 44, pc: 86] -\u003e 86 when : any\n      Line numbers:\n        [pc: 0, line: 3]\n        [pc: 2, line: 5]\n        [pc: 4, line: 7]\n        [pc: 6, line: 9]\n        [pc: 13, line: 25]\n        [pc: 16, line: 26]\n        [pc: 43, line: 10]\n        [pc: 44, line: 11]\n        [pc: 46, line: 12]\n        [pc: 53, line: 13]\n        [pc: 56, line: 15]\n        [pc: 57, line: 16]\n        [pc: 60, line: 18]\n        [pc: 61, line: 19]\n        [pc: 64, line: 20]\n        [pc: 71, line: 21]\n        [pc: 75, line: 22]\n        [pc: 83, line: 23]\n        [pc: 86, line: 24]\n        [pc: 88, line: 25]\n        [pc: 91, line: 26]\n        [pc: 118, line: 27]\n\nand verifyError:\njava.lang.VerifyError: (class: X, method: save signature: ()V) Register 3 contains wrong type\n\tat java.lang.Class.forName0(Native Method)\n\tat java.lang.Class.forName(Class.java:164)\n\tat Compile.main(Compile.java:108)",
    "The problem is that when entering subroutine (pc:13), register 3 may contain various local variable contents, which are not tolerated by bytecode verifier (even though the register is not used within the shared block).",
    "Problem solved. Issues where related to miscomputed exception handler ranges.\nOptimization is also performed for \"return null\" (not a constant).\n\nAnd optimization is performing independantly from inlineJSR mode, so it can slightly reduce code size in presence of JSR patterns:\n\n10 jsr \u003cfinally\u003e\n   areturn\n...\n   jsr \u003cfinally\u003e\n   areturn\n\nbecomes:\n\n10 jsr \u003cfinally\u003e\n   areturn\n...\n   goto 10\n\nAdded GenericTypeTest#test040-043.\nAlso tuned existing tests which got affected by reuse and exception handler changes.",
    "Verified for 3.2 M6 using build I20060328-0010"
  ],
  "commentCreationDates": [
    "2006-02-20T19:02:12+01:00",
    "2006-02-20T21:57:33+01:00",
    "2006-02-22T20:19:18+01:00",
    "2006-02-22T23:57:22+01:00",
    "2006-02-23T02:37:37+01:00",
    "2006-02-23T10:57:15+01:00",
    "2006-02-23T18:13:31+01:00",
    "2006-02-23T18:16:19+01:00",
    "2006-02-23T20:28:16+01:00",
    "2006-02-23T20:29:39+01:00",
    "2006-02-25T22:20:04+01:00",
    "2006-03-28T10:27:11+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.VerifyError",
      "message": "(class: X, method: foo signature: ([Ljava/lang/String;)I) Accessing value from uninitialized register 4",
      "elements": [
        {
          "method": "java.lang.Class.forName0",
          "source": "Native Method"
        },
        {
          "method": "java.lang.Class.forName",
          "source": "Class.java:164"
        },
        {
          "method": "Compile.main",
          "source": "Compile.java:108"
        }
      ],
      "number": 0,
      "commentIndex": 2,
      "bugId": "128705",
      "date": "2006-02-22T20:19:18+01:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    },
    {
      "exceptionType": "java.lang.VerifyError",
      "message": "(class: X, method: save signature: ()V) Register 3 contains wrong type",
      "elements": [
        {
          "method": "java.lang.Class.forName0",
          "source": "Native Method"
        },
        {
          "method": "java.lang.Class.forName",
          "source": "Class.java:164"
        },
        {
          "method": "Compile.main",
          "source": "Compile.java:108"
        }
      ],
      "number": 1,
      "commentIndex": 8,
      "bugId": "128705",
      "date": "2006-02-23T20:28:16+01:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "128705",
  "bugId": "128705",
  "date": "2006-02-20T19:02:12+01:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}