{
  "comments": [
    "This was seen at startup (I think you need to sync the findRuntimeClasspathProvider() methods in addition to the load methods):\n\njava.util.ConcurrentModificationException\n\nat java.util.AbstractList$Itr.checkForComodification(AbstractList.java:449)\n\nat java.util.AbstractList$Itr.next(AbstractList.java:420)\n\nat org.eclipse.jst.server.core.internal.JavaServerPlugin.findRuntimeClasspathProvider(JavaServerPlugin.java:250)\n\nat org.eclipse.jst.server.core.internal.RuntimeClasspathContainerInitializer.initialize(RuntimeClasspathContainerInitializer.java:31)\n\nat org.eclipse.jdt.internal.core.JavaModelManager.initializeContainer(JavaModelManager.java:1754)\n\nat org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1199)\n\nat org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:1372)\n\nat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:2046)\n\nat org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1954)\n...",
    "Maybe I\u0027m missing something, but the find methods should not need to be synchronized. Within the find method, the load has already been called at this point. The load method itself is synchronized and non-reentrant, so once the list has been created there should be no modifications to it...\n\nCould you take a trace with org.eclipse.jst.server.core? I\u0027ve never seen any indication of the load method running twice.",
    "I didn\u0027t actually hit this myself and it\u0027s only occurred once that I know of; I had assumed that one thread was executing a load* method while another thread was inside a find* method - I need to look at the JavaServerPlugin code more closely...",
    "I think you need to synchronize the body of code that loops over the  contents of runtimeClasspathProviders.  Seems like the variable can be non null, thus passing the \"if (runtimeClasspathProviders \u003d\u003d null)\" check, but still be in the middle of being populated.  It gets iterated over while being populated, and you get the exception.\n\nAn even better approach might be to initialize the value of runtimeClasspathProviders only after creating a populated list.  If this route is taken, I believe you\u0027d also have to declare the variable as volatile or simply not do the if-null check and always call loadRuntimeClasspathProviders.  Otherwise you\u0027d be doing the equivalent of double-checked locking, which is known not to work in java (see http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html).\n\nHope that helps!",
    "Would be good to get this into 1.0.2.  I\u0027ve seen this a few times, and if I remember right, my session was totally hosed and I had to restart eclipse to things working again.",
    "Wow - this turned out to be a really good catch. It turns out that the extension point loading code used in wst \u0026 jst server tools and the TCP/IP monitor was all flawed in the same way.\n\nI\u0027ve made the changes throughout and released to 1.5 (sorry we didn\u0027t get this in for 1.0.2). As suggested I changed the code to use a temporary list/map and set the variable when finished. I beleive we should be safe from double-checked locking because all of the getX() methods check for null before calling loadX() - if we hit the double-checked case the variable would be null and it will call the load method, hit the synchronized block (which updates the variable), and immediately return.",
    "Thanks for the fix!  I\u0027m not sure you\u0027re safe from the double checked locking case though.  I believe the problem is that the variable can be seen by the calling thread as non null, yet the value it points to can be in a partially initialized state.  I kindly suggest reading the page for which I provided a link in my earlier comment and seeing if it doesn\u0027t convince you :).",
    "Already did (thanks, it was interesting reading :) ), and I beleive it\u0027s ok in this case. Since we\u0027re creating the list and then swapping the reference I don\u0027t beleive it\u0027s possible for the reference to be updated in the other thread but the list to still be uninitialized. Either way, your verification once you move up to a build with this fix will be the real test.",
    "Closing old bugs."
  ],
  "commentCreationDates": [
    "2006-04-05T20:00:05+02:00",
    "2006-04-05T20:36:34+02:00",
    "2006-04-05T20:59:34+02:00",
    "2006-04-07T02:37:58+02:00",
    "2006-04-08T03:16:18+02:00",
    "2006-04-24T00:49:33+02:00",
    "2006-04-24T18:11:47+02:00",
    "2006-04-24T18:58:42+02:00",
    "2006-11-21T19:35:15+01:00"
  ],
  "traces": [
    {
      "exceptionType": "java.util.ConcurrentModificationException",
      "elements": [
        {
          "method": "java.util.AbstractList$Itr.checkForComodification",
          "source": "AbstractList.java:449"
        },
        {
          "method": "java.util.AbstractList$Itr.next",
          "source": "AbstractList.java:420"
        },
        {
          "method": "org.eclipse.jst.server.core.internal.JavaServerPlugin.findRuntimeClasspathProvider",
          "source": "JavaServerPlugin.java:250"
        },
        {
          "method": "org.eclipse.jst.server.core.internal.RuntimeClasspathContainerInitializer.initialize",
          "source": "RuntimeClasspathContainerInitializer.java:31"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelManager.initializeContainer",
          "source": "JavaModelManager.java:1754"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer",
          "source": "JavaModelManager.java:1199"
        },
        {
          "method": "org.eclipse.jdt.core.JavaCore.getClasspathContainer",
          "source": "JavaCore.java:1372"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:2046"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath",
          "source": "JavaProject.java:1954"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "135092",
      "date": "2006-04-05T20:00:05+02:00",
      "product": "Web Tools",
      "component": "jst.server",
      "severity": "normal"
    }
  ],
  "groupId": "135092",
  "bugId": "135092",
  "date": "2006-04-05T20:00:05+02:00",
  "product": "Web Tools",
  "component": "jst.server",
  "severity": "normal"
}