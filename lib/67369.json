{
  "comments": [
    "This occurs intermittently on Eclipse 3.0 RC2.\n\nIn the Java text editor, cut and copy sometimes don\u0027t work and at other times\nlock up the Eclipse GUI (need to kill Eclipse to continue).\n\nI have tested several scenarios and have seen the problem about half a dozen\ntimes (I only started using RC2 today) but I have been unable to figure out how\nto reliably reproduce the problem. (It may have something to do with the import\nblock but I cannot be certain.)\n\nSorry to be so vague.",
    "is there anything in .log?\n",
    "Are you sure the UI is locked up and not \"just\" the key board no longer working \ni.e. might it be the same problem as described in bug 67231?\n\nCan you try again and when you see the lock up go to the console and produce a\nstack dump using kill -QUIT or kill -3.",
    "Yes, it is a true \u0027lock-up\u0027 (GUI not redrawn when another window is dragged \nover it).\n\nThe good news is that a stack-trace gets logged. I ought to have looked for \nthis yesterday: sorry and thanks for the prompt to do so :-)\n\nSo, looking back through the log, the following happens every time but this is \na fresh one (it took a matter of seconds this morning to generate it!):\n\n!SESSION Jun 16, 2004 01:50:32.774 ---------------------------------------------\neclipse.buildId\u003dI200406111814\njava.version\u003d1.4.2_02\njava.vendor\u003dSun Microsystems Inc.\nBootLoader constants: OS\u003dlinux, ARCH\u003dx86, WS\u003dgtk, NL\u003den_US\n\n!ENTRY org.eclipse.ui 4 4 Jun 16, 2004 01:50:32.774\n!MESSAGE Unhandled event loop exception\n\n!ENTRY org.eclipse.ui 4 0 Jun 16, 2004 01:50:32.776\n!MESSAGE java.lang.NoClassDefFoundError\n!STACK 0\njava.lang.NoClassDefFoundError\n\tat org.eclipse.jdt.core.dom.AST.newMethodDeclaration(AST.java:1503)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:697)\n\tat org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations\n(ASTConverter.java:336)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:274)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:152)\n\tat org.eclipse.jdt.core.dom.ASTParser.convert(ASTParser.java:711)\n\tat org.eclipse.jdt.core.dom.ASTParser.internalCreateAST\n(ASTParser.java:681)\n\tat org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:574)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST\n(ASTProvider.java:439)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST\n(ASTProvider.java:391)\n\tat \norg.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData\n(ClipboardOperationAction.java:363)\n\tat \norg.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImp\nortsOperation(ClipboardOperationAction.java:300)\n\tat \norg.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperat\nion(ClipboardOperationAction.java:256)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run\n(ClipboardOperationAction.java:225)\n\tat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run\n(ClipboardOperationAction.java:223)\n\tat org.eclipse.jface.action.Action.runWithEvent(Action.java:881)\n\tat org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection\n(ActionContributionItem.java:915)\n\tat org.eclipse.jface.action.ActionContributionItem.access$2\n(ActionContributionItem.java:866)\n\tat org.eclipse.jface.action.ActionContributionItem$7.handleEvent\n(ActionContributionItem.java:785)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:950)\n\tat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2512)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2223)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1362)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1333)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench\n(Workbench.java:252)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:141)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run\n(IDEApplication.java:96)\n\tat org.eclipse.core.internal.runtime.PlatformActivator$1.run\n(PlatformActivator.java:334)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run\n(EclipseStarter.java:272)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run\n(EclipseStarter.java:128)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:185)\n\tat org.eclipse.core.launcher.Main.run(Main.java:638)\n\tat org.eclipse.core.launcher.Main.main(Main.java:622)\n\n",
    "If it is a deadlock we need the stack dump. The log only contains stack traces\nfor errors.\n\nMoving to JCore to comment on the exception",
    "On what looks like a related symptom, I usually get the following on startup:\n\n\njava.lang.ExceptionInInitializerError\n        at java.lang.Class.forName0(Native Method)\n        at java.lang.Class.forName(Unknown Source)\n        at org.eclipse.jdt.core.dom.TryStatement.\u003cclinit\u003e(TryStatement.java:42)\n        at org.eclipse.jdt.core.dom.AST.newTryStatement(AST.java:1960)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2114)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1855)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1910)\n        at \norg.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration\n(ASTConverter.java:353)\n        at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations\n(ASTConverter.java:330)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:274)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:152)\n        at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:253)\n        at \norg.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation\n(ReconcileWorkingCopyOperation.java:81)\n        at org.eclipse.jdt.internal.core.JavaModelOperation.run\n(JavaModelOperation.java:700)\n        at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation\n(JavaModelOperation.java:739)\n        at org.eclipse.jdt.internal.core.CompilationUnit.reconcile\n(CompilationUnit.java:1098)\n        at \norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile\n(JavaReconcilingStrategy.java:88)\n        at \norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile\n(JavaReconcilingStrategy.java:156)\n        at \norg.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile\n(CompositeReconcilingStrategy.java:114)\n        at \norg.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconci\nle(JavaCompositeReconcilingStrategy.java:122)\n        at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess\n(MonoReconciler.java:104)\n        at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess\n(JavaReconciler.java:304)\n        at \norg.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run\n(AbstractReconciler.java:169)\nCaused by: java.lang.RuntimeException: Structural property descriptor has wrong \nnode class!\n        at org.eclipse.jdt.core.dom.ASTNode.addProperty(ASTNode.java:1731)\n        at org.eclipse.jdt.core.dom.CatchClause.\u003cclinit\u003e(CatchClause.java:51)\n        ... 23 more\njava.lang.NoClassDefFoundError\n        at org.eclipse.jdt.core.dom.AST.newTryStatement(AST.java:1960)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2114)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1855)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:770)\n        at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations\n(ASTConverter.java:336)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:274)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:152)\n        at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:253)\n        at \norg.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation\n(ReconcileWorkingCopyOperation.java:81)\n        at org.eclipse.jdt.internal.core.JavaModelOperation.run\n(JavaModelOperation.java:700)\n        at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation\n(JavaModelOperation.java:739)\n        at org.eclipse.jdt.internal.core.CompilationUnit.reconcile\n(CompilationUnit.java:1098)\n        at \norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile\n(JavaReconcilingStrategy.java:88)\n        at \norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile\n(JavaReconcilingStrategy.java:156)\n        at \norg.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile\n(CompositeReconcilingStrategy.java:114)\n        at \norg.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconci\nle(JavaCompositeReconcilingStrategy.java:122)\n        at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess\n(MonoReconciler.java:104)\n        at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess\n(JavaReconciler.java:304)\n        at \norg.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run\n(AbstractReconciler.java:169)\n\n\n\n",
    "Looks like VM or classloader issues. \n\nThere are classes not found, or exception during invocation of \u003cclinit\u003e which \nshouldn\u0027t occur at all.\n\nMoving to platform as may be classloader related.",
    "If a deadlock on classload was happening then it would have been broken by the \ntimeout mechanism we have and a message would be in the log.\n\nNoClassDefFoundErrors are however strange. Are you seeing this message when \nselfhosting? If yes, do you have jdt loaded in your workspace?\nOtherwise I have seen NoClassDefFoundError in JDT but this only happens on \nshutdown because the indexer is not killed properly. However here it does not \nseems to be the case.\n\nJeff, the next time it happens please provide us with a full stack.",
    "Hi,\n\nI have never waited long enough to see a time-out mechanism kick-in.\n\nI don\u0027t know what you mean by \"self-hosting\" but I do have JDT loaded...I\u0027m\ndeveloping a plug-in.\n\nI confess that I really don\u0027t know how to get a full stack. I have a BASH\nscript that enables me to set the memory size and I can select the Terminal\nbutton when I run the script. I kill locked-up instances of Eclipse using\nSystem Monitor.\n\n(Off subject: Although I\u0027ve been developing software commercially for more\nthan twenty years and developing Java software for five years, it\u0027s only\nrecently that I switched from Windows to Linux, just as an experiment really\n(about six months ago). Personally, I find Linux uses much more memory than\nWindows and is slower than Windows but I like the software (no leaked files\nlocks and lots of nice little features) so I don\u0027t intend to stop any time\nsoon.)\n\nIf you let me know how to generate a full stack, I\u0027ll do it :-)\n\n\nWarmest regards,\n\nJeff\n",
    "The time out occurs after 5 seconds so you should have seen it.\n\nTo get the full dump please see Daniel\u0027s comment #2.\n\nWhich eclipse is blocking? The one in which you develop, or the one you start\nfrom within eclipse?",
    "\nThe Eclipse I use for development has the problem, i.e. not the Run-time \nWorkbench.\n\nI figured out that I need to do a  ps -efH  to see the PID then a  kill -Q PID\nso, with Daniel\u0027s help, I think I now know how to get a full dump. \nUnfortunately, since I\u0027ve added more text to the file that caused the problem, \nI no longer see the problem (or, it\u0027s harder to recreate, I suspect).\n\nI\u0027ll try to recreate the problem. I\u0027m surprized that other people haven\u0027t \nreported it (perhaps they saw this report and took it no futher).\n\nPlease remember, however, that the stack trace did arise from a cut/copy \noperation, notice:\n\norg.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run \n(ClipboardOperationAction.java:223)\n\nso the stack trace ought to get you to the right ballpark (AST.java:1503).\n\n\n",
    "I was lucky enough to get this or very similar deadlock when running eclipse\nunder debugger. Unfortunately \"Threads and Monitors\" view did not provide too\nmuch information so here is a thread stack snapshot (as by \"Copy Stack\" from\ndebug view).\n\nI am running Win2k SP2, Sun JDK 1.4.2_04, Eclipse 200406111814 with cheetah(!)\nfrom CVS. Hope this helps.\n\nSystem Thread [Finalizer] (Suspended)\n        Object.wait(long) line: not available [native method]\nSystem Thread [Reference Handler] (Suspended)\n        Object.wait(long) line: not available [native method]\nThread [main] (Suspended)\n        Object.wait(long) line: not available [native method]\n        Object.wait() line: 429\n        ASTProvider.getAST(IJavaElement, boolean, IProgressMonitor) line: 373\n        ClipboardOperationAction.getClipboardData(IJavaElement, int, int) line: 363\n        ClipboardOperationAction.doCutCopyWithImportsOperation() line: 300\n        ClipboardOperationAction.internalDoOperation() line: 256\n        ClipboardOperationAction$1.run() line: 225\n        BusyIndicator.showWhile(Display, Runnable) line: 69\n        ClipboardOperationAction.run() line: 223\n        ClipboardOperationAction(Action).runWithEvent(Event) line: 881\n        ActionHandler.execute(Map) line: 141\n        Command.execute(Map) line: 132\n        WorkbenchKeyboard.executeCommand(String) line: 469\n        WorkbenchKeyboard.press(List, Event) line: 887\n        WorkbenchKeyboard.processKeyEvent(List, Event) line: 928\n        WorkbenchKeyboard.filterKeySequenceBindings(Event) line: 546\n        WorkbenchKeyboard.access$2(WorkbenchKeyboard, Event) line: 494\n        WorkbenchKeyboard$1.handleEvent(Event) line: 259\n        EventTable.sendEvent(Event) line: 82\n        Display.filterEvent(Event) line: 714\n        StyledText(Widget).sendEvent(Event) line: 795\n        StyledText(Widget).sendEvent(int, Event, boolean) line: 820\n        StyledText(Widget).sendEvent(int, Event) line: 805\n        StyledText(Control).sendKeyEvent(int, int, int, int, Event) line: 1729\n        StyledText(Control).sendKeyEvent(int, int, int, int) line: 1725\n        StyledText(Control).WM_CHAR(int, int) line: 3053\n        StyledText(Control).windowProc(int, int, int, int) line: 2956\n        Display.windowProc(int, int, int, int) line: 3298\n        OS.DispatchMessageW(MSG) line: not available [native method]\n        OS.DispatchMessage(MSG) line: 1460\n        Display.readAndDispatch() line: 2396\n        Workbench.runEventLoop(Window$IExceptionHandler, Display) line: 1362\n        Workbench.runUI() line: 1333\n        Workbench.createAndRunWorkbench(Display, WorkbenchAdvisor) line: 252\n        PlatformUI.createAndRunWorkbench(Display, WorkbenchAdvisor) line: 141\n        IDEApplication.run(Object) line: 96\n        PlatformActivator$1.run(Object) line: 334\n        EclipseStarter.run(Object) line: 272\n        EclipseStarter.run(String[], Runnable) line: 128\n        NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not\navailable [native method]\n        NativeMethodAccessorImpl.invoke(Object, Object[]) line: 39\n        DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 25\n        Method.invoke(Object, Object[]) line: 324\n        Main.basicRun(String[]) line: 185\n        Main.run(String[]) line: 638\n        Main.main(String[]) line: 622\nSystem Thread [Signal Dispatcher] (Suspended)\nThread [Framework Event Dispatcher] (Suspended)\n        Object.wait(long) line: not available [native method]\n        EventThread(Object).wait() line: 429 [local variables unavailable]\n        EventThread.getNextEvent() line: 162\n        EventThread.run() line: 100\nThread [OSGi Console] (Suspended)\n        Object.wait(long) line: not available [native method]\n        FrameworkConsole.console() line: 264\n        FrameworkConsole.console(String[]) line: 236\n        FrameworkConsole.run() line: 207\n        Thread.run() line: 534 [local variables unavailable]\nThread [Start Level Event Dispatcher] (Suspended)\n        Object.wait(long) line: not available [native method]\n        EventThread(Object).wait() line: 429 [local variables unavailable]\n        EventThread.getNextEvent() line: 162\n        EventThread.run() line: 100\nThread [Reference Cleaner - 1] (Suspended)\n        Object.wait(long) line: not available [native method]\n        ReferenceQueue.remove(long) line: 111\n        ReferenceQueue.remove() line: 127 [local variables unavailable]\n        ActionContributionItem$ImageCache$ReferenceCleanerThread.run() line: 207\nThread [Reference Cleaner - 2] (Suspended)\n        Object.wait(long) line: not available [native method]\n        ReferenceQueue.remove(long) line: 111\n        ReferenceQueue.remove() line: 127 [local variables unavailable]\n        ActionContributionItem$ImageCache$ReferenceCleanerThread.run() line: 207\nThread [Java indexing] (Suspended)\n        Object.wait(long) line: not available [native method]\n        IndexManager(Object).wait() line: 429 [local variables unavailable]\n        IndexManager(JobManager).run() line: 338\n        Thread.run() line: 534 [local variables unavailable]\nThread [Worker-8] (Suspended)\n        Object.wait(long) line: not available [native method]\n        WorkerPool.sleep(long) line: 166\n        WorkerPool.startJob(Worker) line: 193\n        Worker.run() line: 59\n\n\n",
    "Philippe what does the getAST wait for / on?",
    "Just in case you anyone is interested, I spent some more time on this and here\nis what I\u0027ve found. The problem is triggered by a runtime exception during\nexecution of org.eclipse.jdt.internal.ui.javaeditor.ASTProvider#getAST. I\nchanged the source to always throw NullPointerException to reproduce it 100%\n;-). Assuming that you have similar change here are the steps to reproduce the\ndeadlock\n\nFirst, double check that you can reproduce a runtime exception\n1. Open a file in java editor\n2. Select some text\n3. Ctrl-C. \nAt this point you should get popup window with information about the runtime\nexception.\n\nNow the deadlock\n4. Edit the file but do not save\n5. Select some text\n6. Ctrl-C.\nAt this point eclipse locks up and you\u0027ll have to kill it.\n\nHope this provides enough information to debug this problem, but should you need\nany additional details I\u0027ll be happy to help (btw, my ibm email is igorf at ca\nibm com).",
    "Re: comment#12. The DOM AST doesn\u0027t wait on anything. It just never gets \ncreated due to suspicious exception in runtime. This is why I forwarded it to \nyou. However, as Igor stated, this is only one of the problems.\nIt appears that if an exception occurs in this very code (like it does here), \nit then causes some deadlock above JDT Core (likely in UI components).\n\nA thread dump would definitely help to figure out what is the deadlock \nsituation.\n\nCC\u0027ing Dirk who owns the call to the DOM AST creation code.",
    "CC\u0027ing Kai as well since the call comes from ASTProvider",
    "Suspect something in Text land...",
    "Where exactly did you modifiy the code to throw an NPE?\n\nNote: the call to ICompilationUnit.reconcile(...) is already protected with a\nfinally block in which we send out the notification.\n",
    "Sorry for confusion, it was not ASTProvider#getAST, but ASTConverter#convert.\nHere is the diff that I double and tripple check to \"work\" with the steps.\n\n\nIndex: dom/org/eclipse/jdt/core/dom/ASTConverter.java\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nRCS file:\n/home/eclipse/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java,v\nretrieving revision 1.154\ndiff -u -r1.154 ASTConverter.java\n--- dom/org/eclipse/jdt/core/dom/ASTConverter.java\t9 Jun 2004 18:17:46 -0000\t1.154\n+++ dom/org/eclipse/jdt/core/dom/ASTConverter.java\t18 Jun 2004 19:56:38 -0000\n@@ -247,6 +247,7 @@\n \n \tpublic TypeDeclaration\nconvert(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration) {\n \t\tcheckCanceled();\n+\t\tObject o \u003d null; o.toString();\n \t\tTypeDeclaration typeDecl \u003d this.ast.newTypeDeclaration();\n \t\tint modifiers \u003d typeDeclaration.modifiers;\n \t\tmodifiers \u0026\u003d ~IConstants.AccInterface; // remove AccInterface flags\n",
    "will investigate",
    "Even with the added NPE I could not reproduce the deadlock. What I see is:\n- the finally block which wakes up waiting callers gets called\n- I get a dialog \"Error Running Operations\" which comes back all the time but\nthe UI is not blocked: I can move the focus away from the editor e.g. to the\nOutline view and then close the editor.\n\nAlso, I (and others) haven\u0027t seen this without the modified code.\n\nWhat\u0027s really important is to get the \"real\" exception that causes this.\n\nSetting resolution to REMIND until we have further data to investigate.\n",
    "I spent some time on this yesterday, and here is what I\u0027ve found.\n\nMy workspace has one java source opened. I start eclipse with the added NPE\nunder debugger and here is what I see\n\n1. Background java reconciliation thread dies because of the NPE and does not\nget restarted. \n\n2. If I copy from clean (i.e. unchanged) aditor, ASTProvider#getAST invokes\nASTProvider#createAST which eventually hits my planted NPE and I get \"Error\nRunning Operations\" dialog. Nothing gets copied to the clipboard.\n\n3. ASTProvider#aboutToBeReconciled is invoked when I modifty the source in the\neditor. The source is considered \"being reconsiled\" stay in this state forever\nsince there is no reconcilation thread running.\n\n4. If I now copy from this dirty editor, ASTProvider#getAST will determine that\nthe source is being reconsiled (by calling ASTProvider#isReconciling) and will\nwait forever for reconsiliation to finish. This blocks event delivery thread and\nas a result Eclise UI stops funtioning.\n\nI would consider few improvements to make eclipse more robust\n\nFirst, it looks like a \"generally good idea\" to restart background\nreconciliation threads. \n\nSecond, make synchronization between UI and background reconciliation threads\nmore robust. For example, instead of waiting forever, UI could wait with timeout\nand have a fallback behaviour should timeout ever occure.\n\nAnd last, how come single \"bad\" plugin can block entire elcipse UI? It looks so\nmuch like Windows 3.1. ;-)\n\nAnyways, I agree with Daniel that it is more important to understand the cause\nof real exception.",
    "I would say there are 2 problems. \n\n1. Exception should not occur, and we want to understand it.\n2. An exception should not kill the IDE. It should be robust enough to\n   do something reasonable. ",
    "I can partially confirm your analysis: we do not restart the reconcile thread,\nhowever, what should happen (and what I see using JRE 1.4.2_03) is that the\nfinally block in JavaReconcilingStrategy resets the AST provider and since the\nreconcile thread is already shutting down no further aboutToBeReconciled will be\nsent. What VM do you use? 1.5 maybe?\n\nWe could make the code more robust with a time-out but this time-out must be\ncomputed in function of the CU size because otherwise we would always compute\ntwo AST for large CUs (one during reconcile and one after the time-out. Instead\nof computing the AST after the time-out we could add API to check whether the\nreconcile thread is alive and if so, continue to wait.\n\nPhilippe can you provide some basic timing information for the reconcile\noperation  especially in function of file size (e.g. is it linear)?\n",
    "As I mentioned earlier, I am using SUN JDK 1.4.2_04. Java reconciliation thread\ndies during eclipse startup. To make it clear, I have never seen this problem\nwith regular JDT. It happens a lot with cheetah (due to unimplemented features)\nand with JDT I had to plant artificial NPE to reproduce it.\n\nAlso, I don\u0027t think UI wait timeout should NOT be a function of CU size, but\nshould be set based on user UI response expectations. If reconciliation finishes\nwithin this time, great, use reconciled AST to copy source to the clipboard. If,\nhowever, reconciliation does not finish within timeout period, then copy plain\ntext to the clipboard. This way UI will become more responsive for very large\nCUs and as a good side effect it will tolerate problems with background\nreconciliation.",
    "I can now reproduce it with the steps outline in comment 13. I could first not\nreproduce it because the \"Update imports on paste\" was disabled in my test\nworkspace.\n\nJ Core will (or has already) put in code into the Cheeta branch which will no\nlonger break the reconcile.\n\nRegarding your second section in comment 24: we chache the AST for the active\neditor and use this editor\u0027s AST for several features one of which is the smart\ncopy/past of imports. If we followed your strategy to not have an AST if it\ncould not be computed after a fixed time-out then features like semantic\ncoloring, override indication in vertical ruler, occurrence marking, etc. would\nbe disabled (especially for large CUs).\n",
    "Created an attachment (id\u003d12565)\nPatch against AbstractReconciler which prevents calls to aboutToBeReconciled()\nin cases where the reconcile thread is no longer alive\n",
    "The fix is about improving the robustness of the reconciler framework. As \npointed out, it is not required for the Java tooling any longer. In case \nThread.isAlive is not 100% reliable method, there is still room to fail, \nhowever not as badly as right now.",
    "Approved to be released into RC4",
    "Build I200406221600.",
    "Verified in I20040625\n\nI loaded jdt.core in workspace, applied patch #18 and followed steps in #13.\nI got the exception (as expected), but could not lock up eclipse."
  ],
  "commentCreationDates": [
    "2004-06-15T22:37:18+02:00",
    "2004-06-16T10:36:19+02:00",
    "2004-06-16T10:43:32+02:00",
    "2004-06-16T15:49:24+02:00",
    "2004-06-16T20:18:19+02:00",
    "2004-06-16T23:20:36+02:00",
    "2004-06-17T15:17:26+02:00",
    "2004-06-17T18:38:36+02:00",
    "2004-06-17T19:35:11+02:00",
    "2004-06-17T20:00:04+02:00",
    "2004-06-17T20:43:59+02:00",
    "2004-06-18T04:38:59+02:00",
    "2004-06-18T04:54:50+02:00",
    "2004-06-18T06:10:11+02:00",
    "2004-06-18T11:20:37+02:00",
    "2004-06-18T12:39:26+02:00",
    "2004-06-18T16:42:26+02:00",
    "2004-06-18T18:47:39+02:00",
    "2004-06-18T22:02:30+02:00",
    "2004-06-18T22:20:40+02:00",
    "2004-06-19T19:16:12+02:00",
    "2004-06-19T21:21:35+02:00",
    "2004-06-19T21:35:54+02:00",
    "2004-06-21T09:27:34+02:00",
    "2004-06-21T13:36:35+02:00",
    "2004-06-21T16:06:49+02:00",
    "2004-06-21T16:13:36+02:00",
    "2004-06-22T13:07:00+02:00",
    "2004-06-22T17:35:50+02:00",
    "2004-06-22T18:31:37+02:00",
    "2004-06-25T11:48:37+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NoClassDefFoundError",
      "elements": [
        {
          "method": "org.eclipse.jdt.core.dom.AST.newMethodDeclaration",
          "source": "AST.java:1503"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:697"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations",
          "source": "ASTConverter.java:336"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:274"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:152"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTParser.convert",
          "source": "ASTParser.java:711"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTParser.internalCreateAST",
          "source": "ASTParser.java:681"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTParser.createAST",
          "source": "ASTParser.java:574"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST",
          "source": "ASTProvider.java:439"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST",
          "source": "ASTProvider.java:391"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData",
          "source": "ClipboardOperationAction.java:363"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation",
          "source": "ClipboardOperationAction.java:300"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation",
          "source": "ClipboardOperationAction.java:256"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run",
          "source": "ClipboardOperationAction.java:225"
        },
        {
          "method": "org.eclipse.swt.custom.BusyIndicator.showWhile",
          "source": "BusyIndicator.java:69"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run",
          "source": "ClipboardOperationAction.java:223"
        },
        {
          "method": "org.eclipse.jface.action.Action.runWithEvent",
          "source": "Action.java:881"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection",
          "source": "ActionContributionItem.java:915"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem.access$2",
          "source": "ActionContributionItem.java:866"
        },
        {
          "method": "org.eclipse.jface.action.ActionContributionItem$7.handleEvent",
          "source": "ActionContributionItem.java:785"
        },
        {
          "method": "org.eclipse.swt.widgets.EventTable.sendEvent",
          "source": "EventTable.java:82"
        },
        {
          "method": "org.eclipse.swt.widgets.Widget.sendEvent",
          "source": "Widget.java:950"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.runDeferredEvents",
          "source": "Display.java:2512"
        },
        {
          "method": "org.eclipse.swt.widgets.Display.readAndDispatch",
          "source": "Display.java:2223"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runEventLoop",
          "source": "Workbench.java:1362"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.runUI",
          "source": "Workbench.java:1333"
        },
        {
          "method": "org.eclipse.ui.internal.Workbench.createAndRunWorkbench",
          "source": "Workbench.java:252"
        },
        {
          "method": "org.eclipse.ui.PlatformUI.createAndRunWorkbench",
          "source": "PlatformUI.java:141"
        },
        {
          "method": "org.eclipse.ui.internal.ide.IDEApplication.run",
          "source": "IDEApplication.java:96"
        },
        {
          "method": "org.eclipse.core.internal.runtime.PlatformActivator$1.run",
          "source": "PlatformActivator.java:334"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:272"
        },
        {
          "method": "org.eclipse.core.runtime.adaptor.EclipseStarter.run",
          "source": "EclipseStarter.java:128"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke0",
          "source": "Native Method"
        },
        {
          "method": "sun.reflect.NativeMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "sun.reflect.DelegatingMethodAccessorImpl.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "java.lang.reflect.Method.invoke",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.core.launcher.Main.basicRun",
          "source": "Main.java:185"
        },
        {
          "method": "org.eclipse.core.launcher.Main.run",
          "source": "Main.java:638"
        },
        {
          "method": "org.eclipse.core.launcher.Main.main",
          "source": "Main.java:622"
        }
      ],
      "number": 0,
      "commentIndex": 3,
      "bugId": "67369",
      "date": "2004-06-16T15:49:24+02:00",
      "product": "JDT",
      "component": "Text",
      "severity": "critical"
    },
    {
      "exceptionType": "java.lang.ExceptionInInitializerError",
      "elements": [
        {
          "method": "java.lang.Class.forName0",
          "source": "Native Method"
        },
        {
          "method": "java.lang.Class.forName",
          "source": "Unknown Source"
        },
        {
          "method": "org.eclipse.jdt.core.dom.TryStatement.\u003cclinit\u003e",
          "source": "TryStatement.java:42"
        },
        {
          "method": "org.eclipse.jdt.core.dom.AST.newTryStatement",
          "source": "AST.java:1960"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:2114"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:1855"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:1910"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration",
          "source": "ASTConverter.java:353"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations",
          "source": "ASTConverter.java:330"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:274"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:152"
        },
        {
          "method": "org.eclipse.jdt.core.dom.AST.convertCompilationUnit",
          "source": "AST.java:253"
        },
        {
          "method": "org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation",
          "source": "ReconcileWorkingCopyOperation.java:81"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.run",
          "source": "JavaModelOperation.java:700"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.runOperation",
          "source": "JavaModelOperation.java:739"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.reconcile",
          "source": "CompilationUnit.java:1098"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile",
          "source": "JavaReconcilingStrategy.java:88"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile",
          "source": "JavaReconcilingStrategy.java:156"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile",
          "source": "CompositeReconcilingStrategy.java:114"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile",
          "source": "JavaCompositeReconcilingStrategy.java:122"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess",
          "source": "MonoReconciler.java:104"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess",
          "source": "JavaReconciler.java:304"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run",
          "source": "AbstractReconciler.java:169"
        }
      ],
      "causedBy": {
        "exceptionType": "java.lang.RuntimeException",
        "message": "Structural property descriptor has wrong  node class!",
        "elements": [
          {
            "method": "org.eclipse.jdt.core.dom.ASTNode.addProperty",
            "source": "ASTNode.java:1731"
          },
          {
            "method": "org.eclipse.jdt.core.dom.CatchClause.\u003cclinit\u003e",
            "source": "CatchClause.java:51"
          }
        ],
        "number": 0,
        "commentIndex": 0
      },
      "number": 1,
      "commentIndex": 5,
      "bugId": "67369",
      "date": "2004-06-16T23:20:36+02:00",
      "product": "JDT",
      "component": "Text",
      "severity": "critical"
    },
    {
      "exceptionType": "java.lang.NoClassDefFoundError",
      "elements": [
        {
          "method": "org.eclipse.jdt.core.dom.AST.newTryStatement",
          "source": "AST.java:1960"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:2114"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:1855"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:770"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations",
          "source": "ASTConverter.java:336"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:274"
        },
        {
          "method": "org.eclipse.jdt.core.dom.ASTConverter.convert",
          "source": "ASTConverter.java:152"
        },
        {
          "method": "org.eclipse.jdt.core.dom.AST.convertCompilationUnit",
          "source": "AST.java:253"
        },
        {
          "method": "org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation",
          "source": "ReconcileWorkingCopyOperation.java:81"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.run",
          "source": "JavaModelOperation.java:700"
        },
        {
          "method": "org.eclipse.jdt.internal.core.JavaModelOperation.runOperation",
          "source": "JavaModelOperation.java:739"
        },
        {
          "method": "org.eclipse.jdt.internal.core.CompilationUnit.reconcile",
          "source": "CompilationUnit.java:1098"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile",
          "source": "JavaReconcilingStrategy.java:88"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile",
          "source": "JavaReconcilingStrategy.java:156"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile",
          "source": "CompositeReconcilingStrategy.java:114"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile",
          "source": "JavaCompositeReconcilingStrategy.java:122"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess",
          "source": "MonoReconciler.java:104"
        },
        {
          "method": "org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess",
          "source": "JavaReconciler.java:304"
        },
        {
          "method": "org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run",
          "source": "AbstractReconciler.java:169"
        }
      ],
      "number": 2,
      "commentIndex": 5,
      "bugId": "67369",
      "date": "2004-06-16T23:20:36+02:00",
      "product": "JDT",
      "component": "Text",
      "severity": "critical"
    }
  ],
  "groupId": "67369",
  "bugId": "67369",
  "date": "2004-06-15T22:37:18+02:00",
  "product": "JDT",
  "component": "Text",
  "severity": "critical"
}