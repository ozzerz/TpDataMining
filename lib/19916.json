{
  "comments": [
    "We have found a potential class loading issue? However, it seems to have been \nresolved in Eclipse 2.0 (F2 driver). However, we are looking for a workaround \nin the current workbench (Eclipse 1.0). This doesn\u0027t seem to be a problem with \nthe workbench\u0027s JRE since we have built the source and run it successfully with \nthe same JRE outside the workbench. Is this a known problem? Can you provide a \nworkaround for 1.0? \n\nSteps to reproduce:\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d \n\npackage problem2;\npublic class ClassLoadTest {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tClass clz1 \u003d Class.forName(\"problem2.C\");\n\t\t\tSystem.out.println(\"success\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"error\");\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d \n\npackage problem2;\npublic class C {\n\n\tboolean b \u003d false;\n\n\tprivate Integer f() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tint x \u003d 3;\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (b)\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\tint y \u003d 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d \n\nRunning this in Workbench will give you the following error: \n\njava.lang.VerifyError: (class: problem2/C, method: f signature: ()\nLjava/lang/Integer;) Accessing value from uninitialized localvariable 3 \nat java.lang.Class.forName1(Native Method) \nat java.lang.Class.forName(Class.java:134) \nat problem2.ClassLoadTest.main(ClassLoadTest.java:7) \nException in thread \"main\"",
    "The following code would work fine:\n\tprivate Integer f() {\n\t\tint x;\n\t\tint y;\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tx \u003d 3;\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (b) {\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\ty \u003d 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nThe problem comes from locals defined in a try/finally when the try block \nreturns. If you extract your locals before the try statement, it will work fine.",
    "Is this good enough for a workaround?",
    "I sent the workaround to the customer.  I haven\u0027t heard anything back yet, but \nI\u0027ll let you know as soon as I do.",
    "This bug is a duplicate of bug 16279, which got addressed in 2.0 stream. \nBackporting would be fairly dangerous, since the change in 2.0 stream is quite \nnasty and relying on other changes.",
    "\n\n*** This bug has been marked as a duplicate of 16279 ***",
    "From the customer:\n\nThank you for the workaround, actually we had discovered this as a workaround \nourselves as well. However, is their a better workaround, since enclosing \nvariables within a try block achieves data hiding and provides us with better \nscoping. Furthermore, it is acceptable code since running the code as is with \nvirtually any JRE outside the workbench will work. Do you know of any other \nworkarounds that we may be able to try? \n",
    "From the customer:\n\nWhat I need to know is, \nWhich compiler..? the JDK given by Hursley..? The javac..? \nI understand that the development of a fix can be tricky, sensitive and \ndangerous in some situation maybe this situation might be one but I need to \nexplain to the customer why..? as he is demading a fix, because the workaround \nis not a good workaround as he has hundread and hundreads of classes to modify \nto apply the workaround that was suggested (ie. go into every class of his app \nand take the Fields out of the try{} catch block) \n\nReply:\n\nThe problem is in the internal compiler that is included in Eclipse, WSWB and \nWSAD, not an external compiler like Javac. Bad bytecodes are being generated \nand therefore the class cannot be loaded. \n\nThe compiler is started from: \norg.eclipse.pde.internal.core.JDTCompilerAdapter \nand it\u0027s in the org.eclipse.jdt.core plugin. \n\nSource is in wswb10\\eclipse\\plugins\\org.eclipse.jdt.core\\jdtcoresrc.zip, mostly \nin the parser and compiler packages. \n\nThe reason that development says that backporting would be dangerous is that so \nmuch code has been changed that relies upon previous changes. Other \nfunctionality could be easily broken.\n",
    "Backporting fix to 1.0 (release into v_146). The fix is quite big, will ensure \nwe pass jck1.3a before calling it good.",
    "Support Note: HD100126."
  ],
  "commentCreationDates": [
    "2002-06-11T18:00:30+02:00",
    "2002-06-11T19:49:30+02:00",
    "2002-06-11T22:01:40+02:00",
    "2002-06-11T22:16:38+02:00",
    "2002-06-12T11:04:11+02:00",
    "2002-06-12T11:42:02+02:00",
    "2002-06-12T16:07:16+02:00",
    "2002-06-26T22:49:41+02:00",
    "2002-08-21T00:52:50+02:00",
    "2002-08-21T16:46:50+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.VerifyError",
      "message": "(class: problem2/C, method: f signature: () Ljava/lang/Integer;) Accessing value from uninitialized localvariable 3",
      "elements": [
        {
          "method": "java.lang.Class.forName1",
          "source": "Native Method"
        },
        {
          "method": "java.lang.Class.forName",
          "source": "Class.java:134"
        },
        {
          "method": "problem2.ClassLoadTest.main",
          "source": "ClassLoadTest.java:7"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "19916",
      "duplicateId": "16279",
      "date": "2002-06-11T18:00:30+02:00",
      "product": "JDT",
      "component": "Core",
      "severity": "normal"
    }
  ],
  "groupId": "16279",
  "bugId": "19916",
  "duplicateId": "16279",
  "date": "2002-06-11T18:00:30+02:00",
  "product": "JDT",
  "component": "Core",
  "severity": "normal"
}