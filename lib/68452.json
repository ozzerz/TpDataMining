{
  "comments": [
    "I200406221600\nSun JDK 1.4.2_04\n\nNot sure what effect this had on overall stability since I immediately restarted\neclipse.\n\nlog follows:\n\n!ENTRY org.eclipse.core.runtime 4 2 Jun 24, 2004 08:45:13.820\n!MESSAGE An internal error occurred during: \"Decoration Calculation\".\n!STACK 0\njava.lang.NullPointerException\n\tat\norg.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:222)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:66)",
    "Did you have any more in you log?",
    "Line 222 is \n\n\tmonitor.beginTask(WorkbenchMessages.getString\n(\"DecorationScheduler.CalculatingTask\"), 100); //$NON-NLS-1$\n\nThis is a monitor passed to me by the JobManager.\n\nMoving to Core",
    "This is suspicous code in JobManager:\n\n\t/**\n\t * Attempts to immediately start a given job.  Returns true if the job \nwas\n\t * successfully started, and false if it could not be started \nimmediately\n\t * due to a currently running job with a conflicting rule.  Listeners \nwill never\n\t * be notified of jobs that are run in this way.\n\t */\n\tprotected boolean runNow(InternalJob job) {\n\t\tsynchronized (lock) {\n\t\t\t//cannot start if there is a conflicting job\n\t\t\tif (findBlockingJob(job) !\u003d null)\n\t\t\t\treturn false;\n\t\t\tchangeState(job, Job.RUNNING);\n\t\t\tjob.setProgressMonitor(new NullProgressMonitor());\n\t\t\tjob.run(null);\n\t\t}\n\t\treturn true;",
    "Looks like it was introduced as fix to Bug 62368 last month.",
    "Nothing else in the log. It happened to me again and this time I kept running\nwith no adverse effects.",
    "The spec for Job#run says that the progress monitor is never null. I will check\nwith John this morning but I believe that a good change would be:\n\n\t...\n\tjob.setProgressMonitor(new NullProgressMonitor());\n\tjob.run(job.getProgressMonitor());\n\t...\n",
    "We have reviewed the code and that was a red herring. The #runNow method is only\ncalled on ThreadJob instances which have no-ops for their #run methods. \n\nWe will investigate further.",
    "I can reproduce this in a test case. If a job change listener reschedules the\nsame job from within the scheduled() callback, we can get into a state where the\nsame job is being executed in two worker threads at once. When the first thread\nfinishes, it nulls the progress monitor, thus causing the NPE in the second\nthread. Thus the NPE is a sympton of an extremely severe problem. Having the\nsame job running in multiple threads at once can potentially have many adverse\nside-effects.",
    "Created an attachment (id\u003d12785)\nPatch to JobManager.java\n\nThis is the proposed fix. The old code did this:\n\n1) enter sync block\n2) assert scheduling preconditions\n3) exit sync block\n4) call job change listeners\n5) enter sync block\n6) change job state and add to wait queue\n7) exit sync block\n\nStep 2) (assertion preconditions) is the guard code to ensure that the same job\nis not scheduled twice. If this occurs, the second schedule() attempt is\nignored (this is the specified behaviour).\n\nDuring 4), another thread (or the same thread in a recursive schedule() call),\ncould reschedule the identical job. Step 6) would then occur twice on the same\njob, causing the NPE, or much worse problems.\n\nThe patch adds a new step to re-assert the preconditions after entering the\nsync block a second time:\n\n1) enter sync block\n2) assert scheduling preconditions\n3) exit sync block\n4) call job change listeners\n5) enter sync block\n5a) NEW: assert scheduling preconditions\n6) change job state and add to wait queue\n7) exit sync block\n\nWhy check the preconditions twice? We want to avoid calling job change\nlisteners and telling them the job is scheduled if in fact it will be\ndiscarded. This reduces notifications that would cause unnecessary flicker.\nWith the patched code, it is still possible for a listener to get the\nscheduled() notification twice for the same job. This is not great, but much\nbetter than actually running the job twice simultaneously.",
    "We need to get the fix approval process started.",
    "Created an attachment (id\u003d12795)\nImproved patch\n\nImproved patch. This patch avoids the possibility of multiple scheduling\nnotifications. It adds a new internal state to indicate that a job has been\nscheduled but not yet added to the wait queue. Thus a second call to schedule()\ncan distinguish this case properly and immediately bail out.",
    "Fix released. Fix reviewed by Jean-Michel, DJ, McQ, MVM, and Kevin H.",
    "It is quite likely that the following bugs are duplicates of this one:\n\nbug 57656\nbug 63635\nbug 65415\nbug 68240"
  ],
  "commentCreationDates": [
    "2004-06-24T08:55:45+02:00",
    "2004-06-24T14:21:16+02:00",
    "2004-06-24T14:29:01+02:00",
    "2004-06-24T14:31:27+02:00",
    "2004-06-24T14:40:47+02:00",
    "2004-06-24T15:09:25+02:00",
    "2004-06-24T15:20:42+02:00",
    "2004-06-24T16:04:55+02:00",
    "2004-06-24T17:13:47+02:00",
    "2004-06-24T18:19:09+02:00",
    "2004-06-24T18:19:41+02:00",
    "2004-06-24T20:02:27+02:00",
    "2004-06-24T20:05:35+02:00",
    "2004-06-24T20:12:55+02:00"
  ],
  "traces": [
    {
      "exceptionType": "java.lang.NullPointerException",
      "elements": [
        {
          "method": "org.eclipse.ui.internal.decorators.DecorationScheduler$1.run",
          "source": "DecorationScheduler.java:222"
        },
        {
          "method": "org.eclipse.core.internal.jobs.Worker.run",
          "source": "Worker.java:66"
        }
      ],
      "number": 0,
      "commentIndex": 0,
      "bugId": "68452",
      "date": "2004-06-24T08:55:45+02:00",
      "product": "Platform",
      "component": "Resources",
      "severity": "major"
    }
  ],
  "groupId": "68452",
  "bugId": "68452",
  "date": "2004-06-24T08:55:45+02:00",
  "product": "Platform",
  "component": "Resources",
  "severity": "major"
}